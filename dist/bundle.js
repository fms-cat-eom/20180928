/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/main.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/@fms-cat/automaton/dist/automaton.js":
/*!***********************************************************!*\
  !*** ./node_modules/@fms-cat/automaton/dist/automaton.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var require;var require;function _typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

/*!
  Automaton v2.0.1
  Animation engine with Timeline GUI for creative coding
 
  Copyright (c) 2017-2018 FMS_Cat
  Automaton is distributed under the MIT License
  https://opensource.org/licenses/MIT

  Repository: https://github.com/FMS-Cat/automaton
*/
(function (f) {
  if (( false ? undefined : _typeof2(exports)) === "object" && typeof module !== "undefined") {
    module.exports = f();
  } else if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (f),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else { var g; }
})(function () {
  var define, module, exports;
  return function () {
    function r(e, n, t) {
      function o(i, f) {
        if (!n[i]) {
          if (!e[i]) {
            var c = "function" == typeof require && require;
            if (!f && c) return require(i, !0);
            if (u) return u(i, !0);
            var a = new Error("Cannot find module '" + i + "'");
            throw a.code = "MODULE_NOT_FOUND", a;
          }

          var p = n[i] = {
            exports: {}
          };
          e[i][0].call(p.exports, function (r) {
            var n = e[i][1][r];
            return o(n || r);
          }, p, p.exports, r, e, n, t);
        }

        return n[i].exports;
      }

      for (var u = "function" == typeof require && require, i = 0; i < t.length; i++) {
        o(t[i]);
      }

      return o;
    }

    return r;
  }()({
    1: [function (require, module, exports) {
      module.exports = {
        "default": require("core-js/library/fn/array/from"),
        __esModule: true
      };
    }, {
      "core-js/library/fn/array/from": 5
    }],
    2: [function (require, module, exports) {
      module.exports = {
        "default": require("core-js/library/fn/math/log10"),
        __esModule: true
      };
    }, {
      "core-js/library/fn/math/log10": 6
    }],
    3: [function (require, module, exports) {
      module.exports = {
        "default": require("core-js/library/fn/math/sign"),
        __esModule: true
      };
    }, {
      "core-js/library/fn/math/sign": 7
    }],
    4: [function (require, module, exports) {
      "use strict";

      exports.__esModule = true;

      var _from = require("../core-js/array/from");

      var _from2 = _interopRequireDefault(_from);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        };
      }

      exports.default = function (arr) {
        if (Array.isArray(arr)) {
          for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
            arr2[i] = arr[i];
          }

          return arr2;
        } else {
          return (0, _from2.default)(arr);
        }
      };
    }, {
      "../core-js/array/from": 1
    }],
    5: [function (require, module, exports) {
      require('../../modules/es6.string.iterator');

      require('../../modules/es6.array.from');

      module.exports = require('../../modules/_core').Array.from;
    }, {
      "../../modules/_core": 13,
      "../../modules/es6.array.from": 58,
      "../../modules/es6.string.iterator": 61
    }],
    6: [function (require, module, exports) {
      require('../../modules/es6.math.log10');

      module.exports = require('../../modules/_core').Math.log10;
    }, {
      "../../modules/_core": 13,
      "../../modules/es6.math.log10": 59
    }],
    7: [function (require, module, exports) {
      require('../../modules/es6.math.sign');

      module.exports = require('../../modules/_core').Math.sign;
    }, {
      "../../modules/_core": 13,
      "../../modules/es6.math.sign": 60
    }],
    8: [function (require, module, exports) {
      module.exports = function (it) {
        if (typeof it != 'function') throw TypeError(it + ' is not a function!');
        return it;
      };
    }, {}],
    9: [function (require, module, exports) {
      var isObject = require('./_is-object');

      module.exports = function (it) {
        if (!isObject(it)) throw TypeError(it + ' is not an object!');
        return it;
      };
    }, {
      "./_is-object": 29
    }],
    10: [function (require, module, exports) {
      // false -> Array#indexOf
      // true  -> Array#includes
      var toIObject = require('./_to-iobject');

      var toLength = require('./_to-length');

      var toAbsoluteIndex = require('./_to-absolute-index');

      module.exports = function (IS_INCLUDES) {
        return function ($this, el, fromIndex) {
          var O = toIObject($this);
          var length = toLength(O.length);
          var index = toAbsoluteIndex(fromIndex, length);
          var value; // Array#includes uses SameValueZero equality algorithm
          // eslint-disable-next-line no-self-compare

          if (IS_INCLUDES && el != el) while (length > index) {
            value = O[index++]; // eslint-disable-next-line no-self-compare

            if (value != value) return true; // Array#indexOf ignores holes, Array#includes - not
          } else for (; length > index; index++) {
            if (IS_INCLUDES || index in O) {
              if (O[index] === el) return IS_INCLUDES || index || 0;
            }
          }
          return !IS_INCLUDES && -1;
        };
      };
    }, {
      "./_to-absolute-index": 49,
      "./_to-iobject": 51,
      "./_to-length": 52
    }],
    11: [function (require, module, exports) {
      // getting tag from 19.1.3.6 Object.prototype.toString()
      var cof = require('./_cof');

      var TAG = require('./_wks')('toStringTag'); // ES3 wrong here


      var ARG = cof(function () {
        return arguments;
      }()) == 'Arguments'; // fallback for IE11 Script Access Denied error

      var tryGet = function tryGet(it, key) {
        try {
          return it[key];
        } catch (e) {
          /* empty */
        }
      };

      module.exports = function (it) {
        var O, T, B;
        return it === undefined ? 'Undefined' : it === null ? 'Null' // @@toStringTag case
        : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T // builtinTag case
        : ARG ? cof(O) // ES3 arguments fallback
        : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
      };
    }, {
      "./_cof": 12,
      "./_wks": 56
    }],
    12: [function (require, module, exports) {
      var toString = {}.toString;

      module.exports = function (it) {
        return toString.call(it).slice(8, -1);
      };
    }, {}],
    13: [function (require, module, exports) {
      var core = module.exports = {
        version: '2.5.7'
      };
      if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef
    }, {}],
    14: [function (require, module, exports) {
      'use strict';

      var $defineProperty = require('./_object-dp');

      var createDesc = require('./_property-desc');

      module.exports = function (object, index, value) {
        if (index in object) $defineProperty.f(object, index, createDesc(0, value));else object[index] = value;
      };
    }, {
      "./_object-dp": 38,
      "./_property-desc": 43
    }],
    15: [function (require, module, exports) {
      // optional / simple context binding
      var aFunction = require('./_a-function');

      module.exports = function (fn, that, length) {
        aFunction(fn);
        if (that === undefined) return fn;

        switch (length) {
          case 1:
            return function (a) {
              return fn.call(that, a);
            };

          case 2:
            return function (a, b) {
              return fn.call(that, a, b);
            };

          case 3:
            return function (a, b, c) {
              return fn.call(that, a, b, c);
            };
        }

        return function ()
        /* ...args */
        {
          return fn.apply(that, arguments);
        };
      };
    }, {
      "./_a-function": 8
    }],
    16: [function (require, module, exports) {
      // 7.2.1 RequireObjectCoercible(argument)
      module.exports = function (it) {
        if (it == undefined) throw TypeError("Can't call method on  " + it);
        return it;
      };
    }, {}],
    17: [function (require, module, exports) {
      // Thank's IE8 for his funny defineProperty
      module.exports = !require('./_fails')(function () {
        return Object.defineProperty({}, 'a', {
          get: function get() {
            return 7;
          }
        }).a != 7;
      });
    }, {
      "./_fails": 21
    }],
    18: [function (require, module, exports) {
      var isObject = require('./_is-object');

      var document = require('./_global').document; // typeof document.createElement is 'object' in old IE


      var is = isObject(document) && isObject(document.createElement);

      module.exports = function (it) {
        return is ? document.createElement(it) : {};
      };
    }, {
      "./_global": 22,
      "./_is-object": 29
    }],
    19: [function (require, module, exports) {
      // IE 8- don't enum bug keys
      module.exports = 'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'.split(',');
    }, {}],
    20: [function (require, module, exports) {
      var global = require('./_global');

      var core = require('./_core');

      var ctx = require('./_ctx');

      var hide = require('./_hide');

      var has = require('./_has');

      var PROTOTYPE = 'prototype';

      var $export = function $export(type, name, source) {
        var IS_FORCED = type & $export.F;
        var IS_GLOBAL = type & $export.G;
        var IS_STATIC = type & $export.S;
        var IS_PROTO = type & $export.P;
        var IS_BIND = type & $export.B;
        var IS_WRAP = type & $export.W;
        var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
        var expProto = exports[PROTOTYPE];
        var target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE];
        var key, own, out;
        if (IS_GLOBAL) source = name;

        for (key in source) {
          // contains in native
          own = !IS_FORCED && target && target[key] !== undefined;
          if (own && has(exports, key)) continue; // export native or passed

          out = own ? target[key] : source[key]; // prevent global pollution for namespaces

          exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key] // bind timers to global for call from export context
          : IS_BIND && own ? ctx(out, global) // wrap global constructors for prevent change them in library
          : IS_WRAP && target[key] == out ? function (C) {
            var F = function F(a, b, c) {
              if (this instanceof C) {
                switch (arguments.length) {
                  case 0:
                    return new C();

                  case 1:
                    return new C(a);

                  case 2:
                    return new C(a, b);
                }

                return new C(a, b, c);
              }

              return C.apply(this, arguments);
            };

            F[PROTOTYPE] = C[PROTOTYPE];
            return F; // make static versions for prototype methods
          }(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out; // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%

          if (IS_PROTO) {
            (exports.virtual || (exports.virtual = {}))[key] = out; // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%

            if (type & $export.R && expProto && !expProto[key]) hide(expProto, key, out);
          }
        }
      }; // type bitmap


      $export.F = 1; // forced

      $export.G = 2; // global

      $export.S = 4; // static

      $export.P = 8; // proto

      $export.B = 16; // bind

      $export.W = 32; // wrap

      $export.U = 64; // safe

      $export.R = 128; // real proto method for `library`

      module.exports = $export;
    }, {
      "./_core": 13,
      "./_ctx": 15,
      "./_global": 22,
      "./_has": 23,
      "./_hide": 24
    }],
    21: [function (require, module, exports) {
      module.exports = function (exec) {
        try {
          return !!exec();
        } catch (e) {
          return true;
        }
      };
    }, {}],
    22: [function (require, module, exports) {
      // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
      var global = module.exports = typeof window != 'undefined' && window.Math == Math ? window : typeof self != 'undefined' && self.Math == Math ? self // eslint-disable-next-line no-new-func
      : Function('return this')();
      if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef
    }, {}],
    23: [function (require, module, exports) {
      var hasOwnProperty = {}.hasOwnProperty;

      module.exports = function (it, key) {
        return hasOwnProperty.call(it, key);
      };
    }, {}],
    24: [function (require, module, exports) {
      var dP = require('./_object-dp');

      var createDesc = require('./_property-desc');

      module.exports = require('./_descriptors') ? function (object, key, value) {
        return dP.f(object, key, createDesc(1, value));
      } : function (object, key, value) {
        object[key] = value;
        return object;
      };
    }, {
      "./_descriptors": 17,
      "./_object-dp": 38,
      "./_property-desc": 43
    }],
    25: [function (require, module, exports) {
      var document = require('./_global').document;

      module.exports = document && document.documentElement;
    }, {
      "./_global": 22
    }],
    26: [function (require, module, exports) {
      module.exports = !require('./_descriptors') && !require('./_fails')(function () {
        return Object.defineProperty(require('./_dom-create')('div'), 'a', {
          get: function get() {
            return 7;
          }
        }).a != 7;
      });
    }, {
      "./_descriptors": 17,
      "./_dom-create": 18,
      "./_fails": 21
    }],
    27: [function (require, module, exports) {
      // fallback for non-array-like ES3 and non-enumerable old V8 strings
      var cof = require('./_cof'); // eslint-disable-next-line no-prototype-builtins


      module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
        return cof(it) == 'String' ? it.split('') : Object(it);
      };
    }, {
      "./_cof": 12
    }],
    28: [function (require, module, exports) {
      // check on default Array iterator
      var Iterators = require('./_iterators');

      var ITERATOR = require('./_wks')('iterator');

      var ArrayProto = Array.prototype;

      module.exports = function (it) {
        return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
      };
    }, {
      "./_iterators": 34,
      "./_wks": 56
    }],
    29: [function (require, module, exports) {
      module.exports = function (it) {
        return _typeof2(it) === 'object' ? it !== null : typeof it === 'function';
      };
    }, {}],
    30: [function (require, module, exports) {
      // call something on iterator step with safe closing on error
      var anObject = require('./_an-object');

      module.exports = function (iterator, fn, value, entries) {
        try {
          return entries ? fn(anObject(value)[0], value[1]) : fn(value); // 7.4.6 IteratorClose(iterator, completion)
        } catch (e) {
          var ret = iterator['return'];
          if (ret !== undefined) anObject(ret.call(iterator));
          throw e;
        }
      };
    }, {
      "./_an-object": 9
    }],
    31: [function (require, module, exports) {
      'use strict';

      var create = require('./_object-create');

      var descriptor = require('./_property-desc');

      var setToStringTag = require('./_set-to-string-tag');

      var IteratorPrototype = {}; // 25.1.2.1.1 %IteratorPrototype%[@@iterator]()

      require('./_hide')(IteratorPrototype, require('./_wks')('iterator'), function () {
        return this;
      });

      module.exports = function (Constructor, NAME, next) {
        Constructor.prototype = create(IteratorPrototype, {
          next: descriptor(1, next)
        });
        setToStringTag(Constructor, NAME + ' Iterator');
      };
    }, {
      "./_hide": 24,
      "./_object-create": 37,
      "./_property-desc": 43,
      "./_set-to-string-tag": 45,
      "./_wks": 56
    }],
    32: [function (require, module, exports) {
      'use strict';

      var LIBRARY = require('./_library');

      var $export = require('./_export');

      var redefine = require('./_redefine');

      var hide = require('./_hide');

      var Iterators = require('./_iterators');

      var $iterCreate = require('./_iter-create');

      var setToStringTag = require('./_set-to-string-tag');

      var getPrototypeOf = require('./_object-gpo');

      var ITERATOR = require('./_wks')('iterator');

      var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`

      var FF_ITERATOR = '@@iterator';
      var KEYS = 'keys';
      var VALUES = 'values';

      var returnThis = function returnThis() {
        return this;
      };

      module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
        $iterCreate(Constructor, NAME, next);

        var getMethod = function getMethod(kind) {
          if (!BUGGY && kind in proto) return proto[kind];

          switch (kind) {
            case KEYS:
              return function keys() {
                return new Constructor(this, kind);
              };

            case VALUES:
              return function values() {
                return new Constructor(this, kind);
              };
          }

          return function entries() {
            return new Constructor(this, kind);
          };
        };

        var TAG = NAME + ' Iterator';
        var DEF_VALUES = DEFAULT == VALUES;
        var VALUES_BUG = false;
        var proto = Base.prototype;
        var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
        var $default = $native || getMethod(DEFAULT);
        var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
        var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
        var methods, key, IteratorPrototype; // Fix native

        if ($anyNative) {
          IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));

          if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
            // Set @@toStringTag to native iterators
            setToStringTag(IteratorPrototype, TAG, true); // fix for some old engines

            if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != 'function') hide(IteratorPrototype, ITERATOR, returnThis);
          }
        } // fix Array#{values, @@iterator}.name in V8 / FF


        if (DEF_VALUES && $native && $native.name !== VALUES) {
          VALUES_BUG = true;

          $default = function values() {
            return $native.call(this);
          };
        } // Define iterator


        if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
          hide(proto, ITERATOR, $default);
        } // Plug for library


        Iterators[NAME] = $default;
        Iterators[TAG] = returnThis;

        if (DEFAULT) {
          methods = {
            values: DEF_VALUES ? $default : getMethod(VALUES),
            keys: IS_SET ? $default : getMethod(KEYS),
            entries: $entries
          };
          if (FORCED) for (key in methods) {
            if (!(key in proto)) redefine(proto, key, methods[key]);
          } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
        }

        return methods;
      };
    }, {
      "./_export": 20,
      "./_hide": 24,
      "./_iter-create": 31,
      "./_iterators": 34,
      "./_library": 35,
      "./_object-gpo": 40,
      "./_redefine": 44,
      "./_set-to-string-tag": 45,
      "./_wks": 56
    }],
    33: [function (require, module, exports) {
      var ITERATOR = require('./_wks')('iterator');

      var SAFE_CLOSING = false;

      try {
        var riter = [7][ITERATOR]();

        riter['return'] = function () {
          SAFE_CLOSING = true;
        }; // eslint-disable-next-line no-throw-literal


        Array.from(riter, function () {
          throw 2;
        });
      } catch (e) {
        /* empty */
      }

      module.exports = function (exec, skipClosing) {
        if (!skipClosing && !SAFE_CLOSING) return false;
        var safe = false;

        try {
          var arr = [7];
          var iter = arr[ITERATOR]();

          iter.next = function () {
            return {
              done: safe = true
            };
          };

          arr[ITERATOR] = function () {
            return iter;
          };

          exec(arr);
        } catch (e) {
          /* empty */
        }

        return safe;
      };
    }, {
      "./_wks": 56
    }],
    34: [function (require, module, exports) {
      module.exports = {};
    }, {}],
    35: [function (require, module, exports) {
      module.exports = true;
    }, {}],
    36: [function (require, module, exports) {
      // 20.2.2.28 Math.sign(x)
      module.exports = Math.sign || function sign(x) {
        // eslint-disable-next-line no-self-compare
        return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
      };
    }, {}],
    37: [function (require, module, exports) {
      // 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
      var anObject = require('./_an-object');

      var dPs = require('./_object-dps');

      var enumBugKeys = require('./_enum-bug-keys');

      var IE_PROTO = require('./_shared-key')('IE_PROTO');

      var Empty = function Empty() {
        /* empty */
      };

      var PROTOTYPE = 'prototype'; // Create object with fake `null` prototype: use iframe Object with cleared prototype

      var _createDict = function createDict() {
        // Thrash, waste and sodomy: IE GC bug
        var iframe = require('./_dom-create')('iframe');

        var i = enumBugKeys.length;
        var lt = '<';
        var gt = '>';
        var iframeDocument;
        iframe.style.display = 'none';

        require('./_html').appendChild(iframe);

        iframe.src = 'javascript:'; // eslint-disable-line no-script-url
        // createDict = iframe.contentWindow.Object;
        // html.removeChild(iframe);

        iframeDocument = iframe.contentWindow.document;
        iframeDocument.open();
        iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
        iframeDocument.close();
        _createDict = iframeDocument.F;

        while (i--) {
          delete _createDict[PROTOTYPE][enumBugKeys[i]];
        }

        return _createDict();
      };

      module.exports = Object.create || function create(O, Properties) {
        var result;

        if (O !== null) {
          Empty[PROTOTYPE] = anObject(O);
          result = new Empty();
          Empty[PROTOTYPE] = null; // add "__proto__" for Object.getPrototypeOf polyfill

          result[IE_PROTO] = O;
        } else result = _createDict();

        return Properties === undefined ? result : dPs(result, Properties);
      };
    }, {
      "./_an-object": 9,
      "./_dom-create": 18,
      "./_enum-bug-keys": 19,
      "./_html": 25,
      "./_object-dps": 39,
      "./_shared-key": 46
    }],
    38: [function (require, module, exports) {
      var anObject = require('./_an-object');

      var IE8_DOM_DEFINE = require('./_ie8-dom-define');

      var toPrimitive = require('./_to-primitive');

      var dP = Object.defineProperty;
      exports.f = require('./_descriptors') ? Object.defineProperty : function defineProperty(O, P, Attributes) {
        anObject(O);
        P = toPrimitive(P, true);
        anObject(Attributes);
        if (IE8_DOM_DEFINE) try {
          return dP(O, P, Attributes);
        } catch (e) {
          /* empty */
        }
        if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
        if ('value' in Attributes) O[P] = Attributes.value;
        return O;
      };
    }, {
      "./_an-object": 9,
      "./_descriptors": 17,
      "./_ie8-dom-define": 26,
      "./_to-primitive": 54
    }],
    39: [function (require, module, exports) {
      var dP = require('./_object-dp');

      var anObject = require('./_an-object');

      var getKeys = require('./_object-keys');

      module.exports = require('./_descriptors') ? Object.defineProperties : function defineProperties(O, Properties) {
        anObject(O);
        var keys = getKeys(Properties);
        var length = keys.length;
        var i = 0;
        var P;

        while (length > i) {
          dP.f(O, P = keys[i++], Properties[P]);
        }

        return O;
      };
    }, {
      "./_an-object": 9,
      "./_descriptors": 17,
      "./_object-dp": 38,
      "./_object-keys": 42
    }],
    40: [function (require, module, exports) {
      // 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
      var has = require('./_has');

      var toObject = require('./_to-object');

      var IE_PROTO = require('./_shared-key')('IE_PROTO');

      var ObjectProto = Object.prototype;

      module.exports = Object.getPrototypeOf || function (O) {
        O = toObject(O);
        if (has(O, IE_PROTO)) return O[IE_PROTO];

        if (typeof O.constructor == 'function' && O instanceof O.constructor) {
          return O.constructor.prototype;
        }

        return O instanceof Object ? ObjectProto : null;
      };
    }, {
      "./_has": 23,
      "./_shared-key": 46,
      "./_to-object": 53
    }],
    41: [function (require, module, exports) {
      var has = require('./_has');

      var toIObject = require('./_to-iobject');

      var arrayIndexOf = require('./_array-includes')(false);

      var IE_PROTO = require('./_shared-key')('IE_PROTO');

      module.exports = function (object, names) {
        var O = toIObject(object);
        var i = 0;
        var result = [];
        var key;

        for (key in O) {
          if (key != IE_PROTO) has(O, key) && result.push(key);
        } // Don't enum bug & hidden keys


        while (names.length > i) {
          if (has(O, key = names[i++])) {
            ~arrayIndexOf(result, key) || result.push(key);
          }
        }

        return result;
      };
    }, {
      "./_array-includes": 10,
      "./_has": 23,
      "./_shared-key": 46,
      "./_to-iobject": 51
    }],
    42: [function (require, module, exports) {
      // 19.1.2.14 / 15.2.3.14 Object.keys(O)
      var $keys = require('./_object-keys-internal');

      var enumBugKeys = require('./_enum-bug-keys');

      module.exports = Object.keys || function keys(O) {
        return $keys(O, enumBugKeys);
      };
    }, {
      "./_enum-bug-keys": 19,
      "./_object-keys-internal": 41
    }],
    43: [function (require, module, exports) {
      module.exports = function (bitmap, value) {
        return {
          enumerable: !(bitmap & 1),
          configurable: !(bitmap & 2),
          writable: !(bitmap & 4),
          value: value
        };
      };
    }, {}],
    44: [function (require, module, exports) {
      module.exports = require('./_hide');
    }, {
      "./_hide": 24
    }],
    45: [function (require, module, exports) {
      var def = require('./_object-dp').f;

      var has = require('./_has');

      var TAG = require('./_wks')('toStringTag');

      module.exports = function (it, tag, stat) {
        if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, {
          configurable: true,
          value: tag
        });
      };
    }, {
      "./_has": 23,
      "./_object-dp": 38,
      "./_wks": 56
    }],
    46: [function (require, module, exports) {
      var shared = require('./_shared')('keys');

      var uid = require('./_uid');

      module.exports = function (key) {
        return shared[key] || (shared[key] = uid(key));
      };
    }, {
      "./_shared": 47,
      "./_uid": 55
    }],
    47: [function (require, module, exports) {
      var core = require('./_core');

      var global = require('./_global');

      var SHARED = '__core-js_shared__';
      var store = global[SHARED] || (global[SHARED] = {});
      (module.exports = function (key, value) {
        return store[key] || (store[key] = value !== undefined ? value : {});
      })('versions', []).push({
        version: core.version,
        mode: require('./_library') ? 'pure' : 'global',
        copyright: '© 2018 Denis Pushkarev (zloirock.ru)'
      });
    }, {
      "./_core": 13,
      "./_global": 22,
      "./_library": 35
    }],
    48: [function (require, module, exports) {
      var toInteger = require('./_to-integer');

      var defined = require('./_defined'); // true  -> String#at
      // false -> String#codePointAt


      module.exports = function (TO_STRING) {
        return function (that, pos) {
          var s = String(defined(that));
          var i = toInteger(pos);
          var l = s.length;
          var a, b;
          if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
          a = s.charCodeAt(i);
          return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff ? TO_STRING ? s.charAt(i) : a : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
        };
      };
    }, {
      "./_defined": 16,
      "./_to-integer": 50
    }],
    49: [function (require, module, exports) {
      var toInteger = require('./_to-integer');

      var max = Math.max;
      var min = Math.min;

      module.exports = function (index, length) {
        index = toInteger(index);
        return index < 0 ? max(index + length, 0) : min(index, length);
      };
    }, {
      "./_to-integer": 50
    }],
    50: [function (require, module, exports) {
      // 7.1.4 ToInteger
      var ceil = Math.ceil;
      var floor = Math.floor;

      module.exports = function (it) {
        return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
      };
    }, {}],
    51: [function (require, module, exports) {
      // to indexed object, toObject with fallback for non-array-like ES3 strings
      var IObject = require('./_iobject');

      var defined = require('./_defined');

      module.exports = function (it) {
        return IObject(defined(it));
      };
    }, {
      "./_defined": 16,
      "./_iobject": 27
    }],
    52: [function (require, module, exports) {
      // 7.1.15 ToLength
      var toInteger = require('./_to-integer');

      var min = Math.min;

      module.exports = function (it) {
        return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
      };
    }, {
      "./_to-integer": 50
    }],
    53: [function (require, module, exports) {
      // 7.1.13 ToObject(argument)
      var defined = require('./_defined');

      module.exports = function (it) {
        return Object(defined(it));
      };
    }, {
      "./_defined": 16
    }],
    54: [function (require, module, exports) {
      // 7.1.1 ToPrimitive(input [, PreferredType])
      var isObject = require('./_is-object'); // instead of the ES6 spec version, we didn't implement @@toPrimitive case
      // and the second argument - flag - preferred type is a string


      module.exports = function (it, S) {
        if (!isObject(it)) return it;
        var fn, val;
        if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
        if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
        if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
        throw TypeError("Can't convert object to primitive value");
      };
    }, {
      "./_is-object": 29
    }],
    55: [function (require, module, exports) {
      var id = 0;
      var px = Math.random();

      module.exports = function (key) {
        return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
      };
    }, {}],
    56: [function (require, module, exports) {
      var store = require('./_shared')('wks');

      var uid = require('./_uid');

      var _Symbol = require('./_global').Symbol;

      var USE_SYMBOL = typeof _Symbol == 'function';

      var $exports = module.exports = function (name) {
        return store[name] || (store[name] = USE_SYMBOL && _Symbol[name] || (USE_SYMBOL ? _Symbol : uid)('Symbol.' + name));
      };

      $exports.store = store;
    }, {
      "./_global": 22,
      "./_shared": 47,
      "./_uid": 55
    }],
    57: [function (require, module, exports) {
      var classof = require('./_classof');

      var ITERATOR = require('./_wks')('iterator');

      var Iterators = require('./_iterators');

      module.exports = require('./_core').getIteratorMethod = function (it) {
        if (it != undefined) return it[ITERATOR] || it['@@iterator'] || Iterators[classof(it)];
      };
    }, {
      "./_classof": 11,
      "./_core": 13,
      "./_iterators": 34,
      "./_wks": 56
    }],
    58: [function (require, module, exports) {
      'use strict';

      var ctx = require('./_ctx');

      var $export = require('./_export');

      var toObject = require('./_to-object');

      var call = require('./_iter-call');

      var isArrayIter = require('./_is-array-iter');

      var toLength = require('./_to-length');

      var createProperty = require('./_create-property');

      var getIterFn = require('./core.get-iterator-method');

      $export($export.S + $export.F * !require('./_iter-detect')(function (iter) {
        Array.from(iter);
      }), 'Array', {
        // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
        from: function from(arrayLike
        /* , mapfn = undefined, thisArg = undefined */
        ) {
          var O = toObject(arrayLike);
          var C = typeof this == 'function' ? this : Array;
          var aLen = arguments.length;
          var mapfn = aLen > 1 ? arguments[1] : undefined;
          var mapping = mapfn !== undefined;
          var index = 0;
          var iterFn = getIterFn(O);
          var length, result, step, iterator;
          if (mapping) mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2); // if object isn't iterable or it's array with default iterator - use simple case

          if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {
            for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
              createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
            }
          } else {
            length = toLength(O.length);

            for (result = new C(length); length > index; index++) {
              createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
            }
          }

          result.length = index;
          return result;
        }
      });
    }, {
      "./_create-property": 14,
      "./_ctx": 15,
      "./_export": 20,
      "./_is-array-iter": 28,
      "./_iter-call": 30,
      "./_iter-detect": 33,
      "./_to-length": 52,
      "./_to-object": 53,
      "./core.get-iterator-method": 57
    }],
    59: [function (require, module, exports) {
      // 20.2.2.21 Math.log10(x)
      var $export = require('./_export');

      $export($export.S, 'Math', {
        log10: function log10(x) {
          return Math.log(x) * Math.LOG10E;
        }
      });
    }, {
      "./_export": 20
    }],
    60: [function (require, module, exports) {
      // 20.2.2.28 Math.sign(x)
      var $export = require('./_export');

      $export($export.S, 'Math', {
        sign: require('./_math-sign')
      });
    }, {
      "./_export": 20,
      "./_math-sign": 36
    }],
    61: [function (require, module, exports) {
      'use strict';

      var $at = require('./_string-at')(true); // 21.1.3.27 String.prototype[@@iterator]()


      require('./_iter-define')(String, 'String', function (iterated) {
        this._t = String(iterated); // target

        this._i = 0; // next index
        // 21.1.5.2.1 %StringIteratorPrototype%.next()
      }, function () {
        var O = this._t;
        var index = this._i;
        var point;
        if (index >= O.length) return {
          value: undefined,
          done: true
        };
        point = $at(O, index);
        this._i += point.length;
        return {
          value: point,
          done: false
        };
      });
    }, {
      "./_iter-define": 32,
      "./_string-at": 48
    }],
    62: [function (require, module, exports) {
      // shim for using process in browser
      var process = module.exports = {}; // cached from whatever global is present so that test runners that stub it
      // don't break things.  But we need to wrap it in a try catch in case it is
      // wrapped in strict mode code which doesn't define any globals.  It's inside a
      // function because try/catches deoptimize in certain engines.

      var cachedSetTimeout;
      var cachedClearTimeout;

      function defaultSetTimout() {
        throw new Error('setTimeout has not been defined');
      }

      function defaultClearTimeout() {
        throw new Error('clearTimeout has not been defined');
      }

      (function () {
        try {
          if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
          } else {
            cachedSetTimeout = defaultSetTimout;
          }
        } catch (e) {
          cachedSetTimeout = defaultSetTimout;
        }

        try {
          if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
          } else {
            cachedClearTimeout = defaultClearTimeout;
          }
        } catch (e) {
          cachedClearTimeout = defaultClearTimeout;
        }
      })();

      function runTimeout(fun) {
        if (cachedSetTimeout === setTimeout) {
          //normal enviroments in sane situations
          return setTimeout(fun, 0);
        } // if setTimeout wasn't available but was latter defined


        if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
          cachedSetTimeout = setTimeout;
          return setTimeout(fun, 0);
        }

        try {
          // when when somebody has screwed with setTimeout but no I.E. maddness
          return cachedSetTimeout(fun, 0);
        } catch (e) {
          try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
          } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
          }
        }
      }

      function runClearTimeout(marker) {
        if (cachedClearTimeout === clearTimeout) {
          //normal enviroments in sane situations
          return clearTimeout(marker);
        } // if clearTimeout wasn't available but was latter defined


        if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
          cachedClearTimeout = clearTimeout;
          return clearTimeout(marker);
        }

        try {
          // when when somebody has screwed with setTimeout but no I.E. maddness
          return cachedClearTimeout(marker);
        } catch (e) {
          try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
          } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
          }
        }
      }

      var queue = [];
      var draining = false;
      var currentQueue;
      var queueIndex = -1;

      function cleanUpNextTick() {
        if (!draining || !currentQueue) {
          return;
        }

        draining = false;

        if (currentQueue.length) {
          queue = currentQueue.concat(queue);
        } else {
          queueIndex = -1;
        }

        if (queue.length) {
          drainQueue();
        }
      }

      function drainQueue() {
        if (draining) {
          return;
        }

        var timeout = runTimeout(cleanUpNextTick);
        draining = true;
        var len = queue.length;

        while (len) {
          currentQueue = queue;
          queue = [];

          while (++queueIndex < len) {
            if (currentQueue) {
              currentQueue[queueIndex].run();
            }
          }

          queueIndex = -1;
          len = queue.length;
        }

        currentQueue = null;
        draining = false;
        runClearTimeout(timeout);
      }

      process.nextTick = function (fun) {
        var args = new Array(arguments.length - 1);

        if (arguments.length > 1) {
          for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
          }
        }

        queue.push(new Item(fun, args));

        if (queue.length === 1 && !draining) {
          runTimeout(drainQueue);
        }
      }; // v8 likes predictible objects


      function Item(fun, array) {
        this.fun = fun;
        this.array = array;
      }

      Item.prototype.run = function () {
        this.fun.apply(null, this.array);
      };

      process.title = 'browser';
      process.browser = true;
      process.env = {};
      process.argv = [];
      process.version = ''; // empty string to avoid regexp issues

      process.versions = {};

      function noop() {}

      process.on = noop;
      process.addListener = noop;
      process.once = noop;
      process.off = noop;
      process.removeListener = noop;
      process.removeAllListeners = noop;
      process.emit = noop;
      process.prependListener = noop;
      process.prependOnceListener = noop;

      process.listeners = function (name) {
        return [];
      };

      process.binding = function (name) {
        throw new Error('process.binding is not supported');
      };

      process.cwd = function () {
        return '/';
      };

      process.chdir = function (dir) {
        throw new Error('process.chdir is not supported');
      };

      process.umask = function () {
        return 0;
      };
    }, {}],
    63: [function (require, module, exports) {
      (function (setImmediate, clearImmediate) {
        var nextTick = require('process/browser.js').nextTick;

        var apply = Function.prototype.apply;
        var slice = Array.prototype.slice;
        var immediateIds = {};
        var nextImmediateId = 0; // DOM APIs, for completeness

        exports.setTimeout = function () {
          return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
        };

        exports.setInterval = function () {
          return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
        };

        exports.clearTimeout = exports.clearInterval = function (timeout) {
          timeout.close();
        };

        function Timeout(id, clearFn) {
          this._id = id;
          this._clearFn = clearFn;
        }

        Timeout.prototype.unref = Timeout.prototype.ref = function () {};

        Timeout.prototype.close = function () {
          this._clearFn.call(window, this._id);
        }; // Does not start the time, just sets up the members needed.


        exports.enroll = function (item, msecs) {
          clearTimeout(item._idleTimeoutId);
          item._idleTimeout = msecs;
        };

        exports.unenroll = function (item) {
          clearTimeout(item._idleTimeoutId);
          item._idleTimeout = -1;
        };

        exports._unrefActive = exports.active = function (item) {
          clearTimeout(item._idleTimeoutId);
          var msecs = item._idleTimeout;

          if (msecs >= 0) {
            item._idleTimeoutId = setTimeout(function onTimeout() {
              if (item._onTimeout) item._onTimeout();
            }, msecs);
          }
        }; // That's not how node.js implements it but the exposed api is the same.


        exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function (fn) {
          var id = nextImmediateId++;
          var args = arguments.length < 2 ? false : slice.call(arguments, 1);
          immediateIds[id] = true;
          nextTick(function onNextTick() {
            if (immediateIds[id]) {
              // fn.call() is faster so we optimize for the common use-case
              // @see http://jsperf.com/call-apply-segu
              if (args) {
                fn.apply(null, args);
              } else {
                fn.call(null);
              } // Prevent ids from leaking


              exports.clearImmediate(id);
            }
          });
          return id;
        };
        exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function (id) {
          delete immediateIds[id];
        };
      }).call(this, require("timers").setImmediate, require("timers").clearImmediate);
    }, {
      "process/browser.js": 62,
      "timers": 63
    }],
    64: [function (require, module, exports) {
      var Vue; // late bind

      var version;
      var map = window.__VUE_HOT_MAP__ = Object.create(null);
      var installed = false;
      var isBrowserify = false;
      var initHookName = 'beforeCreate';

      exports.install = function (vue, browserify) {
        if (installed) {
          return;
        }

        installed = true;
        Vue = vue.__esModule ? vue.default : vue;
        version = Vue.version.split('.').map(Number);
        isBrowserify = browserify; // compat with < 2.0.0-alpha.7

        if (Vue.config._lifecycleHooks.indexOf('init') > -1) {
          initHookName = 'init';
        }

        exports.compatible = version[0] >= 2;

        if (!exports.compatible) {
          console.warn('[HMR] You are using a version of vue-hot-reload-api that is ' + 'only compatible with Vue.js core ^2.0.0.');
          return;
        }
      };
      /**
       * Create a record for a hot module, which keeps track of its constructor
       * and instances
       *
       * @param {String} id
       * @param {Object} options
       */


      exports.createRecord = function (id, options) {
        if (map[id]) {
          return;
        }

        var Ctor = null;

        if (typeof options === 'function') {
          Ctor = options;
          options = Ctor.options;
        }

        makeOptionsHot(id, options);
        map[id] = {
          Ctor: Ctor,
          options: options,
          instances: []
        };
      };
      /**
       * Check if module is recorded
       *
       * @param {String} id
       */


      exports.isRecorded = function (id) {
        return typeof map[id] !== 'undefined';
      };
      /**
       * Make a Component options object hot.
       *
       * @param {String} id
       * @param {Object} options
       */


      function makeOptionsHot(id, options) {
        if (options.functional) {
          var render = options.render;

          options.render = function (h, ctx) {
            var instances = map[id].instances;

            if (ctx && instances.indexOf(ctx.parent) < 0) {
              instances.push(ctx.parent);
            }

            return render(h, ctx);
          };
        } else {
          injectHook(options, initHookName, function () {
            var record = map[id];

            if (!record.Ctor) {
              record.Ctor = this.constructor;
            }

            record.instances.push(this);
          });
          injectHook(options, 'beforeDestroy', function () {
            var instances = map[id].instances;
            instances.splice(instances.indexOf(this), 1);
          });
        }
      }
      /**
       * Inject a hook to a hot reloadable component so that
       * we can keep track of it.
       *
       * @param {Object} options
       * @param {String} name
       * @param {Function} hook
       */


      function injectHook(options, name, hook) {
        var existing = options[name];
        options[name] = existing ? Array.isArray(existing) ? existing.concat(hook) : [existing, hook] : [hook];
      }

      function tryWrap(fn) {
        return function (id, arg) {
          try {
            fn(id, arg);
          } catch (e) {
            console.error(e);
            console.warn('Something went wrong during Vue component hot-reload. Full reload required.');
          }
        };
      }

      function updateOptions(oldOptions, newOptions) {
        for (var key in oldOptions) {
          if (!(key in newOptions)) {
            delete oldOptions[key];
          }
        }

        for (var key$1 in newOptions) {
          oldOptions[key$1] = newOptions[key$1];
        }
      }

      exports.rerender = tryWrap(function (id, options) {
        var record = map[id];

        if (!options) {
          record.instances.slice().forEach(function (instance) {
            instance.$forceUpdate();
          });
          return;
        }

        if (typeof options === 'function') {
          options = options.options;
        }

        if (record.Ctor) {
          record.Ctor.options.render = options.render;
          record.Ctor.options.staticRenderFns = options.staticRenderFns;
          record.instances.slice().forEach(function (instance) {
            instance.$options.render = options.render;
            instance.$options.staticRenderFns = options.staticRenderFns; // reset static trees
            // pre 2.5, all static trees are cahced together on the instance

            if (instance._staticTrees) {
              instance._staticTrees = [];
            } // 2.5.0


            if (Array.isArray(record.Ctor.options.cached)) {
              record.Ctor.options.cached = [];
            } // 2.5.3


            if (Array.isArray(instance.$options.cached)) {
              instance.$options.cached = [];
            } // post 2.5.4: v-once trees are cached on instance._staticTrees.
            // Pure static trees are cached on the staticRenderFns array
            // (both already reset above)


            instance.$forceUpdate();
          });
        } else {
          // functional or no instance created yet
          record.options.render = options.render;
          record.options.staticRenderFns = options.staticRenderFns; // handle functional component re-render

          if (record.options.functional) {
            // rerender with full options
            if (Object.keys(options).length > 2) {
              updateOptions(record.options, options);
            } else {
              // template-only rerender.
              // need to inject the style injection code for CSS modules
              // to work properly.
              var injectStyles = record.options._injectStyles;

              if (injectStyles) {
                var render = options.render;

                record.options.render = function (h, ctx) {
                  injectStyles.call(ctx);
                  return render(h, ctx);
                };
              }
            }

            record.options._Ctor = null; // 2.5.3

            if (Array.isArray(record.options.cached)) {
              record.options.cached = [];
            }

            record.instances.slice().forEach(function (instance) {
              instance.$forceUpdate();
            });
          }
        }
      });
      exports.reload = tryWrap(function (id, options) {
        var record = map[id];

        if (options) {
          if (typeof options === 'function') {
            options = options.options;
          }

          makeOptionsHot(id, options);

          if (record.Ctor) {
            if (version[1] < 2) {
              // preserve pre 2.2 behavior for global mixin handling
              record.Ctor.extendOptions = options;
            }

            var newCtor = record.Ctor.super.extend(options);
            record.Ctor.options = newCtor.options;
            record.Ctor.cid = newCtor.cid;
            record.Ctor.prototype = newCtor.prototype;

            if (newCtor.release) {
              // temporary global mixin strategy used in < 2.0.0-alpha.6
              newCtor.release();
            }
          } else {
            updateOptions(record.options, options);
          }
        }

        record.instances.slice().forEach(function (instance) {
          if (instance.$vnode && instance.$vnode.context) {
            instance.$vnode.context.$forceUpdate();
          } else {
            console.warn('Root or manually mounted instance modified. Full reload required.');
          }
        });
      });
    }, {}],
    65: [function (require, module, exports) {
      (function (process, global, setImmediate) {
        /*!
         * Vue.js v2.5.16
         * (c) 2014-2018 Evan You
         * Released under the MIT License.
         */
        'use strict';
        /*  */

        var emptyObject = Object.freeze({}); // these helpers produces better vm code in JS engines due to their
        // explicitness and function inlining

        function isUndef(v) {
          return v === undefined || v === null;
        }

        function isDef(v) {
          return v !== undefined && v !== null;
        }

        function isTrue(v) {
          return v === true;
        }

        function isFalse(v) {
          return v === false;
        }
        /**
         * Check if value is primitive
         */


        function isPrimitive(value) {
          return typeof value === 'string' || typeof value === 'number' || // $flow-disable-line
          _typeof2(value) === 'symbol' || typeof value === 'boolean';
        }
        /**
         * Quick object check - this is primarily used to tell
         * Objects from primitive values when we know the value
         * is a JSON-compliant type.
         */


        function isObject(obj) {
          return obj !== null && _typeof2(obj) === 'object';
        }
        /**
         * Get the raw type string of a value e.g. [object Object]
         */


        var _toString = Object.prototype.toString;

        function toRawType(value) {
          return _toString.call(value).slice(8, -1);
        }
        /**
         * Strict object type check. Only returns true
         * for plain JavaScript objects.
         */


        function isPlainObject(obj) {
          return _toString.call(obj) === '[object Object]';
        }

        function isRegExp(v) {
          return _toString.call(v) === '[object RegExp]';
        }
        /**
         * Check if val is a valid array index.
         */


        function isValidArrayIndex(val) {
          var n = parseFloat(String(val));
          return n >= 0 && Math.floor(n) === n && isFinite(val);
        }
        /**
         * Convert a value to a string that is actually rendered.
         */


        function toString(val) {
          return val == null ? '' : _typeof2(val) === 'object' ? JSON.stringify(val, null, 2) : String(val);
        }
        /**
         * Convert a input value to a number for persistence.
         * If the conversion fails, return original string.
         */


        function toNumber(val) {
          var n = parseFloat(val);
          return isNaN(n) ? val : n;
        }
        /**
         * Make a map and return a function for checking if a key
         * is in that map.
         */


        function makeMap(str, expectsLowerCase) {
          var map = Object.create(null);
          var list = str.split(',');

          for (var i = 0; i < list.length; i++) {
            map[list[i]] = true;
          }

          return expectsLowerCase ? function (val) {
            return map[val.toLowerCase()];
          } : function (val) {
            return map[val];
          };
        }
        /**
         * Check if a tag is a built-in tag.
         */


        var isBuiltInTag = makeMap('slot,component', true);
        /**
         * Check if a attribute is a reserved attribute.
         */

        var isReservedAttribute = makeMap('key,ref,slot,slot-scope,is');
        /**
         * Remove an item from an array
         */

        function remove(arr, item) {
          if (arr.length) {
            var index = arr.indexOf(item);

            if (index > -1) {
              return arr.splice(index, 1);
            }
          }
        }
        /**
         * Check whether the object has the property.
         */


        var hasOwnProperty = Object.prototype.hasOwnProperty;

        function hasOwn(obj, key) {
          return hasOwnProperty.call(obj, key);
        }
        /**
         * Create a cached version of a pure function.
         */


        function cached(fn) {
          var cache = Object.create(null);
          return function cachedFn(str) {
            var hit = cache[str];
            return hit || (cache[str] = fn(str));
          };
        }
        /**
         * Camelize a hyphen-delimited string.
         */


        var camelizeRE = /-(\w)/g;
        var camelize = cached(function (str) {
          return str.replace(camelizeRE, function (_, c) {
            return c ? c.toUpperCase() : '';
          });
        });
        /**
         * Capitalize a string.
         */

        var capitalize = cached(function (str) {
          return str.charAt(0).toUpperCase() + str.slice(1);
        });
        /**
         * Hyphenate a camelCase string.
         */

        var hyphenateRE = /\B([A-Z])/g;
        var hyphenate = cached(function (str) {
          return str.replace(hyphenateRE, '-$1').toLowerCase();
        });
        /**
         * Simple bind polyfill for environments that do not support it... e.g.
         * PhantomJS 1.x. Technically we don't need this anymore since native bind is
         * now more performant in most browsers, but removing it would be breaking for
         * code that was able to run in PhantomJS 1.x, so this must be kept for
         * backwards compatibility.
         */

        /* istanbul ignore next */

        function polyfillBind(fn, ctx) {
          function boundFn(a) {
            var l = arguments.length;
            return l ? l > 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a) : fn.call(ctx);
          }

          boundFn._length = fn.length;
          return boundFn;
        }

        function nativeBind(fn, ctx) {
          return fn.bind(ctx);
        }

        var bind = Function.prototype.bind ? nativeBind : polyfillBind;
        /**
         * Convert an Array-like object to a real Array.
         */

        function toArray(list, start) {
          start = start || 0;
          var i = list.length - start;
          var ret = new Array(i);

          while (i--) {
            ret[i] = list[i + start];
          }

          return ret;
        }
        /**
         * Mix properties into target object.
         */


        function extend(to, _from) {
          for (var key in _from) {
            to[key] = _from[key];
          }

          return to;
        }
        /**
         * Merge an Array of Objects into a single Object.
         */


        function toObject(arr) {
          var res = {};

          for (var i = 0; i < arr.length; i++) {
            if (arr[i]) {
              extend(res, arr[i]);
            }
          }

          return res;
        }
        /**
         * Perform no operation.
         * Stubbing args to make Flow happy without leaving useless transpiled code
         * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/)
         */


        function noop(a, b, c) {}
        /**
         * Always return false.
         */


        var no = function no(a, b, c) {
          return false;
        };
        /**
         * Return same value
         */


        var identity = function identity(_) {
          return _;
        };
        /**
         * Generate a static keys string from compiler modules.
         */

        /**
         * Check if two values are loosely equal - that is,
         * if they are plain objects, do they have the same shape?
         */


        function looseEqual(a, b) {
          if (a === b) {
            return true;
          }

          var isObjectA = isObject(a);
          var isObjectB = isObject(b);

          if (isObjectA && isObjectB) {
            try {
              var isArrayA = Array.isArray(a);
              var isArrayB = Array.isArray(b);

              if (isArrayA && isArrayB) {
                return a.length === b.length && a.every(function (e, i) {
                  return looseEqual(e, b[i]);
                });
              } else if (!isArrayA && !isArrayB) {
                var keysA = Object.keys(a);
                var keysB = Object.keys(b);
                return keysA.length === keysB.length && keysA.every(function (key) {
                  return looseEqual(a[key], b[key]);
                });
              } else {
                /* istanbul ignore next */
                return false;
              }
            } catch (e) {
              /* istanbul ignore next */
              return false;
            }
          } else if (!isObjectA && !isObjectB) {
            return String(a) === String(b);
          } else {
            return false;
          }
        }

        function looseIndexOf(arr, val) {
          for (var i = 0; i < arr.length; i++) {
            if (looseEqual(arr[i], val)) {
              return i;
            }
          }

          return -1;
        }
        /**
         * Ensure a function is called only once.
         */


        function once(fn) {
          var called = false;
          return function () {
            if (!called) {
              called = true;
              fn.apply(this, arguments);
            }
          };
        }

        var SSR_ATTR = 'data-server-rendered';
        var ASSET_TYPES = ['component', 'directive', 'filter'];
        var LIFECYCLE_HOOKS = ['beforeCreate', 'created', 'beforeMount', 'mounted', 'beforeUpdate', 'updated', 'beforeDestroy', 'destroyed', 'activated', 'deactivated', 'errorCaptured'];
        /*  */

        var config = {
          /**
           * Option merge strategies (used in core/util/options)
           */
          // $flow-disable-line
          optionMergeStrategies: Object.create(null),

          /**
           * Whether to suppress warnings.
           */
          silent: false,

          /**
           * Show production mode tip message on boot?
           */
          productionTip: process.env.NODE_ENV !== 'production',

          /**
           * Whether to enable devtools
           */
          devtools: process.env.NODE_ENV !== 'production',

          /**
           * Whether to record perf
           */
          performance: false,

          /**
           * Error handler for watcher errors
           */
          errorHandler: null,

          /**
           * Warn handler for watcher warns
           */
          warnHandler: null,

          /**
           * Ignore certain custom elements
           */
          ignoredElements: [],

          /**
           * Custom user key aliases for v-on
           */
          // $flow-disable-line
          keyCodes: Object.create(null),

          /**
           * Check if a tag is reserved so that it cannot be registered as a
           * component. This is platform-dependent and may be overwritten.
           */
          isReservedTag: no,

          /**
           * Check if an attribute is reserved so that it cannot be used as a component
           * prop. This is platform-dependent and may be overwritten.
           */
          isReservedAttr: no,

          /**
           * Check if a tag is an unknown element.
           * Platform-dependent.
           */
          isUnknownElement: no,

          /**
           * Get the namespace of an element
           */
          getTagNamespace: noop,

          /**
           * Parse the real tag name for the specific platform.
           */
          parsePlatformTagName: identity,

          /**
           * Check if an attribute must be bound using property, e.g. value
           * Platform-dependent.
           */
          mustUseProp: no,

          /**
           * Exposed for legacy reasons
           */
          _lifecycleHooks: LIFECYCLE_HOOKS
        };
        /*  */

        /**
         * Check if a string starts with $ or _
         */

        function isReserved(str) {
          var c = (str + '').charCodeAt(0);
          return c === 0x24 || c === 0x5F;
        }
        /**
         * Define a property.
         */


        function def(obj, key, val, enumerable) {
          Object.defineProperty(obj, key, {
            value: val,
            enumerable: !!enumerable,
            writable: true,
            configurable: true
          });
        }
        /**
         * Parse simple path.
         */


        var bailRE = /[^\w.$]/;

        function parsePath(path) {
          if (bailRE.test(path)) {
            return;
          }

          var segments = path.split('.');
          return function (obj) {
            for (var i = 0; i < segments.length; i++) {
              if (!obj) {
                return;
              }

              obj = obj[segments[i]];
            }

            return obj;
          };
        }
        /*  */
        // can we use __proto__?


        var hasProto = '__proto__' in {}; // Browser environment sniffing

        var inBrowser = typeof window !== 'undefined';
        var inWeex = typeof WXEnvironment !== 'undefined' && !!WXEnvironment.platform;
        var weexPlatform = inWeex && WXEnvironment.platform.toLowerCase();
        var UA = inBrowser && window.navigator.userAgent.toLowerCase();
        var isIE = UA && /msie|trident/.test(UA);
        var isIE9 = UA && UA.indexOf('msie 9.0') > 0;
        var isEdge = UA && UA.indexOf('edge/') > 0;
        var isAndroid = UA && UA.indexOf('android') > 0 || weexPlatform === 'android';
        var isIOS = UA && /iphone|ipad|ipod|ios/.test(UA) || weexPlatform === 'ios';
        var isChrome = UA && /chrome\/\d+/.test(UA) && !isEdge; // Firefox has a "watch" function on Object.prototype...

        var nativeWatch = {}.watch;
        var supportsPassive = false;

        if (inBrowser) {
          try {
            var opts = {};
            Object.defineProperty(opts, 'passive', {
              get: function get() {
                /* istanbul ignore next */
                supportsPassive = true;
              }
            }); // https://github.com/facebook/flow/issues/285

            window.addEventListener('test-passive', null, opts);
          } catch (e) {}
        } // this needs to be lazy-evaled because vue may be required before
        // vue-server-renderer can set VUE_ENV


        var _isServer;

        var isServerRendering = function isServerRendering() {
          if (_isServer === undefined) {
            /* istanbul ignore if */
            if (!inBrowser && !inWeex && typeof global !== 'undefined') {
              // detect presence of vue-server-renderer and avoid
              // Webpack shimming the process
              _isServer = global['process'].env.VUE_ENV === 'server';
            } else {
              _isServer = false;
            }
          }

          return _isServer;
        }; // detect devtools


        var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;
        /* istanbul ignore next */

        function isNative(Ctor) {
          return typeof Ctor === 'function' && /native code/.test(Ctor.toString());
        }

        var hasSymbol = typeof Symbol !== 'undefined' && isNative(Symbol) && typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);

        var _Set;
        /* istanbul ignore if */
        // $flow-disable-line


        if (typeof Set !== 'undefined' && isNative(Set)) {
          // use native Set when available.
          _Set = Set;
        } else {
          // a non-standard Set polyfill that only works with primitive keys.
          _Set = function () {
            function Set() {
              this.set = Object.create(null);
            }

            Set.prototype.has = function has(key) {
              return this.set[key] === true;
            };

            Set.prototype.add = function add(key) {
              this.set[key] = true;
            };

            Set.prototype.clear = function clear() {
              this.set = Object.create(null);
            };

            return Set;
          }();
        }
        /*  */


        var warn = noop;
        var tip = noop;
        var generateComponentTrace = noop; // work around flow check

        var formatComponentName = noop;

        if (process.env.NODE_ENV !== 'production') {
          var hasConsole = typeof console !== 'undefined';
          var classifyRE = /(?:^|[-_])(\w)/g;

          var classify = function classify(str) {
            return str.replace(classifyRE, function (c) {
              return c.toUpperCase();
            }).replace(/[-_]/g, '');
          };

          warn = function warn(msg, vm) {
            var trace = vm ? generateComponentTrace(vm) : '';

            if (config.warnHandler) {
              config.warnHandler.call(null, msg, vm, trace);
            } else if (hasConsole && !config.silent) {
              console.error("[Vue warn]: " + msg + trace);
            }
          };

          tip = function tip(msg, vm) {
            if (hasConsole && !config.silent) {
              console.warn("[Vue tip]: " + msg + (vm ? generateComponentTrace(vm) : ''));
            }
          };

          formatComponentName = function formatComponentName(vm, includeFile) {
            if (vm.$root === vm) {
              return '<Root>';
            }

            var options = typeof vm === 'function' && vm.cid != null ? vm.options : vm._isVue ? vm.$options || vm.constructor.options : vm || {};
            var name = options.name || options._componentTag;
            var file = options.__file;

            if (!name && file) {
              var match = file.match(/([^/\\]+)\.vue$/);
              name = match && match[1];
            }

            return (name ? "<" + classify(name) + ">" : "<Anonymous>") + (file && includeFile !== false ? " at " + file : '');
          };

          var repeat = function repeat(str, n) {
            var res = '';

            while (n) {
              if (n % 2 === 1) {
                res += str;
              }

              if (n > 1) {
                str += str;
              }

              n >>= 1;
            }

            return res;
          };

          generateComponentTrace = function generateComponentTrace(vm) {
            if (vm._isVue && vm.$parent) {
              var tree = [];
              var currentRecursiveSequence = 0;

              while (vm) {
                if (tree.length > 0) {
                  var last = tree[tree.length - 1];

                  if (last.constructor === vm.constructor) {
                    currentRecursiveSequence++;
                    vm = vm.$parent;
                    continue;
                  } else if (currentRecursiveSequence > 0) {
                    tree[tree.length - 1] = [last, currentRecursiveSequence];
                    currentRecursiveSequence = 0;
                  }
                }

                tree.push(vm);
                vm = vm.$parent;
              }

              return '\n\nfound in\n\n' + tree.map(function (vm, i) {
                return "" + (i === 0 ? '---> ' : repeat(' ', 5 + i * 2)) + (Array.isArray(vm) ? formatComponentName(vm[0]) + "... (" + vm[1] + " recursive calls)" : formatComponentName(vm));
              }).join('\n');
            } else {
              return "\n\n(found in " + formatComponentName(vm) + ")";
            }
          };
        }
        /*  */


        var uid = 0;
        /**
         * A dep is an observable that can have multiple
         * directives subscribing to it.
         */

        var Dep = function Dep() {
          this.id = uid++;
          this.subs = [];
        };

        Dep.prototype.addSub = function addSub(sub) {
          this.subs.push(sub);
        };

        Dep.prototype.removeSub = function removeSub(sub) {
          remove(this.subs, sub);
        };

        Dep.prototype.depend = function depend() {
          if (Dep.target) {
            Dep.target.addDep(this);
          }
        };

        Dep.prototype.notify = function notify() {
          // stabilize the subscriber list first
          var subs = this.subs.slice();

          for (var i = 0, l = subs.length; i < l; i++) {
            subs[i].update();
          }
        }; // the current target watcher being evaluated.
        // this is globally unique because there could be only one
        // watcher being evaluated at any time.


        Dep.target = null;
        var targetStack = [];

        function pushTarget(_target) {
          if (Dep.target) {
            targetStack.push(Dep.target);
          }

          Dep.target = _target;
        }

        function popTarget() {
          Dep.target = targetStack.pop();
        }
        /*  */


        var VNode = function VNode(tag, data, children, text, elm, context, componentOptions, asyncFactory) {
          this.tag = tag;
          this.data = data;
          this.children = children;
          this.text = text;
          this.elm = elm;
          this.ns = undefined;
          this.context = context;
          this.fnContext = undefined;
          this.fnOptions = undefined;
          this.fnScopeId = undefined;
          this.key = data && data.key;
          this.componentOptions = componentOptions;
          this.componentInstance = undefined;
          this.parent = undefined;
          this.raw = false;
          this.isStatic = false;
          this.isRootInsert = true;
          this.isComment = false;
          this.isCloned = false;
          this.isOnce = false;
          this.asyncFactory = asyncFactory;
          this.asyncMeta = undefined;
          this.isAsyncPlaceholder = false;
        };

        var prototypeAccessors = {
          child: {
            configurable: true
          }
        }; // DEPRECATED: alias for componentInstance for backwards compat.

        /* istanbul ignore next */

        prototypeAccessors.child.get = function () {
          return this.componentInstance;
        };

        Object.defineProperties(VNode.prototype, prototypeAccessors);

        var createEmptyVNode = function createEmptyVNode(text) {
          if (text === void 0) text = '';
          var node = new VNode();
          node.text = text;
          node.isComment = true;
          return node;
        };

        function createTextVNode(val) {
          return new VNode(undefined, undefined, undefined, String(val));
        } // optimized shallow clone
        // used for static nodes and slot nodes because they may be reused across
        // multiple renders, cloning them avoids errors when DOM manipulations rely
        // on their elm reference.


        function cloneVNode(vnode) {
          var cloned = new VNode(vnode.tag, vnode.data, vnode.children, vnode.text, vnode.elm, vnode.context, vnode.componentOptions, vnode.asyncFactory);
          cloned.ns = vnode.ns;
          cloned.isStatic = vnode.isStatic;
          cloned.key = vnode.key;
          cloned.isComment = vnode.isComment;
          cloned.fnContext = vnode.fnContext;
          cloned.fnOptions = vnode.fnOptions;
          cloned.fnScopeId = vnode.fnScopeId;
          cloned.isCloned = true;
          return cloned;
        }
        /*
         * not type checking this file because flow doesn't play well with
         * dynamically accessing methods on Array prototype
         */


        var arrayProto = Array.prototype;
        var arrayMethods = Object.create(arrayProto);
        var methodsToPatch = ['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'];
        /**
         * Intercept mutating methods and emit events
         */

        methodsToPatch.forEach(function (method) {
          // cache original method
          var original = arrayProto[method];
          def(arrayMethods, method, function mutator() {
            var args = [],
                len = arguments.length;

            while (len--) {
              args[len] = arguments[len];
            }

            var result = original.apply(this, args);
            var ob = this.__ob__;
            var inserted;

            switch (method) {
              case 'push':
              case 'unshift':
                inserted = args;
                break;

              case 'splice':
                inserted = args.slice(2);
                break;
            }

            if (inserted) {
              ob.observeArray(inserted);
            } // notify change


            ob.dep.notify();
            return result;
          });
        });
        /*  */

        var arrayKeys = Object.getOwnPropertyNames(arrayMethods);
        /**
         * In some cases we may want to disable observation inside a component's
         * update computation.
         */

        var shouldObserve = true;

        function toggleObserving(value) {
          shouldObserve = value;
        }
        /**
         * Observer class that is attached to each observed
         * object. Once attached, the observer converts the target
         * object's property keys into getter/setters that
         * collect dependencies and dispatch updates.
         */


        var Observer = function Observer(value) {
          this.value = value;
          this.dep = new Dep();
          this.vmCount = 0;
          def(value, '__ob__', this);

          if (Array.isArray(value)) {
            var augment = hasProto ? protoAugment : copyAugment;
            augment(value, arrayMethods, arrayKeys);
            this.observeArray(value);
          } else {
            this.walk(value);
          }
        };
        /**
         * Walk through each property and convert them into
         * getter/setters. This method should only be called when
         * value type is Object.
         */


        Observer.prototype.walk = function walk(obj) {
          var keys = Object.keys(obj);

          for (var i = 0; i < keys.length; i++) {
            defineReactive(obj, keys[i]);
          }
        };
        /**
         * Observe a list of Array items.
         */


        Observer.prototype.observeArray = function observeArray(items) {
          for (var i = 0, l = items.length; i < l; i++) {
            observe(items[i]);
          }
        }; // helpers

        /**
         * Augment an target Object or Array by intercepting
         * the prototype chain using __proto__
         */


        function protoAugment(target, src, keys) {
          /* eslint-disable no-proto */
          target.__proto__ = src;
          /* eslint-enable no-proto */
        }
        /**
         * Augment an target Object or Array by defining
         * hidden properties.
         */

        /* istanbul ignore next */


        function copyAugment(target, src, keys) {
          for (var i = 0, l = keys.length; i < l; i++) {
            var key = keys[i];
            def(target, key, src[key]);
          }
        }
        /**
         * Attempt to create an observer instance for a value,
         * returns the new observer if successfully observed,
         * or the existing observer if the value already has one.
         */


        function observe(value, asRootData) {
          if (!isObject(value) || value instanceof VNode) {
            return;
          }

          var ob;

          if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
            ob = value.__ob__;
          } else if (shouldObserve && !isServerRendering() && (Array.isArray(value) || isPlainObject(value)) && Object.isExtensible(value) && !value._isVue) {
            ob = new Observer(value);
          }

          if (asRootData && ob) {
            ob.vmCount++;
          }

          return ob;
        }
        /**
         * Define a reactive property on an Object.
         */


        function defineReactive(obj, key, val, customSetter, shallow) {
          var dep = new Dep();
          var property = Object.getOwnPropertyDescriptor(obj, key);

          if (property && property.configurable === false) {
            return;
          } // cater for pre-defined getter/setters


          var getter = property && property.get;

          if (!getter && arguments.length === 2) {
            val = obj[key];
          }

          var setter = property && property.set;
          var childOb = !shallow && observe(val);
          Object.defineProperty(obj, key, {
            enumerable: true,
            configurable: true,
            get: function reactiveGetter() {
              var value = getter ? getter.call(obj) : val;

              if (Dep.target) {
                dep.depend();

                if (childOb) {
                  childOb.dep.depend();

                  if (Array.isArray(value)) {
                    dependArray(value);
                  }
                }
              }

              return value;
            },
            set: function reactiveSetter(newVal) {
              var value = getter ? getter.call(obj) : val;
              /* eslint-disable no-self-compare */

              if (newVal === value || newVal !== newVal && value !== value) {
                return;
              }
              /* eslint-enable no-self-compare */


              if (process.env.NODE_ENV !== 'production' && customSetter) {
                customSetter();
              }

              if (setter) {
                setter.call(obj, newVal);
              } else {
                val = newVal;
              }

              childOb = !shallow && observe(newVal);
              dep.notify();
            }
          });
        }
        /**
         * Set a property on an object. Adds the new property and
         * triggers change notification if the property doesn't
         * already exist.
         */


        function set(target, key, val) {
          if (process.env.NODE_ENV !== 'production' && (isUndef(target) || isPrimitive(target))) {
            warn("Cannot set reactive property on undefined, null, or primitive value: " + target);
          }

          if (Array.isArray(target) && isValidArrayIndex(key)) {
            target.length = Math.max(target.length, key);
            target.splice(key, 1, val);
            return val;
          }

          if (key in target && !(key in Object.prototype)) {
            target[key] = val;
            return val;
          }

          var ob = target.__ob__;

          if (target._isVue || ob && ob.vmCount) {
            process.env.NODE_ENV !== 'production' && warn('Avoid adding reactive properties to a Vue instance or its root $data ' + 'at runtime - declare it upfront in the data option.');
            return val;
          }

          if (!ob) {
            target[key] = val;
            return val;
          }

          defineReactive(ob.value, key, val);
          ob.dep.notify();
          return val;
        }
        /**
         * Delete a property and trigger change if necessary.
         */


        function del(target, key) {
          if (process.env.NODE_ENV !== 'production' && (isUndef(target) || isPrimitive(target))) {
            warn("Cannot delete reactive property on undefined, null, or primitive value: " + target);
          }

          if (Array.isArray(target) && isValidArrayIndex(key)) {
            target.splice(key, 1);
            return;
          }

          var ob = target.__ob__;

          if (target._isVue || ob && ob.vmCount) {
            process.env.NODE_ENV !== 'production' && warn('Avoid deleting properties on a Vue instance or its root $data ' + '- just set it to null.');
            return;
          }

          if (!hasOwn(target, key)) {
            return;
          }

          delete target[key];

          if (!ob) {
            return;
          }

          ob.dep.notify();
        }
        /**
         * Collect dependencies on array elements when the array is touched, since
         * we cannot intercept array element access like property getters.
         */


        function dependArray(value) {
          for (var e = void 0, i = 0, l = value.length; i < l; i++) {
            e = value[i];
            e && e.__ob__ && e.__ob__.dep.depend();

            if (Array.isArray(e)) {
              dependArray(e);
            }
          }
        }
        /*  */

        /**
         * Option overwriting strategies are functions that handle
         * how to merge a parent option value and a child option
         * value into the final value.
         */


        var strats = config.optionMergeStrategies;
        /**
         * Options with restrictions
         */

        if (process.env.NODE_ENV !== 'production') {
          strats.el = strats.propsData = function (parent, child, vm, key) {
            if (!vm) {
              warn("option \"" + key + "\" can only be used during instance " + 'creation with the `new` keyword.');
            }

            return defaultStrat(parent, child);
          };
        }
        /**
         * Helper that recursively merges two data objects together.
         */


        function mergeData(to, from) {
          if (!from) {
            return to;
          }

          var key, toVal, fromVal;
          var keys = Object.keys(from);

          for (var i = 0; i < keys.length; i++) {
            key = keys[i];
            toVal = to[key];
            fromVal = from[key];

            if (!hasOwn(to, key)) {
              set(to, key, fromVal);
            } else if (isPlainObject(toVal) && isPlainObject(fromVal)) {
              mergeData(toVal, fromVal);
            }
          }

          return to;
        }
        /**
         * Data
         */


        function mergeDataOrFn(parentVal, childVal, vm) {
          if (!vm) {
            // in a Vue.extend merge, both should be functions
            if (!childVal) {
              return parentVal;
            }

            if (!parentVal) {
              return childVal;
            } // when parentVal & childVal are both present,
            // we need to return a function that returns the
            // merged result of both functions... no need to
            // check if parentVal is a function here because
            // it has to be a function to pass previous merges.


            return function mergedDataFn() {
              return mergeData(typeof childVal === 'function' ? childVal.call(this, this) : childVal, typeof parentVal === 'function' ? parentVal.call(this, this) : parentVal);
            };
          } else {
            return function mergedInstanceDataFn() {
              // instance merge
              var instanceData = typeof childVal === 'function' ? childVal.call(vm, vm) : childVal;
              var defaultData = typeof parentVal === 'function' ? parentVal.call(vm, vm) : parentVal;

              if (instanceData) {
                return mergeData(instanceData, defaultData);
              } else {
                return defaultData;
              }
            };
          }
        }

        strats.data = function (parentVal, childVal, vm) {
          if (!vm) {
            if (childVal && typeof childVal !== 'function') {
              process.env.NODE_ENV !== 'production' && warn('The "data" option should be a function ' + 'that returns a per-instance value in component ' + 'definitions.', vm);
              return parentVal;
            }

            return mergeDataOrFn(parentVal, childVal);
          }

          return mergeDataOrFn(parentVal, childVal, vm);
        };
        /**
         * Hooks and props are merged as arrays.
         */


        function mergeHook(parentVal, childVal) {
          return childVal ? parentVal ? parentVal.concat(childVal) : Array.isArray(childVal) ? childVal : [childVal] : parentVal;
        }

        LIFECYCLE_HOOKS.forEach(function (hook) {
          strats[hook] = mergeHook;
        });
        /**
         * Assets
         *
         * When a vm is present (instance creation), we need to do
         * a three-way merge between constructor options, instance
         * options and parent options.
         */

        function mergeAssets(parentVal, childVal, vm, key) {
          var res = Object.create(parentVal || null);

          if (childVal) {
            process.env.NODE_ENV !== 'production' && assertObjectType(key, childVal, vm);
            return extend(res, childVal);
          } else {
            return res;
          }
        }

        ASSET_TYPES.forEach(function (type) {
          strats[type + 's'] = mergeAssets;
        });
        /**
         * Watchers.
         *
         * Watchers hashes should not overwrite one
         * another, so we merge them as arrays.
         */

        strats.watch = function (parentVal, childVal, vm, key) {
          // work around Firefox's Object.prototype.watch...
          if (parentVal === nativeWatch) {
            parentVal = undefined;
          }

          if (childVal === nativeWatch) {
            childVal = undefined;
          }
          /* istanbul ignore if */


          if (!childVal) {
            return Object.create(parentVal || null);
          }

          if (process.env.NODE_ENV !== 'production') {
            assertObjectType(key, childVal, vm);
          }

          if (!parentVal) {
            return childVal;
          }

          var ret = {};
          extend(ret, parentVal);

          for (var key$1 in childVal) {
            var parent = ret[key$1];
            var child = childVal[key$1];

            if (parent && !Array.isArray(parent)) {
              parent = [parent];
            }

            ret[key$1] = parent ? parent.concat(child) : Array.isArray(child) ? child : [child];
          }

          return ret;
        };
        /**
         * Other object hashes.
         */


        strats.props = strats.methods = strats.inject = strats.computed = function (parentVal, childVal, vm, key) {
          if (childVal && process.env.NODE_ENV !== 'production') {
            assertObjectType(key, childVal, vm);
          }

          if (!parentVal) {
            return childVal;
          }

          var ret = Object.create(null);
          extend(ret, parentVal);

          if (childVal) {
            extend(ret, childVal);
          }

          return ret;
        };

        strats.provide = mergeDataOrFn;
        /**
         * Default strategy.
         */

        var defaultStrat = function defaultStrat(parentVal, childVal) {
          return childVal === undefined ? parentVal : childVal;
        };
        /**
         * Validate component names
         */


        function checkComponents(options) {
          for (var key in options.components) {
            validateComponentName(key);
          }
        }

        function validateComponentName(name) {
          if (!/^[a-zA-Z][\w-]*$/.test(name)) {
            warn('Invalid component name: "' + name + '". Component names ' + 'can only contain alphanumeric characters and the hyphen, ' + 'and must start with a letter.');
          }

          if (isBuiltInTag(name) || config.isReservedTag(name)) {
            warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + name);
          }
        }
        /**
         * Ensure all props option syntax are normalized into the
         * Object-based format.
         */


        function normalizeProps(options, vm) {
          var props = options.props;

          if (!props) {
            return;
          }

          var res = {};
          var i, val, name;

          if (Array.isArray(props)) {
            i = props.length;

            while (i--) {
              val = props[i];

              if (typeof val === 'string') {
                name = camelize(val);
                res[name] = {
                  type: null
                };
              } else if (process.env.NODE_ENV !== 'production') {
                warn('props must be strings when using array syntax.');
              }
            }
          } else if (isPlainObject(props)) {
            for (var key in props) {
              val = props[key];
              name = camelize(key);
              res[name] = isPlainObject(val) ? val : {
                type: val
              };
            }
          } else if (process.env.NODE_ENV !== 'production') {
            warn("Invalid value for option \"props\": expected an Array or an Object, " + "but got " + toRawType(props) + ".", vm);
          }

          options.props = res;
        }
        /**
         * Normalize all injections into Object-based format
         */


        function normalizeInject(options, vm) {
          var inject = options.inject;

          if (!inject) {
            return;
          }

          var normalized = options.inject = {};

          if (Array.isArray(inject)) {
            for (var i = 0; i < inject.length; i++) {
              normalized[inject[i]] = {
                from: inject[i]
              };
            }
          } else if (isPlainObject(inject)) {
            for (var key in inject) {
              var val = inject[key];
              normalized[key] = isPlainObject(val) ? extend({
                from: key
              }, val) : {
                from: val
              };
            }
          } else if (process.env.NODE_ENV !== 'production') {
            warn("Invalid value for option \"inject\": expected an Array or an Object, " + "but got " + toRawType(inject) + ".", vm);
          }
        }
        /**
         * Normalize raw function directives into object format.
         */


        function normalizeDirectives(options) {
          var dirs = options.directives;

          if (dirs) {
            for (var key in dirs) {
              var def = dirs[key];

              if (typeof def === 'function') {
                dirs[key] = {
                  bind: def,
                  update: def
                };
              }
            }
          }
        }

        function assertObjectType(name, value, vm) {
          if (!isPlainObject(value)) {
            warn("Invalid value for option \"" + name + "\": expected an Object, " + "but got " + toRawType(value) + ".", vm);
          }
        }
        /**
         * Merge two option objects into a new one.
         * Core utility used in both instantiation and inheritance.
         */


        function mergeOptions(parent, child, vm) {
          if (process.env.NODE_ENV !== 'production') {
            checkComponents(child);
          }

          if (typeof child === 'function') {
            child = child.options;
          }

          normalizeProps(child, vm);
          normalizeInject(child, vm);
          normalizeDirectives(child);
          var extendsFrom = child.extends;

          if (extendsFrom) {
            parent = mergeOptions(parent, extendsFrom, vm);
          }

          if (child.mixins) {
            for (var i = 0, l = child.mixins.length; i < l; i++) {
              parent = mergeOptions(parent, child.mixins[i], vm);
            }
          }

          var options = {};
          var key;

          for (key in parent) {
            mergeField(key);
          }

          for (key in child) {
            if (!hasOwn(parent, key)) {
              mergeField(key);
            }
          }

          function mergeField(key) {
            var strat = strats[key] || defaultStrat;
            options[key] = strat(parent[key], child[key], vm, key);
          }

          return options;
        }
        /**
         * Resolve an asset.
         * This function is used because child instances need access
         * to assets defined in its ancestor chain.
         */


        function resolveAsset(options, type, id, warnMissing) {
          /* istanbul ignore if */
          if (typeof id !== 'string') {
            return;
          }

          var assets = options[type]; // check local registration variations first

          if (hasOwn(assets, id)) {
            return assets[id];
          }

          var camelizedId = camelize(id);

          if (hasOwn(assets, camelizedId)) {
            return assets[camelizedId];
          }

          var PascalCaseId = capitalize(camelizedId);

          if (hasOwn(assets, PascalCaseId)) {
            return assets[PascalCaseId];
          } // fallback to prototype chain


          var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];

          if (process.env.NODE_ENV !== 'production' && warnMissing && !res) {
            warn('Failed to resolve ' + type.slice(0, -1) + ': ' + id, options);
          }

          return res;
        }
        /*  */


        function validateProp(key, propOptions, propsData, vm) {
          var prop = propOptions[key];
          var absent = !hasOwn(propsData, key);
          var value = propsData[key]; // boolean casting

          var booleanIndex = getTypeIndex(Boolean, prop.type);

          if (booleanIndex > -1) {
            if (absent && !hasOwn(prop, 'default')) {
              value = false;
            } else if (value === '' || value === hyphenate(key)) {
              // only cast empty string / same name to boolean if
              // boolean has higher priority
              var stringIndex = getTypeIndex(String, prop.type);

              if (stringIndex < 0 || booleanIndex < stringIndex) {
                value = true;
              }
            }
          } // check default value


          if (value === undefined) {
            value = getPropDefaultValue(vm, prop, key); // since the default value is a fresh copy,
            // make sure to observe it.

            var prevShouldObserve = shouldObserve;
            toggleObserving(true);
            observe(value);
            toggleObserving(prevShouldObserve);
          }

          if (process.env.NODE_ENV !== 'production' && // skip validation for weex recycle-list child component props
          !(false && isObject(value) && '@binding' in value)) {
            assertProp(prop, key, value, vm, absent);
          }

          return value;
        }
        /**
         * Get the default value of a prop.
         */


        function getPropDefaultValue(vm, prop, key) {
          // no default, return undefined
          if (!hasOwn(prop, 'default')) {
            return undefined;
          }

          var def = prop.default; // warn against non-factory defaults for Object & Array

          if (process.env.NODE_ENV !== 'production' && isObject(def)) {
            warn('Invalid default value for prop "' + key + '": ' + 'Props with type Object/Array must use a factory function ' + 'to return the default value.', vm);
          } // the raw prop value was also undefined from previous render,
          // return previous default value to avoid unnecessary watcher trigger


          if (vm && vm.$options.propsData && vm.$options.propsData[key] === undefined && vm._props[key] !== undefined) {
            return vm._props[key];
          } // call factory function for non-Function types
          // a value is Function if its prototype is function even across different execution context


          return typeof def === 'function' && getType(prop.type) !== 'Function' ? def.call(vm) : def;
        }
        /**
         * Assert whether a prop is valid.
         */


        function assertProp(prop, name, value, vm, absent) {
          if (prop.required && absent) {
            warn('Missing required prop: "' + name + '"', vm);
            return;
          }

          if (value == null && !prop.required) {
            return;
          }

          var type = prop.type;
          var valid = !type || type === true;
          var expectedTypes = [];

          if (type) {
            if (!Array.isArray(type)) {
              type = [type];
            }

            for (var i = 0; i < type.length && !valid; i++) {
              var assertedType = assertType(value, type[i]);
              expectedTypes.push(assertedType.expectedType || '');
              valid = assertedType.valid;
            }
          }

          if (!valid) {
            warn("Invalid prop: type check failed for prop \"" + name + "\"." + " Expected " + expectedTypes.map(capitalize).join(', ') + ", got " + toRawType(value) + ".", vm);
            return;
          }

          var validator = prop.validator;

          if (validator) {
            if (!validator(value)) {
              warn('Invalid prop: custom validator check failed for prop "' + name + '".', vm);
            }
          }
        }

        var simpleCheckRE = /^(String|Number|Boolean|Function|Symbol)$/;

        function assertType(value, type) {
          var valid;
          var expectedType = getType(type);

          if (simpleCheckRE.test(expectedType)) {
            var t = _typeof2(value);

            valid = t === expectedType.toLowerCase(); // for primitive wrapper objects

            if (!valid && t === 'object') {
              valid = value instanceof type;
            }
          } else if (expectedType === 'Object') {
            valid = isPlainObject(value);
          } else if (expectedType === 'Array') {
            valid = Array.isArray(value);
          } else {
            valid = value instanceof type;
          }

          return {
            valid: valid,
            expectedType: expectedType
          };
        }
        /**
         * Use function string name to check built-in types,
         * because a simple equality check will fail when running
         * across different vms / iframes.
         */


        function getType(fn) {
          var match = fn && fn.toString().match(/^\s*function (\w+)/);
          return match ? match[1] : '';
        }

        function isSameType(a, b) {
          return getType(a) === getType(b);
        }

        function getTypeIndex(type, expectedTypes) {
          if (!Array.isArray(expectedTypes)) {
            return isSameType(expectedTypes, type) ? 0 : -1;
          }

          for (var i = 0, len = expectedTypes.length; i < len; i++) {
            if (isSameType(expectedTypes[i], type)) {
              return i;
            }
          }

          return -1;
        }
        /*  */


        function handleError(err, vm, info) {
          if (vm) {
            var cur = vm;

            while (cur = cur.$parent) {
              var hooks = cur.$options.errorCaptured;

              if (hooks) {
                for (var i = 0; i < hooks.length; i++) {
                  try {
                    var capture = hooks[i].call(cur, err, vm, info) === false;

                    if (capture) {
                      return;
                    }
                  } catch (e) {
                    globalHandleError(e, cur, 'errorCaptured hook');
                  }
                }
              }
            }
          }

          globalHandleError(err, vm, info);
        }

        function globalHandleError(err, vm, info) {
          if (config.errorHandler) {
            try {
              return config.errorHandler.call(null, err, vm, info);
            } catch (e) {
              logError(e, null, 'config.errorHandler');
            }
          }

          logError(err, vm, info);
        }

        function logError(err, vm, info) {
          if (process.env.NODE_ENV !== 'production') {
            warn("Error in " + info + ": \"" + err.toString() + "\"", vm);
          }
          /* istanbul ignore else */


          if ((inBrowser || inWeex) && typeof console !== 'undefined') {
            console.error(err);
          } else {
            throw err;
          }
        }
        /*  */

        /* globals MessageChannel */


        var callbacks = [];
        var pending = false;

        function flushCallbacks() {
          pending = false;
          var copies = callbacks.slice(0);
          callbacks.length = 0;

          for (var i = 0; i < copies.length; i++) {
            copies[i]();
          }
        } // Here we have async deferring wrappers using both microtasks and (macro) tasks.
        // In < 2.4 we used microtasks everywhere, but there are some scenarios where
        // microtasks have too high a priority and fire in between supposedly
        // sequential events (e.g. #4521, #6690) or even between bubbling of the same
        // event (#6566). However, using (macro) tasks everywhere also has subtle problems
        // when state is changed right before repaint (e.g. #6813, out-in transitions).
        // Here we use microtask by default, but expose a way to force (macro) task when
        // needed (e.g. in event handlers attached by v-on).


        var microTimerFunc;
        var macroTimerFunc;
        var useMacroTask = false; // Determine (macro) task defer implementation.
        // Technically setImmediate should be the ideal choice, but it's only available
        // in IE. The only polyfill that consistently queues the callback after all DOM
        // events triggered in the same loop is by using MessageChannel.

        /* istanbul ignore if */

        if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {
          macroTimerFunc = function macroTimerFunc() {
            setImmediate(flushCallbacks);
          };
        } else if (typeof MessageChannel !== 'undefined' && (isNative(MessageChannel) || // PhantomJS
        MessageChannel.toString() === '[object MessageChannelConstructor]')) {
          var channel = new MessageChannel();
          var port = channel.port2;
          channel.port1.onmessage = flushCallbacks;

          macroTimerFunc = function macroTimerFunc() {
            port.postMessage(1);
          };
        } else {
          /* istanbul ignore next */
          macroTimerFunc = function macroTimerFunc() {
            setTimeout(flushCallbacks, 0);
          };
        } // Determine microtask defer implementation.

        /* istanbul ignore next, $flow-disable-line */


        if (typeof Promise !== 'undefined' && isNative(Promise)) {
          var p = Promise.resolve();

          microTimerFunc = function microTimerFunc() {
            p.then(flushCallbacks); // in problematic UIWebViews, Promise.then doesn't completely break, but
            // it can get stuck in a weird state where callbacks are pushed into the
            // microtask queue but the queue isn't being flushed, until the browser
            // needs to do some other work, e.g. handle a timer. Therefore we can
            // "force" the microtask queue to be flushed by adding an empty timer.

            if (isIOS) {
              setTimeout(noop);
            }
          };
        } else {
          // fallback to macro
          microTimerFunc = macroTimerFunc;
        }
        /**
         * Wrap a function so that if any code inside triggers state change,
         * the changes are queued using a (macro) task instead of a microtask.
         */


        function withMacroTask(fn) {
          return fn._withTask || (fn._withTask = function () {
            useMacroTask = true;
            var res = fn.apply(null, arguments);
            useMacroTask = false;
            return res;
          });
        }

        function nextTick(cb, ctx) {
          var _resolve;

          callbacks.push(function () {
            if (cb) {
              try {
                cb.call(ctx);
              } catch (e) {
                handleError(e, ctx, 'nextTick');
              }
            } else if (_resolve) {
              _resolve(ctx);
            }
          });

          if (!pending) {
            pending = true;

            if (useMacroTask) {
              macroTimerFunc();
            } else {
              microTimerFunc();
            }
          } // $flow-disable-line


          if (!cb && typeof Promise !== 'undefined') {
            return new Promise(function (resolve) {
              _resolve = resolve;
            });
          }
        }
        /*  */

        /* not type checking this file because flow doesn't play well with Proxy */


        var initProxy;

        if (process.env.NODE_ENV !== 'production') {
          var allowedGlobals = makeMap('Infinity,undefined,NaN,isFinite,isNaN,' + 'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' + 'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' + 'require' // for Webpack/Browserify
          );

          var warnNonPresent = function warnNonPresent(target, key) {
            warn("Property or method \"" + key + "\" is not defined on the instance but " + 'referenced during render. Make sure that this property is reactive, ' + 'either in the data option, or for class-based components, by ' + 'initializing the property. ' + 'See: https://vuejs.org/v2/guide/reactivity.html#Declaring-Reactive-Properties.', target);
          };

          var hasProxy = typeof Proxy !== 'undefined' && isNative(Proxy);

          if (hasProxy) {
            var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta,exact');
            config.keyCodes = new Proxy(config.keyCodes, {
              set: function set(target, key, value) {
                if (isBuiltInModifier(key)) {
                  warn("Avoid overwriting built-in modifier in config.keyCodes: ." + key);
                  return false;
                } else {
                  target[key] = value;
                  return true;
                }
              }
            });
          }

          var hasHandler = {
            has: function has(target, key) {
              var has = key in target;
              var isAllowed = allowedGlobals(key) || key.charAt(0) === '_';

              if (!has && !isAllowed) {
                warnNonPresent(target, key);
              }

              return has || !isAllowed;
            }
          };
          var getHandler = {
            get: function get(target, key) {
              if (typeof key === 'string' && !(key in target)) {
                warnNonPresent(target, key);
              }

              return target[key];
            }
          };

          initProxy = function initProxy(vm) {
            if (hasProxy) {
              // determine which proxy handler to use
              var options = vm.$options;
              var handlers = options.render && options.render._withStripped ? getHandler : hasHandler;
              vm._renderProxy = new Proxy(vm, handlers);
            } else {
              vm._renderProxy = vm;
            }
          };
        }
        /*  */


        var seenObjects = new _Set();
        /**
         * Recursively traverse an object to evoke all converted
         * getters, so that every nested property inside the object
         * is collected as a "deep" dependency.
         */

        function traverse(val) {
          _traverse(val, seenObjects);

          seenObjects.clear();
        }

        function _traverse(val, seen) {
          var i, keys;
          var isA = Array.isArray(val);

          if (!isA && !isObject(val) || Object.isFrozen(val) || val instanceof VNode) {
            return;
          }

          if (val.__ob__) {
            var depId = val.__ob__.dep.id;

            if (seen.has(depId)) {
              return;
            }

            seen.add(depId);
          }

          if (isA) {
            i = val.length;

            while (i--) {
              _traverse(val[i], seen);
            }
          } else {
            keys = Object.keys(val);
            i = keys.length;

            while (i--) {
              _traverse(val[keys[i]], seen);
            }
          }
        }

        var mark;
        var measure;

        if (process.env.NODE_ENV !== 'production') {
          var perf = inBrowser && window.performance;
          /* istanbul ignore if */

          if (perf && perf.mark && perf.measure && perf.clearMarks && perf.clearMeasures) {
            mark = function mark(tag) {
              return perf.mark(tag);
            };

            measure = function measure(name, startTag, endTag) {
              perf.measure(name, startTag, endTag);
              perf.clearMarks(startTag);
              perf.clearMarks(endTag);
              perf.clearMeasures(name);
            };
          }
        }
        /*  */


        var normalizeEvent = cached(function (name) {
          var passive = name.charAt(0) === '&';
          name = passive ? name.slice(1) : name;
          var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first

          name = once$$1 ? name.slice(1) : name;
          var capture = name.charAt(0) === '!';
          name = capture ? name.slice(1) : name;
          return {
            name: name,
            once: once$$1,
            capture: capture,
            passive: passive
          };
        });

        function createFnInvoker(fns) {
          function invoker() {
            var arguments$1 = arguments;
            var fns = invoker.fns;

            if (Array.isArray(fns)) {
              var cloned = fns.slice();

              for (var i = 0; i < cloned.length; i++) {
                cloned[i].apply(null, arguments$1);
              }
            } else {
              // return handler return value for single handlers
              return fns.apply(null, arguments);
            }
          }

          invoker.fns = fns;
          return invoker;
        }

        function updateListeners(on, oldOn, add, remove$$1, vm) {
          var name, def, cur, old, event;

          for (name in on) {
            def = cur = on[name];
            old = oldOn[name];
            event = normalizeEvent(name);
            /* istanbul ignore if */

            if (isUndef(cur)) {
              process.env.NODE_ENV !== 'production' && warn("Invalid handler for event \"" + event.name + "\": got " + String(cur), vm);
            } else if (isUndef(old)) {
              if (isUndef(cur.fns)) {
                cur = on[name] = createFnInvoker(cur);
              }

              add(event.name, cur, event.once, event.capture, event.passive, event.params);
            } else if (cur !== old) {
              old.fns = cur;
              on[name] = old;
            }
          }

          for (name in oldOn) {
            if (isUndef(on[name])) {
              event = normalizeEvent(name);
              remove$$1(event.name, oldOn[name], event.capture);
            }
          }
        }
        /*  */


        function mergeVNodeHook(def, hookKey, hook) {
          if (def instanceof VNode) {
            def = def.data.hook || (def.data.hook = {});
          }

          var invoker;
          var oldHook = def[hookKey];

          function wrappedHook() {
            hook.apply(this, arguments); // important: remove merged hook to ensure it's called only once
            // and prevent memory leak

            remove(invoker.fns, wrappedHook);
          }

          if (isUndef(oldHook)) {
            // no existing hook
            invoker = createFnInvoker([wrappedHook]);
          } else {
            /* istanbul ignore if */
            if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {
              // already a merged invoker
              invoker = oldHook;
              invoker.fns.push(wrappedHook);
            } else {
              // existing plain hook
              invoker = createFnInvoker([oldHook, wrappedHook]);
            }
          }

          invoker.merged = true;
          def[hookKey] = invoker;
        }
        /*  */


        function extractPropsFromVNodeData(data, Ctor, tag) {
          // we are only extracting raw values here.
          // validation and default values are handled in the child
          // component itself.
          var propOptions = Ctor.options.props;

          if (isUndef(propOptions)) {
            return;
          }

          var res = {};
          var attrs = data.attrs;
          var props = data.props;

          if (isDef(attrs) || isDef(props)) {
            for (var key in propOptions) {
              var altKey = hyphenate(key);

              if (process.env.NODE_ENV !== 'production') {
                var keyInLowerCase = key.toLowerCase();

                if (key !== keyInLowerCase && attrs && hasOwn(attrs, keyInLowerCase)) {
                  tip("Prop \"" + keyInLowerCase + "\" is passed to component " + formatComponentName(tag || Ctor) + ", but the declared prop name is" + " \"" + key + "\". " + "Note that HTML attributes are case-insensitive and camelCased " + "props need to use their kebab-case equivalents when using in-DOM " + "templates. You should probably use \"" + altKey + "\" instead of \"" + key + "\".");
                }
              }

              checkProp(res, props, key, altKey, true) || checkProp(res, attrs, key, altKey, false);
            }
          }

          return res;
        }

        function checkProp(res, hash, key, altKey, preserve) {
          if (isDef(hash)) {
            if (hasOwn(hash, key)) {
              res[key] = hash[key];

              if (!preserve) {
                delete hash[key];
              }

              return true;
            } else if (hasOwn(hash, altKey)) {
              res[key] = hash[altKey];

              if (!preserve) {
                delete hash[altKey];
              }

              return true;
            }
          }

          return false;
        }
        /*  */
        // The template compiler attempts to minimize the need for normalization by
        // statically analyzing the template at compile time.
        //
        // For plain HTML markup, normalization can be completely skipped because the
        // generated render function is guaranteed to return Array<VNode>. There are
        // two cases where extra normalization is needed:
        // 1. When the children contains components - because a functional component
        // may return an Array instead of a single root. In this case, just a simple
        // normalization is needed - if any child is an Array, we flatten the whole
        // thing with Array.prototype.concat. It is guaranteed to be only 1-level deep
        // because functional components already normalize their own children.


        function simpleNormalizeChildren(children) {
          for (var i = 0; i < children.length; i++) {
            if (Array.isArray(children[i])) {
              return Array.prototype.concat.apply([], children);
            }
          }

          return children;
        } // 2. When the children contains constructs that always generated nested Arrays,
        // e.g. <template>, <slot>, v-for, or when the children is provided by user
        // with hand-written render functions / JSX. In such cases a full normalization
        // is needed to cater to all possible types of children values.


        function normalizeChildren(children) {
          return isPrimitive(children) ? [createTextVNode(children)] : Array.isArray(children) ? normalizeArrayChildren(children) : undefined;
        }

        function isTextNode(node) {
          return isDef(node) && isDef(node.text) && isFalse(node.isComment);
        }

        function normalizeArrayChildren(children, nestedIndex) {
          var res = [];
          var i, c, lastIndex, last;

          for (i = 0; i < children.length; i++) {
            c = children[i];

            if (isUndef(c) || typeof c === 'boolean') {
              continue;
            }

            lastIndex = res.length - 1;
            last = res[lastIndex]; //  nested

            if (Array.isArray(c)) {
              if (c.length > 0) {
                c = normalizeArrayChildren(c, (nestedIndex || '') + "_" + i); // merge adjacent text nodes

                if (isTextNode(c[0]) && isTextNode(last)) {
                  res[lastIndex] = createTextVNode(last.text + c[0].text);
                  c.shift();
                }

                res.push.apply(res, c);
              }
            } else if (isPrimitive(c)) {
              if (isTextNode(last)) {
                // merge adjacent text nodes
                // this is necessary for SSR hydration because text nodes are
                // essentially merged when rendered to HTML strings
                res[lastIndex] = createTextVNode(last.text + c);
              } else if (c !== '') {
                // convert primitive to vnode
                res.push(createTextVNode(c));
              }
            } else {
              if (isTextNode(c) && isTextNode(last)) {
                // merge adjacent text nodes
                res[lastIndex] = createTextVNode(last.text + c.text);
              } else {
                // default key for nested array children (likely generated by v-for)
                if (isTrue(children._isVList) && isDef(c.tag) && isUndef(c.key) && isDef(nestedIndex)) {
                  c.key = "__vlist" + nestedIndex + "_" + i + "__";
                }

                res.push(c);
              }
            }
          }

          return res;
        }
        /*  */


        function ensureCtor(comp, base) {
          if (comp.__esModule || hasSymbol && comp[Symbol.toStringTag] === 'Module') {
            comp = comp.default;
          }

          return isObject(comp) ? base.extend(comp) : comp;
        }

        function createAsyncPlaceholder(factory, data, context, children, tag) {
          var node = createEmptyVNode();
          node.asyncFactory = factory;
          node.asyncMeta = {
            data: data,
            context: context,
            children: children,
            tag: tag
          };
          return node;
        }

        function resolveAsyncComponent(factory, baseCtor, context) {
          if (isTrue(factory.error) && isDef(factory.errorComp)) {
            return factory.errorComp;
          }

          if (isDef(factory.resolved)) {
            return factory.resolved;
          }

          if (isTrue(factory.loading) && isDef(factory.loadingComp)) {
            return factory.loadingComp;
          }

          if (isDef(factory.contexts)) {
            // already pending
            factory.contexts.push(context);
          } else {
            var contexts = factory.contexts = [context];
            var sync = true;

            var forceRender = function forceRender() {
              for (var i = 0, l = contexts.length; i < l; i++) {
                contexts[i].$forceUpdate();
              }
            };

            var resolve = once(function (res) {
              // cache resolved
              factory.resolved = ensureCtor(res, baseCtor); // invoke callbacks only if this is not a synchronous resolve
              // (async resolves are shimmed as synchronous during SSR)

              if (!sync) {
                forceRender();
              }
            });
            var reject = once(function (reason) {
              process.env.NODE_ENV !== 'production' && warn("Failed to resolve async component: " + String(factory) + (reason ? "\nReason: " + reason : ''));

              if (isDef(factory.errorComp)) {
                factory.error = true;
                forceRender();
              }
            });
            var res = factory(resolve, reject);

            if (isObject(res)) {
              if (typeof res.then === 'function') {
                // () => Promise
                if (isUndef(factory.resolved)) {
                  res.then(resolve, reject);
                }
              } else if (isDef(res.component) && typeof res.component.then === 'function') {
                res.component.then(resolve, reject);

                if (isDef(res.error)) {
                  factory.errorComp = ensureCtor(res.error, baseCtor);
                }

                if (isDef(res.loading)) {
                  factory.loadingComp = ensureCtor(res.loading, baseCtor);

                  if (res.delay === 0) {
                    factory.loading = true;
                  } else {
                    setTimeout(function () {
                      if (isUndef(factory.resolved) && isUndef(factory.error)) {
                        factory.loading = true;
                        forceRender();
                      }
                    }, res.delay || 200);
                  }
                }

                if (isDef(res.timeout)) {
                  setTimeout(function () {
                    if (isUndef(factory.resolved)) {
                      reject(process.env.NODE_ENV !== 'production' ? "timeout (" + res.timeout + "ms)" : null);
                    }
                  }, res.timeout);
                }
              }
            }

            sync = false; // return in case resolved synchronously

            return factory.loading ? factory.loadingComp : factory.resolved;
          }
        }
        /*  */


        function isAsyncPlaceholder(node) {
          return node.isComment && node.asyncFactory;
        }
        /*  */


        function getFirstComponentChild(children) {
          if (Array.isArray(children)) {
            for (var i = 0; i < children.length; i++) {
              var c = children[i];

              if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {
                return c;
              }
            }
          }
        }
        /*  */

        /*  */


        function initEvents(vm) {
          vm._events = Object.create(null);
          vm._hasHookEvent = false; // init parent attached events

          var listeners = vm.$options._parentListeners;

          if (listeners) {
            updateComponentListeners(vm, listeners);
          }
        }

        var target;

        function add(event, fn, once) {
          if (once) {
            target.$once(event, fn);
          } else {
            target.$on(event, fn);
          }
        }

        function remove$1(event, fn) {
          target.$off(event, fn);
        }

        function updateComponentListeners(vm, listeners, oldListeners) {
          target = vm;
          updateListeners(listeners, oldListeners || {}, add, remove$1, vm);
          target = undefined;
        }

        function eventsMixin(Vue) {
          var hookRE = /^hook:/;

          Vue.prototype.$on = function (event, fn) {
            var this$1 = this;
            var vm = this;

            if (Array.isArray(event)) {
              for (var i = 0, l = event.length; i < l; i++) {
                this$1.$on(event[i], fn);
              }
            } else {
              (vm._events[event] || (vm._events[event] = [])).push(fn); // optimize hook:event cost by using a boolean flag marked at registration
              // instead of a hash lookup

              if (hookRE.test(event)) {
                vm._hasHookEvent = true;
              }
            }

            return vm;
          };

          Vue.prototype.$once = function (event, fn) {
            var vm = this;

            function on() {
              vm.$off(event, on);
              fn.apply(vm, arguments);
            }

            on.fn = fn;
            vm.$on(event, on);
            return vm;
          };

          Vue.prototype.$off = function (event, fn) {
            var this$1 = this;
            var vm = this; // all

            if (!arguments.length) {
              vm._events = Object.create(null);
              return vm;
            } // array of events


            if (Array.isArray(event)) {
              for (var i = 0, l = event.length; i < l; i++) {
                this$1.$off(event[i], fn);
              }

              return vm;
            } // specific event


            var cbs = vm._events[event];

            if (!cbs) {
              return vm;
            }

            if (!fn) {
              vm._events[event] = null;
              return vm;
            }

            if (fn) {
              // specific handler
              var cb;
              var i$1 = cbs.length;

              while (i$1--) {
                cb = cbs[i$1];

                if (cb === fn || cb.fn === fn) {
                  cbs.splice(i$1, 1);
                  break;
                }
              }
            }

            return vm;
          };

          Vue.prototype.$emit = function (event) {
            var vm = this;

            if (process.env.NODE_ENV !== 'production') {
              var lowerCaseEvent = event.toLowerCase();

              if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {
                tip("Event \"" + lowerCaseEvent + "\" is emitted in component " + formatComponentName(vm) + " but the handler is registered for \"" + event + "\". " + "Note that HTML attributes are case-insensitive and you cannot use " + "v-on to listen to camelCase events when using in-DOM templates. " + "You should probably use \"" + hyphenate(event) + "\" instead of \"" + event + "\".");
              }
            }

            var cbs = vm._events[event];

            if (cbs) {
              cbs = cbs.length > 1 ? toArray(cbs) : cbs;
              var args = toArray(arguments, 1);

              for (var i = 0, l = cbs.length; i < l; i++) {
                try {
                  cbs[i].apply(vm, args);
                } catch (e) {
                  handleError(e, vm, "event handler for \"" + event + "\"");
                }
              }
            }

            return vm;
          };
        }
        /*  */

        /**
         * Runtime helper for resolving raw children VNodes into a slot object.
         */


        function resolveSlots(children, context) {
          var slots = {};

          if (!children) {
            return slots;
          }

          for (var i = 0, l = children.length; i < l; i++) {
            var child = children[i];
            var data = child.data; // remove slot attribute if the node is resolved as a Vue slot node

            if (data && data.attrs && data.attrs.slot) {
              delete data.attrs.slot;
            } // named slots should only be respected if the vnode was rendered in the
            // same context.


            if ((child.context === context || child.fnContext === context) && data && data.slot != null) {
              var name = data.slot;
              var slot = slots[name] || (slots[name] = []);

              if (child.tag === 'template') {
                slot.push.apply(slot, child.children || []);
              } else {
                slot.push(child);
              }
            } else {
              (slots.default || (slots.default = [])).push(child);
            }
          } // ignore slots that contains only whitespace


          for (var name$1 in slots) {
            if (slots[name$1].every(isWhitespace)) {
              delete slots[name$1];
            }
          }

          return slots;
        }

        function isWhitespace(node) {
          return node.isComment && !node.asyncFactory || node.text === ' ';
        }

        function resolveScopedSlots(fns, // see flow/vnode
        res) {
          res = res || {};

          for (var i = 0; i < fns.length; i++) {
            if (Array.isArray(fns[i])) {
              resolveScopedSlots(fns[i], res);
            } else {
              res[fns[i].key] = fns[i].fn;
            }
          }

          return res;
        }
        /*  */


        var activeInstance = null;
        var isUpdatingChildComponent = false;

        function initLifecycle(vm) {
          var options = vm.$options; // locate first non-abstract parent

          var parent = options.parent;

          if (parent && !options.abstract) {
            while (parent.$options.abstract && parent.$parent) {
              parent = parent.$parent;
            }

            parent.$children.push(vm);
          }

          vm.$parent = parent;
          vm.$root = parent ? parent.$root : vm;
          vm.$children = [];
          vm.$refs = {};
          vm._watcher = null;
          vm._inactive = null;
          vm._directInactive = false;
          vm._isMounted = false;
          vm._isDestroyed = false;
          vm._isBeingDestroyed = false;
        }

        function lifecycleMixin(Vue) {
          Vue.prototype._update = function (vnode, hydrating) {
            var vm = this;

            if (vm._isMounted) {
              callHook(vm, 'beforeUpdate');
            }

            var prevEl = vm.$el;
            var prevVnode = vm._vnode;
            var prevActiveInstance = activeInstance;
            activeInstance = vm;
            vm._vnode = vnode; // Vue.prototype.__patch__ is injected in entry points
            // based on the rendering backend used.

            if (!prevVnode) {
              // initial render
              vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false
              /* removeOnly */
              , vm.$options._parentElm, vm.$options._refElm); // no need for the ref nodes after initial patch
              // this prevents keeping a detached DOM tree in memory (#5851)

              vm.$options._parentElm = vm.$options._refElm = null;
            } else {
              // updates
              vm.$el = vm.__patch__(prevVnode, vnode);
            }

            activeInstance = prevActiveInstance; // update __vue__ reference

            if (prevEl) {
              prevEl.__vue__ = null;
            }

            if (vm.$el) {
              vm.$el.__vue__ = vm;
            } // if parent is an HOC, update its $el as well


            if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {
              vm.$parent.$el = vm.$el;
            } // updated hook is called by the scheduler to ensure that children are
            // updated in a parent's updated hook.

          };

          Vue.prototype.$forceUpdate = function () {
            var vm = this;

            if (vm._watcher) {
              vm._watcher.update();
            }
          };

          Vue.prototype.$destroy = function () {
            var vm = this;

            if (vm._isBeingDestroyed) {
              return;
            }

            callHook(vm, 'beforeDestroy');
            vm._isBeingDestroyed = true; // remove self from parent

            var parent = vm.$parent;

            if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {
              remove(parent.$children, vm);
            } // teardown watchers


            if (vm._watcher) {
              vm._watcher.teardown();
            }

            var i = vm._watchers.length;

            while (i--) {
              vm._watchers[i].teardown();
            } // remove reference from data ob
            // frozen object may not have observer.


            if (vm._data.__ob__) {
              vm._data.__ob__.vmCount--;
            } // call the last hook...


            vm._isDestroyed = true; // invoke destroy hooks on current rendered tree

            vm.__patch__(vm._vnode, null); // fire destroyed hook


            callHook(vm, 'destroyed'); // turn off all instance listeners.

            vm.$off(); // remove __vue__ reference

            if (vm.$el) {
              vm.$el.__vue__ = null;
            } // release circular reference (#6759)


            if (vm.$vnode) {
              vm.$vnode.parent = null;
            }
          };
        }

        function mountComponent(vm, el, hydrating) {
          vm.$el = el;

          if (!vm.$options.render) {
            vm.$options.render = createEmptyVNode;

            if (process.env.NODE_ENV !== 'production') {
              /* istanbul ignore if */
              if (vm.$options.template && vm.$options.template.charAt(0) !== '#' || vm.$options.el || el) {
                warn('You are using the runtime-only build of Vue where the template ' + 'compiler is not available. Either pre-compile the templates into ' + 'render functions, or use the compiler-included build.', vm);
              } else {
                warn('Failed to mount component: template or render function not defined.', vm);
              }
            }
          }

          callHook(vm, 'beforeMount');
          var updateComponent;
          /* istanbul ignore if */

          if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
            updateComponent = function updateComponent() {
              var name = vm._name;
              var id = vm._uid;
              var startTag = "vue-perf-start:" + id;
              var endTag = "vue-perf-end:" + id;
              mark(startTag);

              var vnode = vm._render();

              mark(endTag);
              measure("vue " + name + " render", startTag, endTag);
              mark(startTag);

              vm._update(vnode, hydrating);

              mark(endTag);
              measure("vue " + name + " patch", startTag, endTag);
            };
          } else {
            updateComponent = function updateComponent() {
              vm._update(vm._render(), hydrating);
            };
          } // we set this to vm._watcher inside the watcher's constructor
          // since the watcher's initial patch may call $forceUpdate (e.g. inside child
          // component's mounted hook), which relies on vm._watcher being already defined


          new Watcher(vm, updateComponent, noop, null, true
          /* isRenderWatcher */
          );
          hydrating = false; // manually mounted instance, call mounted on self
          // mounted is called for render-created child components in its inserted hook

          if (vm.$vnode == null) {
            vm._isMounted = true;
            callHook(vm, 'mounted');
          }

          return vm;
        }

        function updateChildComponent(vm, propsData, listeners, parentVnode, renderChildren) {
          if (process.env.NODE_ENV !== 'production') {
            isUpdatingChildComponent = true;
          } // determine whether component has slot children
          // we need to do this before overwriting $options._renderChildren


          var hasChildren = !!(renderChildren || // has new static slots
          vm.$options._renderChildren || // has old static slots
          parentVnode.data.scopedSlots || // has new scoped slots
          vm.$scopedSlots !== emptyObject // has old scoped slots
          );
          vm.$options._parentVnode = parentVnode;
          vm.$vnode = parentVnode; // update vm's placeholder node without re-render

          if (vm._vnode) {
            // update child tree's parent
            vm._vnode.parent = parentVnode;
          }

          vm.$options._renderChildren = renderChildren; // update $attrs and $listeners hash
          // these are also reactive so they may trigger child update if the child
          // used them during render

          vm.$attrs = parentVnode.data.attrs || emptyObject;
          vm.$listeners = listeners || emptyObject; // update props

          if (propsData && vm.$options.props) {
            toggleObserving(false);
            var props = vm._props;
            var propKeys = vm.$options._propKeys || [];

            for (var i = 0; i < propKeys.length; i++) {
              var key = propKeys[i];
              var propOptions = vm.$options.props; // wtf flow?

              props[key] = validateProp(key, propOptions, propsData, vm);
            }

            toggleObserving(true); // keep a copy of raw propsData

            vm.$options.propsData = propsData;
          } // update listeners


          listeners = listeners || emptyObject;
          var oldListeners = vm.$options._parentListeners;
          vm.$options._parentListeners = listeners;
          updateComponentListeners(vm, listeners, oldListeners); // resolve slots + force update if has children

          if (hasChildren) {
            vm.$slots = resolveSlots(renderChildren, parentVnode.context);
            vm.$forceUpdate();
          }

          if (process.env.NODE_ENV !== 'production') {
            isUpdatingChildComponent = false;
          }
        }

        function isInInactiveTree(vm) {
          while (vm && (vm = vm.$parent)) {
            if (vm._inactive) {
              return true;
            }
          }

          return false;
        }

        function activateChildComponent(vm, direct) {
          if (direct) {
            vm._directInactive = false;

            if (isInInactiveTree(vm)) {
              return;
            }
          } else if (vm._directInactive) {
            return;
          }

          if (vm._inactive || vm._inactive === null) {
            vm._inactive = false;

            for (var i = 0; i < vm.$children.length; i++) {
              activateChildComponent(vm.$children[i]);
            }

            callHook(vm, 'activated');
          }
        }

        function deactivateChildComponent(vm, direct) {
          if (direct) {
            vm._directInactive = true;

            if (isInInactiveTree(vm)) {
              return;
            }
          }

          if (!vm._inactive) {
            vm._inactive = true;

            for (var i = 0; i < vm.$children.length; i++) {
              deactivateChildComponent(vm.$children[i]);
            }

            callHook(vm, 'deactivated');
          }
        }

        function callHook(vm, hook) {
          // #7573 disable dep collection when invoking lifecycle hooks
          pushTarget();
          var handlers = vm.$options[hook];

          if (handlers) {
            for (var i = 0, j = handlers.length; i < j; i++) {
              try {
                handlers[i].call(vm);
              } catch (e) {
                handleError(e, vm, hook + " hook");
              }
            }
          }

          if (vm._hasHookEvent) {
            vm.$emit('hook:' + hook);
          }

          popTarget();
        }
        /*  */


        var MAX_UPDATE_COUNT = 100;
        var queue = [];
        var activatedChildren = [];
        var has = {};
        var circular = {};
        var waiting = false;
        var flushing = false;
        var index = 0;
        /**
         * Reset the scheduler's state.
         */

        function resetSchedulerState() {
          index = queue.length = activatedChildren.length = 0;
          has = {};

          if (process.env.NODE_ENV !== 'production') {
            circular = {};
          }

          waiting = flushing = false;
        }
        /**
         * Flush both queues and run the watchers.
         */


        function flushSchedulerQueue() {
          flushing = true;
          var watcher, id; // Sort queue before flush.
          // This ensures that:
          // 1. Components are updated from parent to child. (because parent is always
          //    created before the child)
          // 2. A component's user watchers are run before its render watcher (because
          //    user watchers are created before the render watcher)
          // 3. If a component is destroyed during a parent component's watcher run,
          //    its watchers can be skipped.

          queue.sort(function (a, b) {
            return a.id - b.id;
          }); // do not cache length because more watchers might be pushed
          // as we run existing watchers

          for (index = 0; index < queue.length; index++) {
            watcher = queue[index];
            id = watcher.id;
            has[id] = null;
            watcher.run(); // in dev build, check and stop circular updates.

            if (process.env.NODE_ENV !== 'production' && has[id] != null) {
              circular[id] = (circular[id] || 0) + 1;

              if (circular[id] > MAX_UPDATE_COUNT) {
                warn('You may have an infinite update loop ' + (watcher.user ? "in watcher with expression \"" + watcher.expression + "\"" : "in a component render function."), watcher.vm);
                break;
              }
            }
          } // keep copies of post queues before resetting state


          var activatedQueue = activatedChildren.slice();
          var updatedQueue = queue.slice();
          resetSchedulerState(); // call component updated and activated hooks

          callActivatedHooks(activatedQueue);
          callUpdatedHooks(updatedQueue); // devtool hook

          /* istanbul ignore if */

          if (devtools && config.devtools) {
            devtools.emit('flush');
          }
        }

        function callUpdatedHooks(queue) {
          var i = queue.length;

          while (i--) {
            var watcher = queue[i];
            var vm = watcher.vm;

            if (vm._watcher === watcher && vm._isMounted) {
              callHook(vm, 'updated');
            }
          }
        }
        /**
         * Queue a kept-alive component that was activated during patch.
         * The queue will be processed after the entire tree has been patched.
         */


        function queueActivatedComponent(vm) {
          // setting _inactive to false here so that a render function can
          // rely on checking whether it's in an inactive tree (e.g. router-view)
          vm._inactive = false;
          activatedChildren.push(vm);
        }

        function callActivatedHooks(queue) {
          for (var i = 0; i < queue.length; i++) {
            queue[i]._inactive = true;
            activateChildComponent(queue[i], true
            /* true */
            );
          }
        }
        /**
         * Push a watcher into the watcher queue.
         * Jobs with duplicate IDs will be skipped unless it's
         * pushed when the queue is being flushed.
         */


        function queueWatcher(watcher) {
          var id = watcher.id;

          if (has[id] == null) {
            has[id] = true;

            if (!flushing) {
              queue.push(watcher);
            } else {
              // if already flushing, splice the watcher based on its id
              // if already past its id, it will be run next immediately.
              var i = queue.length - 1;

              while (i > index && queue[i].id > watcher.id) {
                i--;
              }

              queue.splice(i + 1, 0, watcher);
            } // queue the flush


            if (!waiting) {
              waiting = true;
              nextTick(flushSchedulerQueue);
            }
          }
        }
        /*  */


        var uid$1 = 0;
        /**
         * A watcher parses an expression, collects dependencies,
         * and fires callback when the expression value changes.
         * This is used for both the $watch() api and directives.
         */

        var Watcher = function Watcher(vm, expOrFn, cb, options, isRenderWatcher) {
          this.vm = vm;

          if (isRenderWatcher) {
            vm._watcher = this;
          }

          vm._watchers.push(this); // options


          if (options) {
            this.deep = !!options.deep;
            this.user = !!options.user;
            this.lazy = !!options.lazy;
            this.sync = !!options.sync;
          } else {
            this.deep = this.user = this.lazy = this.sync = false;
          }

          this.cb = cb;
          this.id = ++uid$1; // uid for batching

          this.active = true;
          this.dirty = this.lazy; // for lazy watchers

          this.deps = [];
          this.newDeps = [];
          this.depIds = new _Set();
          this.newDepIds = new _Set();
          this.expression = process.env.NODE_ENV !== 'production' ? expOrFn.toString() : ''; // parse expression for getter

          if (typeof expOrFn === 'function') {
            this.getter = expOrFn;
          } else {
            this.getter = parsePath(expOrFn);

            if (!this.getter) {
              this.getter = function () {};

              process.env.NODE_ENV !== 'production' && warn("Failed watching path: \"" + expOrFn + "\" " + 'Watcher only accepts simple dot-delimited paths. ' + 'For full control, use a function instead.', vm);
            }
          }

          this.value = this.lazy ? undefined : this.get();
        };
        /**
         * Evaluate the getter, and re-collect dependencies.
         */


        Watcher.prototype.get = function get() {
          pushTarget(this);
          var value;
          var vm = this.vm;

          try {
            value = this.getter.call(vm, vm);
          } catch (e) {
            if (this.user) {
              handleError(e, vm, "getter for watcher \"" + this.expression + "\"");
            } else {
              throw e;
            }
          } finally {
            // "touch" every property so they are all tracked as
            // dependencies for deep watching
            if (this.deep) {
              traverse(value);
            }

            popTarget();
            this.cleanupDeps();
          }

          return value;
        };
        /**
         * Add a dependency to this directive.
         */


        Watcher.prototype.addDep = function addDep(dep) {
          var id = dep.id;

          if (!this.newDepIds.has(id)) {
            this.newDepIds.add(id);
            this.newDeps.push(dep);

            if (!this.depIds.has(id)) {
              dep.addSub(this);
            }
          }
        };
        /**
         * Clean up for dependency collection.
         */


        Watcher.prototype.cleanupDeps = function cleanupDeps() {
          var this$1 = this;
          var i = this.deps.length;

          while (i--) {
            var dep = this$1.deps[i];

            if (!this$1.newDepIds.has(dep.id)) {
              dep.removeSub(this$1);
            }
          }

          var tmp = this.depIds;
          this.depIds = this.newDepIds;
          this.newDepIds = tmp;
          this.newDepIds.clear();
          tmp = this.deps;
          this.deps = this.newDeps;
          this.newDeps = tmp;
          this.newDeps.length = 0;
        };
        /**
         * Subscriber interface.
         * Will be called when a dependency changes.
         */


        Watcher.prototype.update = function update() {
          /* istanbul ignore else */
          if (this.lazy) {
            this.dirty = true;
          } else if (this.sync) {
            this.run();
          } else {
            queueWatcher(this);
          }
        };
        /**
         * Scheduler job interface.
         * Will be called by the scheduler.
         */


        Watcher.prototype.run = function run() {
          if (this.active) {
            var value = this.get();

            if (value !== this.value || // Deep watchers and watchers on Object/Arrays should fire even
            // when the value is the same, because the value may
            // have mutated.
            isObject(value) || this.deep) {
              // set new value
              var oldValue = this.value;
              this.value = value;

              if (this.user) {
                try {
                  this.cb.call(this.vm, value, oldValue);
                } catch (e) {
                  handleError(e, this.vm, "callback for watcher \"" + this.expression + "\"");
                }
              } else {
                this.cb.call(this.vm, value, oldValue);
              }
            }
          }
        };
        /**
         * Evaluate the value of the watcher.
         * This only gets called for lazy watchers.
         */


        Watcher.prototype.evaluate = function evaluate() {
          this.value = this.get();
          this.dirty = false;
        };
        /**
         * Depend on all deps collected by this watcher.
         */


        Watcher.prototype.depend = function depend() {
          var this$1 = this;
          var i = this.deps.length;

          while (i--) {
            this$1.deps[i].depend();
          }
        };
        /**
         * Remove self from all dependencies' subscriber list.
         */


        Watcher.prototype.teardown = function teardown() {
          var this$1 = this;

          if (this.active) {
            // remove self from vm's watcher list
            // this is a somewhat expensive operation so we skip it
            // if the vm is being destroyed.
            if (!this.vm._isBeingDestroyed) {
              remove(this.vm._watchers, this);
            }

            var i = this.deps.length;

            while (i--) {
              this$1.deps[i].removeSub(this$1);
            }

            this.active = false;
          }
        };
        /*  */


        var sharedPropertyDefinition = {
          enumerable: true,
          configurable: true,
          get: noop,
          set: noop
        };

        function proxy(target, sourceKey, key) {
          sharedPropertyDefinition.get = function proxyGetter() {
            return this[sourceKey][key];
          };

          sharedPropertyDefinition.set = function proxySetter(val) {
            this[sourceKey][key] = val;
          };

          Object.defineProperty(target, key, sharedPropertyDefinition);
        }

        function initState(vm) {
          vm._watchers = [];
          var opts = vm.$options;

          if (opts.props) {
            initProps(vm, opts.props);
          }

          if (opts.methods) {
            initMethods(vm, opts.methods);
          }

          if (opts.data) {
            initData(vm);
          } else {
            observe(vm._data = {}, true
            /* asRootData */
            );
          }

          if (opts.computed) {
            initComputed(vm, opts.computed);
          }

          if (opts.watch && opts.watch !== nativeWatch) {
            initWatch(vm, opts.watch);
          }
        }

        function initProps(vm, propsOptions) {
          var propsData = vm.$options.propsData || {};
          var props = vm._props = {}; // cache prop keys so that future props updates can iterate using Array
          // instead of dynamic object key enumeration.

          var keys = vm.$options._propKeys = [];
          var isRoot = !vm.$parent; // root instance props should be converted

          if (!isRoot) {
            toggleObserving(false);
          }

          var loop = function loop(key) {
            keys.push(key);
            var value = validateProp(key, propsOptions, propsData, vm);
            /* istanbul ignore else */

            if (process.env.NODE_ENV !== 'production') {
              var hyphenatedKey = hyphenate(key);

              if (isReservedAttribute(hyphenatedKey) || config.isReservedAttr(hyphenatedKey)) {
                warn("\"" + hyphenatedKey + "\" is a reserved attribute and cannot be used as component prop.", vm);
              }

              defineReactive(props, key, value, function () {
                if (vm.$parent && !isUpdatingChildComponent) {
                  warn("Avoid mutating a prop directly since the value will be " + "overwritten whenever the parent component re-renders. " + "Instead, use a data or computed property based on the prop's " + "value. Prop being mutated: \"" + key + "\"", vm);
                }
              });
            } else {
              defineReactive(props, key, value);
            } // static props are already proxied on the component's prototype
            // during Vue.extend(). We only need to proxy props defined at
            // instantiation here.


            if (!(key in vm)) {
              proxy(vm, "_props", key);
            }
          };

          for (var key in propsOptions) {
            loop(key);
          }

          toggleObserving(true);
        }

        function initData(vm) {
          var data = vm.$options.data;
          data = vm._data = typeof data === 'function' ? getData(data, vm) : data || {};

          if (!isPlainObject(data)) {
            data = {};
            process.env.NODE_ENV !== 'production' && warn('data functions should return an object:\n' + 'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function', vm);
          } // proxy data on instance


          var keys = Object.keys(data);
          var props = vm.$options.props;
          var methods = vm.$options.methods;
          var i = keys.length;

          while (i--) {
            var key = keys[i];

            if (process.env.NODE_ENV !== 'production') {
              if (methods && hasOwn(methods, key)) {
                warn("Method \"" + key + "\" has already been defined as a data property.", vm);
              }
            }

            if (props && hasOwn(props, key)) {
              process.env.NODE_ENV !== 'production' && warn("The data property \"" + key + "\" is already declared as a prop. " + "Use prop default value instead.", vm);
            } else if (!isReserved(key)) {
              proxy(vm, "_data", key);
            }
          } // observe data


          observe(data, true
          /* asRootData */
          );
        }

        function getData(data, vm) {
          // #7573 disable dep collection when invoking data getters
          pushTarget();

          try {
            return data.call(vm, vm);
          } catch (e) {
            handleError(e, vm, "data()");
            return {};
          } finally {
            popTarget();
          }
        }

        var computedWatcherOptions = {
          lazy: true
        };

        function initComputed(vm, computed) {
          // $flow-disable-line
          var watchers = vm._computedWatchers = Object.create(null); // computed properties are just getters during SSR

          var isSSR = isServerRendering();

          for (var key in computed) {
            var userDef = computed[key];
            var getter = typeof userDef === 'function' ? userDef : userDef.get;

            if (process.env.NODE_ENV !== 'production' && getter == null) {
              warn("Getter is missing for computed property \"" + key + "\".", vm);
            }

            if (!isSSR) {
              // create internal watcher for the computed property.
              watchers[key] = new Watcher(vm, getter || noop, noop, computedWatcherOptions);
            } // component-defined computed properties are already defined on the
            // component prototype. We only need to define computed properties defined
            // at instantiation here.


            if (!(key in vm)) {
              defineComputed(vm, key, userDef);
            } else if (process.env.NODE_ENV !== 'production') {
              if (key in vm.$data) {
                warn("The computed property \"" + key + "\" is already defined in data.", vm);
              } else if (vm.$options.props && key in vm.$options.props) {
                warn("The computed property \"" + key + "\" is already defined as a prop.", vm);
              }
            }
          }
        }

        function defineComputed(target, key, userDef) {
          var shouldCache = !isServerRendering();

          if (typeof userDef === 'function') {
            sharedPropertyDefinition.get = shouldCache ? createComputedGetter(key) : userDef;
            sharedPropertyDefinition.set = noop;
          } else {
            sharedPropertyDefinition.get = userDef.get ? shouldCache && userDef.cache !== false ? createComputedGetter(key) : userDef.get : noop;
            sharedPropertyDefinition.set = userDef.set ? userDef.set : noop;
          }

          if (process.env.NODE_ENV !== 'production' && sharedPropertyDefinition.set === noop) {
            sharedPropertyDefinition.set = function () {
              warn("Computed property \"" + key + "\" was assigned to but it has no setter.", this);
            };
          }

          Object.defineProperty(target, key, sharedPropertyDefinition);
        }

        function createComputedGetter(key) {
          return function computedGetter() {
            var watcher = this._computedWatchers && this._computedWatchers[key];

            if (watcher) {
              if (watcher.dirty) {
                watcher.evaluate();
              }

              if (Dep.target) {
                watcher.depend();
              }

              return watcher.value;
            }
          };
        }

        function initMethods(vm, methods) {
          var props = vm.$options.props;

          for (var key in methods) {
            if (process.env.NODE_ENV !== 'production') {
              if (methods[key] == null) {
                warn("Method \"" + key + "\" has an undefined value in the component definition. " + "Did you reference the function correctly?", vm);
              }

              if (props && hasOwn(props, key)) {
                warn("Method \"" + key + "\" has already been defined as a prop.", vm);
              }

              if (key in vm && isReserved(key)) {
                warn("Method \"" + key + "\" conflicts with an existing Vue instance method. " + "Avoid defining component methods that start with _ or $.");
              }
            }

            vm[key] = methods[key] == null ? noop : bind(methods[key], vm);
          }
        }

        function initWatch(vm, watch) {
          for (var key in watch) {
            var handler = watch[key];

            if (Array.isArray(handler)) {
              for (var i = 0; i < handler.length; i++) {
                createWatcher(vm, key, handler[i]);
              }
            } else {
              createWatcher(vm, key, handler);
            }
          }
        }

        function createWatcher(vm, expOrFn, handler, options) {
          if (isPlainObject(handler)) {
            options = handler;
            handler = handler.handler;
          }

          if (typeof handler === 'string') {
            handler = vm[handler];
          }

          return vm.$watch(expOrFn, handler, options);
        }

        function stateMixin(Vue) {
          // flow somehow has problems with directly declared definition object
          // when using Object.defineProperty, so we have to procedurally build up
          // the object here.
          var dataDef = {};

          dataDef.get = function () {
            return this._data;
          };

          var propsDef = {};

          propsDef.get = function () {
            return this._props;
          };

          if (process.env.NODE_ENV !== 'production') {
            dataDef.set = function (newData) {
              warn('Avoid replacing instance root $data. ' + 'Use nested data properties instead.', this);
            };

            propsDef.set = function () {
              warn("$props is readonly.", this);
            };
          }

          Object.defineProperty(Vue.prototype, '$data', dataDef);
          Object.defineProperty(Vue.prototype, '$props', propsDef);
          Vue.prototype.$set = set;
          Vue.prototype.$delete = del;

          Vue.prototype.$watch = function (expOrFn, cb, options) {
            var vm = this;

            if (isPlainObject(cb)) {
              return createWatcher(vm, expOrFn, cb, options);
            }

            options = options || {};
            options.user = true;
            var watcher = new Watcher(vm, expOrFn, cb, options);

            if (options.immediate) {
              cb.call(vm, watcher.value);
            }

            return function unwatchFn() {
              watcher.teardown();
            };
          };
        }
        /*  */


        function initProvide(vm) {
          var provide = vm.$options.provide;

          if (provide) {
            vm._provided = typeof provide === 'function' ? provide.call(vm) : provide;
          }
        }

        function initInjections(vm) {
          var result = resolveInject(vm.$options.inject, vm);

          if (result) {
            toggleObserving(false);
            Object.keys(result).forEach(function (key) {
              /* istanbul ignore else */
              if (process.env.NODE_ENV !== 'production') {
                defineReactive(vm, key, result[key], function () {
                  warn("Avoid mutating an injected value directly since the changes will be " + "overwritten whenever the provided component re-renders. " + "injection being mutated: \"" + key + "\"", vm);
                });
              } else {
                defineReactive(vm, key, result[key]);
              }
            });
            toggleObserving(true);
          }
        }

        function resolveInject(inject, vm) {
          if (inject) {
            // inject is :any because flow is not smart enough to figure out cached
            var result = Object.create(null);
            var keys = hasSymbol ? Reflect.ownKeys(inject).filter(function (key) {
              /* istanbul ignore next */
              return Object.getOwnPropertyDescriptor(inject, key).enumerable;
            }) : Object.keys(inject);

            for (var i = 0; i < keys.length; i++) {
              var key = keys[i];
              var provideKey = inject[key].from;
              var source = vm;

              while (source) {
                if (source._provided && hasOwn(source._provided, provideKey)) {
                  result[key] = source._provided[provideKey];
                  break;
                }

                source = source.$parent;
              }

              if (!source) {
                if ('default' in inject[key]) {
                  var provideDefault = inject[key].default;
                  result[key] = typeof provideDefault === 'function' ? provideDefault.call(vm) : provideDefault;
                } else if (process.env.NODE_ENV !== 'production') {
                  warn("Injection \"" + key + "\" not found", vm);
                }
              }
            }

            return result;
          }
        }
        /*  */

        /**
         * Runtime helper for rendering v-for lists.
         */


        function renderList(val, render) {
          var ret, i, l, keys, key;

          if (Array.isArray(val) || typeof val === 'string') {
            ret = new Array(val.length);

            for (i = 0, l = val.length; i < l; i++) {
              ret[i] = render(val[i], i);
            }
          } else if (typeof val === 'number') {
            ret = new Array(val);

            for (i = 0; i < val; i++) {
              ret[i] = render(i + 1, i);
            }
          } else if (isObject(val)) {
            keys = Object.keys(val);
            ret = new Array(keys.length);

            for (i = 0, l = keys.length; i < l; i++) {
              key = keys[i];
              ret[i] = render(val[key], key, i);
            }
          }

          if (isDef(ret)) {
            ret._isVList = true;
          }

          return ret;
        }
        /*  */

        /**
         * Runtime helper for rendering <slot>
         */


        function renderSlot(name, fallback, props, bindObject) {
          var scopedSlotFn = this.$scopedSlots[name];
          var nodes;

          if (scopedSlotFn) {
            // scoped slot
            props = props || {};

            if (bindObject) {
              if (process.env.NODE_ENV !== 'production' && !isObject(bindObject)) {
                warn('slot v-bind without argument expects an Object', this);
              }

              props = extend(extend({}, bindObject), props);
            }

            nodes = scopedSlotFn(props) || fallback;
          } else {
            var slotNodes = this.$slots[name]; // warn duplicate slot usage

            if (slotNodes) {
              if (process.env.NODE_ENV !== 'production' && slotNodes._rendered) {
                warn("Duplicate presence of slot \"" + name + "\" found in the same render tree " + "- this will likely cause render errors.", this);
              }

              slotNodes._rendered = true;
            }

            nodes = slotNodes || fallback;
          }

          var target = props && props.slot;

          if (target) {
            return this.$createElement('template', {
              slot: target
            }, nodes);
          } else {
            return nodes;
          }
        }
        /*  */

        /**
         * Runtime helper for resolving filters
         */


        function resolveFilter(id) {
          return resolveAsset(this.$options, 'filters', id, true) || identity;
        }
        /*  */


        function isKeyNotMatch(expect, actual) {
          if (Array.isArray(expect)) {
            return expect.indexOf(actual) === -1;
          } else {
            return expect !== actual;
          }
        }
        /**
         * Runtime helper for checking keyCodes from config.
         * exposed as Vue.prototype._k
         * passing in eventKeyName as last argument separately for backwards compat
         */


        function checkKeyCodes(eventKeyCode, key, builtInKeyCode, eventKeyName, builtInKeyName) {
          var mappedKeyCode = config.keyCodes[key] || builtInKeyCode;

          if (builtInKeyName && eventKeyName && !config.keyCodes[key]) {
            return isKeyNotMatch(builtInKeyName, eventKeyName);
          } else if (mappedKeyCode) {
            return isKeyNotMatch(mappedKeyCode, eventKeyCode);
          } else if (eventKeyName) {
            return hyphenate(eventKeyName) !== key;
          }
        }
        /*  */

        /**
         * Runtime helper for merging v-bind="object" into a VNode's data.
         */


        function bindObjectProps(data, tag, value, asProp, isSync) {
          if (value) {
            if (!isObject(value)) {
              process.env.NODE_ENV !== 'production' && warn('v-bind without argument expects an Object or Array value', this);
            } else {
              if (Array.isArray(value)) {
                value = toObject(value);
              }

              var hash;

              var loop = function loop(key) {
                if (key === 'class' || key === 'style' || isReservedAttribute(key)) {
                  hash = data;
                } else {
                  var type = data.attrs && data.attrs.type;
                  hash = asProp || config.mustUseProp(tag, type, key) ? data.domProps || (data.domProps = {}) : data.attrs || (data.attrs = {});
                }

                if (!(key in hash)) {
                  hash[key] = value[key];

                  if (isSync) {
                    var on = data.on || (data.on = {});

                    on["update:" + key] = function ($event) {
                      value[key] = $event;
                    };
                  }
                }
              };

              for (var key in value) {
                loop(key);
              }
            }
          }

          return data;
        }
        /*  */

        /**
         * Runtime helper for rendering static trees.
         */


        function renderStatic(index, isInFor) {
          var cached = this._staticTrees || (this._staticTrees = []);
          var tree = cached[index]; // if has already-rendered static tree and not inside v-for,
          // we can reuse the same tree.

          if (tree && !isInFor) {
            return tree;
          } // otherwise, render a fresh tree.


          tree = cached[index] = this.$options.staticRenderFns[index].call(this._renderProxy, null, this // for render fns generated for functional component templates
          );
          markStatic(tree, "__static__" + index, false);
          return tree;
        }
        /**
         * Runtime helper for v-once.
         * Effectively it means marking the node as static with a unique key.
         */


        function markOnce(tree, index, key) {
          markStatic(tree, "__once__" + index + (key ? "_" + key : ""), true);
          return tree;
        }

        function markStatic(tree, key, isOnce) {
          if (Array.isArray(tree)) {
            for (var i = 0; i < tree.length; i++) {
              if (tree[i] && typeof tree[i] !== 'string') {
                markStaticNode(tree[i], key + "_" + i, isOnce);
              }
            }
          } else {
            markStaticNode(tree, key, isOnce);
          }
        }

        function markStaticNode(node, key, isOnce) {
          node.isStatic = true;
          node.key = key;
          node.isOnce = isOnce;
        }
        /*  */


        function bindObjectListeners(data, value) {
          if (value) {
            if (!isPlainObject(value)) {
              process.env.NODE_ENV !== 'production' && warn('v-on without argument expects an Object value', this);
            } else {
              var on = data.on = data.on ? extend({}, data.on) : {};

              for (var key in value) {
                var existing = on[key];
                var ours = value[key];
                on[key] = existing ? [].concat(existing, ours) : ours;
              }
            }
          }

          return data;
        }
        /*  */


        function installRenderHelpers(target) {
          target._o = markOnce;
          target._n = toNumber;
          target._s = toString;
          target._l = renderList;
          target._t = renderSlot;
          target._q = looseEqual;
          target._i = looseIndexOf;
          target._m = renderStatic;
          target._f = resolveFilter;
          target._k = checkKeyCodes;
          target._b = bindObjectProps;
          target._v = createTextVNode;
          target._e = createEmptyVNode;
          target._u = resolveScopedSlots;
          target._g = bindObjectListeners;
        }
        /*  */


        function FunctionalRenderContext(data, props, children, parent, Ctor) {
          var options = Ctor.options; // ensure the createElement function in functional components
          // gets a unique context - this is necessary for correct named slot check

          var contextVm;

          if (hasOwn(parent, '_uid')) {
            contextVm = Object.create(parent); // $flow-disable-line

            contextVm._original = parent;
          } else {
            // the context vm passed in is a functional context as well.
            // in this case we want to make sure we are able to get a hold to the
            // real context instance.
            contextVm = parent; // $flow-disable-line

            parent = parent._original;
          }

          var isCompiled = isTrue(options._compiled);
          var needNormalization = !isCompiled;
          this.data = data;
          this.props = props;
          this.children = children;
          this.parent = parent;
          this.listeners = data.on || emptyObject;
          this.injections = resolveInject(options.inject, parent);

          this.slots = function () {
            return resolveSlots(children, parent);
          }; // support for compiled functional template


          if (isCompiled) {
            // exposing $options for renderStatic()
            this.$options = options; // pre-resolve slots for renderSlot()

            this.$slots = this.slots();
            this.$scopedSlots = data.scopedSlots || emptyObject;
          }

          if (options._scopeId) {
            this._c = function (a, b, c, d) {
              var vnode = createElement(contextVm, a, b, c, d, needNormalization);

              if (vnode && !Array.isArray(vnode)) {
                vnode.fnScopeId = options._scopeId;
                vnode.fnContext = parent;
              }

              return vnode;
            };
          } else {
            this._c = function (a, b, c, d) {
              return createElement(contextVm, a, b, c, d, needNormalization);
            };
          }
        }

        installRenderHelpers(FunctionalRenderContext.prototype);

        function createFunctionalComponent(Ctor, propsData, data, contextVm, children) {
          var options = Ctor.options;
          var props = {};
          var propOptions = options.props;

          if (isDef(propOptions)) {
            for (var key in propOptions) {
              props[key] = validateProp(key, propOptions, propsData || emptyObject);
            }
          } else {
            if (isDef(data.attrs)) {
              mergeProps(props, data.attrs);
            }

            if (isDef(data.props)) {
              mergeProps(props, data.props);
            }
          }

          var renderContext = new FunctionalRenderContext(data, props, children, contextVm, Ctor);
          var vnode = options.render.call(null, renderContext._c, renderContext);

          if (vnode instanceof VNode) {
            return cloneAndMarkFunctionalResult(vnode, data, renderContext.parent, options);
          } else if (Array.isArray(vnode)) {
            var vnodes = normalizeChildren(vnode) || [];
            var res = new Array(vnodes.length);

            for (var i = 0; i < vnodes.length; i++) {
              res[i] = cloneAndMarkFunctionalResult(vnodes[i], data, renderContext.parent, options);
            }

            return res;
          }
        }

        function cloneAndMarkFunctionalResult(vnode, data, contextVm, options) {
          // #7817 clone node before setting fnContext, otherwise if the node is reused
          // (e.g. it was from a cached normal slot) the fnContext causes named slots
          // that should not be matched to match.
          var clone = cloneVNode(vnode);
          clone.fnContext = contextVm;
          clone.fnOptions = options;

          if (data.slot) {
            (clone.data || (clone.data = {})).slot = data.slot;
          }

          return clone;
        }

        function mergeProps(to, from) {
          for (var key in from) {
            to[camelize(key)] = from[key];
          }
        }
        /*  */
        // Register the component hook to weex native render engine.
        // The hook will be triggered by native, not javascript.
        // Updates the state of the component to weex native render engine.

        /*  */
        // https://github.com/Hanks10100/weex-native-directive/tree/master/component
        // listening on native callback

        /*  */

        /*  */
        // inline hooks to be invoked on component VNodes during patch


        var componentVNodeHooks = {
          init: function init(vnode, hydrating, parentElm, refElm) {
            if (vnode.componentInstance && !vnode.componentInstance._isDestroyed && vnode.data.keepAlive) {
              // kept-alive components, treat as a patch
              var mountedNode = vnode; // work around flow

              componentVNodeHooks.prepatch(mountedNode, mountedNode);
            } else {
              var child = vnode.componentInstance = createComponentInstanceForVnode(vnode, activeInstance, parentElm, refElm);
              child.$mount(hydrating ? vnode.elm : undefined, hydrating);
            }
          },
          prepatch: function prepatch(oldVnode, vnode) {
            var options = vnode.componentOptions;
            var child = vnode.componentInstance = oldVnode.componentInstance;
            updateChildComponent(child, options.propsData, // updated props
            options.listeners, // updated listeners
            vnode, // new parent vnode
            options.children // new children
            );
          },
          insert: function insert(vnode) {
            var context = vnode.context;
            var componentInstance = vnode.componentInstance;

            if (!componentInstance._isMounted) {
              componentInstance._isMounted = true;
              callHook(componentInstance, 'mounted');
            }

            if (vnode.data.keepAlive) {
              if (context._isMounted) {
                // vue-router#1212
                // During updates, a kept-alive component's child components may
                // change, so directly walking the tree here may call activated hooks
                // on incorrect children. Instead we push them into a queue which will
                // be processed after the whole patch process ended.
                queueActivatedComponent(componentInstance);
              } else {
                activateChildComponent(componentInstance, true
                /* direct */
                );
              }
            }
          },
          destroy: function destroy(vnode) {
            var componentInstance = vnode.componentInstance;

            if (!componentInstance._isDestroyed) {
              if (!vnode.data.keepAlive) {
                componentInstance.$destroy();
              } else {
                deactivateChildComponent(componentInstance, true
                /* direct */
                );
              }
            }
          }
        };
        var hooksToMerge = Object.keys(componentVNodeHooks);

        function createComponent(Ctor, data, context, children, tag) {
          if (isUndef(Ctor)) {
            return;
          }

          var baseCtor = context.$options._base; // plain options object: turn it into a constructor

          if (isObject(Ctor)) {
            Ctor = baseCtor.extend(Ctor);
          } // if at this stage it's not a constructor or an async component factory,
          // reject.


          if (typeof Ctor !== 'function') {
            if (process.env.NODE_ENV !== 'production') {
              warn("Invalid Component definition: " + String(Ctor), context);
            }

            return;
          } // async component


          var asyncFactory;

          if (isUndef(Ctor.cid)) {
            asyncFactory = Ctor;
            Ctor = resolveAsyncComponent(asyncFactory, baseCtor, context);

            if (Ctor === undefined) {
              // return a placeholder node for async component, which is rendered
              // as a comment node but preserves all the raw information for the node.
              // the information will be used for async server-rendering and hydration.
              return createAsyncPlaceholder(asyncFactory, data, context, children, tag);
            }
          }

          data = data || {}; // resolve constructor options in case global mixins are applied after
          // component constructor creation

          resolveConstructorOptions(Ctor); // transform component v-model data into props & events

          if (isDef(data.model)) {
            transformModel(Ctor.options, data);
          } // extract props


          var propsData = extractPropsFromVNodeData(data, Ctor, tag); // functional component

          if (isTrue(Ctor.options.functional)) {
            return createFunctionalComponent(Ctor, propsData, data, context, children);
          } // extract listeners, since these needs to be treated as
          // child component listeners instead of DOM listeners


          var listeners = data.on; // replace with listeners with .native modifier
          // so it gets processed during parent component patch.

          data.on = data.nativeOn;

          if (isTrue(Ctor.options.abstract)) {
            // abstract components do not keep anything
            // other than props & listeners & slot
            // work around flow
            var slot = data.slot;
            data = {};

            if (slot) {
              data.slot = slot;
            }
          } // install component management hooks onto the placeholder node


          installComponentHooks(data); // return a placeholder vnode

          var name = Ctor.options.name || tag;
          var vnode = new VNode("vue-component-" + Ctor.cid + (name ? "-" + name : ''), data, undefined, undefined, undefined, context, {
            Ctor: Ctor,
            propsData: propsData,
            listeners: listeners,
            tag: tag,
            children: children
          }, asyncFactory); // Weex specific: invoke recycle-list optimized @render function for
          // extracting cell-slot template.
          // https://github.com/Hanks10100/weex-native-directive/tree/master/component

          /* istanbul ignore if */

          return vnode;
        }

        function createComponentInstanceForVnode(vnode, // we know it's MountedComponentVNode but flow doesn't
        parent, // activeInstance in lifecycle state
        parentElm, refElm) {
          var options = {
            _isComponent: true,
            parent: parent,
            _parentVnode: vnode,
            _parentElm: parentElm || null,
            _refElm: refElm || null
          }; // check inline-template render functions

          var inlineTemplate = vnode.data.inlineTemplate;

          if (isDef(inlineTemplate)) {
            options.render = inlineTemplate.render;
            options.staticRenderFns = inlineTemplate.staticRenderFns;
          }

          return new vnode.componentOptions.Ctor(options);
        }

        function installComponentHooks(data) {
          var hooks = data.hook || (data.hook = {});

          for (var i = 0; i < hooksToMerge.length; i++) {
            var key = hooksToMerge[i];
            hooks[key] = componentVNodeHooks[key];
          }
        } // transform component v-model info (value and callback) into
        // prop and event handler respectively.


        function transformModel(options, data) {
          var prop = options.model && options.model.prop || 'value';
          var event = options.model && options.model.event || 'input';
          (data.props || (data.props = {}))[prop] = data.model.value;
          var on = data.on || (data.on = {});

          if (isDef(on[event])) {
            on[event] = [data.model.callback].concat(on[event]);
          } else {
            on[event] = data.model.callback;
          }
        }
        /*  */


        var SIMPLE_NORMALIZE = 1;
        var ALWAYS_NORMALIZE = 2; // wrapper function for providing a more flexible interface
        // without getting yelled at by flow

        function createElement(context, tag, data, children, normalizationType, alwaysNormalize) {
          if (Array.isArray(data) || isPrimitive(data)) {
            normalizationType = children;
            children = data;
            data = undefined;
          }

          if (isTrue(alwaysNormalize)) {
            normalizationType = ALWAYS_NORMALIZE;
          }

          return _createElement(context, tag, data, children, normalizationType);
        }

        function _createElement(context, tag, data, children, normalizationType) {
          if (isDef(data) && isDef(data.__ob__)) {
            process.env.NODE_ENV !== 'production' && warn("Avoid using observed data object as vnode data: " + JSON.stringify(data) + "\n" + 'Always create fresh vnode data objects in each render!', context);
            return createEmptyVNode();
          } // object syntax in v-bind


          if (isDef(data) && isDef(data.is)) {
            tag = data.is;
          }

          if (!tag) {
            // in case of component :is set to falsy value
            return createEmptyVNode();
          } // warn against non-primitive key


          if (process.env.NODE_ENV !== 'production' && isDef(data) && isDef(data.key) && !isPrimitive(data.key)) {
            {
              warn('Avoid using non-primitive value as key, ' + 'use string/number value instead.', context);
            }
          } // support single function children as default scoped slot


          if (Array.isArray(children) && typeof children[0] === 'function') {
            data = data || {};
            data.scopedSlots = {
              default: children[0]
            };
            children.length = 0;
          }

          if (normalizationType === ALWAYS_NORMALIZE) {
            children = normalizeChildren(children);
          } else if (normalizationType === SIMPLE_NORMALIZE) {
            children = simpleNormalizeChildren(children);
          }

          var vnode, ns;

          if (typeof tag === 'string') {
            var Ctor;
            ns = context.$vnode && context.$vnode.ns || config.getTagNamespace(tag);

            if (config.isReservedTag(tag)) {
              // platform built-in elements
              vnode = new VNode(config.parsePlatformTagName(tag), data, children, undefined, undefined, context);
            } else if (isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {
              // component
              vnode = createComponent(Ctor, data, context, children, tag);
            } else {
              // unknown or unlisted namespaced elements
              // check at runtime because it may get assigned a namespace when its
              // parent normalizes children
              vnode = new VNode(tag, data, children, undefined, undefined, context);
            }
          } else {
            // direct component options / constructor
            vnode = createComponent(tag, data, context, children);
          }

          if (Array.isArray(vnode)) {
            return vnode;
          } else if (isDef(vnode)) {
            if (isDef(ns)) {
              applyNS(vnode, ns);
            }

            if (isDef(data)) {
              registerDeepBindings(data);
            }

            return vnode;
          } else {
            return createEmptyVNode();
          }
        }

        function applyNS(vnode, ns, force) {
          vnode.ns = ns;

          if (vnode.tag === 'foreignObject') {
            // use default namespace inside foreignObject
            ns = undefined;
            force = true;
          }

          if (isDef(vnode.children)) {
            for (var i = 0, l = vnode.children.length; i < l; i++) {
              var child = vnode.children[i];

              if (isDef(child.tag) && (isUndef(child.ns) || isTrue(force) && child.tag !== 'svg')) {
                applyNS(child, ns, force);
              }
            }
          }
        } // ref #5318
        // necessary to ensure parent re-render when deep bindings like :style and
        // :class are used on slot nodes


        function registerDeepBindings(data) {
          if (isObject(data.style)) {
            traverse(data.style);
          }

          if (isObject(data.class)) {
            traverse(data.class);
          }
        }
        /*  */


        function initRender(vm) {
          vm._vnode = null; // the root of the child tree

          vm._staticTrees = null; // v-once cached trees

          var options = vm.$options;
          var parentVnode = vm.$vnode = options._parentVnode; // the placeholder node in parent tree

          var renderContext = parentVnode && parentVnode.context;
          vm.$slots = resolveSlots(options._renderChildren, renderContext);
          vm.$scopedSlots = emptyObject; // bind the createElement fn to this instance
          // so that we get proper render context inside it.
          // args order: tag, data, children, normalizationType, alwaysNormalize
          // internal version is used by render functions compiled from templates

          vm._c = function (a, b, c, d) {
            return createElement(vm, a, b, c, d, false);
          }; // normalization is always applied for the public version, used in
          // user-written render functions.


          vm.$createElement = function (a, b, c, d) {
            return createElement(vm, a, b, c, d, true);
          }; // $attrs & $listeners are exposed for easier HOC creation.
          // they need to be reactive so that HOCs using them are always updated


          var parentData = parentVnode && parentVnode.data;
          /* istanbul ignore else */

          if (process.env.NODE_ENV !== 'production') {
            defineReactive(vm, '$attrs', parentData && parentData.attrs || emptyObject, function () {
              !isUpdatingChildComponent && warn("$attrs is readonly.", vm);
            }, true);
            defineReactive(vm, '$listeners', options._parentListeners || emptyObject, function () {
              !isUpdatingChildComponent && warn("$listeners is readonly.", vm);
            }, true);
          } else {
            defineReactive(vm, '$attrs', parentData && parentData.attrs || emptyObject, null, true);
            defineReactive(vm, '$listeners', options._parentListeners || emptyObject, null, true);
          }
        }

        function renderMixin(Vue) {
          // install runtime convenience helpers
          installRenderHelpers(Vue.prototype);

          Vue.prototype.$nextTick = function (fn) {
            return nextTick(fn, this);
          };

          Vue.prototype._render = function () {
            var vm = this;
            var ref = vm.$options;
            var render = ref.render;
            var _parentVnode = ref._parentVnode; // reset _rendered flag on slots for duplicate slot check

            if (process.env.NODE_ENV !== 'production') {
              for (var key in vm.$slots) {
                // $flow-disable-line
                vm.$slots[key]._rendered = false;
              }
            }

            if (_parentVnode) {
              vm.$scopedSlots = _parentVnode.data.scopedSlots || emptyObject;
            } // set parent vnode. this allows render functions to have access
            // to the data on the placeholder node.


            vm.$vnode = _parentVnode; // render self

            var vnode;

            try {
              vnode = render.call(vm._renderProxy, vm.$createElement);
            } catch (e) {
              handleError(e, vm, "render"); // return error render result,
              // or previous vnode to prevent render error causing blank component

              /* istanbul ignore else */

              if (process.env.NODE_ENV !== 'production') {
                if (vm.$options.renderError) {
                  try {
                    vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e);
                  } catch (e) {
                    handleError(e, vm, "renderError");
                    vnode = vm._vnode;
                  }
                } else {
                  vnode = vm._vnode;
                }
              } else {
                vnode = vm._vnode;
              }
            } // return empty vnode in case the render function errored out


            if (!(vnode instanceof VNode)) {
              if (process.env.NODE_ENV !== 'production' && Array.isArray(vnode)) {
                warn('Multiple root nodes returned from render function. Render function ' + 'should return a single root node.', vm);
              }

              vnode = createEmptyVNode();
            } // set parent


            vnode.parent = _parentVnode;
            return vnode;
          };
        }
        /*  */


        var uid$3 = 0;

        function initMixin(Vue) {
          Vue.prototype._init = function (options) {
            var vm = this; // a uid

            vm._uid = uid$3++;
            var startTag, endTag;
            /* istanbul ignore if */

            if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
              startTag = "vue-perf-start:" + vm._uid;
              endTag = "vue-perf-end:" + vm._uid;
              mark(startTag);
            } // a flag to avoid this being observed


            vm._isVue = true; // merge options

            if (options && options._isComponent) {
              // optimize internal component instantiation
              // since dynamic options merging is pretty slow, and none of the
              // internal component options needs special treatment.
              initInternalComponent(vm, options);
            } else {
              vm.$options = mergeOptions(resolveConstructorOptions(vm.constructor), options || {}, vm);
            }
            /* istanbul ignore else */


            if (process.env.NODE_ENV !== 'production') {
              initProxy(vm);
            } else {
              vm._renderProxy = vm;
            } // expose real self


            vm._self = vm;
            initLifecycle(vm);
            initEvents(vm);
            initRender(vm);
            callHook(vm, 'beforeCreate');
            initInjections(vm); // resolve injections before data/props

            initState(vm);
            initProvide(vm); // resolve provide after data/props

            callHook(vm, 'created');
            /* istanbul ignore if */

            if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
              vm._name = formatComponentName(vm, false);
              mark(endTag);
              measure("vue " + vm._name + " init", startTag, endTag);
            }

            if (vm.$options.el) {
              vm.$mount(vm.$options.el);
            }
          };
        }

        function initInternalComponent(vm, options) {
          var opts = vm.$options = Object.create(vm.constructor.options); // doing this because it's faster than dynamic enumeration.

          var parentVnode = options._parentVnode;
          opts.parent = options.parent;
          opts._parentVnode = parentVnode;
          opts._parentElm = options._parentElm;
          opts._refElm = options._refElm;
          var vnodeComponentOptions = parentVnode.componentOptions;
          opts.propsData = vnodeComponentOptions.propsData;
          opts._parentListeners = vnodeComponentOptions.listeners;
          opts._renderChildren = vnodeComponentOptions.children;
          opts._componentTag = vnodeComponentOptions.tag;

          if (options.render) {
            opts.render = options.render;
            opts.staticRenderFns = options.staticRenderFns;
          }
        }

        function resolveConstructorOptions(Ctor) {
          var options = Ctor.options;

          if (Ctor.super) {
            var superOptions = resolveConstructorOptions(Ctor.super);
            var cachedSuperOptions = Ctor.superOptions;

            if (superOptions !== cachedSuperOptions) {
              // super option changed,
              // need to resolve new options.
              Ctor.superOptions = superOptions; // check if there are any late-modified/attached options (#4976)

              var modifiedOptions = resolveModifiedOptions(Ctor); // update base extend options

              if (modifiedOptions) {
                extend(Ctor.extendOptions, modifiedOptions);
              }

              options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);

              if (options.name) {
                options.components[options.name] = Ctor;
              }
            }
          }

          return options;
        }

        function resolveModifiedOptions(Ctor) {
          var modified;
          var latest = Ctor.options;
          var extended = Ctor.extendOptions;
          var sealed = Ctor.sealedOptions;

          for (var key in latest) {
            if (latest[key] !== sealed[key]) {
              if (!modified) {
                modified = {};
              }

              modified[key] = dedupe(latest[key], extended[key], sealed[key]);
            }
          }

          return modified;
        }

        function dedupe(latest, extended, sealed) {
          // compare latest and sealed to ensure lifecycle hooks won't be duplicated
          // between merges
          if (Array.isArray(latest)) {
            var res = [];
            sealed = Array.isArray(sealed) ? sealed : [sealed];
            extended = Array.isArray(extended) ? extended : [extended];

            for (var i = 0; i < latest.length; i++) {
              // push original options and not sealed options to exclude duplicated options
              if (extended.indexOf(latest[i]) >= 0 || sealed.indexOf(latest[i]) < 0) {
                res.push(latest[i]);
              }
            }

            return res;
          } else {
            return latest;
          }
        }

        function Vue(options) {
          if (process.env.NODE_ENV !== 'production' && !(this instanceof Vue)) {
            warn('Vue is a constructor and should be called with the `new` keyword');
          }

          this._init(options);
        }

        initMixin(Vue);
        stateMixin(Vue);
        eventsMixin(Vue);
        lifecycleMixin(Vue);
        renderMixin(Vue);
        /*  */

        function initUse(Vue) {
          Vue.use = function (plugin) {
            var installedPlugins = this._installedPlugins || (this._installedPlugins = []);

            if (installedPlugins.indexOf(plugin) > -1) {
              return this;
            } // additional parameters


            var args = toArray(arguments, 1);
            args.unshift(this);

            if (typeof plugin.install === 'function') {
              plugin.install.apply(plugin, args);
            } else if (typeof plugin === 'function') {
              plugin.apply(null, args);
            }

            installedPlugins.push(plugin);
            return this;
          };
        }
        /*  */


        function initMixin$1(Vue) {
          Vue.mixin = function (mixin) {
            this.options = mergeOptions(this.options, mixin);
            return this;
          };
        }
        /*  */


        function initExtend(Vue) {
          /**
           * Each instance constructor, including Vue, has a unique
           * cid. This enables us to create wrapped "child
           * constructors" for prototypal inheritance and cache them.
           */
          Vue.cid = 0;
          var cid = 1;
          /**
           * Class inheritance
           */

          Vue.extend = function (extendOptions) {
            extendOptions = extendOptions || {};
            var Super = this;
            var SuperId = Super.cid;
            var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});

            if (cachedCtors[SuperId]) {
              return cachedCtors[SuperId];
            }

            var name = extendOptions.name || Super.options.name;

            if (process.env.NODE_ENV !== 'production' && name) {
              validateComponentName(name);
            }

            var Sub = function VueComponent(options) {
              this._init(options);
            };

            Sub.prototype = Object.create(Super.prototype);
            Sub.prototype.constructor = Sub;
            Sub.cid = cid++;
            Sub.options = mergeOptions(Super.options, extendOptions);
            Sub['super'] = Super; // For props and computed properties, we define the proxy getters on
            // the Vue instances at extension time, on the extended prototype. This
            // avoids Object.defineProperty calls for each instance created.

            if (Sub.options.props) {
              initProps$1(Sub);
            }

            if (Sub.options.computed) {
              initComputed$1(Sub);
            } // allow further extension/mixin/plugin usage


            Sub.extend = Super.extend;
            Sub.mixin = Super.mixin;
            Sub.use = Super.use; // create asset registers, so extended classes
            // can have their private assets too.

            ASSET_TYPES.forEach(function (type) {
              Sub[type] = Super[type];
            }); // enable recursive self-lookup

            if (name) {
              Sub.options.components[name] = Sub;
            } // keep a reference to the super options at extension time.
            // later at instantiation we can check if Super's options have
            // been updated.


            Sub.superOptions = Super.options;
            Sub.extendOptions = extendOptions;
            Sub.sealedOptions = extend({}, Sub.options); // cache constructor

            cachedCtors[SuperId] = Sub;
            return Sub;
          };
        }

        function initProps$1(Comp) {
          var props = Comp.options.props;

          for (var key in props) {
            proxy(Comp.prototype, "_props", key);
          }
        }

        function initComputed$1(Comp) {
          var computed = Comp.options.computed;

          for (var key in computed) {
            defineComputed(Comp.prototype, key, computed[key]);
          }
        }
        /*  */


        function initAssetRegisters(Vue) {
          /**
           * Create asset registration methods.
           */
          ASSET_TYPES.forEach(function (type) {
            Vue[type] = function (id, definition) {
              if (!definition) {
                return this.options[type + 's'][id];
              } else {
                /* istanbul ignore if */
                if (process.env.NODE_ENV !== 'production' && type === 'component') {
                  validateComponentName(id);
                }

                if (type === 'component' && isPlainObject(definition)) {
                  definition.name = definition.name || id;
                  definition = this.options._base.extend(definition);
                }

                if (type === 'directive' && typeof definition === 'function') {
                  definition = {
                    bind: definition,
                    update: definition
                  };
                }

                this.options[type + 's'][id] = definition;
                return definition;
              }
            };
          });
        }
        /*  */


        function getComponentName(opts) {
          return opts && (opts.Ctor.options.name || opts.tag);
        }

        function matches(pattern, name) {
          if (Array.isArray(pattern)) {
            return pattern.indexOf(name) > -1;
          } else if (typeof pattern === 'string') {
            return pattern.split(',').indexOf(name) > -1;
          } else if (isRegExp(pattern)) {
            return pattern.test(name);
          }
          /* istanbul ignore next */


          return false;
        }

        function pruneCache(keepAliveInstance, filter) {
          var cache = keepAliveInstance.cache;
          var keys = keepAliveInstance.keys;
          var _vnode = keepAliveInstance._vnode;

          for (var key in cache) {
            var cachedNode = cache[key];

            if (cachedNode) {
              var name = getComponentName(cachedNode.componentOptions);

              if (name && !filter(name)) {
                pruneCacheEntry(cache, key, keys, _vnode);
              }
            }
          }
        }

        function pruneCacheEntry(cache, key, keys, current) {
          var cached$$1 = cache[key];

          if (cached$$1 && (!current || cached$$1.tag !== current.tag)) {
            cached$$1.componentInstance.$destroy();
          }

          cache[key] = null;
          remove(keys, key);
        }

        var patternTypes = [String, RegExp, Array];
        var KeepAlive = {
          name: 'keep-alive',
          abstract: true,
          props: {
            include: patternTypes,
            exclude: patternTypes,
            max: [String, Number]
          },
          created: function created() {
            this.cache = Object.create(null);
            this.keys = [];
          },
          destroyed: function destroyed() {
            var this$1 = this;

            for (var key in this$1.cache) {
              pruneCacheEntry(this$1.cache, key, this$1.keys);
            }
          },
          mounted: function mounted() {
            var this$1 = this;
            this.$watch('include', function (val) {
              pruneCache(this$1, function (name) {
                return matches(val, name);
              });
            });
            this.$watch('exclude', function (val) {
              pruneCache(this$1, function (name) {
                return !matches(val, name);
              });
            });
          },
          render: function render() {
            var slot = this.$slots.default;
            var vnode = getFirstComponentChild(slot);
            var componentOptions = vnode && vnode.componentOptions;

            if (componentOptions) {
              // check pattern
              var name = getComponentName(componentOptions);
              var ref = this;
              var include = ref.include;
              var exclude = ref.exclude;

              if ( // not included
              include && (!name || !matches(include, name)) || // excluded
              exclude && name && matches(exclude, name)) {
                return vnode;
              }

              var ref$1 = this;
              var cache = ref$1.cache;
              var keys = ref$1.keys;
              var key = vnode.key == null // same constructor may get registered as different local components
              // so cid alone is not enough (#3269)
              ? componentOptions.Ctor.cid + (componentOptions.tag ? "::" + componentOptions.tag : '') : vnode.key;

              if (cache[key]) {
                vnode.componentInstance = cache[key].componentInstance; // make current key freshest

                remove(keys, key);
                keys.push(key);
              } else {
                cache[key] = vnode;
                keys.push(key); // prune oldest entry

                if (this.max && keys.length > parseInt(this.max)) {
                  pruneCacheEntry(cache, keys[0], keys, this._vnode);
                }
              }

              vnode.data.keepAlive = true;
            }

            return vnode || slot && slot[0];
          }
        };
        var builtInComponents = {
          KeepAlive: KeepAlive
          /*  */

        };

        function initGlobalAPI(Vue) {
          // config
          var configDef = {};

          configDef.get = function () {
            return config;
          };

          if (process.env.NODE_ENV !== 'production') {
            configDef.set = function () {
              warn('Do not replace the Vue.config object, set individual fields instead.');
            };
          }

          Object.defineProperty(Vue, 'config', configDef); // exposed util methods.
          // NOTE: these are not considered part of the public API - avoid relying on
          // them unless you are aware of the risk.

          Vue.util = {
            warn: warn,
            extend: extend,
            mergeOptions: mergeOptions,
            defineReactive: defineReactive
          };
          Vue.set = set;
          Vue.delete = del;
          Vue.nextTick = nextTick;
          Vue.options = Object.create(null);
          ASSET_TYPES.forEach(function (type) {
            Vue.options[type + 's'] = Object.create(null);
          }); // this is used to identify the "base" constructor to extend all plain-object
          // components with in Weex's multi-instance scenarios.

          Vue.options._base = Vue;
          extend(Vue.options.components, builtInComponents);
          initUse(Vue);
          initMixin$1(Vue);
          initExtend(Vue);
          initAssetRegisters(Vue);
        }

        initGlobalAPI(Vue);
        Object.defineProperty(Vue.prototype, '$isServer', {
          get: isServerRendering
        });
        Object.defineProperty(Vue.prototype, '$ssrContext', {
          get: function get() {
            /* istanbul ignore next */
            return this.$vnode && this.$vnode.ssrContext;
          }
        }); // expose FunctionalRenderContext for ssr runtime helper installation

        Object.defineProperty(Vue, 'FunctionalRenderContext', {
          value: FunctionalRenderContext
        });
        Vue.version = '2.5.16';
        /*  */
        // these are reserved for web because they are directly compiled away
        // during template compilation

        var isReservedAttr = makeMap('style,class'); // attributes that should be using props for binding

        var acceptValue = makeMap('input,textarea,option,select,progress');

        var mustUseProp = function mustUseProp(tag, type, attr) {
          return attr === 'value' && acceptValue(tag) && type !== 'button' || attr === 'selected' && tag === 'option' || attr === 'checked' && tag === 'input' || attr === 'muted' && tag === 'video';
        };

        var isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');
        var isBooleanAttr = makeMap('allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' + 'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' + 'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' + 'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' + 'required,reversed,scoped,seamless,selected,sortable,translate,' + 'truespeed,typemustmatch,visible');
        var xlinkNS = 'http://www.w3.org/1999/xlink';

        var isXlink = function isXlink(name) {
          return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink';
        };

        var getXlinkProp = function getXlinkProp(name) {
          return isXlink(name) ? name.slice(6, name.length) : '';
        };

        var isFalsyAttrValue = function isFalsyAttrValue(val) {
          return val == null || val === false;
        };
        /*  */


        function genClassForVnode(vnode) {
          var data = vnode.data;
          var parentNode = vnode;
          var childNode = vnode;

          while (isDef(childNode.componentInstance)) {
            childNode = childNode.componentInstance._vnode;

            if (childNode && childNode.data) {
              data = mergeClassData(childNode.data, data);
            }
          }

          while (isDef(parentNode = parentNode.parent)) {
            if (parentNode && parentNode.data) {
              data = mergeClassData(data, parentNode.data);
            }
          }

          return renderClass(data.staticClass, data.class);
        }

        function mergeClassData(child, parent) {
          return {
            staticClass: concat(child.staticClass, parent.staticClass),
            class: isDef(child.class) ? [child.class, parent.class] : parent.class
          };
        }

        function renderClass(staticClass, dynamicClass) {
          if (isDef(staticClass) || isDef(dynamicClass)) {
            return concat(staticClass, stringifyClass(dynamicClass));
          }
          /* istanbul ignore next */


          return '';
        }

        function concat(a, b) {
          return a ? b ? a + ' ' + b : a : b || '';
        }

        function stringifyClass(value) {
          if (Array.isArray(value)) {
            return stringifyArray(value);
          }

          if (isObject(value)) {
            return stringifyObject(value);
          }

          if (typeof value === 'string') {
            return value;
          }
          /* istanbul ignore next */


          return '';
        }

        function stringifyArray(value) {
          var res = '';
          var stringified;

          for (var i = 0, l = value.length; i < l; i++) {
            if (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {
              if (res) {
                res += ' ';
              }

              res += stringified;
            }
          }

          return res;
        }

        function stringifyObject(value) {
          var res = '';

          for (var key in value) {
            if (value[key]) {
              if (res) {
                res += ' ';
              }

              res += key;
            }
          }

          return res;
        }
        /*  */


        var namespaceMap = {
          svg: 'http://www.w3.org/2000/svg',
          math: 'http://www.w3.org/1998/Math/MathML'
        };
        var isHTMLTag = makeMap('html,body,base,head,link,meta,style,title,' + 'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' + 'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' + 'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' + 's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' + 'embed,object,param,source,canvas,script,noscript,del,ins,' + 'caption,col,colgroup,table,thead,tbody,td,th,tr,' + 'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' + 'output,progress,select,textarea,' + 'details,dialog,menu,menuitem,summary,' + 'content,element,shadow,template,blockquote,iframe,tfoot'); // this map is intentionally selective, only covering SVG elements that may
        // contain child elements.

        var isSVG = makeMap('svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' + 'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' + 'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view', true);

        var isReservedTag = function isReservedTag(tag) {
          return isHTMLTag(tag) || isSVG(tag);
        };

        function getTagNamespace(tag) {
          if (isSVG(tag)) {
            return 'svg';
          } // basic support for MathML
          // note it doesn't support other MathML elements being component roots


          if (tag === 'math') {
            return 'math';
          }
        }

        var unknownElementCache = Object.create(null);

        function isUnknownElement(tag) {
          /* istanbul ignore if */
          if (!inBrowser) {
            return true;
          }

          if (isReservedTag(tag)) {
            return false;
          }

          tag = tag.toLowerCase();
          /* istanbul ignore if */

          if (unknownElementCache[tag] != null) {
            return unknownElementCache[tag];
          }

          var el = document.createElement(tag);

          if (tag.indexOf('-') > -1) {
            // http://stackoverflow.com/a/28210364/1070244
            return unknownElementCache[tag] = el.constructor === window.HTMLUnknownElement || el.constructor === window.HTMLElement;
          } else {
            return unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString());
          }
        }

        var isTextInputType = makeMap('text,number,password,search,email,tel,url');
        /*  */

        /**
         * Query an element selector if it's not an element already.
         */

        function query(el) {
          if (typeof el === 'string') {
            var selected = document.querySelector(el);

            if (!selected) {
              process.env.NODE_ENV !== 'production' && warn('Cannot find element: ' + el);
              return document.createElement('div');
            }

            return selected;
          } else {
            return el;
          }
        }
        /*  */


        function createElement$1(tagName, vnode) {
          var elm = document.createElement(tagName);

          if (tagName !== 'select') {
            return elm;
          } // false or null will remove the attribute but undefined will not


          if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {
            elm.setAttribute('multiple', 'multiple');
          }

          return elm;
        }

        function createElementNS(namespace, tagName) {
          return document.createElementNS(namespaceMap[namespace], tagName);
        }

        function createTextNode(text) {
          return document.createTextNode(text);
        }

        function createComment(text) {
          return document.createComment(text);
        }

        function insertBefore(parentNode, newNode, referenceNode) {
          parentNode.insertBefore(newNode, referenceNode);
        }

        function removeChild(node, child) {
          node.removeChild(child);
        }

        function appendChild(node, child) {
          node.appendChild(child);
        }

        function parentNode(node) {
          return node.parentNode;
        }

        function nextSibling(node) {
          return node.nextSibling;
        }

        function tagName(node) {
          return node.tagName;
        }

        function setTextContent(node, text) {
          node.textContent = text;
        }

        function setStyleScope(node, scopeId) {
          node.setAttribute(scopeId, '');
        }

        var nodeOps = Object.freeze({
          createElement: createElement$1,
          createElementNS: createElementNS,
          createTextNode: createTextNode,
          createComment: createComment,
          insertBefore: insertBefore,
          removeChild: removeChild,
          appendChild: appendChild,
          parentNode: parentNode,
          nextSibling: nextSibling,
          tagName: tagName,
          setTextContent: setTextContent,
          setStyleScope: setStyleScope
        });
        /*  */

        var ref = {
          create: function create(_, vnode) {
            registerRef(vnode);
          },
          update: function update(oldVnode, vnode) {
            if (oldVnode.data.ref !== vnode.data.ref) {
              registerRef(oldVnode, true);
              registerRef(vnode);
            }
          },
          destroy: function destroy(vnode) {
            registerRef(vnode, true);
          }
        };

        function registerRef(vnode, isRemoval) {
          var key = vnode.data.ref;

          if (!isDef(key)) {
            return;
          }

          var vm = vnode.context;
          var ref = vnode.componentInstance || vnode.elm;
          var refs = vm.$refs;

          if (isRemoval) {
            if (Array.isArray(refs[key])) {
              remove(refs[key], ref);
            } else if (refs[key] === ref) {
              refs[key] = undefined;
            }
          } else {
            if (vnode.data.refInFor) {
              if (!Array.isArray(refs[key])) {
                refs[key] = [ref];
              } else if (refs[key].indexOf(ref) < 0) {
                // $flow-disable-line
                refs[key].push(ref);
              }
            } else {
              refs[key] = ref;
            }
          }
        }
        /**
         * Virtual DOM patching algorithm based on Snabbdom by
         * Simon Friis Vindum (@paldepind)
         * Licensed under the MIT License
         * https://github.com/paldepind/snabbdom/blob/master/LICENSE
         *
         * modified by Evan You (@yyx990803)
         *
         * Not type-checking this because this file is perf-critical and the cost
         * of making flow understand it is not worth it.
         */


        var emptyNode = new VNode('', {}, []);
        var hooks = ['create', 'activate', 'update', 'remove', 'destroy'];

        function sameVnode(a, b) {
          return a.key === b.key && (a.tag === b.tag && a.isComment === b.isComment && isDef(a.data) === isDef(b.data) && sameInputType(a, b) || isTrue(a.isAsyncPlaceholder) && a.asyncFactory === b.asyncFactory && isUndef(b.asyncFactory.error));
        }

        function sameInputType(a, b) {
          if (a.tag !== 'input') {
            return true;
          }

          var i;
          var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;
          var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;
          return typeA === typeB || isTextInputType(typeA) && isTextInputType(typeB);
        }

        function createKeyToOldIdx(children, beginIdx, endIdx) {
          var i, key;
          var map = {};

          for (i = beginIdx; i <= endIdx; ++i) {
            key = children[i].key;

            if (isDef(key)) {
              map[key] = i;
            }
          }

          return map;
        }

        function createPatchFunction(backend) {
          var i, j;
          var cbs = {};
          var modules = backend.modules;
          var nodeOps = backend.nodeOps;

          for (i = 0; i < hooks.length; ++i) {
            cbs[hooks[i]] = [];

            for (j = 0; j < modules.length; ++j) {
              if (isDef(modules[j][hooks[i]])) {
                cbs[hooks[i]].push(modules[j][hooks[i]]);
              }
            }
          }

          function emptyNodeAt(elm) {
            return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm);
          }

          function createRmCb(childElm, listeners) {
            function remove() {
              if (--remove.listeners === 0) {
                removeNode(childElm);
              }
            }

            remove.listeners = listeners;
            return remove;
          }

          function removeNode(el) {
            var parent = nodeOps.parentNode(el); // element may have already been removed due to v-html / v-text

            if (isDef(parent)) {
              nodeOps.removeChild(parent, el);
            }
          }

          function isUnknownElement$$1(vnode, inVPre) {
            return !inVPre && !vnode.ns && !(config.ignoredElements.length && config.ignoredElements.some(function (ignore) {
              return isRegExp(ignore) ? ignore.test(vnode.tag) : ignore === vnode.tag;
            })) && config.isUnknownElement(vnode.tag);
          }

          var creatingElmInVPre = 0;

          function createElm(vnode, insertedVnodeQueue, parentElm, refElm, nested, ownerArray, index) {
            if (isDef(vnode.elm) && isDef(ownerArray)) {
              // This vnode was used in a previous render!
              // now it's used as a new node, overwriting its elm would cause
              // potential patch errors down the road when it's used as an insertion
              // reference node. Instead, we clone the node on-demand before creating
              // associated DOM element for it.
              vnode = ownerArray[index] = cloneVNode(vnode);
            }

            vnode.isRootInsert = !nested; // for transition enter check

            if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {
              return;
            }

            var data = vnode.data;
            var children = vnode.children;
            var tag = vnode.tag;

            if (isDef(tag)) {
              if (process.env.NODE_ENV !== 'production') {
                if (data && data.pre) {
                  creatingElmInVPre++;
                }

                if (isUnknownElement$$1(vnode, creatingElmInVPre)) {
                  warn('Unknown custom element: <' + tag + '> - did you ' + 'register the component correctly? For recursive components, ' + 'make sure to provide the "name" option.', vnode.context);
                }
              }

              vnode.elm = vnode.ns ? nodeOps.createElementNS(vnode.ns, tag) : nodeOps.createElement(tag, vnode);
              setScope(vnode);
              /* istanbul ignore if */

              {
                createChildren(vnode, children, insertedVnodeQueue);

                if (isDef(data)) {
                  invokeCreateHooks(vnode, insertedVnodeQueue);
                }

                insert(parentElm, vnode.elm, refElm);
              }

              if (process.env.NODE_ENV !== 'production' && data && data.pre) {
                creatingElmInVPre--;
              }
            } else if (isTrue(vnode.isComment)) {
              vnode.elm = nodeOps.createComment(vnode.text);
              insert(parentElm, vnode.elm, refElm);
            } else {
              vnode.elm = nodeOps.createTextNode(vnode.text);
              insert(parentElm, vnode.elm, refElm);
            }
          }

          function createComponent(vnode, insertedVnodeQueue, parentElm, refElm) {
            var i = vnode.data;

            if (isDef(i)) {
              var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;

              if (isDef(i = i.hook) && isDef(i = i.init)) {
                i(vnode, false
                /* hydrating */
                , parentElm, refElm);
              } // after calling the init hook, if the vnode is a child component
              // it should've created a child instance and mounted it. the child
              // component also has set the placeholder vnode's elm.
              // in that case we can just return the element and be done.


              if (isDef(vnode.componentInstance)) {
                initComponent(vnode, insertedVnodeQueue);

                if (isTrue(isReactivated)) {
                  reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);
                }

                return true;
              }
            }
          }

          function initComponent(vnode, insertedVnodeQueue) {
            if (isDef(vnode.data.pendingInsert)) {
              insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);
              vnode.data.pendingInsert = null;
            }

            vnode.elm = vnode.componentInstance.$el;

            if (isPatchable(vnode)) {
              invokeCreateHooks(vnode, insertedVnodeQueue);
              setScope(vnode);
            } else {
              // empty component root.
              // skip all element-related modules except for ref (#3455)
              registerRef(vnode); // make sure to invoke the insert hook

              insertedVnodeQueue.push(vnode);
            }
          }

          function reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm) {
            var i; // hack for #4339: a reactivated component with inner transition
            // does not trigger because the inner node's created hooks are not called
            // again. It's not ideal to involve module-specific logic in here but
            // there doesn't seem to be a better way to do it.

            var innerNode = vnode;

            while (innerNode.componentInstance) {
              innerNode = innerNode.componentInstance._vnode;

              if (isDef(i = innerNode.data) && isDef(i = i.transition)) {
                for (i = 0; i < cbs.activate.length; ++i) {
                  cbs.activate[i](emptyNode, innerNode);
                }

                insertedVnodeQueue.push(innerNode);
                break;
              }
            } // unlike a newly created component,
            // a reactivated keep-alive component doesn't insert itself


            insert(parentElm, vnode.elm, refElm);
          }

          function insert(parent, elm, ref$$1) {
            if (isDef(parent)) {
              if (isDef(ref$$1)) {
                if (ref$$1.parentNode === parent) {
                  nodeOps.insertBefore(parent, elm, ref$$1);
                }
              } else {
                nodeOps.appendChild(parent, elm);
              }
            }
          }

          function createChildren(vnode, children, insertedVnodeQueue) {
            if (Array.isArray(children)) {
              if (process.env.NODE_ENV !== 'production') {
                checkDuplicateKeys(children);
              }

              for (var i = 0; i < children.length; ++i) {
                createElm(children[i], insertedVnodeQueue, vnode.elm, null, true, children, i);
              }
            } else if (isPrimitive(vnode.text)) {
              nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(String(vnode.text)));
            }
          }

          function isPatchable(vnode) {
            while (vnode.componentInstance) {
              vnode = vnode.componentInstance._vnode;
            }

            return isDef(vnode.tag);
          }

          function invokeCreateHooks(vnode, insertedVnodeQueue) {
            for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
              cbs.create[i$1](emptyNode, vnode);
            }

            i = vnode.data.hook; // Reuse variable

            if (isDef(i)) {
              if (isDef(i.create)) {
                i.create(emptyNode, vnode);
              }

              if (isDef(i.insert)) {
                insertedVnodeQueue.push(vnode);
              }
            }
          } // set scope id attribute for scoped CSS.
          // this is implemented as a special case to avoid the overhead
          // of going through the normal attribute patching process.


          function setScope(vnode) {
            var i;

            if (isDef(i = vnode.fnScopeId)) {
              nodeOps.setStyleScope(vnode.elm, i);
            } else {
              var ancestor = vnode;

              while (ancestor) {
                if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {
                  nodeOps.setStyleScope(vnode.elm, i);
                }

                ancestor = ancestor.parent;
              }
            } // for slot content they should also get the scopeId from the host instance.


            if (isDef(i = activeInstance) && i !== vnode.context && i !== vnode.fnContext && isDef(i = i.$options._scopeId)) {
              nodeOps.setStyleScope(vnode.elm, i);
            }
          }

          function addVnodes(parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {
            for (; startIdx <= endIdx; ++startIdx) {
              createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm, false, vnodes, startIdx);
            }
          }

          function invokeDestroyHook(vnode) {
            var i, j;
            var data = vnode.data;

            if (isDef(data)) {
              if (isDef(i = data.hook) && isDef(i = i.destroy)) {
                i(vnode);
              }

              for (i = 0; i < cbs.destroy.length; ++i) {
                cbs.destroy[i](vnode);
              }
            }

            if (isDef(i = vnode.children)) {
              for (j = 0; j < vnode.children.length; ++j) {
                invokeDestroyHook(vnode.children[j]);
              }
            }
          }

          function removeVnodes(parentElm, vnodes, startIdx, endIdx) {
            for (; startIdx <= endIdx; ++startIdx) {
              var ch = vnodes[startIdx];

              if (isDef(ch)) {
                if (isDef(ch.tag)) {
                  removeAndInvokeRemoveHook(ch);
                  invokeDestroyHook(ch);
                } else {
                  // Text node
                  removeNode(ch.elm);
                }
              }
            }
          }

          function removeAndInvokeRemoveHook(vnode, rm) {
            if (isDef(rm) || isDef(vnode.data)) {
              var i;
              var listeners = cbs.remove.length + 1;

              if (isDef(rm)) {
                // we have a recursively passed down rm callback
                // increase the listeners count
                rm.listeners += listeners;
              } else {
                // directly removing
                rm = createRmCb(vnode.elm, listeners);
              } // recursively invoke hooks on child component root node


              if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {
                removeAndInvokeRemoveHook(i, rm);
              }

              for (i = 0; i < cbs.remove.length; ++i) {
                cbs.remove[i](vnode, rm);
              }

              if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {
                i(vnode, rm);
              } else {
                rm();
              }
            } else {
              removeNode(vnode.elm);
            }
          }

          function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {
            var oldStartIdx = 0;
            var newStartIdx = 0;
            var oldEndIdx = oldCh.length - 1;
            var oldStartVnode = oldCh[0];
            var oldEndVnode = oldCh[oldEndIdx];
            var newEndIdx = newCh.length - 1;
            var newStartVnode = newCh[0];
            var newEndVnode = newCh[newEndIdx];
            var oldKeyToIdx, idxInOld, vnodeToMove, refElm; // removeOnly is a special flag used only by <transition-group>
            // to ensure removed elements stay in correct relative positions
            // during leaving transitions

            var canMove = !removeOnly;

            if (process.env.NODE_ENV !== 'production') {
              checkDuplicateKeys(newCh);
            }

            while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
              if (isUndef(oldStartVnode)) {
                oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left
              } else if (isUndef(oldEndVnode)) {
                oldEndVnode = oldCh[--oldEndIdx];
              } else if (sameVnode(oldStartVnode, newStartVnode)) {
                patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);
                oldStartVnode = oldCh[++oldStartIdx];
                newStartVnode = newCh[++newStartIdx];
              } else if (sameVnode(oldEndVnode, newEndVnode)) {
                patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);
                oldEndVnode = oldCh[--oldEndIdx];
                newEndVnode = newCh[--newEndIdx];
              } else if (sameVnode(oldStartVnode, newEndVnode)) {
                // Vnode moved right
                patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);
                canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));
                oldStartVnode = oldCh[++oldStartIdx];
                newEndVnode = newCh[--newEndIdx];
              } else if (sameVnode(oldEndVnode, newStartVnode)) {
                // Vnode moved left
                patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);
                canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
                oldEndVnode = oldCh[--oldEndIdx];
                newStartVnode = newCh[++newStartIdx];
              } else {
                if (isUndef(oldKeyToIdx)) {
                  oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
                }

                idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);

                if (isUndef(idxInOld)) {
                  // New element
                  createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);
                } else {
                  vnodeToMove = oldCh[idxInOld];

                  if (sameVnode(vnodeToMove, newStartVnode)) {
                    patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue);
                    oldCh[idxInOld] = undefined;
                    canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);
                  } else {
                    // same key but different element. treat as new element
                    createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);
                  }
                }

                newStartVnode = newCh[++newStartIdx];
              }
            }

            if (oldStartIdx > oldEndIdx) {
              refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;
              addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
            } else if (newStartIdx > newEndIdx) {
              removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
            }
          }

          function checkDuplicateKeys(children) {
            var seenKeys = {};

            for (var i = 0; i < children.length; i++) {
              var vnode = children[i];
              var key = vnode.key;

              if (isDef(key)) {
                if (seenKeys[key]) {
                  warn("Duplicate keys detected: '" + key + "'. This may cause an update error.", vnode.context);
                } else {
                  seenKeys[key] = true;
                }
              }
            }
          }

          function findIdxInOld(node, oldCh, start, end) {
            for (var i = start; i < end; i++) {
              var c = oldCh[i];

              if (isDef(c) && sameVnode(node, c)) {
                return i;
              }
            }
          }

          function patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly) {
            if (oldVnode === vnode) {
              return;
            }

            var elm = vnode.elm = oldVnode.elm;

            if (isTrue(oldVnode.isAsyncPlaceholder)) {
              if (isDef(vnode.asyncFactory.resolved)) {
                hydrate(oldVnode.elm, vnode, insertedVnodeQueue);
              } else {
                vnode.isAsyncPlaceholder = true;
              }

              return;
            } // reuse element for static trees.
            // note we only do this if the vnode is cloned -
            // if the new node is not cloned it means the render functions have been
            // reset by the hot-reload-api and we need to do a proper re-render.


            if (isTrue(vnode.isStatic) && isTrue(oldVnode.isStatic) && vnode.key === oldVnode.key && (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))) {
              vnode.componentInstance = oldVnode.componentInstance;
              return;
            }

            var i;
            var data = vnode.data;

            if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {
              i(oldVnode, vnode);
            }

            var oldCh = oldVnode.children;
            var ch = vnode.children;

            if (isDef(data) && isPatchable(vnode)) {
              for (i = 0; i < cbs.update.length; ++i) {
                cbs.update[i](oldVnode, vnode);
              }

              if (isDef(i = data.hook) && isDef(i = i.update)) {
                i(oldVnode, vnode);
              }
            }

            if (isUndef(vnode.text)) {
              if (isDef(oldCh) && isDef(ch)) {
                if (oldCh !== ch) {
                  updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly);
                }
              } else if (isDef(ch)) {
                if (isDef(oldVnode.text)) {
                  nodeOps.setTextContent(elm, '');
                }

                addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
              } else if (isDef(oldCh)) {
                removeVnodes(elm, oldCh, 0, oldCh.length - 1);
              } else if (isDef(oldVnode.text)) {
                nodeOps.setTextContent(elm, '');
              }
            } else if (oldVnode.text !== vnode.text) {
              nodeOps.setTextContent(elm, vnode.text);
            }

            if (isDef(data)) {
              if (isDef(i = data.hook) && isDef(i = i.postpatch)) {
                i(oldVnode, vnode);
              }
            }
          }

          function invokeInsertHook(vnode, queue, initial) {
            // delay insert hooks for component root nodes, invoke them after the
            // element is really inserted
            if (isTrue(initial) && isDef(vnode.parent)) {
              vnode.parent.data.pendingInsert = queue;
            } else {
              for (var i = 0; i < queue.length; ++i) {
                queue[i].data.hook.insert(queue[i]);
              }
            }
          }

          var hydrationBailed = false; // list of modules that can skip create hook during hydration because they
          // are already rendered on the client or has no need for initialization
          // Note: style is excluded because it relies on initial clone for future
          // deep updates (#7063).

          var isRenderedModule = makeMap('attrs,class,staticClass,staticStyle,key'); // Note: this is a browser-only function so we can assume elms are DOM nodes.

          function hydrate(elm, vnode, insertedVnodeQueue, inVPre) {
            var i;
            var tag = vnode.tag;
            var data = vnode.data;
            var children = vnode.children;
            inVPre = inVPre || data && data.pre;
            vnode.elm = elm;

            if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {
              vnode.isAsyncPlaceholder = true;
              return true;
            } // assert node match


            if (process.env.NODE_ENV !== 'production') {
              if (!assertNodeMatch(elm, vnode, inVPre)) {
                return false;
              }
            }

            if (isDef(data)) {
              if (isDef(i = data.hook) && isDef(i = i.init)) {
                i(vnode, true
                /* hydrating */
                );
              }

              if (isDef(i = vnode.componentInstance)) {
                // child component. it should have hydrated its own tree.
                initComponent(vnode, insertedVnodeQueue);
                return true;
              }
            }

            if (isDef(tag)) {
              if (isDef(children)) {
                // empty element, allow client to pick up and populate children
                if (!elm.hasChildNodes()) {
                  createChildren(vnode, children, insertedVnodeQueue);
                } else {
                  // v-html and domProps: innerHTML
                  if (isDef(i = data) && isDef(i = i.domProps) && isDef(i = i.innerHTML)) {
                    if (i !== elm.innerHTML) {
                      /* istanbul ignore if */
                      if (process.env.NODE_ENV !== 'production' && typeof console !== 'undefined' && !hydrationBailed) {
                        hydrationBailed = true;
                        console.warn('Parent: ', elm);
                        console.warn('server innerHTML: ', i);
                        console.warn('client innerHTML: ', elm.innerHTML);
                      }

                      return false;
                    }
                  } else {
                    // iterate and compare children lists
                    var childrenMatch = true;
                    var childNode = elm.firstChild;

                    for (var i$1 = 0; i$1 < children.length; i$1++) {
                      if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue, inVPre)) {
                        childrenMatch = false;
                        break;
                      }

                      childNode = childNode.nextSibling;
                    } // if childNode is not null, it means the actual childNodes list is
                    // longer than the virtual children list.


                    if (!childrenMatch || childNode) {
                      /* istanbul ignore if */
                      if (process.env.NODE_ENV !== 'production' && typeof console !== 'undefined' && !hydrationBailed) {
                        hydrationBailed = true;
                        console.warn('Parent: ', elm);
                        console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);
                      }

                      return false;
                    }
                  }
                }
              }

              if (isDef(data)) {
                var fullInvoke = false;

                for (var key in data) {
                  if (!isRenderedModule(key)) {
                    fullInvoke = true;
                    invokeCreateHooks(vnode, insertedVnodeQueue);
                    break;
                  }
                }

                if (!fullInvoke && data['class']) {
                  // ensure collecting deps for deep class bindings for future updates
                  traverse(data['class']);
                }
              }
            } else if (elm.data !== vnode.text) {
              elm.data = vnode.text;
            }

            return true;
          }

          function assertNodeMatch(node, vnode, inVPre) {
            if (isDef(vnode.tag)) {
              return vnode.tag.indexOf('vue-component') === 0 || !isUnknownElement$$1(vnode, inVPre) && vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase());
            } else {
              return node.nodeType === (vnode.isComment ? 8 : 3);
            }
          }

          return function patch(oldVnode, vnode, hydrating, removeOnly, parentElm, refElm) {
            if (isUndef(vnode)) {
              if (isDef(oldVnode)) {
                invokeDestroyHook(oldVnode);
              }

              return;
            }

            var isInitialPatch = false;
            var insertedVnodeQueue = [];

            if (isUndef(oldVnode)) {
              // empty mount (likely as component), create new root element
              isInitialPatch = true;
              createElm(vnode, insertedVnodeQueue, parentElm, refElm);
            } else {
              var isRealElement = isDef(oldVnode.nodeType);

              if (!isRealElement && sameVnode(oldVnode, vnode)) {
                // patch existing root node
                patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly);
              } else {
                if (isRealElement) {
                  // mounting to a real element
                  // check if this is server-rendered content and if we can perform
                  // a successful hydration.
                  if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {
                    oldVnode.removeAttribute(SSR_ATTR);
                    hydrating = true;
                  }

                  if (isTrue(hydrating)) {
                    if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {
                      invokeInsertHook(vnode, insertedVnodeQueue, true);
                      return oldVnode;
                    } else if (process.env.NODE_ENV !== 'production') {
                      warn('The client-side rendered virtual DOM tree is not matching ' + 'server-rendered content. This is likely caused by incorrect ' + 'HTML markup, for example nesting block-level elements inside ' + '<p>, or missing <tbody>. Bailing hydration and performing ' + 'full client-side render.');
                    }
                  } // either not server-rendered, or hydration failed.
                  // create an empty node and replace it


                  oldVnode = emptyNodeAt(oldVnode);
                } // replacing existing element


                var oldElm = oldVnode.elm;
                var parentElm$1 = nodeOps.parentNode(oldElm); // create new node

                createElm(vnode, insertedVnodeQueue, // extremely rare edge case: do not insert if old element is in a
                // leaving transition. Only happens when combining transition +
                // keep-alive + HOCs. (#4590)
                oldElm._leaveCb ? null : parentElm$1, nodeOps.nextSibling(oldElm)); // update parent placeholder node element, recursively

                if (isDef(vnode.parent)) {
                  var ancestor = vnode.parent;
                  var patchable = isPatchable(vnode);

                  while (ancestor) {
                    for (var i = 0; i < cbs.destroy.length; ++i) {
                      cbs.destroy[i](ancestor);
                    }

                    ancestor.elm = vnode.elm;

                    if (patchable) {
                      for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
                        cbs.create[i$1](emptyNode, ancestor);
                      } // #6513
                      // invoke insert hooks that may have been merged by create hooks.
                      // e.g. for directives that uses the "inserted" hook.


                      var insert = ancestor.data.hook.insert;

                      if (insert.merged) {
                        // start at index 1 to avoid re-invoking component mounted hook
                        for (var i$2 = 1; i$2 < insert.fns.length; i$2++) {
                          insert.fns[i$2]();
                        }
                      }
                    } else {
                      registerRef(ancestor);
                    }

                    ancestor = ancestor.parent;
                  }
                } // destroy old node


                if (isDef(parentElm$1)) {
                  removeVnodes(parentElm$1, [oldVnode], 0, 0);
                } else if (isDef(oldVnode.tag)) {
                  invokeDestroyHook(oldVnode);
                }
              }
            }

            invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);
            return vnode.elm;
          };
        }
        /*  */


        var directives = {
          create: updateDirectives,
          update: updateDirectives,
          destroy: function unbindDirectives(vnode) {
            updateDirectives(vnode, emptyNode);
          }
        };

        function updateDirectives(oldVnode, vnode) {
          if (oldVnode.data.directives || vnode.data.directives) {
            _update(oldVnode, vnode);
          }
        }

        function _update(oldVnode, vnode) {
          var isCreate = oldVnode === emptyNode;
          var isDestroy = vnode === emptyNode;
          var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);
          var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);
          var dirsWithInsert = [];
          var dirsWithPostpatch = [];
          var key, oldDir, dir;

          for (key in newDirs) {
            oldDir = oldDirs[key];
            dir = newDirs[key];

            if (!oldDir) {
              // new directive, bind
              callHook$1(dir, 'bind', vnode, oldVnode);

              if (dir.def && dir.def.inserted) {
                dirsWithInsert.push(dir);
              }
            } else {
              // existing directive, update
              dir.oldValue = oldDir.value;
              callHook$1(dir, 'update', vnode, oldVnode);

              if (dir.def && dir.def.componentUpdated) {
                dirsWithPostpatch.push(dir);
              }
            }
          }

          if (dirsWithInsert.length) {
            var callInsert = function callInsert() {
              for (var i = 0; i < dirsWithInsert.length; i++) {
                callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);
              }
            };

            if (isCreate) {
              mergeVNodeHook(vnode, 'insert', callInsert);
            } else {
              callInsert();
            }
          }

          if (dirsWithPostpatch.length) {
            mergeVNodeHook(vnode, 'postpatch', function () {
              for (var i = 0; i < dirsWithPostpatch.length; i++) {
                callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);
              }
            });
          }

          if (!isCreate) {
            for (key in oldDirs) {
              if (!newDirs[key]) {
                // no longer present, unbind
                callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);
              }
            }
          }
        }

        var emptyModifiers = Object.create(null);

        function normalizeDirectives$1(dirs, vm) {
          var res = Object.create(null);

          if (!dirs) {
            // $flow-disable-line
            return res;
          }

          var i, dir;

          for (i = 0; i < dirs.length; i++) {
            dir = dirs[i];

            if (!dir.modifiers) {
              // $flow-disable-line
              dir.modifiers = emptyModifiers;
            }

            res[getRawDirName(dir)] = dir;
            dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);
          } // $flow-disable-line


          return res;
        }

        function getRawDirName(dir) {
          return dir.rawName || dir.name + "." + Object.keys(dir.modifiers || {}).join('.');
        }

        function callHook$1(dir, hook, vnode, oldVnode, isDestroy) {
          var fn = dir.def && dir.def[hook];

          if (fn) {
            try {
              fn(vnode.elm, dir, vnode, oldVnode, isDestroy);
            } catch (e) {
              handleError(e, vnode.context, "directive " + dir.name + " " + hook + " hook");
            }
          }
        }

        var baseModules = [ref, directives];
        /*  */

        function updateAttrs(oldVnode, vnode) {
          var opts = vnode.componentOptions;

          if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {
            return;
          }

          if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {
            return;
          }

          var key, cur, old;
          var elm = vnode.elm;
          var oldAttrs = oldVnode.data.attrs || {};
          var attrs = vnode.data.attrs || {}; // clone observed objects, as the user probably wants to mutate it

          if (isDef(attrs.__ob__)) {
            attrs = vnode.data.attrs = extend({}, attrs);
          }

          for (key in attrs) {
            cur = attrs[key];
            old = oldAttrs[key];

            if (old !== cur) {
              setAttr(elm, key, cur);
            }
          } // #4391: in IE9, setting type can reset value for input[type=radio]
          // #6666: IE/Edge forces progress value down to 1 before setting a max

          /* istanbul ignore if */


          if ((isIE || isEdge) && attrs.value !== oldAttrs.value) {
            setAttr(elm, 'value', attrs.value);
          }

          for (key in oldAttrs) {
            if (isUndef(attrs[key])) {
              if (isXlink(key)) {
                elm.removeAttributeNS(xlinkNS, getXlinkProp(key));
              } else if (!isEnumeratedAttr(key)) {
                elm.removeAttribute(key);
              }
            }
          }
        }

        function setAttr(el, key, value) {
          if (el.tagName.indexOf('-') > -1) {
            baseSetAttr(el, key, value);
          } else if (isBooleanAttr(key)) {
            // set attribute for blank value
            // e.g. <option disabled>Select one</option>
            if (isFalsyAttrValue(value)) {
              el.removeAttribute(key);
            } else {
              // technically allowfullscreen is a boolean attribute for <iframe>,
              // but Flash expects a value of "true" when used on <embed> tag
              value = key === 'allowfullscreen' && el.tagName === 'EMBED' ? 'true' : key;
              el.setAttribute(key, value);
            }
          } else if (isEnumeratedAttr(key)) {
            el.setAttribute(key, isFalsyAttrValue(value) || value === 'false' ? 'false' : 'true');
          } else if (isXlink(key)) {
            if (isFalsyAttrValue(value)) {
              el.removeAttributeNS(xlinkNS, getXlinkProp(key));
            } else {
              el.setAttributeNS(xlinkNS, key, value);
            }
          } else {
            baseSetAttr(el, key, value);
          }
        }

        function baseSetAttr(el, key, value) {
          if (isFalsyAttrValue(value)) {
            el.removeAttribute(key);
          } else {
            // #7138: IE10 & 11 fires input event when setting placeholder on
            // <textarea>... block the first input event and remove the blocker
            // immediately.

            /* istanbul ignore if */
            if (isIE && !isIE9 && el.tagName === 'TEXTAREA' && key === 'placeholder' && !el.__ieph) {
              var blocker = function blocker(e) {
                e.stopImmediatePropagation();
                el.removeEventListener('input', blocker);
              };

              el.addEventListener('input', blocker); // $flow-disable-line

              el.__ieph = true;
              /* IE placeholder patched */
            }

            el.setAttribute(key, value);
          }
        }

        var attrs = {
          create: updateAttrs,
          update: updateAttrs
          /*  */

        };

        function updateClass(oldVnode, vnode) {
          var el = vnode.elm;
          var data = vnode.data;
          var oldData = oldVnode.data;

          if (isUndef(data.staticClass) && isUndef(data.class) && (isUndef(oldData) || isUndef(oldData.staticClass) && isUndef(oldData.class))) {
            return;
          }

          var cls = genClassForVnode(vnode); // handle transition classes

          var transitionClass = el._transitionClasses;

          if (isDef(transitionClass)) {
            cls = concat(cls, stringifyClass(transitionClass));
          } // set the class


          if (cls !== el._prevClass) {
            el.setAttribute('class', cls);
            el._prevClass = cls;
          }
        }

        var klass = {
          create: updateClass,
          update: updateClass
          /*  */

          /*  */
          // add a raw attr (use this in preTransforms)
          // note: this only removes the attr from the Array (attrsList) so that it
          // doesn't get processed by processAttrs.
          // By default it does NOT remove it from the map (attrsMap) because the map is
          // needed during codegen.

          /*  */

          /**
           * Cross-platform code generation for component v-model
           */

          /**
           * Cross-platform codegen helper for generating v-model value assignment code.
           */

          /*  */
          // in some cases, the event used has to be determined at runtime
          // so we used some reserved tokens during compile.

        };
        var RANGE_TOKEN = '__r';
        var CHECKBOX_RADIO_TOKEN = '__c';
        /*  */
        // normalize v-model event tokens that can only be determined at runtime.
        // it's important to place the event as the first in the array because
        // the whole point is ensuring the v-model callback gets called before
        // user-attached handlers.

        function normalizeEvents(on) {
          /* istanbul ignore if */
          if (isDef(on[RANGE_TOKEN])) {
            // IE input[type=range] only supports `change` event
            var event = isIE ? 'change' : 'input';
            on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);
            delete on[RANGE_TOKEN];
          } // This was originally intended to fix #4521 but no longer necessary
          // after 2.5. Keeping it for backwards compat with generated code from < 2.4

          /* istanbul ignore if */


          if (isDef(on[CHECKBOX_RADIO_TOKEN])) {
            on.change = [].concat(on[CHECKBOX_RADIO_TOKEN], on.change || []);
            delete on[CHECKBOX_RADIO_TOKEN];
          }
        }

        var target$1;

        function createOnceHandler(handler, event, capture) {
          var _target = target$1; // save current target element in closure

          return function onceHandler() {
            var res = handler.apply(null, arguments);

            if (res !== null) {
              remove$2(event, onceHandler, capture, _target);
            }
          };
        }

        function add$1(event, handler, once$$1, capture, passive) {
          handler = withMacroTask(handler);

          if (once$$1) {
            handler = createOnceHandler(handler, event, capture);
          }

          target$1.addEventListener(event, handler, supportsPassive ? {
            capture: capture,
            passive: passive
          } : capture);
        }

        function remove$2(event, handler, capture, _target) {
          (_target || target$1).removeEventListener(event, handler._withTask || handler, capture);
        }

        function updateDOMListeners(oldVnode, vnode) {
          if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {
            return;
          }

          var on = vnode.data.on || {};
          var oldOn = oldVnode.data.on || {};
          target$1 = vnode.elm;
          normalizeEvents(on);
          updateListeners(on, oldOn, add$1, remove$2, vnode.context);
          target$1 = undefined;
        }

        var events = {
          create: updateDOMListeners,
          update: updateDOMListeners
          /*  */

        };

        function updateDOMProps(oldVnode, vnode) {
          if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {
            return;
          }

          var key, cur;
          var elm = vnode.elm;
          var oldProps = oldVnode.data.domProps || {};
          var props = vnode.data.domProps || {}; // clone observed objects, as the user probably wants to mutate it

          if (isDef(props.__ob__)) {
            props = vnode.data.domProps = extend({}, props);
          }

          for (key in oldProps) {
            if (isUndef(props[key])) {
              elm[key] = '';
            }
          }

          for (key in props) {
            cur = props[key]; // ignore children if the node has textContent or innerHTML,
            // as these will throw away existing DOM nodes and cause removal errors
            // on subsequent patches (#3360)

            if (key === 'textContent' || key === 'innerHTML') {
              if (vnode.children) {
                vnode.children.length = 0;
              }

              if (cur === oldProps[key]) {
                continue;
              } // #6601 work around Chrome version <= 55 bug where single textNode
              // replaced by innerHTML/textContent retains its parentNode property


              if (elm.childNodes.length === 1) {
                elm.removeChild(elm.childNodes[0]);
              }
            }

            if (key === 'value') {
              // store value as _value as well since
              // non-string values will be stringified
              elm._value = cur; // avoid resetting cursor position when value is the same

              var strCur = isUndef(cur) ? '' : String(cur);

              if (shouldUpdateValue(elm, strCur)) {
                elm.value = strCur;
              }
            } else {
              elm[key] = cur;
            }
          }
        } // check platforms/web/util/attrs.js acceptValue


        function shouldUpdateValue(elm, checkVal) {
          return !elm.composing && (elm.tagName === 'OPTION' || isNotInFocusAndDirty(elm, checkVal) || isDirtyWithModifiers(elm, checkVal));
        }

        function isNotInFocusAndDirty(elm, checkVal) {
          // return true when textbox (.number and .trim) loses focus and its value is
          // not equal to the updated value
          var notInFocus = true; // #6157
          // work around IE bug when accessing document.activeElement in an iframe

          try {
            notInFocus = document.activeElement !== elm;
          } catch (e) {}

          return notInFocus && elm.value !== checkVal;
        }

        function isDirtyWithModifiers(elm, newVal) {
          var value = elm.value;
          var modifiers = elm._vModifiers; // injected by v-model runtime

          if (isDef(modifiers)) {
            if (modifiers.lazy) {
              // inputs with lazy should only be updated when not in focus
              return false;
            }

            if (modifiers.number) {
              return toNumber(value) !== toNumber(newVal);
            }

            if (modifiers.trim) {
              return value.trim() !== newVal.trim();
            }
          }

          return value !== newVal;
        }

        var domProps = {
          create: updateDOMProps,
          update: updateDOMProps
          /*  */

        };
        var parseStyleText = cached(function (cssText) {
          var res = {};
          var listDelimiter = /;(?![^(]*\))/g;
          var propertyDelimiter = /:(.+)/;
          cssText.split(listDelimiter).forEach(function (item) {
            if (item) {
              var tmp = item.split(propertyDelimiter);
              tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());
            }
          });
          return res;
        }); // merge static and dynamic style data on the same vnode

        function normalizeStyleData(data) {
          var style = normalizeStyleBinding(data.style); // static style is pre-processed into an object during compilation
          // and is always a fresh object, so it's safe to merge into it

          return data.staticStyle ? extend(data.staticStyle, style) : style;
        } // normalize possible array / string values into Object


        function normalizeStyleBinding(bindingStyle) {
          if (Array.isArray(bindingStyle)) {
            return toObject(bindingStyle);
          }

          if (typeof bindingStyle === 'string') {
            return parseStyleText(bindingStyle);
          }

          return bindingStyle;
        }
        /**
         * parent component style should be after child's
         * so that parent component's style could override it
         */


        function getStyle(vnode, checkChild) {
          var res = {};
          var styleData;

          if (checkChild) {
            var childNode = vnode;

            while (childNode.componentInstance) {
              childNode = childNode.componentInstance._vnode;

              if (childNode && childNode.data && (styleData = normalizeStyleData(childNode.data))) {
                extend(res, styleData);
              }
            }
          }

          if (styleData = normalizeStyleData(vnode.data)) {
            extend(res, styleData);
          }

          var parentNode = vnode;

          while (parentNode = parentNode.parent) {
            if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {
              extend(res, styleData);
            }
          }

          return res;
        }
        /*  */


        var cssVarRE = /^--/;
        var importantRE = /\s*!important$/;

        var setProp = function setProp(el, name, val) {
          /* istanbul ignore if */
          if (cssVarRE.test(name)) {
            el.style.setProperty(name, val);
          } else if (importantRE.test(val)) {
            el.style.setProperty(name, val.replace(importantRE, ''), 'important');
          } else {
            var normalizedName = normalize(name);

            if (Array.isArray(val)) {
              // Support values array created by autoprefixer, e.g.
              // {display: ["-webkit-box", "-ms-flexbox", "flex"]}
              // Set them one by one, and the browser will only set those it can recognize
              for (var i = 0, len = val.length; i < len; i++) {
                el.style[normalizedName] = val[i];
              }
            } else {
              el.style[normalizedName] = val;
            }
          }
        };

        var vendorNames = ['Webkit', 'Moz', 'ms'];
        var emptyStyle;
        var normalize = cached(function (prop) {
          emptyStyle = emptyStyle || document.createElement('div').style;
          prop = camelize(prop);

          if (prop !== 'filter' && prop in emptyStyle) {
            return prop;
          }

          var capName = prop.charAt(0).toUpperCase() + prop.slice(1);

          for (var i = 0; i < vendorNames.length; i++) {
            var name = vendorNames[i] + capName;

            if (name in emptyStyle) {
              return name;
            }
          }
        });

        function updateStyle(oldVnode, vnode) {
          var data = vnode.data;
          var oldData = oldVnode.data;

          if (isUndef(data.staticStyle) && isUndef(data.style) && isUndef(oldData.staticStyle) && isUndef(oldData.style)) {
            return;
          }

          var cur, name;
          var el = vnode.elm;
          var oldStaticStyle = oldData.staticStyle;
          var oldStyleBinding = oldData.normalizedStyle || oldData.style || {}; // if static style exists, stylebinding already merged into it when doing normalizeStyleData

          var oldStyle = oldStaticStyle || oldStyleBinding;
          var style = normalizeStyleBinding(vnode.data.style) || {}; // store normalized style under a different key for next diff
          // make sure to clone it if it's reactive, since the user likely wants
          // to mutate it.

          vnode.data.normalizedStyle = isDef(style.__ob__) ? extend({}, style) : style;
          var newStyle = getStyle(vnode, true);

          for (name in oldStyle) {
            if (isUndef(newStyle[name])) {
              setProp(el, name, '');
            }
          }

          for (name in newStyle) {
            cur = newStyle[name];

            if (cur !== oldStyle[name]) {
              // ie9 setting to null has no effect, must use empty string
              setProp(el, name, cur == null ? '' : cur);
            }
          }
        }

        var style = {
          create: updateStyle,
          update: updateStyle
          /*  */

          /**
           * Add class with compatibility for SVG since classList is not supported on
           * SVG elements in IE
           */

        };

        function addClass(el, cls) {
          /* istanbul ignore if */
          if (!cls || !(cls = cls.trim())) {
            return;
          }
          /* istanbul ignore else */


          if (el.classList) {
            if (cls.indexOf(' ') > -1) {
              cls.split(/\s+/).forEach(function (c) {
                return el.classList.add(c);
              });
            } else {
              el.classList.add(cls);
            }
          } else {
            var cur = " " + (el.getAttribute('class') || '') + " ";

            if (cur.indexOf(' ' + cls + ' ') < 0) {
              el.setAttribute('class', (cur + cls).trim());
            }
          }
        }
        /**
         * Remove class with compatibility for SVG since classList is not supported on
         * SVG elements in IE
         */


        function removeClass(el, cls) {
          /* istanbul ignore if */
          if (!cls || !(cls = cls.trim())) {
            return;
          }
          /* istanbul ignore else */


          if (el.classList) {
            if (cls.indexOf(' ') > -1) {
              cls.split(/\s+/).forEach(function (c) {
                return el.classList.remove(c);
              });
            } else {
              el.classList.remove(cls);
            }

            if (!el.classList.length) {
              el.removeAttribute('class');
            }
          } else {
            var cur = " " + (el.getAttribute('class') || '') + " ";
            var tar = ' ' + cls + ' ';

            while (cur.indexOf(tar) >= 0) {
              cur = cur.replace(tar, ' ');
            }

            cur = cur.trim();

            if (cur) {
              el.setAttribute('class', cur);
            } else {
              el.removeAttribute('class');
            }
          }
        }
        /*  */


        function resolveTransition(def) {
          if (!def) {
            return;
          }
          /* istanbul ignore else */


          if (_typeof2(def) === 'object') {
            var res = {};

            if (def.css !== false) {
              extend(res, autoCssTransition(def.name || 'v'));
            }

            extend(res, def);
            return res;
          } else if (typeof def === 'string') {
            return autoCssTransition(def);
          }
        }

        var autoCssTransition = cached(function (name) {
          return {
            enterClass: name + "-enter",
            enterToClass: name + "-enter-to",
            enterActiveClass: name + "-enter-active",
            leaveClass: name + "-leave",
            leaveToClass: name + "-leave-to",
            leaveActiveClass: name + "-leave-active"
          };
        });
        var hasTransition = inBrowser && !isIE9;
        var TRANSITION = 'transition';
        var ANIMATION = 'animation'; // Transition property/event sniffing

        var transitionProp = 'transition';
        var transitionEndEvent = 'transitionend';
        var animationProp = 'animation';
        var animationEndEvent = 'animationend';

        if (hasTransition) {
          /* istanbul ignore if */
          if (window.ontransitionend === undefined && window.onwebkittransitionend !== undefined) {
            transitionProp = 'WebkitTransition';
            transitionEndEvent = 'webkitTransitionEnd';
          }

          if (window.onanimationend === undefined && window.onwebkitanimationend !== undefined) {
            animationProp = 'WebkitAnimation';
            animationEndEvent = 'webkitAnimationEnd';
          }
        } // binding to window is necessary to make hot reload work in IE in strict mode


        var raf = inBrowser ? window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : setTimeout :
        /* istanbul ignore next */
        function (fn) {
          return fn();
        };

        function nextFrame(fn) {
          raf(function () {
            raf(fn);
          });
        }

        function addTransitionClass(el, cls) {
          var transitionClasses = el._transitionClasses || (el._transitionClasses = []);

          if (transitionClasses.indexOf(cls) < 0) {
            transitionClasses.push(cls);
            addClass(el, cls);
          }
        }

        function removeTransitionClass(el, cls) {
          if (el._transitionClasses) {
            remove(el._transitionClasses, cls);
          }

          removeClass(el, cls);
        }

        function whenTransitionEnds(el, expectedType, cb) {
          var ref = getTransitionInfo(el, expectedType);
          var type = ref.type;
          var timeout = ref.timeout;
          var propCount = ref.propCount;

          if (!type) {
            return cb();
          }

          var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;
          var ended = 0;

          var end = function end() {
            el.removeEventListener(event, onEnd);
            cb();
          };

          var onEnd = function onEnd(e) {
            if (e.target === el) {
              if (++ended >= propCount) {
                end();
              }
            }
          };

          setTimeout(function () {
            if (ended < propCount) {
              end();
            }
          }, timeout + 1);
          el.addEventListener(event, onEnd);
        }

        var transformRE = /\b(transform|all)(,|$)/;

        function getTransitionInfo(el, expectedType) {
          var styles = window.getComputedStyle(el);
          var transitionDelays = styles[transitionProp + 'Delay'].split(', ');
          var transitionDurations = styles[transitionProp + 'Duration'].split(', ');
          var transitionTimeout = getTimeout(transitionDelays, transitionDurations);
          var animationDelays = styles[animationProp + 'Delay'].split(', ');
          var animationDurations = styles[animationProp + 'Duration'].split(', ');
          var animationTimeout = getTimeout(animationDelays, animationDurations);
          var type;
          var timeout = 0;
          var propCount = 0;
          /* istanbul ignore if */

          if (expectedType === TRANSITION) {
            if (transitionTimeout > 0) {
              type = TRANSITION;
              timeout = transitionTimeout;
              propCount = transitionDurations.length;
            }
          } else if (expectedType === ANIMATION) {
            if (animationTimeout > 0) {
              type = ANIMATION;
              timeout = animationTimeout;
              propCount = animationDurations.length;
            }
          } else {
            timeout = Math.max(transitionTimeout, animationTimeout);
            type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
            propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
          }

          var hasTransform = type === TRANSITION && transformRE.test(styles[transitionProp + 'Property']);
          return {
            type: type,
            timeout: timeout,
            propCount: propCount,
            hasTransform: hasTransform
          };
        }

        function getTimeout(delays, durations) {
          /* istanbul ignore next */
          while (delays.length < durations.length) {
            delays = delays.concat(delays);
          }

          return Math.max.apply(null, durations.map(function (d, i) {
            return toMs(d) + toMs(delays[i]);
          }));
        }

        function toMs(s) {
          return Number(s.slice(0, -1)) * 1000;
        }
        /*  */


        function enter(vnode, toggleDisplay) {
          var el = vnode.elm; // call leave callback now

          if (isDef(el._leaveCb)) {
            el._leaveCb.cancelled = true;

            el._leaveCb();
          }

          var data = resolveTransition(vnode.data.transition);

          if (isUndef(data)) {
            return;
          }
          /* istanbul ignore if */


          if (isDef(el._enterCb) || el.nodeType !== 1) {
            return;
          }

          var css = data.css;
          var type = data.type;
          var enterClass = data.enterClass;
          var enterToClass = data.enterToClass;
          var enterActiveClass = data.enterActiveClass;
          var appearClass = data.appearClass;
          var appearToClass = data.appearToClass;
          var appearActiveClass = data.appearActiveClass;
          var beforeEnter = data.beforeEnter;
          var enter = data.enter;
          var afterEnter = data.afterEnter;
          var enterCancelled = data.enterCancelled;
          var beforeAppear = data.beforeAppear;
          var appear = data.appear;
          var afterAppear = data.afterAppear;
          var appearCancelled = data.appearCancelled;
          var duration = data.duration; // activeInstance will always be the <transition> component managing this
          // transition. One edge case to check is when the <transition> is placed
          // as the root node of a child component. In that case we need to check
          // <transition>'s parent for appear check.

          var context = activeInstance;
          var transitionNode = activeInstance.$vnode;

          while (transitionNode && transitionNode.parent) {
            transitionNode = transitionNode.parent;
            context = transitionNode.context;
          }

          var isAppear = !context._isMounted || !vnode.isRootInsert;

          if (isAppear && !appear && appear !== '') {
            return;
          }

          var startClass = isAppear && appearClass ? appearClass : enterClass;
          var activeClass = isAppear && appearActiveClass ? appearActiveClass : enterActiveClass;
          var toClass = isAppear && appearToClass ? appearToClass : enterToClass;
          var beforeEnterHook = isAppear ? beforeAppear || beforeEnter : beforeEnter;
          var enterHook = isAppear ? typeof appear === 'function' ? appear : enter : enter;
          var afterEnterHook = isAppear ? afterAppear || afterEnter : afterEnter;
          var enterCancelledHook = isAppear ? appearCancelled || enterCancelled : enterCancelled;
          var explicitEnterDuration = toNumber(isObject(duration) ? duration.enter : duration);

          if (process.env.NODE_ENV !== 'production' && explicitEnterDuration != null) {
            checkDuration(explicitEnterDuration, 'enter', vnode);
          }

          var expectsCSS = css !== false && !isIE9;
          var userWantsControl = getHookArgumentsLength(enterHook);
          var cb = el._enterCb = once(function () {
            if (expectsCSS) {
              removeTransitionClass(el, toClass);
              removeTransitionClass(el, activeClass);
            }

            if (cb.cancelled) {
              if (expectsCSS) {
                removeTransitionClass(el, startClass);
              }

              enterCancelledHook && enterCancelledHook(el);
            } else {
              afterEnterHook && afterEnterHook(el);
            }

            el._enterCb = null;
          });

          if (!vnode.data.show) {
            // remove pending leave element on enter by injecting an insert hook
            mergeVNodeHook(vnode, 'insert', function () {
              var parent = el.parentNode;
              var pendingNode = parent && parent._pending && parent._pending[vnode.key];

              if (pendingNode && pendingNode.tag === vnode.tag && pendingNode.elm._leaveCb) {
                pendingNode.elm._leaveCb();
              }

              enterHook && enterHook(el, cb);
            });
          } // start enter transition


          beforeEnterHook && beforeEnterHook(el);

          if (expectsCSS) {
            addTransitionClass(el, startClass);
            addTransitionClass(el, activeClass);
            nextFrame(function () {
              removeTransitionClass(el, startClass);

              if (!cb.cancelled) {
                addTransitionClass(el, toClass);

                if (!userWantsControl) {
                  if (isValidDuration(explicitEnterDuration)) {
                    setTimeout(cb, explicitEnterDuration);
                  } else {
                    whenTransitionEnds(el, type, cb);
                  }
                }
              }
            });
          }

          if (vnode.data.show) {
            toggleDisplay && toggleDisplay();
            enterHook && enterHook(el, cb);
          }

          if (!expectsCSS && !userWantsControl) {
            cb();
          }
        }

        function leave(vnode, rm) {
          var el = vnode.elm; // call enter callback now

          if (isDef(el._enterCb)) {
            el._enterCb.cancelled = true;

            el._enterCb();
          }

          var data = resolveTransition(vnode.data.transition);

          if (isUndef(data) || el.nodeType !== 1) {
            return rm();
          }
          /* istanbul ignore if */


          if (isDef(el._leaveCb)) {
            return;
          }

          var css = data.css;
          var type = data.type;
          var leaveClass = data.leaveClass;
          var leaveToClass = data.leaveToClass;
          var leaveActiveClass = data.leaveActiveClass;
          var beforeLeave = data.beforeLeave;
          var leave = data.leave;
          var afterLeave = data.afterLeave;
          var leaveCancelled = data.leaveCancelled;
          var delayLeave = data.delayLeave;
          var duration = data.duration;
          var expectsCSS = css !== false && !isIE9;
          var userWantsControl = getHookArgumentsLength(leave);
          var explicitLeaveDuration = toNumber(isObject(duration) ? duration.leave : duration);

          if (process.env.NODE_ENV !== 'production' && isDef(explicitLeaveDuration)) {
            checkDuration(explicitLeaveDuration, 'leave', vnode);
          }

          var cb = el._leaveCb = once(function () {
            if (el.parentNode && el.parentNode._pending) {
              el.parentNode._pending[vnode.key] = null;
            }

            if (expectsCSS) {
              removeTransitionClass(el, leaveToClass);
              removeTransitionClass(el, leaveActiveClass);
            }

            if (cb.cancelled) {
              if (expectsCSS) {
                removeTransitionClass(el, leaveClass);
              }

              leaveCancelled && leaveCancelled(el);
            } else {
              rm();
              afterLeave && afterLeave(el);
            }

            el._leaveCb = null;
          });

          if (delayLeave) {
            delayLeave(performLeave);
          } else {
            performLeave();
          }

          function performLeave() {
            // the delayed leave may have already been cancelled
            if (cb.cancelled) {
              return;
            } // record leaving element


            if (!vnode.data.show) {
              (el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] = vnode;
            }

            beforeLeave && beforeLeave(el);

            if (expectsCSS) {
              addTransitionClass(el, leaveClass);
              addTransitionClass(el, leaveActiveClass);
              nextFrame(function () {
                removeTransitionClass(el, leaveClass);

                if (!cb.cancelled) {
                  addTransitionClass(el, leaveToClass);

                  if (!userWantsControl) {
                    if (isValidDuration(explicitLeaveDuration)) {
                      setTimeout(cb, explicitLeaveDuration);
                    } else {
                      whenTransitionEnds(el, type, cb);
                    }
                  }
                }
              });
            }

            leave && leave(el, cb);

            if (!expectsCSS && !userWantsControl) {
              cb();
            }
          }
        } // only used in dev mode


        function checkDuration(val, name, vnode) {
          if (typeof val !== 'number') {
            warn("<transition> explicit " + name + " duration is not a valid number - " + "got " + JSON.stringify(val) + ".", vnode.context);
          } else if (isNaN(val)) {
            warn("<transition> explicit " + name + " duration is NaN - " + 'the duration expression might be incorrect.', vnode.context);
          }
        }

        function isValidDuration(val) {
          return typeof val === 'number' && !isNaN(val);
        }
        /**
         * Normalize a transition hook's argument length. The hook may be:
         * - a merged hook (invoker) with the original in .fns
         * - a wrapped component method (check ._length)
         * - a plain function (.length)
         */


        function getHookArgumentsLength(fn) {
          if (isUndef(fn)) {
            return false;
          }

          var invokerFns = fn.fns;

          if (isDef(invokerFns)) {
            // invoker
            return getHookArgumentsLength(Array.isArray(invokerFns) ? invokerFns[0] : invokerFns);
          } else {
            return (fn._length || fn.length) > 1;
          }
        }

        function _enter(_, vnode) {
          if (vnode.data.show !== true) {
            enter(vnode);
          }
        }

        var transition = inBrowser ? {
          create: _enter,
          activate: _enter,
          remove: function remove$$1(vnode, rm) {
            /* istanbul ignore else */
            if (vnode.data.show !== true) {
              leave(vnode, rm);
            } else {
              rm();
            }
          }
        } : {};
        var platformModules = [attrs, klass, events, domProps, style, transition];
        /*  */
        // the directive module should be applied last, after all
        // built-in modules have been applied.

        var modules = platformModules.concat(baseModules);
        var patch = createPatchFunction({
          nodeOps: nodeOps,
          modules: modules
        });
        /**
         * Not type checking this file because flow doesn't like attaching
         * properties to Elements.
         */

        /* istanbul ignore if */

        if (isIE9) {
          // http://www.matts411.com/post/internet-explorer-9-oninput/
          document.addEventListener('selectionchange', function () {
            var el = document.activeElement;

            if (el && el.vmodel) {
              trigger(el, 'input');
            }
          });
        }

        var directive = {
          inserted: function inserted(el, binding, vnode, oldVnode) {
            if (vnode.tag === 'select') {
              // #6903
              if (oldVnode.elm && !oldVnode.elm._vOptions) {
                mergeVNodeHook(vnode, 'postpatch', function () {
                  directive.componentUpdated(el, binding, vnode);
                });
              } else {
                setSelected(el, binding, vnode.context);
              }

              el._vOptions = [].map.call(el.options, getValue);
            } else if (vnode.tag === 'textarea' || isTextInputType(el.type)) {
              el._vModifiers = binding.modifiers;

              if (!binding.modifiers.lazy) {
                el.addEventListener('compositionstart', onCompositionStart);
                el.addEventListener('compositionend', onCompositionEnd); // Safari < 10.2 & UIWebView doesn't fire compositionend when
                // switching focus before confirming composition choice
                // this also fixes the issue where some browsers e.g. iOS Chrome
                // fires "change" instead of "input" on autocomplete.

                el.addEventListener('change', onCompositionEnd);
                /* istanbul ignore if */

                if (isIE9) {
                  el.vmodel = true;
                }
              }
            }
          },
          componentUpdated: function componentUpdated(el, binding, vnode) {
            if (vnode.tag === 'select') {
              setSelected(el, binding, vnode.context); // in case the options rendered by v-for have changed,
              // it's possible that the value is out-of-sync with the rendered options.
              // detect such cases and filter out values that no longer has a matching
              // option in the DOM.

              var prevOptions = el._vOptions;
              var curOptions = el._vOptions = [].map.call(el.options, getValue);

              if (curOptions.some(function (o, i) {
                return !looseEqual(o, prevOptions[i]);
              })) {
                // trigger change event if
                // no matching option found for at least one value
                var needReset = el.multiple ? binding.value.some(function (v) {
                  return hasNoMatchingOption(v, curOptions);
                }) : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, curOptions);

                if (needReset) {
                  trigger(el, 'change');
                }
              }
            }
          }
        };

        function setSelected(el, binding, vm) {
          actuallySetSelected(el, binding, vm);
          /* istanbul ignore if */

          if (isIE || isEdge) {
            setTimeout(function () {
              actuallySetSelected(el, binding, vm);
            }, 0);
          }
        }

        function actuallySetSelected(el, binding, vm) {
          var value = binding.value;
          var isMultiple = el.multiple;

          if (isMultiple && !Array.isArray(value)) {
            process.env.NODE_ENV !== 'production' && warn("<select multiple v-model=\"" + binding.expression + "\"> " + "expects an Array value for its binding, but got " + Object.prototype.toString.call(value).slice(8, -1), vm);
            return;
          }

          var selected, option;

          for (var i = 0, l = el.options.length; i < l; i++) {
            option = el.options[i];

            if (isMultiple) {
              selected = looseIndexOf(value, getValue(option)) > -1;

              if (option.selected !== selected) {
                option.selected = selected;
              }
            } else {
              if (looseEqual(getValue(option), value)) {
                if (el.selectedIndex !== i) {
                  el.selectedIndex = i;
                }

                return;
              }
            }
          }

          if (!isMultiple) {
            el.selectedIndex = -1;
          }
        }

        function hasNoMatchingOption(value, options) {
          return options.every(function (o) {
            return !looseEqual(o, value);
          });
        }

        function getValue(option) {
          return '_value' in option ? option._value : option.value;
        }

        function onCompositionStart(e) {
          e.target.composing = true;
        }

        function onCompositionEnd(e) {
          // prevent triggering an input event for no reason
          if (!e.target.composing) {
            return;
          }

          e.target.composing = false;
          trigger(e.target, 'input');
        }

        function trigger(el, type) {
          var e = document.createEvent('HTMLEvents');
          e.initEvent(type, true, true);
          el.dispatchEvent(e);
        }
        /*  */
        // recursively search for possible transition defined inside the component root


        function locateNode(vnode) {
          return vnode.componentInstance && (!vnode.data || !vnode.data.transition) ? locateNode(vnode.componentInstance._vnode) : vnode;
        }

        var show = {
          bind: function bind(el, ref, vnode) {
            var value = ref.value;
            vnode = locateNode(vnode);
            var transition$$1 = vnode.data && vnode.data.transition;
            var originalDisplay = el.__vOriginalDisplay = el.style.display === 'none' ? '' : el.style.display;

            if (value && transition$$1) {
              vnode.data.show = true;
              enter(vnode, function () {
                el.style.display = originalDisplay;
              });
            } else {
              el.style.display = value ? originalDisplay : 'none';
            }
          },
          update: function update(el, ref, vnode) {
            var value = ref.value;
            var oldValue = ref.oldValue;
            /* istanbul ignore if */

            if (!value === !oldValue) {
              return;
            }

            vnode = locateNode(vnode);
            var transition$$1 = vnode.data && vnode.data.transition;

            if (transition$$1) {
              vnode.data.show = true;

              if (value) {
                enter(vnode, function () {
                  el.style.display = el.__vOriginalDisplay;
                });
              } else {
                leave(vnode, function () {
                  el.style.display = 'none';
                });
              }
            } else {
              el.style.display = value ? el.__vOriginalDisplay : 'none';
            }
          },
          unbind: function unbind(el, binding, vnode, oldVnode, isDestroy) {
            if (!isDestroy) {
              el.style.display = el.__vOriginalDisplay;
            }
          }
        };
        var platformDirectives = {
          model: directive,
          show: show
          /*  */
          // Provides transition support for a single element/component.
          // supports transition mode (out-in / in-out)

        };
        var transitionProps = {
          name: String,
          appear: Boolean,
          css: Boolean,
          mode: String,
          type: String,
          enterClass: String,
          leaveClass: String,
          enterToClass: String,
          leaveToClass: String,
          enterActiveClass: String,
          leaveActiveClass: String,
          appearClass: String,
          appearActiveClass: String,
          appearToClass: String,
          duration: [Number, String, Object]
        }; // in case the child is also an abstract component, e.g. <keep-alive>
        // we want to recursively retrieve the real component to be rendered

        function getRealChild(vnode) {
          var compOptions = vnode && vnode.componentOptions;

          if (compOptions && compOptions.Ctor.options.abstract) {
            return getRealChild(getFirstComponentChild(compOptions.children));
          } else {
            return vnode;
          }
        }

        function extractTransitionData(comp) {
          var data = {};
          var options = comp.$options; // props

          for (var key in options.propsData) {
            data[key] = comp[key];
          } // events.
          // extract listeners and pass them directly to the transition methods


          var listeners = options._parentListeners;

          for (var key$1 in listeners) {
            data[camelize(key$1)] = listeners[key$1];
          }

          return data;
        }

        function placeholder(h, rawChild) {
          if (/\d-keep-alive$/.test(rawChild.tag)) {
            return h('keep-alive', {
              props: rawChild.componentOptions.propsData
            });
          }
        }

        function hasParentTransition(vnode) {
          while (vnode = vnode.parent) {
            if (vnode.data.transition) {
              return true;
            }
          }
        }

        function isSameChild(child, oldChild) {
          return oldChild.key === child.key && oldChild.tag === child.tag;
        }

        var Transition = {
          name: 'transition',
          props: transitionProps,
          abstract: true,
          render: function render(h) {
            var this$1 = this;
            var children = this.$slots.default;

            if (!children) {
              return;
            } // filter out text nodes (possible whitespaces)


            children = children.filter(function (c) {
              return c.tag || isAsyncPlaceholder(c);
            });
            /* istanbul ignore if */

            if (!children.length) {
              return;
            } // warn multiple elements


            if (process.env.NODE_ENV !== 'production' && children.length > 1) {
              warn('<transition> can only be used on a single element. Use ' + '<transition-group> for lists.', this.$parent);
            }

            var mode = this.mode; // warn invalid mode

            if (process.env.NODE_ENV !== 'production' && mode && mode !== 'in-out' && mode !== 'out-in') {
              warn('invalid <transition> mode: ' + mode, this.$parent);
            }

            var rawChild = children[0]; // if this is a component root node and the component's
            // parent container node also has transition, skip.

            if (hasParentTransition(this.$vnode)) {
              return rawChild;
            } // apply transition data to child
            // use getRealChild() to ignore abstract components e.g. keep-alive


            var child = getRealChild(rawChild);
            /* istanbul ignore if */

            if (!child) {
              return rawChild;
            }

            if (this._leaving) {
              return placeholder(h, rawChild);
            } // ensure a key that is unique to the vnode type and to this transition
            // component instance. This key will be used to remove pending leaving nodes
            // during entering.


            var id = "__transition-" + this._uid + "-";
            child.key = child.key == null ? child.isComment ? id + 'comment' : id + child.tag : isPrimitive(child.key) ? String(child.key).indexOf(id) === 0 ? child.key : id + child.key : child.key;
            var data = (child.data || (child.data = {})).transition = extractTransitionData(this);
            var oldRawChild = this._vnode;
            var oldChild = getRealChild(oldRawChild); // mark v-show
            // so that the transition module can hand over the control to the directive

            if (child.data.directives && child.data.directives.some(function (d) {
              return d.name === 'show';
            })) {
              child.data.show = true;
            }

            if (oldChild && oldChild.data && !isSameChild(child, oldChild) && !isAsyncPlaceholder(oldChild) && // #6687 component root is a comment node
            !(oldChild.componentInstance && oldChild.componentInstance._vnode.isComment)) {
              // replace old child transition data with fresh one
              // important for dynamic transitions!
              var oldData = oldChild.data.transition = extend({}, data); // handle transition mode

              if (mode === 'out-in') {
                // return placeholder node and queue update when leave finishes
                this._leaving = true;
                mergeVNodeHook(oldData, 'afterLeave', function () {
                  this$1._leaving = false;
                  this$1.$forceUpdate();
                });
                return placeholder(h, rawChild);
              } else if (mode === 'in-out') {
                if (isAsyncPlaceholder(child)) {
                  return oldRawChild;
                }

                var delayedLeave;

                var performLeave = function performLeave() {
                  delayedLeave();
                };

                mergeVNodeHook(data, 'afterEnter', performLeave);
                mergeVNodeHook(data, 'enterCancelled', performLeave);
                mergeVNodeHook(oldData, 'delayLeave', function (leave) {
                  delayedLeave = leave;
                });
              }
            }

            return rawChild;
          }
          /*  */
          // Provides transition support for list items.
          // supports move transitions using the FLIP technique.
          // Because the vdom's children update algorithm is "unstable" - i.e.
          // it doesn't guarantee the relative positioning of removed elements,
          // we force transition-group to update its children into two passes:
          // in the first pass, we remove all nodes that need to be removed,
          // triggering their leaving transition; in the second pass, we insert/move
          // into the final desired state. This way in the second pass removed
          // nodes will remain where they should be.

        };
        var props = extend({
          tag: String,
          moveClass: String
        }, transitionProps);
        delete props.mode;
        var TransitionGroup = {
          props: props,
          render: function render(h) {
            var tag = this.tag || this.$vnode.data.tag || 'span';
            var map = Object.create(null);
            var prevChildren = this.prevChildren = this.children;
            var rawChildren = this.$slots.default || [];
            var children = this.children = [];
            var transitionData = extractTransitionData(this);

            for (var i = 0; i < rawChildren.length; i++) {
              var c = rawChildren[i];

              if (c.tag) {
                if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {
                  children.push(c);
                  map[c.key] = c;
                  (c.data || (c.data = {})).transition = transitionData;
                } else if (process.env.NODE_ENV !== 'production') {
                  var opts = c.componentOptions;
                  var name = opts ? opts.Ctor.options.name || opts.tag || '' : c.tag;
                  warn("<transition-group> children must be keyed: <" + name + ">");
                }
              }
            }

            if (prevChildren) {
              var kept = [];
              var removed = [];

              for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {
                var c$1 = prevChildren[i$1];
                c$1.data.transition = transitionData;
                c$1.data.pos = c$1.elm.getBoundingClientRect();

                if (map[c$1.key]) {
                  kept.push(c$1);
                } else {
                  removed.push(c$1);
                }
              }

              this.kept = h(tag, null, kept);
              this.removed = removed;
            }

            return h(tag, null, children);
          },
          beforeUpdate: function beforeUpdate() {
            // force removing pass
            this.__patch__(this._vnode, this.kept, false, // hydrating
            true // removeOnly (!important, avoids unnecessary moves)
            );

            this._vnode = this.kept;
          },
          updated: function updated() {
            var children = this.prevChildren;
            var moveClass = this.moveClass || (this.name || 'v') + '-move';

            if (!children.length || !this.hasMove(children[0].elm, moveClass)) {
              return;
            } // we divide the work into three loops to avoid mixing DOM reads and writes
            // in each iteration - which helps prevent layout thrashing.


            children.forEach(callPendingCbs);
            children.forEach(recordPosition);
            children.forEach(applyTranslation); // force reflow to put everything in position
            // assign to this to avoid being removed in tree-shaking
            // $flow-disable-line

            this._reflow = document.body.offsetHeight;
            children.forEach(function (c) {
              if (c.data.moved) {
                var el = c.elm;
                var s = el.style;
                addTransitionClass(el, moveClass);
                s.transform = s.WebkitTransform = s.transitionDuration = '';
                el.addEventListener(transitionEndEvent, el._moveCb = function cb(e) {
                  if (!e || /transform$/.test(e.propertyName)) {
                    el.removeEventListener(transitionEndEvent, cb);
                    el._moveCb = null;
                    removeTransitionClass(el, moveClass);
                  }
                });
              }
            });
          },
          methods: {
            hasMove: function hasMove(el, moveClass) {
              /* istanbul ignore if */
              if (!hasTransition) {
                return false;
              }
              /* istanbul ignore if */


              if (this._hasMove) {
                return this._hasMove;
              } // Detect whether an element with the move class applied has
              // CSS transitions. Since the element may be inside an entering
              // transition at this very moment, we make a clone of it and remove
              // all other transition classes applied to ensure only the move class
              // is applied.


              var clone = el.cloneNode();

              if (el._transitionClasses) {
                el._transitionClasses.forEach(function (cls) {
                  removeClass(clone, cls);
                });
              }

              addClass(clone, moveClass);
              clone.style.display = 'none';
              this.$el.appendChild(clone);
              var info = getTransitionInfo(clone);
              this.$el.removeChild(clone);
              return this._hasMove = info.hasTransform;
            }
          }
        };

        function callPendingCbs(c) {
          /* istanbul ignore if */
          if (c.elm._moveCb) {
            c.elm._moveCb();
          }
          /* istanbul ignore if */


          if (c.elm._enterCb) {
            c.elm._enterCb();
          }
        }

        function recordPosition(c) {
          c.data.newPos = c.elm.getBoundingClientRect();
        }

        function applyTranslation(c) {
          var oldPos = c.data.pos;
          var newPos = c.data.newPos;
          var dx = oldPos.left - newPos.left;
          var dy = oldPos.top - newPos.top;

          if (dx || dy) {
            c.data.moved = true;
            var s = c.elm.style;
            s.transform = s.WebkitTransform = "translate(" + dx + "px," + dy + "px)";
            s.transitionDuration = '0s';
          }
        }

        var platformComponents = {
          Transition: Transition,
          TransitionGroup: TransitionGroup
          /*  */
          // install platform specific utils

        };
        Vue.config.mustUseProp = mustUseProp;
        Vue.config.isReservedTag = isReservedTag;
        Vue.config.isReservedAttr = isReservedAttr;
        Vue.config.getTagNamespace = getTagNamespace;
        Vue.config.isUnknownElement = isUnknownElement; // install platform runtime directives & components

        extend(Vue.options.directives, platformDirectives);
        extend(Vue.options.components, platformComponents); // install platform patch function

        Vue.prototype.__patch__ = inBrowser ? patch : noop; // public mount method

        Vue.prototype.$mount = function (el, hydrating) {
          el = el && inBrowser ? query(el) : undefined;
          return mountComponent(this, el, hydrating);
        }; // devtools global hook

        /* istanbul ignore next */


        if (inBrowser) {
          setTimeout(function () {
            if (config.devtools) {
              if (devtools) {
                devtools.emit('init', Vue);
              } else if (process.env.NODE_ENV !== 'production' && process.env.NODE_ENV !== 'test' && isChrome) {
                console[console.info ? 'info' : 'log']('Download the Vue Devtools extension for a better development experience:\n' + 'https://github.com/vuejs/vue-devtools');
              }
            }

            if (process.env.NODE_ENV !== 'production' && process.env.NODE_ENV !== 'test' && config.productionTip !== false && typeof console !== 'undefined') {
              console[console.info ? 'info' : 'log']("You are running Vue in development mode.\n" + "Make sure to turn on production mode when deploying for production.\n" + "See more tips at https://vuejs.org/guide/deployment.html");
            }
          }, 0);
        }
        /*  */


        module.exports = Vue;
      }).call(this, require('_process'), typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, require("timers").setImmediate);
    }, {
      "_process": 62,
      "timers": 63
    }],
    66: [function (require, module, exports) {
      var inserted = exports.cache = {};

      function noop() {}

      exports.insert = function (css) {
        if (inserted[css]) return noop;
        inserted[css] = true;
        var elem = document.createElement('style');
        elem.setAttribute('type', 'text/css');

        if ('textContent' in elem) {
          elem.textContent = css;
        } else {
          elem.styleSheet.cssText = css;
        }

        document.getElementsByTagName('head')[0].appendChild(elem);
        return function () {
          document.getElementsByTagName('head')[0].removeChild(elem);
          inserted[css] = false;
        };
      };
    }, {}],
    67: [function (require, module, exports) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      exports.default = function (value, message) {
        if (value) {
          return true;
        } else {
          throw new Error(message);
        }
      };
    }, {}],
    68: [function (require, module, exports) {
      'use strict';

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _createClass = function () {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }

        return function (Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);
          if (staticProps) defineProperties(Constructor, staticProps);
          return Constructor;
        };
      }();

      var _clock = require('./clock');

      var _clock2 = _interopRequireDefault(_clock);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        };
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      function _possibleConstructorReturn(self, call) {
        if (!self) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }

        return call && (_typeof2(call) === "object" || typeof call === "function") ? call : self;
      }

      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function, not " + _typeof2(superClass));
        }

        subClass.prototype = Object.create(superClass && superClass.prototype, {
          constructor: {
            value: subClass,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
      }
      /**
       * **Usually you don't need to know about this class.**
       * Class that deals with time.
       * This is "frame" type clock, the frame increases every update call.
       * @extends Clock
       * @param {Automaton} _automaton Parent automaton object
       * @param {number} _fps Frames per second
       */


      var ClockFrame = function (_Clock) {
        _inherits(ClockFrame, _Clock);

        function ClockFrame(_automaton, _fps) {
          _classCallCheck(this, ClockFrame);

          var _this = _possibleConstructorReturn(this, (ClockFrame.__proto__ || Object.getPrototypeOf(ClockFrame)).call(this, _automaton));

          _this.frame = 0.0;
          _this.fps = _fps;
          return _this;
        }
        /**
         * Update the clock. It will increase the frame by 1.
         * @returns {void} void
         */


        _createClass(ClockFrame, [{
          key: 'update',
          value: function update() {
            if (this.isPlaying) {
              this.time = this.frame / this.fps;
              this.deltaTime = 1.0 / this.fps;
              this.frame++;
            } else {
              this.deltaTime = 0.0;
            }
          }
        }]);

        return ClockFrame;
      }(_clock2.default);

      exports.default = ClockFrame;
    }, {
      "./clock": 70
    }],
    69: [function (require, module, exports) {
      'use strict';

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _createClass = function () {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }

        return function (Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);
          if (staticProps) defineProperties(Constructor, staticProps);
          return Constructor;
        };
      }();

      var _clock = require('./clock');

      var _clock2 = _interopRequireDefault(_clock);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        };
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      function _possibleConstructorReturn(self, call) {
        if (!self) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }

        return call && (_typeof2(call) === "object" || typeof call === "function") ? call : self;
      }

      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function, not " + _typeof2(superClass));
        }

        subClass.prototype = Object.create(superClass && superClass.prototype, {
          constructor: {
            value: subClass,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
      }
      /**
       * **Usually you don't need to know about this class.**
       * Class that deals with time.
       * This is "realtime" type clock, the time goes on as real world.
       * @extends Clock
       * @param {Automaton} _automaton Parent automaton object
       */


      var ClockRealtime = function (_Clock) {
        _inherits(ClockRealtime, _Clock);

        function ClockRealtime(_automaton) {
          _classCallCheck(this, ClockRealtime);

          var _this = _possibleConstructorReturn(this, (ClockRealtime.__proto__ || Object.getPrototypeOf(ClockRealtime)).call(this, _automaton));

          _this.realtime = true;
          _this.rtTime = 0.0;
          _this.rtDate = +new Date();
          return _this;
        }
        /**
         * Update the clock. Time is calculated based on time in real world.
         * @returns {void} void
         */


        _createClass(ClockRealtime, [{
          key: 'update',
          value: function update() {
            if (this.isPlaying) {
              var prevTime = this.time;
              var now = Date.now();
              var deltaDate = now - this.rtDate;
              this.time = this.rtTime + deltaDate / 1000.0;
              this.deltaTime = this.time - prevTime;
            } else {
              this.rtTime = this.time;
              this.rtDate = +new Date();
              this.deltaTime = 0.0;
            }
          }
          /**
           * Set the time manually.
           * @param {number} _time Time
           * @returns {void} void
           */

        }, {
          key: 'setTime',
          value: function setTime(_time) {
            this.time = _time;
            this.rtTime = this.time;
            this.rtDate = +new Date();
          }
        }]);

        return ClockRealtime;
      }(_clock2.default);

      exports.default = ClockRealtime;
    }, {
      "./clock": 70
    }],
    70: [function (require, module, exports) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _createClass = function () {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }

        return function (Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);
          if (staticProps) defineProperties(Constructor, staticProps);
          return Constructor;
        };
      }();

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      /**
       * **Usually you don't need to know about this class.**
       * Class that deals with time.
       * In this base class, you need to set time manually from `Automaton.update()`.
       * Best for sync with external clock stuff.
       * @param {Automaton} _automaton Parent automaton object
       */


      var Clock = function () {
        function Clock(_automaton) {
          _classCallCheck(this, Clock);

          this.automaton = _automaton;
          this.time = 0.0;
          this.deltaTime = 0.0;
          this.isPlaying = true;
        }
        /**
         * Update the clock.
         * @param {number} _time Time. You need to set manually
         * @returns {void} void
         */


        _createClass(Clock, [{
          key: "update",
          value: function update(_time) {
            var prevTime = this.time;
            this.time = _time;
            this.deltaTime = this.time - prevTime;
          }
          /**
           * Start the clock.
           * @returns {void} void
           */

        }, {
          key: "play",
          value: function play() {
            this.isPlaying = true;
          }
          /**
           * Stop the clock.
           * @returns {void} void
           */

        }, {
          key: "pause",
          value: function pause() {
            this.isPlaying = false;
          }
          /**
           * Set the time manually.
           * @param {number} _time Time
           * @returns {void} void
           */

        }, {
          key: "setTime",
          value: function setTime(_time) {
            this.time = _time;
          }
        }]);

        return Clock;
      }();

      exports.default = Clock;
    }, {}],
    71: [function (require, module, exports) {
      'use strict';

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
        return _typeof2(obj);
      } : function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
      };

      var defaultData = {
        v: "2.0.1",
        length: 1.0,
        resolution: 1000.0,
        params: {},
        guiSettings: {
          snapActive: false,
          snapTime: 0.1,
          snapValue: 0.1
        }
      };

      var compat = function compat(_data) {
        if (!_data) {
          return Object.assign({}, defaultData);
        }

        var data = void 0;

        if ((typeof _data === 'undefined' ? 'undefined' : _typeof(_data)) === 'object') {
          data = _data;
        } else if (typeof _data === 'string') {
          try {
            data = JSON.parse(_data);
          } catch (e) {
            console.error('Loaded data is invalid');
            return Object.assign({}, defaultData);
          }
        } else {
          console.error('Loaded data is invalid');
          return Object.assign({}, defaultData);
        }

        var v = parseFloat(data.v);

        if (!v && !data.rev) {
          if (data.gui) {
            // "Shift" version of automaton, has incompatible gui params
            delete data.gui;
            data.gui = Object.assign({}, defaultData.gui);
          } else {
            // wtf is this
            console.error('Loaded data is not compatible with this revision');
            return Object.assign({}, defaultData);
          }
        }

        if (data.rev) {
          // fuck
          v = 1.0;
          delete data.rev;
        }

        if (v < 2.0) {
          var _loop = function _loop(name) {
            var oldParam = data.params[name];
            var newParam = {
              nodes: oldParam.map(function (node, i) {
                return {
                  time: node.time,
                  value: node.value,
                  in: i === 0 ? undefined : {
                    time: 0.0,
                    value: 0.0
                  },
                  out: i === oldParam.length - 1 ? undefined : {
                    time: 0.0,
                    value: 0.0
                  }
                };
              }),
              fxs: []
            };
            var head = 0;

            for (var i = 1; i < oldParam.length; i++) {
              head++;

              if (oldParam[i].mode === 0) {
                // hold
                newParam.nodes.splice(head, 0, {
                  time: oldParam[i].time,
                  value: oldParam[i - 1].value,
                  in: {
                    time: 0.0,
                    value: 0.0
                  },
                  out: {
                    time: 0.0,
                    value: 0.0
                  }
                });
                head++;
              } else if (oldParam[i].mode === 1) {// linear
                // do nothing
              } else if (oldParam[i].mode === 2) {
                // cosine
                var l = newParam.nodes[head].time - newParam.nodes[head - 1].time;
                newParam.nodes[head - 1].out = {
                  time: l * 0.37,
                  value: 0.0
                };
                newParam.nodes[head].in = {
                  time: -l * 0.37,
                  value: 0.0
                };
              } else {
                newParam.nodes.splice(head, 0, {
                  time: oldParam[i - 1].time,
                  value: oldParam[i].value,
                  in: {
                    time: 0.0,
                    value: 0.0
                  },
                  out: {
                    time: 0.0,
                    value: 0.0
                  }
                });
                head++;

                if (oldParam[i].mode === 3) {
                  // exp
                  newParam.fxs.push({
                    name: 'Exponential Smoothing',
                    bypass: false,
                    row: 0,
                    time: oldParam[i - 1].time - 1.0 / data.resolution,
                    // 🔥
                    length: oldParam[i].time - oldParam[i - 1].time,
                    params: {
                      factor: oldParam[i].params.factor,
                      preserve: true
                    }
                  });
                } else if (oldParam[i].mode === 4) {
                  // spring
                  newParam.fxs.push({
                    name: 'Critically Damped Spring',
                    bypass: false,
                    row: 0,
                    time: oldParam[i - 1].time - 1.0 / data.resolution,
                    // 🔥
                    length: oldParam[i].time - oldParam[i - 1].time,
                    params: {
                      factor: oldParam[i].params.rate,
                      ratio: oldParam[i].params.damp,
                      preserve: true
                    }
                  });
                } else if (oldParam[i].mode === 5) {
                  // gravity
                  newParam.fxs.push({
                    name: 'Gravity',
                    bypass: false,
                    row: 0,
                    time: oldParam[i - 1].time - 1.0 / data.resolution,
                    // 🔥
                    length: oldParam[i].time - oldParam[i - 1].time,
                    params: {
                      a: oldParam[i].params.gravity,
                      e: oldParam[i].params.bounce,
                      preserve: true
                    }
                  });
                }
              }

              if (oldParam[i].mods[1]) {
                newParam.fxs.push({
                  name: 'Sinewave',
                  bypass: false,
                  row: 1,
                  time: oldParam[i - 1].time,
                  length: oldParam[i].time - oldParam[i - 1].time,
                  params: {
                    freq: oldParam[i].mods[1].freq,
                    amp: oldParam[i].mods[1].amp,
                    phase: oldParam[i].mods[1].phase
                  }
                });
              }

              if (oldParam[i].mods[2]) {
                newParam.fxs.push({
                  name: 'Fractal Noise',
                  bypass: false,
                  row: 2,
                  time: oldParam[i - 1].time,
                  length: oldParam[i].time - oldParam[i - 1].time,
                  params: {
                    amp: oldParam[i].mods[2].amp,
                    recursion: oldParam[i].mods[2].recursion,
                    freq: oldParam[i].mods[2].freq,
                    reso: oldParam[i].mods[2].reso,
                    seed: oldParam[i].mods[2].seed
                  }
                });
              }

              if (oldParam[i].mods[3]) {
                newParam.fxs.push({
                  name: 'Lo-Fi',
                  bypass: false,
                  row: 3,
                  time: oldParam[i - 1].time,
                  length: oldParam[i].time - oldParam[i - 1].time,
                  params: {
                    resolution: oldParam[i].mods[3].freq,
                    relative: true
                  }
                });
              }
            }

            data.params[name] = newParam;
          }; // v1, modes and modifiers, CURSED


          for (var name in data.params) {
            _loop(name);
          }

          data.guiSettings = {
            snapActive: false,
            snapTime: 0.1,
            snapValue: 0.1
          };
        }

        data.v = "2.0.1";
        return data;
      };

      exports.default = compat;
    }, {}],
    72: [function (require, module, exports) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      }); // ref: https://github.com/gre/bezier-easing/blob/master/src/index.js

      var NEWTON_ITER = 4;
      var NEWTON_EPSILON = 0.001;
      var SUBDIV_ITER = 10;
      var SUBDIV_EPSILON = 0.000001;
      var TABLE_SIZE = 21;
      var tab = [];

      var A = function A(a1, a2) {
        return 1.0 - 3.0 * a2 + 3.0 * a1;
      };

      var B = function B(a1, a2) {
        return 3.0 * a2 - 6.0 * a1;
      };

      var C = function C(a1) {
        return 3.0 * a1;
      };

      var saturate = function saturate(x) {
        return Math.min(Math.max(x, 0.0), 1.0);
      };

      var calc = function calc(t, a1, a2) {
        return ((A(a1, a2) * t + B(a1, a2)) * t + C(a1)) * t;
      };

      var delta = function delta(t, a1, a2) {
        return 3.0 * A(a1, a2) * t * t + 2.0 * B(a1, a2) * t + C(a1);
      };

      var subdiv = function subdiv(x, a, b, x1, x2) {
        var cx = 0;
        var ct = 0;

        for (var i = 0; i < SUBDIV_ITER; i++) {
          ct = a + (b - a) / 2.0;
          cx = calc(ct, x1, x2) - x;
          0.0 < cx ? b = ct : a = ct;

          if (SUBDIV_EPSILON < Math.abs(cx)) {
            break;
          }
        }

        return ct;
      };

      var newton = function newton(x, gt, x1, x2) {
        for (var i = 0; i < NEWTON_ITER; i++) {
          var d = delta(gt, x1, x2);

          if (d === 0.0) {
            return gt;
          }

          var cx = calc(gt, x1, x2) - x;
          gt = gt - cx / d;
        }

        return gt;
      };

      var rawCubicBezier = function rawCubicBezier(x1, y1, x2, y2, x) {
        if (isNaN(x1) || isNaN(y1) || isNaN(x2) || isNaN(y2)) {
          return x;
        } // heh


        if (x1 === y1 && x2 === y2) {
          return x;
        } // linear


        if (x <= 0.0) {
          return 0.0;
        }

        if (1.0 <= x) {
          return 1.0;
        }

        x1 = saturate(x1);
        x2 = saturate(x2);

        for (var i = 0; i < TABLE_SIZE; i++) {
          tab[i] = calc(i / (TABLE_SIZE - 1.0), x1, x2);
        }

        var sample = 1;

        for (var _i = 1; _i < TABLE_SIZE; _i++) {
          sample = _i - 1;

          if (x < tab[_i]) {
            break;
          }
        }

        var dist = (x - tab[sample]) / (tab[sample + 1] - tab[sample]);
        var t = (sample + dist) / (TABLE_SIZE - 1);
        var d = delta(t, x1, x2);

        if (NEWTON_EPSILON <= d) {
          t = newton(x, t, x1, x2);
        } else if (d !== 0.0) {
          t = subdiv(x, sample / (TABLE_SIZE - 1), (sample + 1.0) / (TABLE_SIZE - 1), x1, x2);
        }

        return calc(t, y1, y2);
      };

      var cubicBezier = function cubicBezier(node0, node1, time) {
        var tL = node1.time - node0.time;
        var vL = node1.value - node0.value;
        var x1 = node0.out.time / tL;
        var y1 = node0.out.value / vL;
        var x2 = (node1.time + node1.in.time - node0.time) / tL;
        var y2 = (node1.value + node1.in.value - node0.value) / vL;
        var x = (time - node0.time) / tL;
        return node0.value + rawCubicBezier(x1, y1, x2, y2, x) * vL;
      };

      exports.default = cubicBezier;
    }, {}],
    73: [function (require, module, exports) {
      'use strict';

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = [require('./fxs/add').default, require('./fxs/cds').default, require('./fxs/clamp').default, require('./fxs/exp').default, require('./fxs/gravity').default, require('./fxs/lofi').default, require('./fxs/noise').default, require('./fxs/pow').default, require('./fxs/sine').default];
    }, {
      "./fxs/add": 74,
      "./fxs/cds": 75,
      "./fxs/clamp": 76,
      "./fxs/exp": 77,
      "./fxs/gravity": 78,
      "./fxs/lofi": 79,
      "./fxs/noise": 81,
      "./fxs/pow": 82,
      "./fxs/sine": 83
    }],
    74: [function (require, module, exports) {
      'use strict';

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = ['add', {
        name: 'Add',
        description: 'The simplest fx ever. Just add a constant value to the curve.',
        params: {
          value: {
            name: 'Value',
            type: 'float',
            default: 1.0
          }
        },
        func: function func(context) {
          return context.v + context.params.value;
        }
      }];
    }, {}],
    75: [function (require, module, exports) {
      'use strict';

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = ['cds', {
        name: 'Critically Damped Spring',
        description: 'Basically the best smoothing method. Shoutouts to Keijiro Takahashi',
        params: {
          factor: {
            name: 'Factor',
            type: 'float',
            default: 100.0,
            min: 0.0
          },
          ratio: {
            name: 'Damp Ratio',
            type: 'float',
            default: 1.0
          },
          preserve: {
            name: 'Preserve Velocity',
            type: 'boolean',
            default: false
          }
        },
        func: function func(context) {
          var dt = context.dt;
          var v = context.v;
          var k = context.params.factor;

          if (context.init) {
            context.pos = context.v;

            if (context.params.preserve) {
              var dv = v - context.getValue(context.t - dt);
              context.vel = dv / dt;
            } else {
              context.vel = 0.0;
            }
          }

          context.vel += (-k * (context.pos - v) - 2.0 * context.vel * Math.sqrt(k) * context.params.ratio) * dt;
          context.pos += context.vel * dt;
          return context.pos;
        }
      }];
    }, {}],
    76: [function (require, module, exports) {
      'use strict';

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var clamp = function clamp(x, a, b) {
        return Math.min(Math.max(x, a), b);
      };

      var smin = function smin(a, b, k) {
        var h = Math.max(k - Math.abs(a - b), 0.0);
        return Math.min(a, b) - h * h * h / (6.0 * k * k);
      };

      exports.default = ['clamp', {
        name: 'Clamp',
        description: 'Constrain the curve between two values, featuring smooth minimum.',
        params: {
          min: {
            name: 'Min',
            type: 'float',
            default: 0.0
          },
          max: {
            name: 'Max',
            type: 'float',
            default: 1.0
          },
          smooth: {
            name: 'Smooth',
            type: 'float',
            default: 0.0,
            min: 0.0
          }
        },
        func: function func(context) {
          if (context.params.smooth === 0.0) {
            return clamp(context.v, context.params.min, context.params.max);
          }

          var v = -smin(-context.params.min, -context.v, context.params.smooth);
          return smin(context.params.max, v, context.params.smooth);
        }
      }];
    }, {}],
    77: [function (require, module, exports) {
      'use strict';

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = ['exp', {
        name: 'Exponential Smoothing',
        description: 'Smooth the curve. Simple but good.',
        params: {
          factor: {
            name: 'Factor',
            type: 'float',
            default: 10.0,
            min: 0.0
          }
        },
        func: function func(context) {
          var v = context.v;

          if (context.init) {
            context.pos = v;
          }

          var k = Math.exp(-context.dt * context.params.factor);
          context.pos = context.pos * k + v * (1.0 - k);
          return context.pos;
        }
      }];
    }, {}],
    78: [function (require, module, exports) {
      'use strict';

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = ['gravity', {
        name: 'Gravity',
        description: 'Accelerate and bounce the curve.',
        params: {
          a: {
            name: 'Acceleration',
            type: 'float',
            default: 9.8
          },
          e: {
            name: 'Restitution',
            type: 'float',
            default: 0.5,
            min: 0.0
          },
          preserve: {
            name: 'Preserve Velocity',
            type: 'boolean',
            default: false
          }
        },
        func: function func(context) {
          var dt = context.dt;
          var v = context.v;

          if (context.init) {
            context.pos = v;

            if (context.params.preserve) {
              var dv = v - context.getValue(context.t - dt);
              context.vel = dv / dt;
            } else {
              context.vel = 0.0;
            }
          }

          var a = Math.sign(v - context.pos) * context.params.a;
          context.vel += a * dt;
          context.pos += context.vel * dt;

          if (Math.sign(a) !== Math.sign(v - context.pos)) {
            context.vel *= -context.params.e;
            context.pos = v + context.params.e * (v - context.pos);
          }

          return context.pos;
        }
      }];
    }, {}],
    79: [function (require, module, exports) {
      'use strict';

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = ['lofi', {
        name: 'Lo-Fi',
        description: 'Make curve more crunchy.',
        params: {
          rate: {
            name: 'Frame Rate',
            type: 'float',
            default: 10.0,
            min: 0.0,
            max: 1000.0
          },
          relative: {
            name: 'Relative',
            type: 'boolean',
            default: false
          },
          reso: {
            name: 'Reso Per Unit',
            type: 'float',
            default: 0.1,
            min: 0.0,
            max: 1000.0
          },
          round: {
            name: 'Round',
            type: 'boolean',
            default: false
          }
        },
        func: function func(context) {
          var t = void 0;

          if (context.params.rate === 0.0) {
            t = context.t;
          } else if (context.params.relative) {
            t = context.t0 + Math.floor((context.t - context.t0) * context.params.rate) / context.params.rate;
          } else {
            t = Math.floor(context.t * context.params.rate) / context.params.rate;
          }

          var v = context.getValue(t);

          if (context.params.reso !== 0.0) {
            v = Math.floor(v * context.params.reso + (context.params.round ? 0.5 : 0.0)) / context.params.reso;
          }

          return v;
        }
      }];
    }, {}],
    80: [function (require, module, exports) {
      "use strict";

      var _createClass = function () {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }

        return function (Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);
          if (staticProps) defineProperties(Constructor, staticProps);
          return Constructor;
        };
      }();

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      var Xorshift = function () {
        function Xorshift(_seed) {
          _classCallCheck(this, Xorshift);

          this.set(_seed);
        }

        _createClass(Xorshift, [{
          key: "gen",
          value: function gen(_seed) {
            if (_seed) {
              this.set(_seed);
            }

            this.seed = this.seed ^ this.seed << 13;
            this.seed = this.seed ^ this.seed >>> 17;
            this.seed = this.seed ^ this.seed << 5;
            return this.seed / Math.pow(2, 32) + 0.5;
          }
        }, {
          key: "set",
          value: function set(_seed) {
            this.seed = _seed || this.seed || 1;
          }
        }]);

        return Xorshift;
      }();

      module.exports = Xorshift;
    }, {}],
    81: [function (require, module, exports) {
      'use strict';

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _xorshift = require('./modules/xorshift');

      var _xorshift2 = _interopRequireDefault(_xorshift);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        };
      }

      var xorshift = new _xorshift2.default();

      var smoothstep = function smoothstep(_a, _b, _k) {
        var smooth = _k * _k * (3.0 - 2.0 * _k);
        return _a + (_b - _a) * smooth;
      };

      exports.default = ['noise', {
        name: 'Fractal Noise',
        description: 'wiggle()',
        params: {
          recursion: {
            name: 'Recursion',
            type: 'int',
            default: 4,
            min: 1,
            max: 99
          },
          freq: {
            name: 'Frequency',
            type: 'float',
            default: 1.0,
            min: 0.0
          },
          reso: {
            name: 'Resolution',
            type: 'float',
            default: 8.0,
            min: 1.0
          },
          seed: {
            name: 'Seed',
            type: 'int',
            default: 1,
            min: 0
          },
          amp: {
            name: 'Amp',
            type: 'float',
            default: 0.2
          }
        },
        func: function func(context) {
          if (context.init) {
            xorshift.gen(context.params.seed);
            context.table = new Float32Array(Math.floor(context.params.reso) + 2);

            for (var i = 1; i < context.params.reso; i++) {
              context.table[i] = xorshift.gen() * 2.0 - 1.0;
            }
          }

          var v = context.v;
          var p = context.progress;

          for (var _i = 0; _i < context.params.recursion; _i++) {
            var index = p * context.params.freq * context.params.reso * Math.pow(2.0, _i) % context.params.reso;
            var indexi = Math.floor(index);
            var indexf = index - indexi;
            var factor = Math.pow(0.5, _i + 1.0);
            v += context.params.amp * factor * smoothstep(context.table[indexi], context.table[indexi + 1], indexf);
          }

          return v;
        }
      }];
    }, {
      "./modules/xorshift": 80
    }],
    82: [function (require, module, exports) {
      'use strict';

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = ['pow', {
        name: 'Power',
        description: 'You got boost power!',
        params: {
          pow: {
            name: 'Power',
            type: 'float',
            default: 2.0
          },
          bias: {
            name: 'Bias',
            type: 'float',
            default: 0.0
          },
          positive: {
            name: 'Force Positive',
            type: 'boolean',
            default: false
          }
        },
        func: function func(context) {
          var v = context.v - context.params.bias;
          var sign = context.params.positive ? 1.0 : Math.sign(v);
          return Math.pow(Math.abs(v), context.params.pow) * sign + context.params.bias;
        }
      }];
    }, {}],
    83: [function (require, module, exports) {
      'use strict';

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      var TAU = Math.PI * 2.0;
      exports.default = ['sine', {
        name: 'Sinewave',
        description: 'Overlay a sinewave to the curve.',
        params: {
          amp: {
            name: 'Amp',
            type: 'float',
            default: 0.1
          },
          freq: {
            name: 'Frequency',
            type: 'float',
            default: 5.0
          },
          phase: {
            name: 'Phase',
            type: 'float',
            default: 0.0,
            min: 0.0,
            max: 1.0
          }
        },
        func: function func(context) {
          var v = context.v;
          var p = context.progress * context.params.freq + context.params.phase;
          return v + context.params.amp * Math.sin(p * TAU);
        }
      }];
    }, {}],
    84: [function (require, module, exports) {
      'use strict';

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      exports.default = function () {
        var ret = '';

        for (var i = 0; i < 16; i++) {
          ret += Math.floor(16.0 * Math.random()).toString(16);
        }

        return ret;
      };
    }, {}],
    85: [function (require, module, exports) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var hasOverwrap = function hasOverwrap(t1, l1, t2, l2) {
        if (l2 < l1) {
          return hasOverwrap(t2, l2, t1, l1);
        }

        return t2 < t1 && t1 < t2 + l2 || t2 < t1 + l1 && t1 + l1 < t2 + l2;
      };

      exports.default = hasOverwrap;
    }, {}],
    86: [function (require, module, exports) {
      module.exports = "data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8' standalone='no'%3F%3E %3C!DOCTYPE svg PUBLIC '-//W3C//DTD SVG 1.1//EN' 'http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd'%3E %3Csvg width='100%25' height='100%25' viewBox='0 0 128 128' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' xml:space='preserve' xmlns:serif='http://www.serif.com/' style='fill-rule:evenodd%3Bclip-rule:evenodd%3Bstroke-linejoin:round%3Bstroke-miterlimit:1.41421%3B'%3E     %3Cpath d='M64%2C55.537L105.023%2C14.513L113.487%2C22.977L72.463%2C64L113.487%2C105.023L105.023%2C113.487L64%2C72.463L22.977%2C113.487L14.513%2C105.023L55.537%2C64L14.513%2C22.977L22.977%2C14.513L64%2C55.537Z' style='fill:rgb(201%2C226%2C255)%3B'/%3E %3C/svg%3E";
    }, {}],
    87: [function (require, module, exports) {
      module.exports = "data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8' standalone='no'%3F%3E %3C!DOCTYPE svg PUBLIC '-//W3C//DTD SVG 1.1//EN' 'http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd'%3E %3Csvg width='100%25' height='100%25' viewBox='0 0 64 64' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' xml:space='preserve' xmlns:serif='http://www.serif.com/' style='fill-rule:evenodd%3Bclip-rule:evenodd%3Bstroke-linejoin:round%3Bstroke-miterlimit:1.41421%3B'%3E     %3Cg id='a' transform='matrix(1.10297%2C0%2C0%2C1.10297%2C-22.0454%2C-38.5886)'%3E         %3Cpath d='M44.397%2C47.274C42.928%2C45.991 42%2C44.104 42%2C42L42%2C41.998C42%2C38.133 45.133%2C35 48.998%2C35L49.002%2C35C52.867%2C35 56%2C38.133 56%2C41.998L56%2C42C56%2C44.113 55.063%2C46.008 53.583%2C47.292L68.047%2C79.064C68.358%2C79.022 68.676%2C79 68.998%2C79L69.002%2C79C72.867%2C79 76%2C82.133 76%2C85.998L76%2C86C76%2C89.866 72.866%2C93 69%2C93L69%2C93C65.134%2C93 62%2C89.866 62%2C86L62%2C85.998C62%2C83.891 62.931%2C82.001 64.405%2C80.718L49.937%2C48.938C49.631%2C48.979 49.318%2C49 49%2C49L49%2C49C48.673%2C49 48.351%2C48.978 48.036%2C48.934L33.591%2C80.715C35.067%2C81.998 36%2C83.889 36%2C85.998L36%2C86C36%2C89.866 32.866%2C93 29%2C93L29%2C93C25.134%2C93 22%2C89.866 22%2C86L22%2C85.998C22%2C82.133 25.133%2C79 28.998%2C79L29.002%2C79C29.323%2C79 29.639%2C79.022 29.948%2C79.064L44.397%2C47.274ZM29%2C89C30.657%2C89 32%2C87.657 32%2C86L32%2C86C32%2C84.343 30.657%2C83 29%2C83L29%2C83C27.343%2C83 26%2C84.343 26%2C86L26%2C86C26%2C87.657 27.343%2C89 29%2C89L29%2C89ZM69%2C89C70.657%2C89 72%2C87.657 72%2C86L72%2C86C72%2C84.343 70.657%2C83 69%2C83L69%2C83C67.343%2C83 66%2C84.343 66%2C86L66%2C86C66%2C87.657 67.343%2C89 69%2C89L69%2C89ZM49%2C45C50.657%2C45 52%2C43.657 52%2C42L52%2C42C52%2C40.343 50.657%2C39 49%2C39L49%2C39C47.343%2C39 46%2C40.343 46%2C42L46%2C42C46%2C43.657 47.343%2C45 49%2C45L49%2C45Z' style='fill:rgb(201%2C226%2C255)%3B'/%3E     %3C/g%3E %3C/svg%3E";
    }, {}],
    88: [function (require, module, exports) {
      module.exports = "data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8' standalone='no'%3F%3E %3C!DOCTYPE svg PUBLIC '-//W3C//DTD SVG 1.1//EN' 'http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd'%3E %3Csvg width='100%25' height='100%25' viewBox='0 0 720 64' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' xml:space='preserve' xmlns:serif='http://www.serif.com/' style='fill-rule:evenodd%3Bclip-rule:evenodd%3Bstroke-linejoin:round%3Bstroke-miterlimit:1.41421%3B'%3E     %3Cg transform='matrix(1.10297%2C0%2C0%2C1.10297%2C78.1502%2C-38.5886)'%3E         %3Cg id='a' transform='matrix(1%2C0%2C0%2C1%2C-92.3303%2C0)'%3E             %3Cpath d='M44.397%2C47.274C42.928%2C45.991 42%2C44.104 42%2C42L42%2C41.998C42%2C38.133 45.133%2C35 48.998%2C35L49.002%2C35C52.867%2C35 56%2C38.133 56%2C41.998L56%2C42C56%2C44.113 55.063%2C46.008 53.583%2C47.292L68.047%2C79.064C68.358%2C79.022 68.676%2C79 68.998%2C79L69.002%2C79C72.867%2C79 76%2C82.133 76%2C85.998L76%2C86C76%2C89.866 72.866%2C93 69%2C93L69%2C93C65.134%2C93 62%2C89.866 62%2C86L62%2C85.998C62%2C83.891 62.931%2C82.001 64.405%2C80.718L49.937%2C48.938C49.631%2C48.979 49.318%2C49 49%2C49L49%2C49C48.673%2C49 48.351%2C48.978 48.036%2C48.934L33.591%2C80.715C35.067%2C81.998 36%2C83.889 36%2C85.998L36%2C86C36%2C89.866 32.866%2C93 29%2C93L29%2C93C25.134%2C93 22%2C89.866 22%2C86L22%2C85.998C22%2C82.133 25.133%2C79 28.998%2C79L29.002%2C79C29.323%2C79 29.639%2C79.022 29.948%2C79.064L44.397%2C47.274ZM29%2C89C30.657%2C89 32%2C87.657 32%2C86L32%2C86C32%2C84.343 30.657%2C83 29%2C83L29%2C83C27.343%2C83 26%2C84.343 26%2C86L26%2C86C26%2C87.657 27.343%2C89 29%2C89L29%2C89ZM69%2C89C70.657%2C89 72%2C87.657 72%2C86L72%2C86C72%2C84.343 70.657%2C83 69%2C83L69%2C83C67.343%2C83 66%2C84.343 66%2C86L66%2C86C66%2C87.657 67.343%2C89 69%2C89L69%2C89ZM49%2C45C50.657%2C45 52%2C43.657 52%2C42L52%2C42C52%2C40.343 50.657%2C39 49%2C39L49%2C39C47.343%2C39 46%2C40.343 46%2C42L46%2C42C46%2C43.657 47.343%2C45 49%2C45L49%2C45Z' style='fill:rgb(201%2C226%2C255)%3B'/%3E         %3C/g%3E         %3Cg id='u' transform='matrix(1%2C0%2C0%2C1%2C-69.252%2C0)'%3E             %3Cpath d='M78%2C35L82%2C35L82%2C73C82%2C81.836 89.154%2C89 98%2C89C106.827%2C89 114%2C81.712 114%2C73L114%2C34.975L118%2C35L118%2C73C118%2C84.046 109%2C93 97.99%2C93C86.945%2C93 78%2C84.046 78%2C73L78%2C35Z' style='fill:rgb(201%2C226%2C255)%3B'/%3E         %3C/g%3E         %3Cg id='t' transform='matrix(1%2C0%2C0%2C1%2C-46.171%2C0)'%3E             %3Cpath d='M125%2C35L167%2C35L167%2C39.032L148%2C39.032L148%2C93L144%2C93L144%2C39.032L125%2C39.032L125%2C35Z' style='fill:rgb(201%2C226%2C255)%3Bfill-rule:nonzero%3B'/%3E         %3C/g%3E         %3Cg id='o' transform='matrix(1%2C0%2C0%2C1%2C-23.1034%2C0)'%3E             %3Cpath d='M228%2C63.986C228%2C56.298 224.946%2C48.926 219.51%2C43.49C214.074%2C38.054 206.702%2C35 199.014%2C35C199.005%2C35 199%2C35 199%2C35C199%2C35 199%2C35 198.999%2C35C191.31%2C34.993 183.934%2C38.043 178.495%2C43.477C173.056%2C48.912 170%2C56.285 170%2C63.974L170%2C64C170%2C71.691 173.055%2C79.068 178.494%2C84.506C183.932%2C89.945 191.309%2C93 199%2C93L199%2C93C206.691%2C93 214.068%2C89.945 219.506%2C84.506C224.945%2C79.068 228%2C71.691 228%2C64C228%2C63.992 228%2C63.987 228%2C63.987C228%2C63.987 228%2C63.987 228%2C63.986ZM223.977%2C63.986C223.977%2C50.198 212.8%2C39.022 199.013%2C39.022C199.004%2C39.022 199%2C39.022 199%2C39.022C199%2C39.022 199%2C39.022 198.999%2C39.022C192.377%2C39.016 186.024%2C41.642 181.34%2C46.323C176.655%2C51.003 174.023%2C57.354 174.023%2C63.976L174.023%2C63.999C174.023%2C70.623 176.655%2C76.976 181.339%2C81.66C186.023%2C86.343 192.375%2C88.975 198.999%2C88.975L199.001%2C88.975C205.625%2C88.975 211.977%2C86.343 216.661%2C81.66C221.345%2C76.976 223.977%2C70.623 223.977%2C63.999C223.977%2C63.991 223.977%2C63.987 223.977%2C63.987C223.977%2C63.987 223.977%2C63.987 223.977%2C63.986Z' style='fill:rgb(201%2C226%2C255)%3B'/%3E         %3C/g%3E         %3Cpath id='m' d='M285%2C93L281%2C93L281%2C42.284L261.606%2C72.99L258.402%2C73.005L239%2C42.324L239%2C93L235%2C93L235%2C35L239.102%2C35L259.998%2C68.045L280.869%2C35L285%2C35C285%2C54.333 285%2C73.667 285%2C93Z' style='fill:rgb(201%2C226%2C255)%3Bfill-rule:nonzero%3B'/%3E         %3Cg id='a2' transform='matrix(1%2C0%2C0%2C1%2C20.0558%2C32)'%3E             %3Cpath d='M346.8%2C61L342.445%2C61L335.557%2C45L308.865%2C45L310.587%2C41L333.835%2C41L320.017%2C8.899L297.622%2C61L293.268%2C61L318.198%2C3L321.832%2C3L346.8%2C61Z' style='fill:rgb(201%2C226%2C255)%3B'/%3E         %3C/g%3E         %3Cg id='t2' transform='matrix(1%2C0%2C0%2C1%2C259.187%2C0)'%3E             %3Cpath d='M125%2C35L167%2C35L167%2C39.032L148%2C39.032L148%2C93L144%2C93L144%2C39.032L125%2C39.032L125%2C35Z' style='fill:rgb(201%2C226%2C255)%3Bfill-rule:nonzero%3B'/%3E         %3C/g%3E         %3Cg id='o2' transform='matrix(1%2C0%2C0%2C1%2C281.257%2C1.16685e-05)'%3E             %3Cpath d='M228%2C63.986C228%2C56.298 224.946%2C48.926 219.51%2C43.49C214.074%2C38.054 206.702%2C35 199.014%2C35C199.005%2C35 199%2C35 199%2C35C199%2C35 199%2C35 198.999%2C35C191.31%2C34.993 183.934%2C38.043 178.495%2C43.477C173.056%2C48.912 170%2C56.285 170%2C63.974L170%2C64C170%2C71.691 173.055%2C79.068 178.494%2C84.506C183.932%2C89.945 191.309%2C93 199%2C93L199%2C93C206.691%2C93 214.068%2C89.945 219.506%2C84.506C224.945%2C79.068 228%2C71.691 228%2C64C228%2C63.992 228%2C63.987 228%2C63.987C228%2C63.987 228%2C63.987 228%2C63.986ZM223.977%2C63.986C223.977%2C50.198 212.8%2C39.022 199.013%2C39.022C199.004%2C39.022 199%2C39.022 199%2C39.022C199%2C39.022 199%2C39.022 198.999%2C39.022C192.377%2C39.016 186.024%2C41.642 181.34%2C46.323C176.655%2C51.003 174.023%2C57.354 174.023%2C63.976L174.023%2C63.999C174.023%2C70.623 176.655%2C76.976 181.339%2C81.66C186.023%2C86.343 192.375%2C88.975 198.999%2C88.975L199.001%2C88.975C205.625%2C88.975 211.977%2C86.343 216.661%2C81.66C221.345%2C76.976 223.977%2C70.623 223.977%2C63.999C223.977%2C63.991 223.977%2C63.987 223.977%2C63.987C223.977%2C63.987 223.977%2C63.987 223.977%2C63.986Z' style='fill:rgb(201%2C226%2C255)%3B'/%3E         %3C/g%3E         %3Cg id='n' transform='matrix(1%2C0%2C0%2C1%2C92.4061%2C0)'%3E             %3Cpath d='M484.93%2C93L451.002%2C42.108L450.998%2C93L446.998%2C93L447.002%2C35L451.07%2C35L485%2C85.894L485%2C35L489%2C35L489%2C93C487.643%2C93 486.286%2C93 484.93%2C93Z' style='fill:rgb(201%2C226%2C255)%3Bfill-rule:nonzero%3B'/%3E         %3C/g%3E     %3C/g%3E %3C/svg%3E";
    }, {}],
    89: [function (require, module, exports) {
      module.exports = "data:image/svg+xml,%3Csvg   xmlns='http://www.w3.org/2000/svg'   viewBox='0 0 100 100'   width='256'   height='256'   font-family='Helvetica Neue'   font-weight='300' %3E   %3Cpath     fill='%232af'     d='       M 92 45       L 92 55       L 78 61       L 74 68       L 76 83       L 66 89       L 54 80       L 46 80       L 34 89       L 24 83       L 26 68       L 22 61       L 8 55       L 8 45       L 22 39       L 26 32       L 24 17       L 34 11       L 46 20       L 54 20       L 66 11       L 76 17       L 74 32       L 78 39       z       M 50 50       m 0 -12       a 12 12 0 0 0 0 24       a 12 12 0 0 0 0 -24       z     '   /%3E %3C/svg%3E";
    }, {}],
    90: [function (require, module, exports) {
      module.exports = "data:image/svg+xml,%3Csvg   xmlns='http://www.w3.org/2000/svg'   viewBox='0 0 80 80'   width='256'   height='256'   font-family='Helvetica Neue'   font-weight='300' %3E   %3Cpath     fill='%232af'     d='       M 18 65       L 33 65       L 33 15       L 18 15       z       M 47 65       L 62 65       L 62 15       L 47 15       z     '   /%3E %3C/svg%3E";
    }, {}],
    91: [function (require, module, exports) {
      module.exports = "data:image/svg+xml,%3Csvg   xmlns='http://www.w3.org/2000/svg'   viewBox='0 0 80 80'   width='256'   height='256'   font-family='Helvetica Neue'   font-weight='300' %3E   %3Cpath     fill='%232af'     d='       M 15 70       L 65 40       L 15 10       z     '   /%3E %3C/svg%3E";
    }, {}],
    92: [function (require, module, exports) {
      module.exports = "data:image/svg+xml,%3Csvg   xmlns='http://www.w3.org/2000/svg'   viewBox='0 0 80 80'   width='256'   height='256'   font-family='Helvetica Neue'   font-weight='300' %3E   %3Cpath     fill='%232af'     d='       M 10 65       L 10 30       L 20 20       L 50 20       L 50 10       L 70 30       L 50 50       L 50 40       L 30 40       L 30 65       z     '   /%3E %3C/svg%3E";
    }, {}],
    93: [function (require, module, exports) {
      module.exports = "data:image/svg+xml,%3Csvg   xmlns='http://www.w3.org/2000/svg'   viewBox='0 0 80 80'   width='256'   height='256'   font-family='Helvetica Neue'   font-weight='300' %3E   %3Cpath     fill='%232af'     d='       M 10 10       L 10 70       L 70 70       L 70 20       L 60 10       z       M 20 40       L 60 40       L 60 65       L 20 65       z       M 54 13       L 54 32       L 25 32       L 25 13       z       M 42 15       L 50 15       L 50 30       L 42 30       z     '   /%3E %3C/svg%3E";
    }, {}],
    94: [function (require, module, exports) {
      module.exports = "data:image/svg+xml,%3Csvg   xmlns='http://www.w3.org/2000/svg'   viewBox='0 0 80 80'   width='256'   height='256'   font-family='Helvetica Neue'   font-weight='300' %3E   %3Cpath     fill='%232af'     d='       M 10 60       L 10 70       L 30 70       L 30 60       z              M 50 60       L 50 70       L 70 70       L 70 60       z       M 10 55       L 10 40       A 30 30 0 0 1 70 40       L 70 55       L 50 55       L 50 40       A 10 10 0 0 0 30 40       L 30 55       z     '   /%3E %3C/svg%3E";
    }, {}],
    95: [function (require, module, exports) {
      module.exports = "data:image/svg+xml,%3Csvg   xmlns='http://www.w3.org/2000/svg'   viewBox='0 0 80 80'   width='256'   height='256'   font-family='Helvetica Neue'   font-weight='300' %3E   %3Cpath     fill='%232af'     d='       M 70 65       L 70 30       L 60 20       L 30 20       L 30 10       L 10 30       L 30 50       L 30 40       L 50 40       L 50 65       z     '   /%3E %3C/svg%3E";
    }, {}],
    96: [function (require, module, exports) {
      module.exports = "data:image/svg+xml,%3Csvg   xmlns='http://www.w3.org/2000/svg'   viewBox='0 0 100 100'   width='256'   height='256'   font-family='Helvetica Neue'   font-weight='300' %3E   %3Cpath     fill='none'     stroke='%23222'     stroke-width='20'     stroke-linecap='round'     stroke-linejoin='round'      d='       M 50 50       m -6 -32       l 12 0       l 30 50       l -8 12       l -56 0       l -8 -12       l 30 -50       z     '   /%3E   %3Cpath     fill='%23f92'     stroke='%23f92'     stroke-width='5'     stroke-linecap='round'     stroke-linejoin='round'      d='       M 50 50       m -6 -32       l 12 0       l 30 50       l -8 12       l -56 0       l -8 -12       l 30 -50       z     '   /%3E   %3Cpath     fill='%23222'     stroke='%23222'     stroke-width='5'     stroke-linecap='round'     stroke-linejoin='round'      d='       M 50 30       m -6 0       l 12 0       l 0 27       l -12 0       z       M 50 66       m -6 0       l 12 0       l 0 8       l -12 0       z     '   /%3E %3C/svg%3E";
    }, {}],
    97: [function (require, module, exports) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      exports.default = function (data) {
        return JSON.parse(JSON.stringify(data));
      };
    }, {}],
    98: [function (require, module, exports) {
      'use strict';

      var _createClass = function () {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }

        return function (Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);
          if (staticProps) defineProperties(Constructor, staticProps);
          return Constructor;
        };
      }();

      var _get = function get(object, property, receiver) {
        if (object === null) object = Function.prototype;
        var desc = Object.getOwnPropertyDescriptor(object, property);

        if (desc === undefined) {
          var parent = Object.getPrototypeOf(object);

          if (parent === null) {
            return undefined;
          } else {
            return get(parent, property, receiver);
          }
        } else if ("value" in desc) {
          return desc.value;
        } else {
          var getter = desc.get;

          if (getter === undefined) {
            return undefined;
          }

          return getter.call(receiver);
        }
      };

      var _ass = require('./ass');

      var _ass2 = _interopRequireDefault(_ass);

      var _compat = require('./compat');

      var _compat2 = _interopRequireDefault(_compat);

      var _jsonCopy = require('./json-copy');

      var _jsonCopy2 = _interopRequireDefault(_jsonCopy);

      var _paramGui = require('./param-gui');

      var _paramGui2 = _interopRequireDefault(_paramGui);

      var _main = require('./main');

      var _main2 = _interopRequireDefault(_main);

      var _fxDefinitions = require('./fx-definitions');

      var _fxDefinitions2 = _interopRequireDefault(_fxDefinitions);

      var _vue = require('vue');

      var _vue2 = _interopRequireDefault(_vue);

      var _main3 = require('./vue/main.vue');

      var _main4 = _interopRequireDefault(_main3);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        };
      }

      function _toConsumableArray(arr) {
        if (Array.isArray(arr)) {
          for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
            arr2[i] = arr[i];
          }

          return arr2;
        } else {
          return Array.from(arr);
        }
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      function _possibleConstructorReturn(self, call) {
        if (!self) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }

        return call && (_typeof2(call) === "object" || typeof call === "function") ? call : self;
      }

      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function, not " + _typeof2(superClass));
        }

        subClass.prototype = Object.create(superClass && superClass.prototype, {
          constructor: {
            value: subClass,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
      }
      /**
       * IT'S AUTOMATON!
       * It's `automaton.js` and `automaton.min.js` version.
       * Since GUI stuff is pretty big for intro heh
       * @extends Automaton
       * @param {Object} [_props]
       * @param {boolean} [_props.loop] Whether let the time loop or not
       * @param {number} [_props.fps] If this is set, the clock will become frame mode
       * @param {boolean} [_props.realtime] If this is true, the clock will become realtime mode
       * @param {DOM} [_props.gui] DOM element where you want to attach the Automaton GUI
       * @param {string|Object} [_props.data] Data of the automaton. Don't worry, I can generate an initial data for you!
       */


      var AutomatonWithGUI = function (_Automaton) {
        _inherits(AutomatonWithGUI, _Automaton);

        function AutomatonWithGUI(_props) {
          _classCallCheck(this, AutomatonWithGUI);

          var props = Object.assign({}, _props);
          (0, _ass2.default)(!_props.onseek, 'The handler "onseek" is no longer supported. Use Automaton.on( "seek", ... ) instead.');
          (0, _ass2.default)(!_props.onplay, 'The handler "onplay" is no longer supported. Use Automaton.on( "play", ... ) instead.');
          (0, _ass2.default)(!_props.onpause, 'The handler "onpause" is no longer supported. Use Automaton.on( "pause", ... ) instead.');
          /**
           * History stack.
           * Will be managed from {@link AutomatonWithGUI#pushHistory|pushHistory()}, navigated from {@link AutomatonWithGUI#undo|undo()} and {@link AutomatonWithGUI#redo|redo()}.
           * @type {Object[]}
           * @protected
           */

          var _this = _possibleConstructorReturn(this, (AutomatonWithGUI.__proto__ || Object.getPrototypeOf(AutomatonWithGUI)).call(this, props));

          _this.__history = [];
          /**
           * Current position of history stack.
           * @type {number}
           * @protected
           */

          _this.__historyIndex = 0;

          _fxDefinitions2.default.map(function (fxDef) {
            _this.addFxDefinition.apply(_this, _toConsumableArray(fxDef));
          });

          if (_props.gui) {
            _this.__prepareGUI(_props.gui);
          }

          window.addEventListener('beforeunload', function (event) {
            if (_this.__historyIndex !== 0) {
              var confirmationMessage = 'Automaton: Did you saved your progress?';
              event.returnValue = confirmationMessage;
              return confirmationMessage;
            }
          });
          return _this;
        }
        /**
         * Prepare GUI.
         * @param {DOM} _target DOM element where you want to attach the Automaton GUI
         * @returns {void} void
         * @protected
         */


        _createClass(AutomatonWithGUI, [{
          key: '__prepareGUI',
          value: function __prepareGUI(_target) {
            var el = document.createElement('div');

            _target.appendChild(el);
            /**
             * Vue instance that manages automaton gui.
             * @type {Vue}
             */


            this.__vue = new _vue2.default({
              el: el,
              data: {
                automaton: this
              },
              render: function render(createElement) {
                return createElement(_main4.default, {
                  props: {
                    automaton: this.automaton
                  }
                });
              }
            });
          }
          /**
           * Generate default fx params object.
           * @param {string} _id Id of the fx
           * @returns {Object} Default fx params object
           */

        }, {
          key: 'generateDefaultFxParams',
          value: function generateDefaultFxParams(_id) {
            var fxDef = this.__paramFxDefs[_id];

            if (!fxDef) {
              throw new Error('Fx definition called ' + _id + ' is not defined');
            }

            var ret = {};

            for (var key in fxDef.params) {
              ret[key] = fxDef.params[key].default;
            }

            return ret;
          }
          /**
           * Toggle play / pause.
           * @returns {void} void
           */

        }, {
          key: 'togglePlay',
          value: function togglePlay() {
            if (this.isPlaying) {
              this.pause();
            } else {
              this.play();
            }
          }
          /**
           * Put some operation into the history stack.
           * Since it should accessible from GUI this function is public, basically `-- DON'T TOUCH IT KIDDO --`
           * @param {string} _desc Description of the operation
           * @param {function} _do Operation
           * @param {function} _undo Operation that undoes the `_do`
           * @param {boolean} [_execute=false] _do will be executed instantly if true
           * @returns {any} any if `_execute` is true, void otherwise
           */

        }, {
          key: 'pushHistory',
          value: function pushHistory(_desc, _do, _undo, _execute) {
            this.__history.splice(this.__historyIndex);

            this.__history.push({
              desc: _desc,
              do: _do,
              undo: _undo
            });

            this.__historyIndex++;

            if (_execute || false) {
              return _do();
            }
          }
          /**
           * Undo the operation based on history stack.
           * Can be performed via GUI.
           * @returns {any} Result of _undo
           */

        }, {
          key: 'undo',
          value: function undo() {
            if (this.__historyIndex <= 0) {
              return;
            }

            this.__historyIndex--;
            return this.__history[this.__historyIndex].undo();
          }
          /**
           * Redo the operation based on history stack.
           * Can be performed via GUI.
           * @returns {any} Result of _do
           */

        }, {
          key: 'redo',
          value: function redo() {
            if (this.__history.length <= this.__historyIndex) {
              return;
            }

            this.__historyIndex++;
            return this.__history[this.__historyIndex - 1].do();
          }
          /**
           * Return description of latest operation.
           * If there are no operation before the current state, it will return empty string instead.
           * @returns {string} Description of operation
           */

        }, {
          key: 'getUndoDesc',
          value: function getUndoDesc() {
            return this.__history[this.__historyIndex - 1] ? this.__history[this.__historyIndex - 1].desc : '';
          }
          /**
           * Return description of recently undo-ed operation.
           * If there are no operation after the current state, it will return empty string instead.
           * @returns {string} Description of operation
           */

        }, {
          key: 'getRedoDesc',
          value: function getRedoDesc() {
            return this.__history[this.__historyIndex] ? this.__history[this.__historyIndex].desc : '';
          }
          /**
           * Drop all the history. YABAI.
           */

        }, {
          key: 'dropHistory',
          value: function dropHistory() {
            this.__history.splice(0);

            this.__historyIndex = 0;
          }
          /**
           * Set new length for this automaton instance.
           * **Some nodes / fxs might be automatically removed / changed.**
           * Can be performed via GUI.
           * @param {number} _length New length for the automaton
           * @returns {void} void
           */

        }, {
          key: 'setLength',
          value: function setLength(_length) {
            // if length is invalid then throw error
            if (isNaN(_length)) {
              throw new Error('Automaton.setLength: _length is invalid');
            } // if length is not changed then do fast-return


            if (_length === this.length) {
              return;
            } // changeLength is a good method


            for (var paramName in this.__params) {
              var param = this.__params[paramName];
              param.changeLength(_length);
            } // finally set the length


            this.__length = _length; // It's irreversible operation, sorry.

            this.dropHistory(); // Poke vue

            this.__vue.$emit('changedLength');
          }
          /**
           * Set new resolution for this automaton instance.
           * @param {number} _resolultion New resolution for the automaton lul
           * @returns {void} void
           */

        }, {
          key: 'setResolution',
          value: function setResolution(_resolultion) {
            // lul
            this.__resolution = _resolultion; // lul

            this.precalcAll();
          }
          /**
           * Create a new param.
           * @param {string} _name Name of param
           * @returns {Param} Created param
           */

        }, {
          key: 'createParam',
          value: function createParam(_name, _data) {
            var param = new _paramGui2.default({
              automaton: this,
              data: _data
            });

            _vue2.default.set(this.__params, _name, param);

            return param;
          }
          /**
           * Remove a param.
           * @param {string} _name Name of param
           * @returns {void} void
           */

        }, {
          key: 'removeParam',
          value: function removeParam(_name) {
            _vue2.default.delete(this.__params, _name);
          }
          /**
           * Get a param.
           * @param {string} _name Name of the param
           * @returns {Param} Param object
           */

        }, {
          key: 'getParam',
          value: function getParam(_name) {
            return this.__params[_name] || null;
          }
          /**
           * Return list of name of params. Sorted.
           * @returns {Array} List of name of params
           */

        }, {
          key: 'getParamNames',
          value: function getParamNames() {
            var arr = [];

            for (var name in this.__params) {
              arr.push(name);
            }

            arr = arr.sort();
            return arr;
          }
          /**
           * Return list of id of fx definitions. Sorted.
           * @returns {Array} List of id of fx definitions
           */

        }, {
          key: 'getFxDefinitionIds',
          value: function getFxDefinitionIds() {
            var arr = [];

            for (var id in this.__paramFxDefs) {
              arr.push(id);
            }

            arr = arr.sort();
            return arr;
          }
          /**
           * Return display name of a fx definition.
           * @param {string} _id Id of the fx definition you want to grab
           * @returns {string} Name of the fx definition
           */

        }, {
          key: 'getFxDefinitionName',
          value: function getFxDefinitionName(_id) {
            if (this.__paramFxDefs[_id]) {
              return this.__paramFxDefs[_id].name || _id;
            } else {
              return undefined;
            }
          }
          /**
           * Return description of a fx definition.
           * @param {string} _id Id of the fx definition you want to grab
           * @returns {string} Description of the fx definition
           */

        }, {
          key: 'getFxDefinitionDescription',
          value: function getFxDefinitionDescription(_id) {
            if (this.__paramFxDefs[_id]) {
              return this.__paramFxDefs[_id].description || '';
            } else {
              return undefined;
            }
          }
          /**
           * Return params section of a fx definition.
           * @param {string} _id Id of the fx definition you want to grab
           * @returns {Object} Params section
           */

        }, {
          key: 'getFxDefinitionParams',
          value: function getFxDefinitionParams(_id) {
            if (this.__paramFxDefs[_id]) {
              return (0, _jsonCopy2.default)(this.__paramFxDefs[_id].params || {});
            } else {
              return undefined;
            }
          }
          /**
           * Return count of params.
           * @returns {number} Count of params
           */

        }, {
          key: 'countParams',
          value: function countParams() {
            var sum = 0;

            for (var name in this.__params) {
              sum++;
            }

            return sum;
          }
          /**
           * Assigned to `Automaton.auto` at constructor.
           * @param {string} _name name of the param
           * @returns {number} Current value of the param
           * @protected
           */

        }, {
          key: '__auto',
          value: function __auto(_name) {
            var param = this.__params[_name];

            if (!param) {
              param = this.createParam(_name);
            }

            param.markAsUsed();
            return param.getValue();
          }
          /**
           * Load automaton state data.
           * @param {Object} _data Object contains automaton data.
           * @returns {void} void
           */

        }, {
          key: 'load',
          value: function load(_data) {
            var data = (0, _compat2.default)(_data);

            _get(AutomatonWithGUI.prototype.__proto__ || Object.getPrototypeOf(AutomatonWithGUI.prototype), 'load', this).call(this, data);
            /**
             * GUI settings.
             * Feel free to get / set these values.
             * @type {Object}
             */


            this.guiSettings = data.guiSettings; // Poke vue

            if (this.__vue) {
              this.__vue.$emit('loaded');
            } // Bye history


            if (this.__history) {
              this.dropHistory();
            }
          }
          /**
           * Export current state as JSON.
           * @returns {string} Saved object as JSON
           * @example
           * あとでやる
           * @todo はい
           */

        }, {
          key: 'save',
          value: function save() {
            var ret = {
              v: this.version,
              length: this.length,
              resolution: this.resolution,
              params: {},
              // will be filled later
              guiSettings: this.guiSettings
            };
            ret.params = {};

            for (var name in this.__params) {
              var param = this.__params[name];
              ret.params[name] = {
                nodes: param.dumpNodesWithoutId(),
                fxs: param.dumpFxsWithoutId()
              };
            }

            return JSON.stringify(ret);
          }
          /**
           * Poke the vue renderer.
           * @returns {void} void
           */

        }, {
          key: 'pokeRenderer',
          value: function pokeRenderer() {
            if (this.__vue) {
              this.__vue.$emit('poke');
            }
          }
        }]);

        return AutomatonWithGUI;
      }(_main2.default);

      module.exports = AutomatonWithGUI;
      AutomatonWithGUI.default = AutomatonWithGUI;
    }, {
      "./ass": 67,
      "./compat": 71,
      "./fx-definitions": 73,
      "./json-copy": 97,
      "./main": 99,
      "./param-gui": 100,
      "./vue/main.vue": 105,
      "vue": 65
    }],
    99: [function (require, module, exports) {
      'use strict';

      var _createClass = function () {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }

        return function (Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);
          if (staticProps) defineProperties(Constructor, staticProps);
          return Constructor;
        };
      }();

      var _clock = require('./clock');

      var _clock2 = _interopRequireDefault(_clock);

      var _clockFrame = require('./clock-frame');

      var _clockFrame2 = _interopRequireDefault(_clockFrame);

      var _clockRealtime = require('./clock-realtime');

      var _clockRealtime2 = _interopRequireDefault(_clockRealtime);

      var _param = require('./param');

      var _param2 = _interopRequireDefault(_param);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        };
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      /**
       * IT'S AUTOMATON!
       * It's `automaton.nogui.js` version and also base class for {@link AutomatonWithGUI}.
       * @param {Object} _props
       * @param {boolean} [_props.loop] Whether let the time loop or not
       * @param {number} [_props.fps] If this is set, the clock will become frame mode
       * @param {boolean} [_props.realtime] If this is true, the clock will become realtime mode
       * @param {Object} _props.data Data of the automaton. **Required in noGUI mode**
       */


      var Automaton = function () {
        function Automaton(_props) {
          var _this = this;

          _classCallCheck(this, Automaton);
          /**
           * Version of the automaton.
           * @type {number}
           * @protected
           */


          this.__version = "2.0.1";
          /**
           * Whether the animation will be looped or not.
           * @type {boolean}
           */

          this.loop = _props.loop || false;
          /**
           * Clock of the automaton.
           * @type {Clock}
           * @protected
           */

          this.__clock = _props.fps ? new _clockFrame2.default(this, _props.fps) : _props.realtime ? new _clockRealtime2.default(this) : new _clock2.default(this);
          /**
           * List of event listeners.
           * @type {Object.<string, function[]>}
           */

          this.__listeners = {};
          /**
           * A list of param fx definitions.
           * @type {Object.<string, Fx>}
           * @protected
           */

          this.__paramFxDefs = {};
          var data = _props.data;
          this.load(data);
          /**
           * **THE MIGHTY `auto()` FUNCTION!! GRAB IT**
           * It creates a new param automatically if there are no param called `_name` (GUI mode only).
           * Otherwise it returns current value of the param called `_name`.
           * @param {string} _name name of the param
           * @returns {number} Current value of the param
           */

          this.auto = function (_name) {
            return _this.__auto(_name);
          };
        }
        /**
         * Version of the automaton.
         * @type {number}
         * @readonly
         */


        _createClass(Automaton, [{
          key: 'createParam',

          /**
           * Create a new param.
           * @param _name Name of the param
           * @param _data Data for the param
           * @returns {void} void
           */
          value: function createParam(_name, _data) {
            this.__params[name] = new _param2.default({
              automaton: this,
              data: _data
            });
          }
          /**
           * Load automaton state data.
           * @param {Object} _data Object contains automaton data.
           * @returns {void} void
           */

        }, {
          key: 'load',
          value: function load(_data) {
            /**
             * Total length of animation in seconds.
             * @type {number}
             * @protected
             */
            this.__length = _data.length;
            /**
             * Resolution = Sampling point per second.
             * @type {number}
             * @protected
             */

            this.__resolution = _data.resolution;
            /**
             * List of Param.
             * @type {Object.<string, Param>}
             * @protected
             */

            this.__params = {};

            for (var _name2 in _data.params) {
              this.createParam(_name2, _data.params[_name2]);
            }
          }
          /**
           * Seek the timeline.
           * Can be performed via GUI.
           * @param {number} _time Time
           * @returns {void} void
           */

        }, {
          key: 'seek',
          value: function seek(_time) {
            this.__clock.setTime(_time);

            this.__emit('seek');
          }
          /**
           * Play the timeline.
           * @returns {void} void
           * @todo SHOULD be performed via GUI.
           */

        }, {
          key: 'play',
          value: function play() {
            this.__clock.play();

            this.__emit('play');
          }
          /**
           * Pause the timeline.
           * @returns {void} void
           * @todo SHOULD be performed via GUI.
           */

        }, {
          key: 'pause',
          value: function pause() {
            this.__clock.pause();

            this.__emit('pause');
          }
          /**
           * Add a fx definition.
           * @param {string} _id Unique id for the Fx definition
           * @param {FxDefinition} _fxDef Fx definition object
           * @returns {void} void
           */

        }, {
          key: 'addFxDefinition',
          value: function addFxDefinition(_id, _fxDef) {
            this.__paramFxDefs[_id] = _fxDef;
            this.precalcAll();
          }
          /**
           * Emit an event.
           * @param {string} _event Event name
           * @param {...any} _arg Arguments passed to listeners
           * @returns {void} void
           * @protected
           */

        }, {
          key: '__emit',
          value: function __emit(_event) {
            for (var _len = arguments.length, _arg = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              _arg[_key - 1] = arguments[_key];
            }

            if (!this.__listeners[_event]) {
              return;
            }

            this.__listeners[_event].map(function (listener) {
              return listener.apply(undefined, _arg);
            });
          }
          /**
           * Register a listener function.
           * @param {string} _event Event name
           * @param {function} _func Listener function
           * @returns {void} void
           */

        }, {
          key: 'on',
          value: function on(_event, _func) {
            if (!this.__listeners[_event]) {
              this.__listeners[_event] = [];
            }

            this.__listeners[_event].push(_func);
          }
          /**
           * Precalculate all params.
           * @returns {void} void
           */

        }, {
          key: 'precalcAll',
          value: function precalcAll() {
            for (var _name3 in this.__params) {
              this.__params[_name3].precalc();
            }
          }
          /**
           * Update the entire automaton.
           * **You may want to call this in your update loop.**
           * @param {number} [_time] Current time, **Required if the clock mode is manual**
           * @returns {void} void
           */

        }, {
          key: 'update',
          value: function update(_time) {
            // update the clock
            this.__clock.update(_time); // if loop is enabled, loop the time


            if (this.loop && (this.time < 0 || this.length < this.time)) {
              this.__clock.setTime(this.time - Math.floor(this.time / this.length) * this.length);
            } // grab current value for each param


            for (var _name4 in this.__params) {
              this.__params[_name4].getValue();
            }
          }
          /**
           * Assigned to Automaton.auto at constructor.
           * @param {string} _name name of the param
           * @returns {number} Current value of the param
           * @protected
           */

        }, {
          key: '__auto',
          value: function __auto(_name) {
            return this.params[_name].__currentValue;
          }
        }, {
          key: 'version',
          get: function get() {
            return this.__version;
          }
          /**
           * Current time. Same as `automaton.__clock.time`.
           * @type {number}
           * @readonly
           */

        }, {
          key: 'time',
          get: function get() {
            return this.__clock.time;
          }
          /**
           * Total length of animation in seconds.
           * @type {number}
           * @readonly
           */

        }, {
          key: 'length',
          get: function get() {
            return this.__length;
          }
          /**
           * Resolution = Sampling point per second.
           * @type {number}
           * @readonly
           */

        }, {
          key: 'resolution',
          get: function get() {
            return this.__resolution;
          }
          /**
           * Delta of time between now and previous update call.
           * @type {number}
           * @readonly
           */

        }, {
          key: 'deltaTime',
          get: function get() {
            return this.__clock.deltaTime;
          }
          /**
           * Whether it's playing or not.
           * @type {boolean}
           * @readonly
           */

        }, {
          key: 'isPlaying',
          get: function get() {
            return this.__clock.isPlaying;
          }
          /**
           * Current progress by whole length. Might NOT be [0-1] unless `_props.loop` (see constructor) is true.
           * @type {number}
           * @readonly
           */

        }, {
          key: 'progress',
          get: function get() {
            return this.time / this.length;
          }
          /**
           * Frame per second. If the clock type is not fps, it will return `0` instead.
           * @type {number}
           * @readonly
           */

        }, {
          key: 'fps',
          get: function get() {
            return this.__clock.fps ? this.__clock.fps : 0;
          }
          /**
           * Boolean that represents whether the clock is based on realtime or not.
           * @type {boolean}
           * @readonly
           */

        }, {
          key: 'realtime',
          get: function get() {
            return Boolean(this.__clock.realtime);
          }
        }]);

        return Automaton;
      }();

      module.exports = Automaton;
      Automaton.default = Automaton;
    }, {
      "./clock": 70,
      "./clock-frame": 68,
      "./clock-realtime": 69,
      "./param": 101
    }],
    100: [function (require, module, exports) {
      'use strict';

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _createClass = function () {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }

        return function (Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);
          if (staticProps) defineProperties(Constructor, staticProps);
          return Constructor;
        };
      }();

      var _get = function get(object, property, receiver) {
        if (object === null) object = Function.prototype;
        var desc = Object.getOwnPropertyDescriptor(object, property);

        if (desc === undefined) {
          var parent = Object.getPrototypeOf(object);

          if (parent === null) {
            return undefined;
          } else {
            return get(parent, property, receiver);
          }
        } else if ("value" in desc) {
          return desc.value;
        } else {
          var getter = desc.get;

          if (getter === undefined) {
            return undefined;
          }

          return getter.call(receiver);
        }
      };

      var _jsonCopy = require('./json-copy');

      var _jsonCopy2 = _interopRequireDefault(_jsonCopy);

      var _ass = require('./ass');

      var _ass2 = _interopRequireDefault(_ass);

      var _genId = require('./gen-id');

      var _genId2 = _interopRequireDefault(_genId);

      var _hasOverwrap = require('./has-overwrap');

      var _hasOverwrap2 = _interopRequireDefault(_hasOverwrap);

      var _mainGui = require('./main-gui');

      var _mainGui2 = _interopRequireDefault(_mainGui);

      var _param = require('./param');

      var _param2 = _interopRequireDefault(_param);

      var _vue = require('vue');

      var _vue2 = _interopRequireDefault(_vue);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        };
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      function _possibleConstructorReturn(self, call) {
        if (!self) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }

        return call && (_typeof2(call) === "object" || typeof call === "function") ? call : self;
      }

      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function, not " + _typeof2(superClass));
        }

        subClass.prototype = Object.create(superClass && superClass.prototype, {
          constructor: {
            value: subClass,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
      }
      /**
       * It represents a param of Automaton.
       * It's `automaton.js` and `automaton.min.js` version.
       * It has even more pretty APIs yay
       * @param {Object} _props
       * @param {Automaton} _props.automaton Parent automaton
       * @param {Object} [_props.data] Data of the param. Don't worry, I can generate an initial data for you!
       */


      var ParamWithGUI = function (_Param) {
        _inherits(ParamWithGUI, _Param);

        function ParamWithGUI(_props) {
          _classCallCheck(this, ParamWithGUI);

          var props = Object.assign({}, _props);
          var len = _props.automaton.length;
          props.data = props.data ? props.data : {
            nodes: [{
              time: 0.0,
              value: 0.0,
              out: {
                time: ParamWithGUI.DEFAULT_HANDLE_LENGTH,
                value: 0.0
              }
            }, {
              time: len,
              value: 0.0,
              in: {
                time: -ParamWithGUI.DEFAULT_HANDLE_LENGTH,
                value: 0.0
              }
            }],
            fxs: []
          };
          /**
           * True if the param is used once at least in current session.
           * Can be operated by {@link ParamWithGUI#markAsUsed}.
           * @type {boolean}
           * @protected
           */

          var _this = _possibleConstructorReturn(this, (ParamWithGUI.__proto__ || Object.getPrototypeOf(ParamWithGUI)).call(this, props));

          _this.__isUsed = false;
          return _this;
        }
        /**
         * Load a param data.
         * @param {object} _data Data of param
         * @returns {void} void
         */


        _createClass(ParamWithGUI, [{
          key: 'load',
          value: function load(_data) {
            var data = (0, _jsonCopy2.default)(_data);

            _get(ParamWithGUI.prototype.__proto__ || Object.getPrototypeOf(ParamWithGUI.prototype), 'load', this).call(this, data);

            this.__nodes.forEach(function (node) {
              return node.$id = (0, _genId2.default)();
            });

            this.__fxs.forEach(function (fx) {
              return fx.$id = (0, _genId2.default)();
            });
          }
          /**
           * Precalculate values.
           * @returns {void} void
           */

        }, {
          key: 'precalc',
          value: function precalc() {
            _get(ParamWithGUI.prototype.__proto__ || Object.getPrototypeOf(ParamWithGUI.prototype), 'precalc', this).call(this);

            this.__automaton.pokeRenderer();
          }
          /**
           * Mark this param as used.
           * @returns {void} void
           */

        }, {
          key: 'markAsUsed',
          value: function markAsUsed() {
            this.__isUsed = true;
          }
          /**
           * Return whether this is used param or not.
           * @returns {bool} True if the param is used at least once in current session
           */

        }, {
          key: 'isUsed',
          value: function isUsed() {
            return this.__isUsed;
          }
          /**
           * Sort nodes by time.
           * @returns {void} void
           * @protected
           */

        }, {
          key: '__sortNodes',
          value: function __sortNodes() {
            this.__nodes = this.__nodes.sort(function (a, b) {
              return a.time - b.time;
            });
          }
          /**
           * Search for node that has given id then return index of it.
           * If it couldn't find the node, it will throw an error instead.
           * @param {number} _id Id of node you want to grab
           * @protected
           */

        }, {
          key: '__getNodeIndexById',
          value: function __getNodeIndexById(_id) {
            var index = this.__nodes.findIndex(function (node) {
              return node.$id === _id;
            });

            if (index === -1) {
              throw new Error('Searched for node id: ' + _id + ' but not found');
            }

            return index;
          }
          /**
           * Return how many node the param currently have.
           * @returns {number} Nodes count
           */

        }, {
          key: 'getNumNode',
          value: function getNumNode() {
            return this.__nodes.length;
          }
          /**
           * Dump data of a node.
           * @param {string} _id Id of the node you want to dump
           * @returns {object} Data of the node
           */

        }, {
          key: 'dumpNode',
          value: function dumpNode(_id) {
            var index = this.__getNodeIndexById(_id);

            return (0, _jsonCopy2.default)(this.__nodes[index]);
          }
          /**
           * Dump data of nodes.
           * @returns {object[]} Data of nodes
           */

        }, {
          key: 'dumpNodes',
          value: function dumpNodes() {
            return (0, _jsonCopy2.default)(this.__nodes);
          }
          /**
           * Dump data of nodes, without `$id`.
           * @returns {object[]} Data of nodes
           */

        }, {
          key: 'dumpNodesWithoutId',
          value: function dumpNodesWithoutId() {
            var nodes = this.dumpNodes();
            return nodes.map(function (node) {
              delete node.$id;
              return node;
            });
          }
          /**
           * Create a node.
           * @param {number} _time Time of new node
           * @param {number} _value Value of new node
           * @returns {string} Id of the new node
           */

        }, {
          key: 'createNode',
          value: function createNode(_time, _value) {
            var data = {
              $id: (0, _genId2.default)(),
              time: _time,
              value: _value,
              in: {
                time: -ParamWithGUI.DEFAULT_HANDLE_LENGTH,
                value: 0.0
              },
              out: {
                time: ParamWithGUI.DEFAULT_HANDLE_LENGTH,
                value: 0.0
              }
            };

            this.__nodes.push(data);

            this.__sortNodes();

            this.precalc();
            return data.$id;
          }
          /**
           * Create a node from dumped data.
           * @param {object} _obj Dumped node data
           * @returns {string} Id of the new node
           */

        }, {
          key: 'createNodeFromData',
          value: function createNodeFromData(_obj) {
            var data = (0, _jsonCopy2.default)(_obj);

            this.__nodes.push(data);

            this.__sortNodes();

            this.precalc();
            return data.$id;
          }
          /**
           * Remove a node.
           * @param {string} _id Id of the node you want to remove
           * @returns {void} void
           */

        }, {
          key: 'removeNode',
          value: function removeNode(_id) {
            var index = this.__getNodeIndexById(_id);

            this.__nodes.splice(index, 1);

            this.precalc();
          }
          /**
           * Move a node.
           * @param {string} _id Id of the node you want to move
           * @param {number} _time Time
           * @param {number} _value Value
           * @returns {void} void
           */

        }, {
          key: 'moveNode',
          value: function moveNode(_id, _time, _value) {
            var index = this.__getNodeIndexById(_id);

            var node = this.__nodes[index];
            var time = typeof _time === 'number' ? _time : node.time;

            if (index === 0) {
              time = 0;
            } else if (index === this.__nodes.length - 1) {
              time = this.__automaton.length;
            } else {
              time = Math.min(Math.max(time, this.__nodes[index - 1].time), this.__nodes[index + 1].time);
            }

            node.time = time;
            node.value = typeof _value === 'number' ? _value : node.value;
            this.precalc();
          }
          /**
           * Move a handle of a node.
           * @param {string} _id Id of the node you want to operate
           * @param {boolean} _isOut Input handle if false, output handle if true
           * @param {number} _time Time
           * @param {number} _value Value
           * @returns {void} void
           */

        }, {
          key: 'moveHandle',
          value: function moveHandle(_id, _isOut, _time, _value) {
            var index = this.__getNodeIndexById(_id);

            if (index === 0 && !_isOut || index === this.getNumNode() - 1 && _isOut) {
              return;
            }

            var node = this.__nodes[index];
            var handle = _isOut ? node.out : node.in;
            var time = typeof _time === 'number' ? _time : handle.time;

            if (_isOut) {
              time = Math.max(0.0, time);
            } else {
              time = Math.min(0.0, time);
            }

            handle.time = time;
            handle.value = typeof _value === 'number' ? _value : handle.value;
            this.precalc();
          }
          /**
           * Reset a handle of a node.
           * @param {string} _id Id of the node you want to operate
           * @param {boolean} _isOut Input handle if false, output handle if true
           * @returns {void} void
           */

        }, {
          key: 'resetHandle',
          value: function resetHandle(_id, _isOut) {
            var index = this.__getNodeIndexById(_id);

            if (index === 0 && !_isOut || index === this.getNumNode() - 1 && _isOut) {
              return;
            }

            var node = this.__nodes[index];
            var handle = _isOut ? node.out : node.in;
            handle.time = (_isOut ? 1.0 : -1.0) * ParamWithGUI.DEFAULT_HANDLE_LENGTH;
            handle.value = 0.0;
            this.precalc();
          }
          /**
           * Sort fxs by time.
           * @returns {void} void
           * @protected
           */

        }, {
          key: '__sortFxs',
          value: function __sortFxs() {
            this.__fxs = this.__fxs.sort(function (a, b) {
              return a.time - b.time;
            }).sort(function (a, b) {
              return a.row - b.row;
            });
          }
          /**
           * Search for fx that has given id then return index of it.
           * If it couldn't find the fx, it will throw an error instead.
           * @param {number} _id Id of fx you want to grab
           * @protected
           */

        }, {
          key: '__getFxIndexById',
          value: function __getFxIndexById(_id) {
            var index = this.__fxs.findIndex(function (fx) {
              return fx.$id === _id;
            });

            if (index === -1) {
              throw new Error('Searched for fx id: ' + _id + ' but not found');
            }

            return index;
          }
          /**
           * Search for vacance fx row for given time and length.
           * @param {number} _time Beginning time of fx
           * @param {number} _length Length of fx
           * @param {number} [_row=0] If given, rows lower than this value will not be searched.
           * @returns {number} Minimal free fx row
           * @protected
           */

        }, {
          key: '__getFreeRow',
          value: function __getFreeRow(_time, _length, _row) {
            var row = _row || 0;

            for (var iFx = 0; iFx < this.__fxs.length; iFx++) {
              var fx = this.__fxs[iFx];

              if (fx.row < row) {
                continue;
              }

              if (row < fx.row) {
                break;
              }

              if ((0, _hasOverwrap2.default)(_time, _length, fx.time, fx.length)) {
                row++;
              }
            }

            return row;
          }
          /**
           * Dump data of a fx.
           * @param {number} _id Id of a fx you want to dump
           * @returns {object} Data of the fx
           */

        }, {
          key: 'dumpFx',
          value: function dumpFx(_id) {
            var index = this.__getFxIndexById(_id);

            return (0, _jsonCopy2.default)(this.__fxs[index]);
          }
          /**
           * Dump data of fxs.
           * @returns {object[]} Data of fxs
           */

        }, {
          key: 'dumpFxs',
          value: function dumpFxs() {
            return (0, _jsonCopy2.default)(this.__fxs);
          }
          /**
           * Dump data of fxs, without `$id`.
           * @returns {object[]} Data of fxs
           */

        }, {
          key: 'dumpFxsWithoutId',
          value: function dumpFxsWithoutId() {
            var fxs = this.dumpFxs();
            return fxs.map(function (fx) {
              delete fx.$id;
              return fx;
            });
          }
          /**
           * Create a fx.
           * If it couldn't create param, it will return empty string instead.
           * @param {number} _time Beginning time of new fx
           * @param {number} _length Length of new fx
           * @param {string} _def Definition id (kind) of new fx
           * @returns {string} Id of the new fx
           */

        }, {
          key: 'createFx',
          value: function createFx(_time, _length, _def) {
            var row = this.__getFreeRow(_time, _length);

            if (ParamWithGUI.FX_ROW_MAX < row) {
              console.error('Too many fx stacks at here!');
              return '';
            }

            var data = {
              $id: (0, _genId2.default)(),
              time: _time,
              length: _length,
              row: row,
              def: _def,
              params: this.__automaton.generateDefaultFxParams(_def)
            };

            this.__fxs.push(data);

            this.__sortFxs();

            this.precalc();
            return data.$id;
          }
          /**
           * Create a fx from dumped data.
           * If it couldn't create param, it will return empty string instead.
           * @param {object} _obj Dumped fx data
           * @returns {string} Id of the new fx
           */

        }, {
          key: 'createFxFromData',
          value: function createFxFromData(_obj) {
            var row = this.__getFreeRow(_obj.time, _obj.length, _obj.row);

            if (ParamWithGUI.FX_ROW_MAX < row) {
              console.error('Too many fx stacks at here!');
              return '';
            }

            var data = (0, _jsonCopy2.default)(_obj);
            data.row = row;

            this.__fxs.push(data);

            this.__sortFxs();

            this.precalc();
            return data.$id;
          }
          /**
           * Remove a fx.
           * @param {string} _id Id of the fx you want to remove
           * @returns {void} void
           */

        }, {
          key: 'removeFx',
          value: function removeFx(_id) {
            var index = this.__getFxIndexById(_id);

            this.__fxs.splice(index, 1);

            this.precalc();
          }
          /**
           * Move a fx.
           * @param {string} _id Id of the fx you want to move
           * @param {number} _time Beginning time
           * @returns {void} void
           */

        }, {
          key: 'moveFx',
          value: function moveFx(_id, _time) {
            var index = this.__getFxIndexById(_id);

            var fx = this.__fxs[index];

            var sameRow = this.__fxs.filter(function (fxOp) {
              return fxOp.row === fx.row;
            });

            var indexInRow = sameRow.indexOf(fx);
            var prev = sameRow[indexInRow - 1];
            var next = sameRow[indexInRow + 1];
            var left = prev ? prev.time + prev.length : 0.0;
            var right = next ? next.time : this.__automaton.length;
            fx.time = Math.min(Math.max(_time, left), right - fx.length);
            this.precalc();
          }
          /**
           * Change row of a fx.
           * @param {string} _id Id of the fx you want to move
           * @param {number} _row Row
           * @returns {void} void
           */

        }, {
          key: 'changeFxRow',
          value: function changeFxRow(_id, _row) {
            var index = this.__getFxIndexById(_id);

            if (_row < 0 || ParamWithGUI.FX_ROW_MAX < _row) {
              throw new Error('Row number ' + _row + ' is invalid');
            }

            var fx = this.__fxs[index];

            if (fx.row === _row) {
              return;
            }

            var sameRow = this.__fxs.filter(function (fxOp) {
              return fxOp.row === _row;
            });

            var isValid = sameRow.every(function (fxOp) {
              return !(fxOp.time < fx.time && fx.time < fxOp.time + fxOp.length) && !(fxOp.time < fx.time + fx.length && fx.time + fx.length < fxOp.time + fxOp.length) && !(fx.time < fxOp.time && fxOp.time < fx.time + fx.length) && !(fx.time < fxOp.time + fxOp.length && fxOp.time + fxOp.length < fx.time + fx.length);
            });

            if (!isValid) {
              return;
            }

            fx.row = _row;

            this.__sortFxs();

            this.precalc();
          }
          /**
           * Bypass or unbypass a fx.
           * @param {string} _id Id of the fx you want to change
           * @param {boolean} _bypass If true, fx will be bypassed
           * @returns {void} void
           */

        }, {
          key: 'bypassFx',
          value: function bypassFx(_id, _bypass) {
            var index = this.__getFxIndexById(_id);

            var fx = this.__fxs[index];

            _vue2.default.set(fx, 'bypass', !!_bypass);

            this.precalc();
          }
          /**
           * Change a param of a fx.
           * @param {string} _id Id of the fx you want to change
           * @param {string} _name Name of the param you want to change
           * @param {any} _value Your desired value
           * @returns {void} void
           */

        }, {
          key: 'changeFxParam',
          value: function changeFxParam(_id, _name, _value) {
            var index = this.__getFxIndexById(_id);

            var fx = this.__fxs[index];

            var params = this.__automaton.getFxDefinitionParams(fx.def);

            var value = _value;

            if (typeof params[_name].min === 'number') {
              value = Math.max(params[_name].min, value);
            }

            if (typeof params[_name].max === 'number') {
              value = Math.min(params[_name].max, value);
            }

            _vue2.default.set(fx.params, _name, value);

            this.precalc();
          }
          /**
           * Move a fx --force.
           * Best for undo-redo operation. probably.
           * @param {string} _id Id of the fx you want to move
           * @param {number} _time Beginning time
           * @param {number} _row Row
           * @returns {void} void
           */

        }, {
          key: 'forceMoveFx',
          value: function forceMoveFx(_id, _time, _row) {
            var index = this.__getFxIndexById(_id);

            var fx = this.__fxs[index];
            fx.time = _time;
            fx.row = _row;

            this.__sortFxs();

            this.precalc();
          }
          /**
           * Resize a fx.
           * @param {string} _id Index of the fx you want to resize
           * @param {number} _length Length
           * @returns {void} void
           */

        }, {
          key: 'resizeFx',
          value: function resizeFx(_id, _length) {
            var index = this.__getFxIndexById(_id);

            var fx = this.__fxs[index];

            var sameRow = this.__fxs.filter(function (fxOp) {
              return fxOp.row === fx.row;
            });

            var indexInRow = sameRow.indexOf(fx);
            var next = sameRow[indexInRow + 1];
            var right = next ? next.time : this.__automaton.length;
            fx.length = Math.min(Math.max(_length, 0.0), right - fx.time);
            this.precalc();
          }
          /**
           * Resize a fx by left side of the end.
           * It's very GUI dev friendly method. yeah.
           * @param {string} _id Index of the fx you want to resize
           * @param {number} _length Length
           * @returns {void} void
           */

        }, {
          key: 'resizeFxByLeft',
          value: function resizeFxByLeft(_id, _length) {
            var index = this.__getFxIndexById(_id);

            var fx = this.__fxs[index];
            var end = fx.time + fx.length;

            var sameRow = this.__fxs.filter(function (fxOp) {
              return fxOp.row === fx.row;
            });

            var indexInRow = sameRow.indexOf(fx);
            var prev = sameRow[indexInRow - 1];
            var left = prev ? prev.time + prev.length : 0.0;
            fx.length = Math.min(Math.max(_length, 0.0), end - left);
            fx.time = end - fx.length;
            this.precalc();
          }
          /**
           * Call when you need to change automaton length.
           * This is very hardcore method. Should not be called by anywhere except {@link AutomatonWithGUI#setLength}.
           * @param {number} _length Desired length
           * @returns {void} void
           */

        }, {
          key: 'changeLength',
          value: function changeLength(_length) {
            for (var i = this.__nodes.length - 1; 0 <= i; i--) {
              var node = this.__nodes[i];

              if (_length < node.time) {
                this.__nodes.splice(i, 1);
              } else if (node.time === _length) {
                delete node.out;
                break;
              } else {
                var lastNode = this.__nodes[this.__nodes.length - 1];

                if (lastNode) {
                  lastNode.out = {
                    time: ParamWithGUI.DEFAULT_HANDLE_LENGTH,
                    value: 0.0
                  };
                }

                this.__nodes.push({
                  time: _length,
                  value: 0.0,
                  in: {
                    time: -ParamWithGUI.DEFAULT_HANDLE_LENGTH,
                    value: 0.0
                  }
                });

                break;
              }
            }

            for (var _i = this.__fxs.length - 1; 0 <= _i; _i--) {
              var fx = this.__fxs[_i];

              if (_length < fx.time) {
                this.__fxs.splice(_i, 1);
              } else if (_length < fx.time + fx.length) {
                fx.length = _length - fx.time;
              }
            }

            this.__values = new Float32Array(this.__automaton.resolution * _length + 1);
            this.precalc();
          }
        }]);

        return ParamWithGUI;
      }(_param2.default);
      /**
       * Handles of a new node will be created in this length.
       * @type {number}
       * @constant
       */


      ParamWithGUI.DEFAULT_HANDLE_LENGTH = 0.5;
      ParamWithGUI.FX_ROW_MAX = 4;
      exports.default = ParamWithGUI;
    }, {
      "./ass": 67,
      "./gen-id": 84,
      "./has-overwrap": 85,
      "./json-copy": 97,
      "./main-gui": 98,
      "./param": 101,
      "vue": 65
    }],
    101: [function (require, module, exports) {
      'use strict';

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _createClass = function () {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }

        return function (Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);
          if (staticProps) defineProperties(Constructor, staticProps);
          return Constructor;
        };
      }();

      var _cubicBezier = require('./cubic-bezier');

      var _cubicBezier2 = _interopRequireDefault(_cubicBezier);

      var _main = require('./main');

      var _main2 = _interopRequireDefault(_main);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        };
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      /**
       * It represents a param of Automaton.
       * It's `automaton.nogui.js` version and also base class for {@link ParamWithGUI}
       * @param {Object} _props
       * @param {Automaton} _props.automaton Parent automaton
       * @param {Object} [_props.data] Data of the param. **Required in noGUI mode**
       */


      var Param = function () {
        function Param(_props) {
          _classCallCheck(this, Param);
          /**
           * The parent automaton.
           * @type {Automaton}
           * @protected
           */


          this.__automaton = _props.automaton;
          /**
           * An array of precalculated value.
           * Its length is same as `param.__automaton.resolution * param.__automaton.length + 1`.
           * @type {number[]}
           * @protected
           */

          this.__values = new Float32Array(this.__automaton.resolution * this.__automaton.length + 1);
          this.load(_props.data);
          /**
           * A buffer of last calculated value.
           * @type {number}
           * @protected
           */

          this.__lastValue = 0.0;
          /**
           * Will be used for calculation of `param.__lastValue`.
           * @type {number}
           * @protected
           */

          this.__lastTime = 0.0;
        }
        /**
         * Load a param data.
         * @param {object} _data Data of param
         * @returns {void} void
         */


        _createClass(Param, [{
          key: 'load',
          value: function load(_data) {
            /**
             * List of node.
             * @type {ParamNode[]}
             * @protected
             */
            this.__nodes = _data.nodes;
            /**
             * List of fx.
             * @type {ParamFxStrip[]}
             * @protected
             */

            this.__fxs = _data.fxs;
            this.precalc();
          }
          /**
           * Precalculate value of a sample.
           * @returns {void} void
           */

        }, {
          key: 'precalc',
          value: function precalc() {
            for (var iNode = 0; iNode < this.__nodes.length - 1; iNode++) {
              var node0 = this.__nodes[iNode];
              var node1 = this.__nodes[iNode + 1];
              var i0 = Math.floor(node0.time * this.__automaton.resolution);
              var i1 = Math.floor(node1.time * this.__automaton.resolution);
              this.__values[i0] = node0.value;

              for (var i = i0 + 1; i <= i1; i++) {
                var time = i / this.__automaton.resolution;
                var value = (0, _cubicBezier2.default)(node0, node1, time);
                this.__values[i] = value;
              }
            }

            for (var iFx = 0; iFx < this.__fxs.length; iFx++) {
              var fx = this.__fxs[iFx];

              if (fx.bypass) {
                continue;
              }

              var fxDef = this.__automaton.__paramFxDefs[fx.def];

              if (!fxDef) {
                continue;
              }

              var _i = Math.ceil(this.__automaton.resolution * fx.time);

              var _i2 = Math.floor(this.__automaton.resolution * (fx.time + fx.length));

              var tempValues = new Float32Array(_i2 - _i);
              var tempLength = tempValues.length;
              var context = {
                i0: _i,
                i1: _i2,
                t0: fx.time,
                t1: fx.time + fx.length,
                dt: 1.0 / this.__automaton.resolution,
                resolution: this.__automaton.resolution,
                length: fx.length,
                params: fx.params,
                array: this.__values,
                getValue: this.getValue.bind(this),
                init: true
              };

              for (var _i3 = 0; _i3 < tempLength; _i3++) {
                context.i = _i3 + _i;
                context.t = context.i / this.__automaton.resolution;
                context.v = this.__values[_i3 + _i];
                context.progress = (context.t - fx.time) / fx.length;
                tempValues[_i3] = fxDef.func(context);
                context.init = false;
              }

              this.__values.set(tempValues, _i);
            }
          }
          /**
           * Return the value of specified time point.
           * @param {number} {_time} Time at the point you want to grab the value.
           * If it is not given, use current time of parent automaton instead
           * @returns {number} Result value
           */

        }, {
          key: 'getValue',
          value: function getValue(_time) {
            var time = _time;

            if (typeof time !== 'number') {
              // use parent automaton time instead
              time = this.__automaton.time;
            }

            if (time === this.__lastTime) {
              // use the buffer!
              return this.__lastValue;
            }

            if (this.__automaton.loop) {
              time = time - Math.floor(time / this.__automaton.length) * this.__automaton.length;
            }

            if (time <= 0.0) {
              // left clamp
              return this.__values[0];
            } else if (this.__automaton.length <= time) {
              // right clamp
              return this.__values[this.__values.length - 1];
            } else {
              // fetch two value then do linear interpolation
              var index = time * this.__automaton.resolution;
              var indexi = Math.floor(index);
              var indexf = index % 1.0;
              var v0 = this.__values[indexi];
              var v1 = this.__values[indexi + 1];
              var v = v0 + (v1 - v0) * indexf; // store lastValue

              this.__lastTime = time;
              this.__lastValue = v;
              return v;
            }
          }
        }]);

        return Param;
      }(); // ------


      exports.default = Param;
    }, {
      "./cubic-bezier": 72,
      "./main": 99
    }],
    102: [function (require, module, exports) {
      var __vueify_style_dispose__ = require("vueify/lib/insert-css").insert("/* line 54, stdin */\n.blur-layer[data-v-548efbdb] {\n  position: absolute;\n  left: 0;\n  top: 0;\n  width: 100%;\n  height: 100%;\n  background: #00000066; }\n\n/* line 64, stdin */\n.root[data-v-548efbdb] {\n  position: absolute;\n  left: calc( 50% - 17em);\n  top: 1em;\n  width: 30em;\n  padding: 1em;\n  overflow: hidden;\n  background: #2c3236;\n  border-radius: 0.5em;\n  color: #c9e2ff;\n  font-size: 0.8em;\n  line-height: 1.2;\n  filter: drop-shadow(0 0 2px #000000); }\n  /* line 80, stdin */\n  .root a[data-v-548efbdb] {\n    color: #22aaff;\n    text-decoration: none; }\n    /* line 84, stdin */\n    .root a[data-v-548efbdb]:hover {\n      opacity: 0.7; }\n  /* line 87, stdin */\n  .root .logo-bg[data-v-548efbdb] {\n    position: absolute;\n    right: -1em;\n    bottom: -1em;\n    width: 14em;\n    opacity: 0.07; }\n  /* line 96, stdin */\n  .root .logo[data-v-548efbdb] {\n    width: 20em;\n    margin-bottom: 0.3em; }\n  /* line 101, stdin */\n  .root .version[data-v-548efbdb] {\n    display: inline-block;\n    vertical-align: bottom;\n    margin-left: 4px;\n    margin-bottom: 0.3em; }\n  /* line 108, stdin */\n  .root .logo-hr[data-v-548efbdb] {\n    width: 100%;\n    height: 1px;\n    margin: 0.5em 0;\n    background: #bad0eb; }\n  /* line 116, stdin */\n  .root .close[data-v-548efbdb] {\n    position: absolute;\n    right: 0.5em;\n    top: 0.5em;\n    width: 1em;\n    cursor: pointer; }\n    /* line 124, stdin */\n    .root .close[data-v-548efbdb]:hover {\n      opacity: 0.7; }");

      (function () {
        'use strict';

        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports.default = {
          name: 'about',
          props: ['automaton'],
          data: function data() {
            return {};
          },
          methods: {
            blur: function blur() {
              this.$emit('blur');
            }
          }
        };
      })();

      if (module.exports.__esModule) module.exports = module.exports.default;

      var __vue__options__ = typeof module.exports === "function" ? module.exports.options : module.exports;

      if (__vue__options__.functional) {
        console.error("[vueify] functional components are not supported and should be defined in plain js files using render functions.");
      }

      __vue__options__.render = function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', [_c('div', {
          staticClass: "blur-layer",
          on: {
            "mousedown": _vm.blur
          }
        }), _vm._v(" "), _c('div', {
          staticClass: "root"
        }, [_c('img', {
          staticClass: "logo-bg",
          attrs: {
            "src": require('../images/automaton-a.svg')
          }
        }), _vm._v(" "), _c('img', {
          staticClass: "logo",
          attrs: {
            "src": require('../images/automaton.svg')
          }
        }), _vm._v(" "), _c('div', {
          staticClass: "version"
        }, [_vm._v(_vm._s(_vm.automaton.version))]), _c('br'), _vm._v("\n    Animation engine with Timeline GUI for creative coding\n\n    "), _c('div', {
          staticClass: "logo-hr"
        }), _vm._v("\n\n    Author: "), _c('a', {
          attrs: {
            "href": "https://github.com/fms-cat/",
            "target": "_blank"
          }
        }, [_vm._v("@FMS_Cat")]), _c('br'), _vm._v("\n    Repository: "), _c('a', {
          attrs: {
            "href": "https://github.com/fms-cat/automaton/",
            "target": "_blank"
          }
        }, [_vm._v("https://github.com/fms-cat/automaton/")]), _c('br'), _vm._v("\n    Automaton is distributed under permissive "), _c('a', {
          attrs: {
            "href": "https://opensource.org/licenses/MIT",
            "target": "_blank"
          }
        }, [_vm._v("MIT License")]), _vm._v("."), _c('br'), _vm._v("\n    Shoutouts to "), _c('a', {
          attrs: {
            "href": "https://www.image-line.com/flstudio/",
            "target": "_blank"
          }
        }, [_vm._v("Image Line Software")]), _vm._v(" <3\n\n    "), _c('img', {
          staticClass: "close",
          attrs: {
            "src": require('../images/about-close.svg')
          },
          on: {
            "mousedown": _vm.blur
          }
        })])]);
      };

      __vue__options__.staticRenderFns = [];
      __vue__options__._scopeId = "data-v-548efbdb";

      if (module.hot) {
        (function () {
          var hotAPI = require("vue-hot-reload-api");

          hotAPI.install(require("vue"), true);
          if (!hotAPI.compatible) return;
          module.hot.accept();
          module.hot.dispose(__vueify_style_dispose__);

          if (!module.hot.data) {
            hotAPI.createRecord("data-v-548efbdb", __vue__options__);
          } else {
            hotAPI.rerender("data-v-548efbdb", __vue__options__);
          }
        })();
      }
    }, {
      "../images/about-close.svg": 86,
      "../images/automaton-a.svg": 87,
      "../images/automaton.svg": 88,
      "vue": 65,
      "vue-hot-reload-api": 64,
      "vueify/lib/insert-css": 66
    }],
    103: [function (require, module, exports) {
      var __vueify_style_dispose__ = require("vueify/lib/insert-css").insert("/* line 81, stdin */\n.blur-layer[data-v-123585df] {\n  position: fixed;\n  left: 0;\n  top: 0;\n  width: 100%;\n  height: 100%; }\n\n/* line 89, stdin */\n.root[data-v-123585df] {\n  position: fixed;\n  white-space: nowrap;\n  padding: 0.4em;\n  font-size: 0.8em;\n  background: rgba(0, 0, 0, 0.5);\n  border: solid 1px #3d4449;\n  color: #bad0eb;\n  border-radius: 0.2em;\n  filter: drop-shadow(0 0 2px #000000); }\n  /* line 102, stdin */\n  .root .command[data-v-123585df] {\n    padding-left: 0.2em;\n    padding-right: 2em;\n    border-radius: 0.2em;\n    cursor: pointer; }\n    /* line 110, stdin */\n    .root .command[data-v-123585df]:hover {\n      background: #3d4449;\n      color: #c9e2ff; }");

      (function () {
        'use strict';

        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports.default = {
          name: 'context-menu',
          props: ['active', 'x', 'y', 'commands'],
          data: function data() {
            return {
              left: 0,
              right: 0,
              top: 0,
              bottom: 0
            };
          },
          methods: {
            blur: function blur() {
              this.$emit('blur');
            },
            moveRoot: function moveRoot() {
              var x = this.x;
              var y = this.y;
              var w = document.documentElement.clientWidth;
              var h = document.documentElement.clientHeight;
              var bLeftSide = w - 240 < x;
              var bUpSide = h - 40 < y;
              this.left = bLeftSide ? null : x;
              this.right = bLeftSide ? w - x : null;
              this.top = bUpSide ? null : y;
              this.bottom = bUpSide ? h - y : null;
            },
            selectCommand: function selectCommand(index) {
              this.commands[index].func();
              this.$emit('blur');
            }
          },
          watch: {
            x: function x() {
              this.moveRoot();
            },
            y: function y() {
              this.moveRoot();
            }
          }
        };
      })();

      if (module.exports.__esModule) module.exports = module.exports.default;

      var __vue__options__ = typeof module.exports === "function" ? module.exports.options : module.exports;

      if (__vue__options__.functional) {
        console.error("[vueify] functional components are not supported and should be defined in plain js files using render functions.");
      }

      __vue__options__.render = function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', [_vm.active ? _c('div', {
          staticClass: "blur-layer",
          on: {
            "mousedown": _vm.blur
          }
        }) : _vm._e(), _vm._v(" "), _vm.active ? _c('div', {
          staticClass: "root",
          style: {
            left: typeof _vm.left === 'number' ? _vm.left + "px" : undefined,
            right: typeof _vm.right === 'number' ? _vm.right + "px" : undefined,
            top: typeof _vm.top === 'number' ? _vm.top + "px" : undefined,
            bottom: typeof _vm.bottom === 'number' ? _vm.bottom + "px" : undefined
          }
        }, _vm._l(_vm.commands, function (command, index) {
          return _c('div', {
            key: 'command' + index,
            staticClass: "command",
            on: {
              "mouseup": function mouseup($event) {
                _vm.selectCommand(index);
              }
            }
          }, [_vm._v(_vm._s(command.text))]);
        })) : _vm._e()]);
      };

      __vue__options__.staticRenderFns = [];
      __vue__options__._scopeId = "data-v-123585df";

      if (module.hot) {
        (function () {
          var hotAPI = require("vue-hot-reload-api");

          hotAPI.install(require("vue"), true);
          if (!hotAPI.compatible) return;
          module.hot.accept();
          module.hot.dispose(__vueify_style_dispose__);

          if (!module.hot.data) {
            hotAPI.createRecord("data-v-123585df", __vue__options__);
          } else {
            hotAPI.rerender("data-v-123585df", __vue__options__);
          }
        })();
      }
    }, {
      "vue": 65,
      "vue-hot-reload-api": 64,
      "vueify/lib/insert-css": 66
    }],
    104: [function (require, module, exports) {
      var __vueify_style_dispose__ = require("vueify/lib/insert-css").insert("/* line 155, stdin */\n.root[data-v-608a592f] {\n  position: absolute;\n  left: 0;\n  top: 0;\n  width: 100%;\n  height: 100%;\n  background: #3d4449; }\n  /* line 164, stdin */\n  .root .row[data-v-608a592f] {\n    position: absolute;\n    height: calc( 100% - 0.25em);\n    margin: 0.125em; }\n    /* line 169, stdin */\n    .root .row.row-center[data-v-608a592f] {\n      width: calc( 100% - 0.25em);\n      text-align: center; }\n    /* line 173, stdin */\n    .root .row.row-left[data-v-608a592f] {\n      left: 0.125em; }\n    /* line 174, stdin */\n    .root .row.row-right[data-v-608a592f] {\n      right: 0.125em; }\n    /* line 176, stdin */\n    .root .row > *[data-v-608a592f] {\n      display: inline-block;\n      position: relative;\n      vertical-align: bottom;\n      margin: 0 0.125em;\n      height: 100%; }\n    /* line 184, stdin */\n    .root .row .logobox[data-v-608a592f] {\n      color: #c9e2ff;\n      opacity: 0.5;\n      cursor: pointer; }\n      /* line 190, stdin */\n      .root .row .logobox[data-v-608a592f]:hover {\n        opacity: 0.8; }\n      /* line 192, stdin */\n      .root .row .logobox .logo[data-v-608a592f] {\n        display: inline-block;\n        position: relative;\n        height: 60%;\n        top: 20%; }\n    /* line 200, stdin */\n    .root .row .button[data-v-608a592f] {\n      height: 100%;\n      cursor: pointer; }\n      /* line 205, stdin */\n      .root .row .button[data-v-608a592f]:hover {\n        opacity: 0.7; }\n    /* line 208, stdin */\n    .root .row .time[data-v-608a592f] {\n      width: 8em;\n      white-space: nowrap;\n      text-align: right;\n      cursor: pointer; }\n      /* line 216, stdin */\n      .root .row .time *[data-v-608a592f] {\n        pointer-events: none; }\n      /* line 220, stdin */\n      .root .row .time .current[data-v-608a592f] {\n        position: relative;\n        font-size: 0.8em;\n        margin-right: 0;\n        color: #c9e2ff; }\n      /* line 229, stdin */\n      .root .row .time .length[data-v-608a592f] {\n        position: relative;\n        font-size: 0.6em;\n        margin-left: 0;\n        color: #bad0eb; }\n      /* line 237, stdin */\n      .root .row .time .bar[data-v-608a592f] {\n        display: block;\n        position: absolute;\n        bottom: 0.25em;\n        left: 0px;\n        height: 2px;\n        margin: 0; }\n        /* line 245, stdin */\n        .root .row .time .bar.bar-bg[data-v-608a592f] {\n          background: #000000; }\n        /* line 246, stdin */\n        .root .row .time .bar.bar-fg[data-v-608a592f] {\n          background: #c9e2ff; }\n      /* line 250, stdin */\n      .root .row .time:hover .bar-fg[data-v-608a592f] {\n        background: #22aaff; }\n      /* line 254, stdin */\n      .root .row .time.seeking .bar-fg[data-v-608a592f] {\n        background: #22aaff; }");

      (function () {
        'use strict';

        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports.default = {
          mounted: function mounted() {},
          beforeDestroy: function beforeDestroy() {},
          props: ["automaton"],
          data: function data() {
            return {
              saveText: 'Copy current state as JSON',
              seeking: false,
              cantUndoThis: 0
            };
          },
          methods: {
            seek: function seek(event) {
              var _this = this;

              var width = event.target.offsetWidth;
              var xOffset0 = event.offsetX;
              var xClient0 = event.clientX;
              var isPlaying0 = this.automaton.isPlaying;

              if (isPlaying0) {
                this.automaton.pause();
              }

              this.automaton.seek(this.automaton.length * xOffset0 / width);
              this.seeking = true;

              var move = function move(event) {
                var x = xOffset0 + event.clientX - xClient0;

                _this.automaton.seek(_this.automaton.length * x / width);
              };

              var up = function up(event) {
                if (isPlaying0) {
                  _this.automaton.play();
                }

                _this.seeking = false;
                window.removeEventListener('mousemove', move);
                window.removeEventListener('mouseup', up);
              };

              window.addEventListener('mousemove', move);
              window.addEventListener('mouseup', up);
            },
            undo: function undo() {
              if (this.automaton.getUndoDesc()) {
                this.automaton.undo();
                this.cantUndoThis = 0;
              } else {
                this.cantUndoThis++;

                if (10 === this.cantUndoThis) {
                  window.open('https://youtu.be/bzY7J0Xle08', '_blank');
                  this.cantUndoThis = 0;
                }
              }

              this.$emit('historyMoved');
            },
            redo: function redo() {
              this.automaton.redo();
              this.$emit('historyMoved');
            },
            save: function save() {
              var _this2 = this;

              var el = document.createElement('textarea');
              el.value = this.automaton.save();
              document.body.appendChild(el);
              el.select();
              document.execCommand('copy');
              document.body.removeChild(el);
              this.saveText = 'Copied!';
              setTimeout(function () {
                _this2.saveText = 'Copy current state as JSON';
              }, 3000);
            }
          }
        };
      })();

      if (module.exports.__esModule) module.exports = module.exports.default;

      var __vue__options__ = typeof module.exports === "function" ? module.exports.options : module.exports;

      if (__vue__options__.functional) {
        console.error("[vueify] functional components are not supported and should be defined in plain js files using render functions.");
      }

      __vue__options__.render = function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', [_c('div', {
          staticClass: "root"
        }, [_c('div', {
          staticClass: "row row-center"
        }, [_c('div', {
          staticClass: "logobox",
          on: {
            "click": function click($event) {
              $event.stopPropagation();

              _vm.$emit('logoClicked');
            }
          }
        }, [_c('img', {
          staticClass: "logo",
          attrs: {
            "src": require('../images/automaton.svg')
          }
        })])]), _vm._v(" "), _c('div', {
          staticClass: "row row-left"
        }, [_c('img', {
          staticClass: "button",
          attrs: {
            "src": _vm.automaton.isPlaying ? require('../images/pause.svg') : require('../images/play.svg')
          },
          on: {
            "click": function click($event) {
              $event.stopPropagation();

              _vm.automaton.togglePlay();
            }
          }
        }), _vm._v(" "), _c('div', {
          staticClass: "time",
          class: {
            seeking: _vm.seeking
          },
          on: {
            "mousedown": function mousedown($event) {
              $event.stopPropagation();
              return _vm.seek($event);
            }
          }
        }, [_c('span', {
          staticClass: "current"
        }, [_vm._v(_vm._s(_vm.automaton.time.toFixed(3)))]), _vm._v(" "), _c('span', {
          staticClass: "length"
        }, [_vm._v(" / " + _vm._s(_vm.automaton.length.toFixed(3)))]), _vm._v(" "), _c('div', {
          staticClass: "bar bar-bg",
          style: {
            width: '100%'
          }
        }), _vm._v(" "), _c('div', {
          staticClass: "bar bar-fg",
          style: {
            width: _vm.automaton.progress * 100 + "%"
          }
        })])]), _vm._v(" "), _c('div', {
          staticClass: "row row-right"
        }, [_c('img', {
          staticClass: "button",
          attrs: {
            "src": require('../images/undo.svg'),
            "stalker-text": _vm.automaton.getUndoDesc() ? "Undo: " + _vm.automaton.getUndoDesc() : 'Can\'t undo'
          },
          on: {
            "click": function click($event) {
              $event.stopPropagation();

              _vm.undo();
            }
          }
        }), _vm._v(" "), _c('img', {
          staticClass: "button",
          attrs: {
            "src": require('../images/redo.svg'),
            "stalker-text": _vm.automaton.getRedoDesc() ? "Redo: " + _vm.automaton.getRedoDesc() : 'Can\'t redo'
          },
          on: {
            "click": function click($event) {
              $event.stopPropagation();

              _vm.redo();
            }
          }
        }), _vm._v(" "), _c('img', {
          staticClass: "button",
          attrs: {
            "src": require('../images/snap.svg'),
            "stalker-text": "Snap Settings"
          },
          on: {
            "click": function click($event) {
              $event.stopPropagation();

              _vm.$emit('configSelected', 'snap');
            }
          }
        }), _vm._v(" "), _c('img', {
          staticClass: "button",
          attrs: {
            "src": require('../images/cog.svg'),
            "stalker-text": "General Config"
          },
          on: {
            "click": function click($event) {
              $event.stopPropagation();

              _vm.$emit('configSelected', 'general');
            }
          }
        }), _vm._v(" "), _c('img', {
          staticClass: "button",
          attrs: {
            "src": require('../images/save.svg'),
            "stalker-text": _vm.saveText
          },
          on: {
            "click": function click($event) {
              $event.stopPropagation();
              return _vm.save($event);
            }
          }
        })])])]);
      };

      __vue__options__.staticRenderFns = [];
      __vue__options__._scopeId = "data-v-608a592f";

      if (module.hot) {
        (function () {
          var hotAPI = require("vue-hot-reload-api");

          hotAPI.install(require("vue"), true);
          if (!hotAPI.compatible) return;
          module.hot.accept();
          module.hot.dispose(__vueify_style_dispose__);

          if (!module.hot.data) {
            hotAPI.createRecord("data-v-608a592f", __vue__options__);
          } else {
            hotAPI.rerender("data-v-608a592f", __vue__options__);
          }
        })();
      }
    }, {
      "../images/automaton.svg": 88,
      "../images/cog.svg": 89,
      "../images/pause.svg": 90,
      "../images/play.svg": 91,
      "../images/redo.svg": 92,
      "../images/save.svg": 93,
      "../images/snap.svg": 94,
      "../images/undo.svg": 95,
      "vue": 65,
      "vue-hot-reload-api": 64,
      "vueify/lib/insert-css": 66
    }],
    105: [function (require, module, exports) {
      var __vueify_style_dispose__ = require("vueify/lib/insert-css").insert("@import url(\"https://fonts.googleapis.com/css?family=Roboto:300,400,500,700,900\");\n/* line 142, stdin */\n.automaton {\n  font-family: 'Roboto', sans-serif;\n  font-weight: 300;\n  font-size: 16px; }\n/* line 152, stdin */\n.root[data-v-491bbe4a] {\n  user-select: none; }\n  /* line 156, stdin */\n  .root .header[data-v-491bbe4a] {\n    position: absolute;\n    left: 0;\n    top: 0;\n    width: 100%;\n    height: 2em; }\n  /* line 165, stdin */\n  .root .paramlist[data-v-491bbe4a] {\n    position: absolute;\n    left: 0;\n    top: 2em;\n    width: 8em;\n    height: calc( 100% - 2em); }\n  /* line 174, stdin */\n  .root .propmenu[data-v-491bbe4a] {\n    position: absolute;\n    right: 0;\n    top: 2em;\n    width: 12em;\n    height: calc( 100% - 2em); }\n  /* line 182, stdin */\n  .root .timeline[data-v-491bbe4a] {\n    position: absolute;\n    left: 8em;\n    top: 2em;\n    width: calc( 100% - 20em);\n    height: calc( 100% - 2em); }");

      (function () {
        'use strict';

        Object.defineProperty(exports, "__esModule", {
          value: true
        });

        var _about = require('./about.vue');

        var _about2 = _interopRequireDefault(_about);

        var _header = require('./header.vue');

        var _header2 = _interopRequireDefault(_header);

        var _paramlist = require('./paramlist.vue');

        var _paramlist2 = _interopRequireDefault(_paramlist);

        var _propmenu = require('./propmenu.vue');

        var _propmenu2 = _interopRequireDefault(_propmenu);

        var _timeline = require('./timeline.vue');

        var _timeline2 = _interopRequireDefault(_timeline);

        var _contextMenu = require('./context-menu.vue');

        var _contextMenu2 = _interopRequireDefault(_contextMenu);

        var _stalker = require('./stalker.vue');

        var _stalker2 = _interopRequireDefault(_stalker);

        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : {
            default: obj
          };
        }

        exports.default = {
          components: {
            About: _about2.default,
            Header: _header2.default,
            ParamList: _paramlist2.default,
            PropMenu: _propmenu2.default,
            Timeline: _timeline2.default,
            ContextMenu: _contextMenu2.default,
            Stalker: _stalker2.default
          },
          props: ['automaton'],
          data: function data() {
            return {
              aboutActive: false,
              selectedParamName: null,
              selectedNodeIds: [],
              selectedFxIds: [],
              config: '',
              contextMenuActive: false,
              contextMenuX: 0,
              contextMenuY: 0,
              contextMenuCommands: []
            };
          },
          methods: {
            selectParam: function selectParam(name) {
              this.selectedParamName = name;
              this.selectNodes([]);
              this.selectFxs([]);
            },
            selectNodes: function selectNodes(arr) {
              this.selectedNodeIds = arr;
              this.config = '';
            },
            selectFxs: function selectFxs(arr) {
              this.selectedFxIds = arr;
              this.config = '';
            },
            onHistoryMoved: function onHistoryMoved() {
              this.selectNodes([]);
              this.selectFxs([]);
            },
            onConfigSelected: function onConfigSelected(config) {
              this.selectNodes([]);
              this.selectFxs([]);
              this.config = config;
            },
            openContextMenu: function openContextMenu(event) {
              this.contextMenuActive = true;
              this.contextMenuX = event.clientX;
              this.contextMenuY = event.clientY;
              this.contextMenuCommands = event.commands;
            }
          },
          mounted: function mounted() {
            var _this = this;

            this.$root.$on('loaded', function () {
              _this.selectParam(null);

              _this.selectNodes([]);

              _this.selectFxs([]);

              _this.config = '';
            });
          },
          beforeDestroy: function beforeDestroy() {}
        };
      })();

      if (module.exports.__esModule) module.exports = module.exports.default;

      var __vue__options__ = typeof module.exports === "function" ? module.exports.options : module.exports;

      if (__vue__options__.functional) {
        console.error("[vueify] functional components are not supported and should be defined in plain js files using render functions.");
      }

      __vue__options__.render = function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', [_c('div', {
          staticClass: "root automaton color-theme-dark"
        }, [_c('Header', {
          staticClass: "header",
          attrs: {
            "automaton": _vm.automaton
          },
          on: {
            "historyMoved": _vm.onHistoryMoved,
            "configSelected": _vm.onConfigSelected,
            "context": _vm.openContextMenu,
            "logoClicked": function logoClicked($event) {
              _vm.aboutActive = true;
            }
          }
        }), _vm._v(" "), _c('ParamList', {
          staticClass: "paramlist",
          attrs: {
            "automaton": _vm.automaton,
            "selectedParamName": _vm.selectedParamName
          },
          on: {
            "selected": function selected($event) {
              _vm.selectParam($event);
            },
            "context": _vm.openContextMenu
          }
        }), _vm._v(" "), _c('PropMenu', {
          staticClass: "propmenu",
          attrs: {
            "automaton": _vm.automaton,
            "selectedParamName": _vm.selectedParamName,
            "selectedNodeIds": _vm.selectedNodeIds,
            "selectedFxIds": _vm.selectedFxIds,
            "config": _vm.config
          },
          on: {
            "context": _vm.openContextMenu
          }
        }), _vm._v(" "), _c('Timeline', {
          staticClass: "timeline",
          attrs: {
            "automaton": _vm.automaton,
            "selectedParamName": _vm.selectedParamName,
            "selectedNodeIds": _vm.selectedNodeIds,
            "selectedFxIds": _vm.selectedFxIds
          },
          on: {
            "nodeSelected": function nodeSelected($event) {
              _vm.selectNodes($event);
            },
            "fxSelected": function fxSelected($event) {
              _vm.selectFxs($event);
            },
            "context": _vm.openContextMenu
          }
        }), _vm._v(" "), _vm.aboutActive ? _c('About', {
          staticClass: "about",
          attrs: {
            "automaton": _vm.automaton
          },
          on: {
            "blur": function blur($event) {
              _vm.aboutActive = false;
            }
          }
        }) : _vm._e(), _vm._v(" "), _c('ContextMenu', {
          staticClass: "context-menu",
          attrs: {
            "active": _vm.contextMenuActive,
            "x": _vm.contextMenuX,
            "y": _vm.contextMenuY,
            "commands": _vm.contextMenuCommands
          },
          on: {
            "blur": function blur($event) {
              _vm.contextMenuActive = false;
            }
          }
        }), _vm._v(" "), _c('Stalker', {
          staticClass: "stalker"
        })], 1)]);
      };

      __vue__options__.staticRenderFns = [];
      __vue__options__._scopeId = "data-v-491bbe4a";

      if (module.hot) {
        (function () {
          var hotAPI = require("vue-hot-reload-api");

          hotAPI.install(require("vue"), true);
          if (!hotAPI.compatible) return;
          module.hot.accept();
          module.hot.dispose(__vueify_style_dispose__);

          if (!module.hot.data) {
            hotAPI.createRecord("data-v-491bbe4a", __vue__options__);
          } else {
            hotAPI.rerender("data-v-491bbe4a", __vue__options__);
          }
        })();
      }
    }, {
      "./about.vue": 102,
      "./context-menu.vue": 103,
      "./header.vue": 104,
      "./paramlist.vue": 106,
      "./propmenu.vue": 108,
      "./stalker.vue": 110,
      "./timeline.vue": 112,
      "vue": 65,
      "vue-hot-reload-api": 64,
      "vueify/lib/insert-css": 66
    }],
    106: [function (require, module, exports) {
      var __vueify_style_dispose__ = require("vueify/lib/insert-css").insert("/* line 75, stdin */\n.root[data-v-3e0dc8f9] {\n  position: absolute;\n  left: 0;\n  top: 0;\n  width: 100%;\n  height: 100%;\n  background: #202325;\n  color: #c9e2ff; }\n  /* line 85, stdin */\n  .root .param[data-v-3e0dc8f9] {\n    position: relative;\n    width: calc( 100% - 4px);\n    height: 1.25em;\n    margin: 2px;\n    background: #2c3236;\n    color: #bad0eb;\n    cursor: pointer; }\n    /* line 96, stdin */\n    .root .param.selected[data-v-3e0dc8f9] {\n      background: #3d4449;\n      color: #c9e2ff; }\n    /* line 101, stdin */\n    .root .param .name[data-v-3e0dc8f9] {\n      position: absolute;\n      left: 0.2em;\n      top: 0;\n      width: calc( 100% - 2em);\n      overflow: hidden;\n      text-overflow: ellipsis;\n      white-space: nowrap;\n      user-select: none; }\n    /* line 113, stdin */\n    .root .param .value[data-v-3e0dc8f9] {\n      position: absolute;\n      right: 0.2em;\n      bottom: 0.1em;\n      font-size: 0.6em;\n      opacity: 0.7;\n      user-select: none; }\n    /* line 124, stdin */\n    .root .param .warning[data-v-3e0dc8f9] {\n      position: absolute;\n      right: 0.1em;\n      bottom: 0.1em;\n      height: calc( 100% - 0.2em); }");

      (function () {
        "use strict";

        Object.defineProperty(exports, "__esModule", {
          value: true
        });

        var _scrollable = require("./scrollable.vue");

        var _scrollable2 = _interopRequireDefault(_scrollable);

        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : {
            default: obj
          };
        }

        exports.default = {
          components: {
            Scrollable: _scrollable2.default
          },
          props: ["automaton", "selectedParamName"],
          data: function data() {
            return {};
          },
          methods: {
            contextParam: function contextParam(event, name) {
              var _this = this;

              this.$emit('context', {
                clientX: event.clientX,
                clientY: event.clientY,
                commands: [{
                  text: 'Select Param',
                  func: function func() {
                    _this.$emit('selected', name);
                  }
                }, {
                  text: 'Remove Param',
                  func: function func() {
                    _this.automaton.removeParam(name);

                    _this.$emit('selected', null);
                  }
                }]
              });
            }
          }
        };
      })();

      if (module.exports.__esModule) module.exports = module.exports.default;

      var __vue__options__ = typeof module.exports === "function" ? module.exports.options : module.exports;

      if (__vue__options__.functional) {
        console.error("[vueify] functional components are not supported and should be defined in plain js files using render functions.");
      }

      __vue__options__.render = function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', [_c('Scrollable', {
          staticClass: "root",
          attrs: {
            "bar": "left"
          }
        }, _vm._l(_vm.automaton.getParamNames(), function (name) {
          return _c('div', {
            key: 'param' + name,
            staticClass: "param",
            class: {
              selected: name === _vm.selectedParamName
            },
            attrs: {
              "stalker-text": name
            },
            on: {
              "click": function click($event) {
                _vm.$emit('selected', name);
              },
              "contextmenu": function contextmenu($event) {
                $event.stopPropagation();
                $event.preventDefault();

                _vm.contextParam($event, name);
              }
            }
          }, [_c('div', {
            staticClass: "name",
            attrs: {
              "stalker-text": name
            }
          }, [_vm._v(_vm._s(name))]), _vm._v(" "), _vm.automaton.getParam(name).isUsed() ? _c('div', {
            staticClass: "value",
            attrs: {
              "stalker-text": name
            }
          }, [_vm._v(_vm._s(_vm.automaton.auto(name).toFixed(3)))]) : _vm._e(), _vm._v(" "), !_vm.automaton.getParam(name).isUsed() ? _c('img', {
            staticClass: "warning",
            attrs: {
              "src": require('../images/warning.svg'),
              "stalker-text": "This param has not been used yet"
            }
          }) : _vm._e()]);
        }))], 1);
      };

      __vue__options__.staticRenderFns = [];
      __vue__options__._scopeId = "data-v-3e0dc8f9";

      if (module.hot) {
        (function () {
          var hotAPI = require("vue-hot-reload-api");

          hotAPI.install(require("vue"), true);
          if (!hotAPI.compatible) return;
          module.hot.accept();
          module.hot.dispose(__vueify_style_dispose__);

          if (!module.hot.data) {
            hotAPI.createRecord("data-v-3e0dc8f9", __vue__options__);
          } else {
            hotAPI.rerender("data-v-3e0dc8f9", __vue__options__);
          }
        })();
      }
    }, {
      "../images/warning.svg": 96,
      "./scrollable.vue": 109,
      "vue": 65,
      "vue-hot-reload-api": 64,
      "vueify/lib/insert-css": 66
    }],
    107: [function (require, module, exports) {
      var __vueify_style_dispose__ = require("vueify/lib/insert-css").insert("/* line 144, stdin */\n.propbox {\n  position: relative;\n  width: 100%;\n  height: 1.25em;\n  margin-bottom: 0.25em; }\n  /* line 150, stdin */\n  .propbox .name {\n    position: absolute;\n    left: 0;\n    top: 0;\n    height: 100%;\n    margin-top: 0.1em; }\n  /* line 159, stdin */\n  .propbox .value {\n    background: #2c3236;\n    cursor: pointer; }\n    /* line 162, stdin */\n    .propbox .value:active:not(.readonly) {\n      background: #0e1011; }\n    /* line 168, stdin */\n    .propbox .value.readonly {\n      cursor: not-allowed; }\n  /* line 173, stdin */\n  .propbox .number {\n    position: absolute;\n    right: 0;\n    top: 0;\n    width: 5em;\n    height: 100%; }\n    /* line 180, stdin */\n    .propbox .number .valueText {\n      width: 100%;\n      margin-top: 0.1em;\n      text-align: center; }\n      /* line 186, stdin */\n      .propbox .number .valueText.readonly {\n        opacity: 0.5; }\n    /* line 191, stdin */\n    .propbox .number .valueInput {\n      position: absolute;\n      left: 0;\n      top: 0;\n      width: 100%;\n      height: 100%;\n      border: none;\n      padding: 0;\n      text-align: center;\n      background: #4a545a;\n      color: #c9e2ff; }\n  /* line 206, stdin */\n  .propbox .boolean {\n    position: absolute;\n    right: 1.875em;\n    top: 0;\n    width: 1.25em;\n    height: 100%; }\n    /* line 213, stdin */\n    .propbox .boolean .booleanCheck {\n      position: absolute;\n      left: 20%;\n      top: 20%;\n      width: 60%;\n      height: 60%;\n      background: #22aaff; }\n      /* line 222, stdin */\n      .propbox .boolean .booleanCheck.readonly {\n        background: #687788;\n        opacity: 0.5; }");

      (function () {
        "use strict";

        Object.defineProperty(exports, "__esModule", {
          value: true
        });

        var _log = require("babel-runtime/core-js/math/log10");

        var _log2 = _interopRequireDefault(_log);

        var _sign = require("babel-runtime/core-js/math/sign");

        var _sign2 = _interopRequireDefault(_sign);

        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : {
            default: obj
          };
        }

        var mouseEvents = function mouseEvents(move, up) {
          var u = function u(event) {
            if (typeof up === "function") {
              up(event);
            }

            window.removeEventListener("mousemove", move);
            window.removeEventListener("mouseup", u);
          };

          window.addEventListener("mousemove", move);
          window.addEventListener("mouseup", u);
        };

        exports.default = {
          name: 'propbox',
          props: ['name', 'value', 'type', 'min', 'max', 'readonly'],
          data: function data() {
            return {
              input: false,
              lastClick: 0
            };
          },
          methods: {
            nMousedown: function nMousedown(event) {
              var _this = this;

              if (this.readonly) {
                return;
              }

              var now = Date.now();

              if (now - this.lastClick < 500) {
                this.input = true;
                this.$refs.valueInput.value = this.value;
                setTimeout(function () {
                  _this.$refs.valueInput.focus();

                  _this.$refs.valueInput.select();
                }, 10);
              }

              this.lastClick = now;
              var y0 = event.clientY;
              var lastY = y0;
              var v0 = Number(this.value);
              mouseEvents(function (event) {
                var v = Number(_this.value);
                var y = event.clientY;
                var dy = lastY - y;
                lastY = y;

                if (_this.type === 'int') {
                  v = v0 - Math.floor((y - y0) / 10.0);
                } else if (event.shiftKey) {
                  var dyAbs = Math.abs(dy);
                  var dySign = (0, _sign2.default)(dy);

                  for (var i = 0; i < dyAbs; i++) {
                    var vAbs = Math.abs(v);
                    var vSign = (0, _sign2.default)(v + 1E-4 * dySign);
                    var order = Math.floor((0, _log2.default)(vAbs + 1E-4 * dySign * vSign)) - 1 - (event.altKey ? 1 : 0);
                    v += Math.max(0.001, Math.pow(10.0, order)) * dySign;
                  }
                } else {
                  v += dy * (event.altKey ? 0.001 : 0.01);
                }

                if (_this.max) {
                  v = Math.min(v, parseFloat(_this.max));
                }

                if (_this.min) {
                  v = Math.max(v, parseFloat(_this.min));
                }

                v = _this.type === 'int' ? v : Number(v.toFixed(3));

                _this.$emit('changed', v);
              }, function (event) {
                if (v0 === Number(_this.value)) {
                  return;
                }

                _this.$emit('finished', [v0, Number(_this.value)]);
              });
            },
            nEnter: function nEnter(event) {
              var v = parseFloat(this.$refs.valueInput.value);

              if (this.type === 'int') {
                v = Math.round(v);
              }

              this.$emit('changed', v);
              this.$emit('finished', [Number(this.value), v]);
              this.input = false;
            },
            nBlur: function nBlur(event) {
              this.input = false;
            },
            bToggle: function bToggle(event) {
              if (this.readonly) {
                return;
              }

              var v = !this.value;
              this.$emit('changed', v);
              this.$emit('finished', [!v, v]);
            }
          }
        };
      })();

      if (module.exports.__esModule) module.exports = module.exports.default;

      var __vue__options__ = typeof module.exports === "function" ? module.exports.options : module.exports;

      if (__vue__options__.functional) {
        console.error("[vueify] functional components are not supported and should be defined in plain js files using render functions.");
      }

      __vue__options__.render = function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', [_c('div', {
          staticClass: "propbox"
        }, [_c('div', {
          staticClass: "name"
        }, [_vm._v(_vm._s(_vm.name))]), _vm._v(" "), _vm.type === 'float' || _vm.type === 'int' ? _c('div', {
          staticClass: "value number",
          class: {
            readonly: _vm.readonly
          }
        }, [_c('div', {
          staticClass: "valueText",
          class: {
            readonly: _vm.readonly
          },
          on: {
            "mousedown": _vm.nMousedown
          }
        }, [_vm._v(_vm._s(_vm.type === 'int' ? _vm.value : _vm.value.toFixed(3)))]), _vm._v(" "), _c('input', {
          directives: [{
            name: "show",
            rawName: "v-show",
            value: _vm.input,
            expression: "input"
          }],
          ref: "valueInput",
          staticClass: "valueInput",
          on: {
            "keydown": function keydown($event) {
              if (!('button' in $event) && _vm._k($event.keyCode, "enter", 13, $event.key, "Enter")) {
                return null;
              }

              return _vm.nEnter($event);
            },
            "blur": _vm.nBlur
          }
        })]) : _vm._e(), _vm._v(" "), _vm.type === 'boolean' ? _c('div', {
          staticClass: "value boolean",
          class: {
            readonly: _vm.readonly
          },
          on: {
            "click": _vm.bToggle
          }
        }, [_c('div', {
          directives: [{
            name: "show",
            rawName: "v-show",
            value: _vm.value,
            expression: "value"
          }],
          staticClass: "booleanCheck"
        })]) : _vm._e()])]);
      };

      __vue__options__.staticRenderFns = [];

      if (module.hot) {
        (function () {
          var hotAPI = require("vue-hot-reload-api");

          hotAPI.install(require("vue"), true);
          if (!hotAPI.compatible) return;
          module.hot.accept();
          module.hot.dispose(__vueify_style_dispose__);

          if (!module.hot.data) {
            hotAPI.createRecord("data-v-1a0e28d6", __vue__options__);
          } else {
            hotAPI.rerender("data-v-1a0e28d6", __vue__options__);
          }
        })();
      }
    }, {
      "babel-runtime/core-js/math/log10": 2,
      "babel-runtime/core-js/math/sign": 3,
      "vue": 65,
      "vue-hot-reload-api": 64,
      "vueify/lib/insert-css": 66
    }],
    108: [function (require, module, exports) {
      var __vueify_style_dispose__ = require("vueify/lib/insert-css").insert("/* line 331, stdin */\n.root[data-v-ffc62e38] {\n  position: absolute;\n  left: 0;\n  top: 0;\n  width: 100%;\n  height: 100%;\n  background: #202325;\n  color: #c9e2ff; }\n  /* line 341, stdin */\n  .root .props[data-v-ffc62e38] {\n    padding: 0.75em 1.5em;\n    font-size: 0.75em; }\n    /* line 345, stdin */\n    .root .props .title[data-v-ffc62e38] {\n      overflow: hidden;\n      text-overflow: ellipsis;\n      white-space: nowrap;\n      font-size: 1.5em;\n      color: #22aaff; }\n    /* line 354, stdin */\n    .root .props hr[data-v-ffc62e38] {\n      border: solid 1px #2c3236; }\n    /* line 358, stdin */\n    .root .props .centering[data-v-ffc62e38] {\n      text-align: center; }\n      /* line 361, stdin */\n      .root .props .centering .button-confirm[data-v-ffc62e38] {\n        display: inline-block;\n        width: 4em;\n        padding: 0.25em;\n        background: #2c3236;\n        cursor: pointer; }\n        /* line 370, stdin */\n        .root .props .centering .button-confirm[data-v-ffc62e38]:hover {\n          background: #0e1011; }\n  /* line 375, stdin */\n  .root .logobox[data-v-ffc62e38] {\n    position: absolute;\n    left: 0;\n    top: 0;\n    width: 100%;\n    height: 100%;\n    overflow: hidden; }\n    /* line 383, stdin */\n    .root .logobox .logo[data-v-ffc62e38] {\n      position: absolute;\n      width: 8em;\n      left: calc( 50% - 4em);\n      top: calc( 50% - 4em);\n      opacity: 0.1; }");

      (function () {
        'use strict';

        Object.defineProperty(exports, "__esModule", {
          value: true
        });

        var _propbox = require('./propbox.vue');

        var _propbox2 = _interopRequireDefault(_propbox);

        var _scrollable = require('./scrollable.vue');

        var _scrollable2 = _interopRequireDefault(_scrollable);

        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : {
            default: obj
          };
        }

        exports.default = {
          name: 'propmenu',
          props: ['automaton', 'selectedParamName', 'selectedNodeIds', 'selectedFxIds', 'config'],
          components: {
            Propbox: _propbox2.default,
            Scrollable: _scrollable2.default
          },
          data: function data() {
            return {
              generalConfigs: {
                length: 0,
                resolution: 0
              }
            };
          },
          methods: {
            confirmGeneralConfigs: function confirmGeneralConfigs() {
              this.automaton.setLength(this.generalConfigs.length);
              this.automaton.setResolution(this.generalConfigs.resolution);
            }
          },
          computed: {
            selectedParam: function selectedParam() {
              return this.automaton.getParam(this.selectedParamName);
            },
            selectedNodeId: function selectedNodeId() {
              return this.selectedNodeIds.length === 1 ? this.selectedNodeIds[0] : null;
            },
            selectedNode: function selectedNode() {
              return this.selectedNodeIds.length === 1 ? this.selectedParam.dumpNode(this.selectedNodeId) : null;
            },
            selectedFxId: function selectedFxId() {
              return this.selectedFxIds.length === 1 ? this.selectedFxIds[0] : null;
            },
            selectedFx: function selectedFx() {
              return this.selectedFxIds.length === 1 ? this.selectedParam.dumpFx(this.selectedFxId) : null;
            }
          },
          watch: {
            config: function config() {
              if (this.config === 'general') {
                this.generalConfigs.length = this.automaton.length;
                this.generalConfigs.resolution = this.automaton.resolution;
              }
            }
          }
        };
      })();

      if (module.exports.__esModule) module.exports = module.exports.default;

      var __vue__options__ = typeof module.exports === "function" ? module.exports.options : module.exports;

      if (__vue__options__.functional) {
        console.error("[vueify] functional components are not supported and should be defined in plain js files using render functions.");
      }

      __vue__options__.render = function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', [_c('Scrollable', {
          staticClass: "root",
          attrs: {
            "bar": "right"
          }
        }, [_vm.selectedNode ? _c('div', {
          staticClass: "props"
        }, [_c('div', {
          staticClass: "title"
        }, [_vm._v("Node")]), _vm._v(" "), _c('hr'), _vm._v(" "), _c('Propbox', {
          staticClass: "prop",
          attrs: {
            "type": "float",
            "name": "Time",
            "value": _vm.selectedNode.time,
            "readonly": !(_vm.selectedNode.in && _vm.selectedNode.out)
          },
          on: {
            "changed": function changed($event) {
              _vm.selectedParam.moveNode(_vm.selectedNodeId, $event);
            },
            "finished": function finished($event) {
              _vm.automaton.pushHistory('Change Node Time', function () {
                _vm.selectedParam.moveNode(_vm.selectedNodeId, $event[1]);
              }, function () {
                _vm.selectedParam.moveNode(_vm.selectedNodeId, $event[0]);
              });
            }
          }
        }), _vm._v(" "), _c('Propbox', {
          staticClass: "prop",
          attrs: {
            "type": "float",
            "name": "Value",
            "value": _vm.selectedNode.value
          },
          on: {
            "changed": function changed($event) {
              _vm.selectedParam.moveNode(_vm.selectedNodeId, undefined, $event);
            },
            "finished": function finished($event) {
              _vm.automaton.pushHistory('Change Node Value', function () {
                _vm.selectedParam.moveNode(_vm.selectedNodeId, undefined, $event[1]);
              }, function () {
                _vm.selectedParam.moveNode(_vm.selectedNodeId, undefined, $event[0]);
              });
            }
          }
        }), _vm._v(" "), _c('hr'), _vm._v(" "), _c('Propbox', {
          staticClass: "prop",
          attrs: {
            "type": "float",
            "name": "In Time",
            "value": _vm.selectedNode.in ? _vm.selectedNode.in.time : 0,
            "readonly": !_vm.selectedNode.in
          },
          on: {
            "changed": function changed($event) {
              _vm.selectedParam.moveHandle(_vm.selectedNodeId, false, $event);
            },
            "finished": function finished($event) {
              _vm.automaton.pushHistory('Change Node Time', function () {
                _vm.selectedParam.moveHandle(_vm.selectedNodeId, false, $event[1]);
              }, function () {
                _vm.selectedParam.moveHandle(_vm.selectedNodeId, false, $event[0]);
              });
            }
          }
        }), _vm._v(" "), _c('Propbox', {
          staticClass: "prop",
          attrs: {
            "type": "float",
            "name": "In Value",
            "value": _vm.selectedNode.in ? _vm.selectedNode.in.value : 0,
            "readonly": !_vm.selectedNode.in
          },
          on: {
            "changed": function changed($event) {
              _vm.selectedParam.moveHandle(_vm.selectedNodeId, false, undefined, $event);
            },
            "finished": function finished($event) {
              _vm.automaton.pushHistory('Change Node Value', function () {
                _vm.selectedParam.moveHandle(_vm.selectedNodeId, false, undefined, $event[1]);
              }, function () {
                _vm.selectedParam.moveHandle(_vm.selectedNodeId, false, undefined, $event[0]);
              });
            }
          }
        }), _vm._v(" "), _c('hr'), _vm._v(" "), _c('Propbox', {
          staticClass: "prop",
          attrs: {
            "type": "float",
            "name": "Out Time",
            "value": _vm.selectedNode.out ? _vm.selectedNode.out.time : 0,
            "readonly": !_vm.selectedNode.out
          },
          on: {
            "changed": function changed($event) {
              _vm.selectedParam.moveHandle(_vm.selectedNodeId, true, $event);
            },
            "finished": function finished($event) {
              _vm.automaton.pushHistory('Change Node Time', function () {
                _vm.selectedParam.moveHandle(_vm.selectedNodeId, true, $event[1]);
              }, function () {
                _vm.selectedParam.moveHandle(_vm.selectedNodeId, true, $event[0]);
              });
            }
          }
        }), _vm._v(" "), _c('Propbox', {
          staticClass: "prop",
          attrs: {
            "type": "float",
            "name": "Out Value",
            "value": _vm.selectedNode.out ? _vm.selectedNode.out.value : 0,
            "readonly": !_vm.selectedNode.out
          },
          on: {
            "changed": function changed($event) {
              _vm.selectedParam.moveHandle(_vm.selectedNodeId, true, undefined, $event);
            },
            "finished": function finished($event) {
              _vm.automaton.pushHistory('Change Node Value', function () {
                _vm.selectedParam.moveHandle(_vm.selectedNodeId, true, undefined, $event[1]);
              }, function () {
                _vm.selectedParam.moveHandle(_vm.selectedNodeId, true, undefined, $event[0]);
              });
            }
          }
        })], 1) : _vm._e(), _vm._v(" "), _vm.selectedFx ? _c('div', {
          staticClass: "props"
        }, [_c('div', {
          staticClass: "title"
        }, [_vm._v("Fx: " + _vm._s(_vm.automaton.getFxDefinitionName(_vm.selectedFx.def)))]), _vm._v(" "), _c('hr'), _vm._v(" "), _c('Propbox', {
          staticClass: "prop",
          attrs: {
            "type": "float",
            "name": "Time",
            "value": _vm.selectedFx.time
          },
          on: {
            "changed": function changed($event) {
              _vm.selectedParam.moveFx(_vm.selectedFxId, $event);
            },
            "finished": function finished($event) {
              _vm.automaton.pushHistory('Move Fx', function () {
                _vm.selectedParam.moveFx(_vm.selectedFxId, $event[1]);
              }, function () {
                _vm.selectedParam.moveFx(_vm.selectedFxId, $event[0]);
              });
            }
          }
        }), _vm._v(" "), _c('Propbox', {
          staticClass: "prop",
          attrs: {
            "type": "float",
            "name": "Length",
            "value": _vm.selectedFx.length
          },
          on: {
            "changed": function changed($event) {
              _vm.selectedParam.resizeFx(_vm.selectedFxId, $event);
            },
            "finished": function finished($event) {
              _vm.automaton.pushHistory('Move Fx', function () {
                _vm.selectedParam.resizeFx(_vm.selectedFxId, $event[1]);
              }, function () {
                _vm.selectedParam.resizeFx(_vm.selectedFxId, $event[0]);
              });
            }
          }
        }), _vm._v(" "), _c('Propbox', {
          staticClass: "prop",
          attrs: {
            "type": "boolean",
            "name": "Bypass",
            "value": _vm.selectedFx.bypass
          },
          on: {
            "finished": function finished($event) {
              _vm.automaton.pushHistory('Toggle Bypass Fx', function () {
                _vm.selectedParam.bypassFx(_vm.selectedFxId, $event[1]);
              }, function () {
                _vm.selectedParam.bypassFx(_vm.selectedFxId, $event[0]);
              }, true);
            }
          }
        }), _vm._v(" "), _c('hr'), _vm._v(" "), _vm._l(_vm.automaton.getFxDefinitionParams(_vm.selectedFx.def), function (param, key) {
          return _c('Propbox', {
            key: 'fxParam-' + key,
            staticClass: "prop",
            attrs: {
              "type": param.type,
              "name": param.name || key,
              "value": _vm.selectedFx.params[key]
            },
            on: {
              "changed": function changed($event) {
                _vm.selectedParam.changeFxParam(_vm.selectedFxId, key, $event);
              },
              "finished": function finished($event) {
                _vm.automaton.pushHistory('Change Fx Param', function () {
                  _vm.selectedParam.changeFxParam(_vm.selectedFxId, key, $event[1]);
                }, function () {
                  _vm.selectedParam.changeFxParam(_vm.selectedFxId, key, $event[0]);
                });
              }
            }
          });
        })], 2) : _vm._e(), _vm._v(" "), _vm.config === 'snap' ? _c('div', {
          staticClass: "props"
        }, [_c('div', {
          staticClass: "title"
        }, [_vm._v("Snap Settings")]), _vm._v(" "), _c('hr'), _vm._v(" "), _c('Propbox', {
          staticClass: "prop",
          attrs: {
            "name": "Enable Snap",
            "type": "boolean",
            "value": _vm.automaton.guiSettings.snapActive
          },
          on: {
            "changed": function changed($event) {
              _vm.automaton.guiSettings.snapActive = $event;
            }
          }
        }), _vm._v(" "), _c('Propbox', {
          staticClass: "prop",
          attrs: {
            "name": "Interval (Time)",
            "min": "0.0",
            "type": "float",
            "value": _vm.automaton.guiSettings.snapTime
          },
          on: {
            "changed": function changed($event) {
              _vm.automaton.guiSettings.snapTime = $event;
            }
          }
        }), _vm._v(" "), _c('Propbox', {
          staticClass: "prop",
          attrs: {
            "name": "Interval (Value)",
            "min": "0.0",
            "type": "float",
            "value": _vm.automaton.guiSettings.snapValue
          },
          on: {
            "changed": function changed($event) {
              _vm.automaton.guiSettings.snapValue = $event;
            }
          }
        })], 1) : _vm._e(), _vm._v(" "), _vm.config === 'general' ? _c('div', {
          staticClass: "props"
        }, [_c('div', {
          staticClass: "title"
        }, [_vm._v("General Config")]), _vm._v(" "), _c('hr'), _vm._v(" "), _c('Propbox', {
          staticClass: "prop",
          attrs: {
            "name": "Length",
            "type": "float",
            "min": "0",
            "value": _vm.generalConfigs.length
          },
          on: {
            "changed": function changed($event) {
              _vm.generalConfigs.length = $event;
            }
          }
        }), _vm._v(" "), _c('Propbox', {
          staticClass: "prop",
          attrs: {
            "name": "Resolution",
            "type": "int",
            "min": "1",
            "value": _vm.generalConfigs.resolution
          },
          on: {
            "changed": function changed($event) {
              _vm.generalConfigs.resolution = $event;
            }
          }
        }), _vm._v(" "), _c('hr'), _vm._v(" "), _c('div', {
          staticClass: "centering"
        }, [_vm._v("\n        This cannot be undone!\n        "), _c('div', {
          staticClass: "button-confirm",
          on: {
            "click": _vm.confirmGeneralConfigs
          }
        }, [_vm._v("Apply")])])], 1) : _vm._e()]), _vm._v(" "), !_vm.selectedNode && !_vm.selectedFx && !_vm.config ? _c('div', {
          staticClass: "logobox"
        }, [_c('img', {
          staticClass: "logo",
          attrs: {
            "src": require('../images/automaton-a.svg')
          }
        })]) : _vm._e()], 1);
      };

      __vue__options__.staticRenderFns = [];
      __vue__options__._scopeId = "data-v-ffc62e38";

      if (module.hot) {
        (function () {
          var hotAPI = require("vue-hot-reload-api");

          hotAPI.install(require("vue"), true);
          if (!hotAPI.compatible) return;
          module.hot.accept();
          module.hot.dispose(__vueify_style_dispose__);

          if (!module.hot.data) {
            hotAPI.createRecord("data-v-ffc62e38", __vue__options__);
          } else {
            hotAPI.rerender("data-v-ffc62e38", __vue__options__);
          }
        })();
      }
    }, {
      "../images/automaton-a.svg": 87,
      "./propbox.vue": 107,
      "./scrollable.vue": 109,
      "vue": 65,
      "vue-hot-reload-api": 64,
      "vueify/lib/insert-css": 66
    }],
    109: [function (require, module, exports) {
      var __vueify_style_dispose__ = require("vueify/lib/insert-css").insert("/* line 77, stdin */\n.root[data-v-696f5249] {\n  position: relative;\n  width: 100%;\n  height: 100%;\n  overflow: hidden; }\n  /* line 83, stdin */\n  .root .inside[data-v-696f5249] {\n    position: absolute;\n    left: 0;\n    width: 100%; }\n  /* line 89, stdin */\n  .root .bar[data-v-696f5249] {\n    position: absolute;\n    width: 4px;\n    background: #22aaff;\n    border-radius: 2px; }");

      (function () {
        'use strict';

        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports.default = {
          props: ['bar'],
          data: function data() {
            return {
              top: 0,
              barOpacity: 0.0
            };
          },
          methods: {
            onWheel: function onWheel(event) {
              event.preventDefault();
              this.top = this.top - event.deltaY;
              var scrollMax = this.$refs.inside.clientHeight - this.$refs.root.clientHeight;

              if (this.top < -scrollMax) {
                var overrun = -scrollMax - this.top;
                this.top = -scrollMax;
              }

              if (0 < this.top) {
                var _overrun = this.top;
                this.top = 0;
              }

              this.barHeight = 100.0 * this.$refs.root.clientHeight / this.$refs.inside.clientHeight;
              this.barTop = -100.0 * this.top / this.$refs.inside.clientHeight;
              this.barOpacity += Math.min(this.barOpacity + 0.1 * Math.abs(event.deltaY), 1.0);
            },
            update: function update() {
              this.barOpacity *= 0.9;
            }
          },
          mounted: function mounted() {
            var _this = this;

            var update = function update() {
              _this.update();

              requestAnimationFrame(update);
            };

            update();
          }
        };
      })();

      if (module.exports.__esModule) module.exports = module.exports.default;

      var __vue__options__ = typeof module.exports === "function" ? module.exports.options : module.exports;

      if (__vue__options__.functional) {
        console.error("[vueify] functional components are not supported and should be defined in plain js files using render functions.");
      }

      __vue__options__.render = function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', [_c('div', {
          ref: "root",
          staticClass: "root",
          on: {
            "wheel": function wheel($event) {
              $event.stopPropagation();
              return _vm.onWheel($event);
            }
          }
        }, [_c('div', {
          ref: "inside",
          staticClass: "inside",
          style: {
            top: _vm.top + 'px'
          }
        }, [_vm._t("default")], 2), _vm._v(" "), _c('div', {
          staticClass: "bar",
          style: {
            top: _vm.barTop + '%',
            height: _vm.barHeight + '%',
            left: _vm.bar === 'left' ? 0 : undefined,
            right: _vm.bar === 'right' ? 0 : undefined,
            opacity: _vm.barOpacity
          }
        })])]);
      };

      __vue__options__.staticRenderFns = [];
      __vue__options__._scopeId = "data-v-696f5249";

      if (module.hot) {
        (function () {
          var hotAPI = require("vue-hot-reload-api");

          hotAPI.install(require("vue"), true);
          if (!hotAPI.compatible) return;
          module.hot.accept();
          module.hot.dispose(__vueify_style_dispose__);

          if (!module.hot.data) {
            hotAPI.createRecord("data-v-696f5249", __vue__options__);
          } else {
            hotAPI.rerender("data-v-696f5249", __vue__options__);
          }
        })();
      }
    }, {
      "vue": 65,
      "vue-hot-reload-api": 64,
      "vueify/lib/insert-css": 66
    }],
    110: [function (require, module, exports) {
      var __vueify_style_dispose__ = require("vueify/lib/insert-css").insert("/* line 71, stdin */\n.root[data-v-5e81204c] {\n  position: fixed;\n  pointer-events: none;\n  white-space: nowrap;\n  padding: 0.2em 0.4em;\n  margin: 10px;\n  font-size: 0.8em;\n  background: rgba(0, 0, 0, 0.8);\n  color: #c9e2ff;\n  border-radius: 0.2em; }");

      (function () {
        'use strict';

        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports.default = {
          name: 'stalker',
          data: function data() {
            return {
              left: 0,
              right: 0,
              top: 0,
              bottom: 0,
              text: ''
            };
          },
          methods: {
            applyStalkerText: function applyStalkerText(el) {
              var _this = this;

              setTimeout(function () {
                _this.text = el.getAttribute('stalker-text');
              }, 10);
            }
          },
          mounted: function mounted() {
            var _this2 = this;

            window.addEventListener('mousemove', function (event) {
              var x = event.clientX;
              var y = event.clientY;
              var w = document.documentElement.clientWidth;
              var h = document.documentElement.clientHeight;
              var bLeftSide = w - 240 < x;
              var bUpSide = h - 40 < y;
              _this2.left = bLeftSide ? null : x;
              _this2.right = bLeftSide ? w - x : null;
              _this2.top = bUpSide ? null : y;
              _this2.bottom = bUpSide ? h - y : null;

              _this2.applyStalkerText(event.target);
            });
            window.addEventListener('mousedown', function (event) {
              _this2.applyStalkerText(event.target);
            });
            window.addEventListener('mouseup', function (event) {
              _this2.applyStalkerText(event.target);
            });
          }
        };
      })();

      if (module.exports.__esModule) module.exports = module.exports.default;

      var __vue__options__ = typeof module.exports === "function" ? module.exports.options : module.exports;

      if (__vue__options__.functional) {
        console.error("[vueify] functional components are not supported and should be defined in plain js files using render functions.");
      }

      __vue__options__.render = function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', [_vm.text ? _c('div', {
          staticClass: "root",
          style: {
            left: typeof _vm.left === 'number' ? _vm.left + "px" : undefined,
            right: typeof _vm.right === 'number' ? _vm.right + "px" : undefined,
            top: typeof _vm.top === 'number' ? _vm.top + "px" : undefined,
            bottom: typeof _vm.bottom === 'number' ? _vm.bottom + "px" : undefined
          }
        }, [_vm._v("\n    " + _vm._s(_vm.text) + "\n  ")]) : _vm._e()]);
      };

      __vue__options__.staticRenderFns = [];
      __vue__options__._scopeId = "data-v-5e81204c";

      if (module.hot) {
        (function () {
          var hotAPI = require("vue-hot-reload-api");

          hotAPI.install(require("vue"), true);
          if (!hotAPI.compatible) return;
          module.hot.accept();
          module.hot.dispose(__vueify_style_dispose__);

          if (!module.hot.data) {
            hotAPI.createRecord("data-v-5e81204c", __vue__options__);
          } else {
            hotAPI.rerender("data-v-5e81204c", __vue__options__);
          }
        })();
      }
    }, {
      "vue": 65,
      "vue-hot-reload-api": 64,
      "vueify/lib/insert-css": 66
    }],
    111: [function (require, module, exports) {
      var __vueify_style_dispose__ = require("vueify/lib/insert-css").insert("/* line 125, stdin */\n.blur-layer[data-v-6e78990b] {\n  position: fixed;\n  left: 0;\n  top: 0;\n  width: 100%;\n  height: 100%; }\n\n/* line 133, stdin */\n.root[data-v-6e78990b] {\n  position: absolute;\n  left: calc( 50% - 10em);\n  top: 1em;\n  width: 20em;\n  height: calc( 100% - 2em);\n  overflow: hidden;\n  background: #0e1011;\n  font-size: 0.8em;\n  filter: drop-shadow(0 0 2px #000000); }\n  /* line 146, stdin */\n  .root .search-box[data-v-6e78990b] {\n    position: relative;\n    font-size: 1em;\n    width: calc( 100% - 12px);\n    margin: 2px;\n    padding: 2px 4px;\n    border: none;\n    background: #3d4449;\n    color: #c9e2ff; }\n  /* line 158, stdin */\n  .root .fx-names[data-v-6e78990b] {\n    position: relative;\n    width: 100%;\n    height: calc( 100% - 1em - 12px); }\n    /* line 163, stdin */\n    .root .fx-names .fx-name[data-v-6e78990b] {\n      position: relative;\n      width: calc( 100% - 12px);\n      margin: 2px;\n      padding: 2px 4px;\n      white-space: nowrap;\n      overflow: hidden;\n      text-overflow: ellipsis;\n      background: #202325;\n      cursor: pointer; }\n      /* line 176, stdin */\n      .root .fx-names .fx-name[data-v-6e78990b]:hover {\n        background: #2c3236; }\n      /* line 177, stdin */\n      .root .fx-names .fx-name.selected[data-v-6e78990b] {\n        background: #2c3236; }");

      (function () {
        'use strict';

        Object.defineProperty(exports, "__esModule", {
          value: true
        });

        var _toConsumableArray2 = require('babel-runtime/helpers/toConsumableArray');

        var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

        var _scrollable = require('./scrollable.vue');

        var _scrollable2 = _interopRequireDefault(_scrollable);

        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : {
            default: obj
          };
        }

        exports.default = {
          props: ['automaton', 'active'],
          components: {
            Scrollable: _scrollable2.default
          },
          data: function data() {
            return {
              fxDefs: [],
              searchText: '',
              selectedIndex: 0
            };
          },
          methods: {
            filterDef: function filterDef(id) {
              var queries = this.searchText.split(/\s+/);
              var name = this.automaton.getFxDefinitionName(id);
              return queries.every(function (query) {
                return name.toLowerCase().includes(query.toLowerCase()) || id.toLowerCase().includes(query.toLowerCase());
              });
            },
            select: function select(id) {
              if (id === '') {
                this.blur();
                return;
              }

              this.$emit('selected', id);
              this.fxDefs.splice(this.fxDefs.indexOf(id), 1);
              this.fxDefs.unshift(id);
              this.blur();
            },
            blur: function blur() {
              this.$emit('blur');
              this.searchText = '';
              this.selectedIndex = 0;
            },
            onSearchBoxKeydown: function onSearchBoxKeydown(event) {
              if (event.which === 13) {
                this.select(this.fxDefsFiltered[this.selectedIndex]);
              } else if (event.which === 27) {
                this.blur();
              } else if (event.which === 38) {
                this.selectedIndex = (this.selectedIndex - 1 + this.fxDefsFiltered.length) % this.fxDefsFiltered.length;
              } else if (event.which === 40) {
                this.selectedIndex = (this.selectedIndex + 1) % this.fxDefsFiltered.length;
              } else {
                this.selectedIndex = 0;
              }
            }
          },
          mounted: function mounted() {
            this.fxDefs = this.automaton.getFxDefinitionIds();
          },
          computed: {
            fxDefsFiltered: function fxDefsFiltered() {
              var _fxDefs,
                  _this = this;

              (_fxDefs = this.fxDefs).push.apply(_fxDefs, (0, _toConsumableArray3.default)(this.automaton.getFxDefinitionIds().filter(function (id) {
                return _this.fxDefs.indexOf(id) === -1;
              })));

              var arr = this.fxDefs.filter(function (id) {
                return _this.filterDef(id);
              });
              return arr.length === 0 ? [''] : arr;
            }
          },
          watch: {
            active: function active(v) {
              var _this2 = this;

              if (!v) {
                return;
              }

              setTimeout(function () {
                _this2.$refs.searchBox.focus();
              }, 10);
            }
          }
        };
      })();

      if (module.exports.__esModule) module.exports = module.exports.default;

      var __vue__options__ = typeof module.exports === "function" ? module.exports.options : module.exports;

      if (__vue__options__.functional) {
        console.error("[vueify] functional components are not supported and should be defined in plain js files using render functions.");
      }

      __vue__options__.render = function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', [_vm.active ? _c('div', {
          staticClass: "blur-layer",
          on: {
            "mousedown": _vm.blur
          }
        }) : _vm._e(), _vm._v(" "), _vm.active ? _c('div', {
          staticClass: "root"
        }, [_c('input', {
          directives: [{
            name: "model",
            rawName: "v-model",
            value: _vm.searchText,
            expression: "searchText"
          }],
          ref: "searchBox",
          staticClass: "search-box",
          attrs: {
            "type": "text",
            "placeholder": "Add a fx..."
          },
          domProps: {
            "value": _vm.searchText
          },
          on: {
            "keydown": _vm.onSearchBoxKeydown,
            "input": function input($event) {
              if ($event.target.composing) {
                return;
              }

              _vm.searchText = $event.target.value;
            }
          }
        }), _vm._v(" "), _c('Scrollable', {
          staticClass: "fx-names",
          attrs: {
            "bar": "right"
          }
        }, _vm._l(_vm.fxDefsFiltered, function (id, index) {
          return _c('div', {
            key: id,
            staticClass: "fx-name",
            class: {
              selected: index === _vm.selectedIndex
            },
            attrs: {
              "stalker-text": _vm.automaton.getFxDefinitionDescription(id) || '(no description provided)'
            },
            on: {
              "mousedown": function mousedown($event) {
                _vm.select(id);
              }
            }
          }, [_vm._v("\n        " + _vm._s(id ? _vm.automaton.getFxDefinitionName(id) : '(No result found)') + "\n      ")]);
        }))], 1) : _vm._e()]);
      };

      __vue__options__.staticRenderFns = [];
      __vue__options__._scopeId = "data-v-6e78990b";

      if (module.hot) {
        (function () {
          var hotAPI = require("vue-hot-reload-api");

          hotAPI.install(require("vue"), true);
          if (!hotAPI.compatible) return;
          module.hot.accept();
          module.hot.dispose(__vueify_style_dispose__);

          if (!module.hot.data) {
            hotAPI.createRecord("data-v-6e78990b", __vue__options__);
          } else {
            hotAPI.rerender("data-v-6e78990b", __vue__options__);
          }
        })();
      }
    }, {
      "./scrollable.vue": 109,
      "babel-runtime/helpers/toConsumableArray": 4,
      "vue": 65,
      "vue-hot-reload-api": 64,
      "vueify/lib/insert-css": 66
    }],
    112: [function (require, module, exports) {
      var __vueify_style_dispose__ = require("vueify/lib/insert-css").insert("/* line 1036, stdin */\n.root[data-v-f3a8533a] {\n  position: absolute;\n  left: 0;\n  top: 0;\n  width: 100%;\n  height: 100%;\n  color: #c9e2ff; }\n  /* line 1045, stdin */\n  .root .hbar[data-v-f3a8533a] {\n    position: absolute;\n    left: 0;\n    bottom: 0;\n    width: 100%;\n    height: 4px;\n    background: #000000; }\n    /* line 1054, stdin */\n    .root .hbar .vision[data-v-f3a8533a] {\n      position: absolute;\n      bottom: 0;\n      height: 100%;\n      border-radius: 2px;\n      background: #22aaff; }\n  /* line 1065, stdin */\n  .root .svg[data-v-f3a8533a] {\n    background: #0e1011;\n    font-size: 10px;\n    pointer-events: none; }\n    /* line 1072, stdin */\n    .root .svg .grid[data-v-f3a8533a] {\n      stroke: #c9e2ff;\n      stroke-width: 1; }\n    /* line 1077, stdin */\n    .root .svg .grid-text[data-v-f3a8533a] {\n      fill: #c9e2ff; }\n    /* line 1081, stdin */\n    .root .svg .graph[data-v-f3a8533a] {\n      fill: none;\n      stroke: #c9e2ff;\n      stroke-width: 2; }\n    /* line 1087, stdin */\n    .root .svg .currentLine[data-v-f3a8533a] {\n      stroke: #22aaff;\n      stroke-width: 2; }\n    /* line 1092, stdin */\n    .root .svg .currentText[data-v-f3a8533a] {\n      fill: #22aaff; }\n    /* line 1096, stdin */\n    .root .svg .currentPoint[data-v-f3a8533a] {\n      fill: #22aaff; }\n    /* line 1102, stdin */\n    .root .svg .node .handle .line[data-v-f3a8533a] {\n      stroke: #22aaff;\n      stroke-width: 1; }\n    /* line 1107, stdin */\n    .root .svg .node .handle .circle[data-v-f3a8533a] {\n      fill: #22aaff;\n      pointer-events: auto;\n      cursor: pointer; }\n    /* line 1115, stdin */\n    .root .svg .node .body[data-v-f3a8533a] {\n      fill: #0e1011;\n      stroke: #22aaff;\n      stroke-width: 2;\n      pointer-events: auto;\n      cursor: pointer; }\n      /* line 1123, stdin */\n      .root .svg .node .body.selected[data-v-f3a8533a] {\n        fill: #22aaff; }\n    /* line 1130, stdin */\n    .root .svg .fx .line[data-v-f3a8533a] {\n      stroke: #0fd895;\n      stroke-width: 1;\n      stroke-dasharray: 4; }\n    /* line 1136, stdin */\n    .root .svg .fx .fill[data-v-f3a8533a] {\n      fill: #0fd895;\n      opacity: 0.1; }\n    /* line 1141, stdin */\n    .root .svg .fx .body[data-v-f3a8533a] {\n      fill: #0e1011;\n      stroke: #0fd895;\n      stroke-width: 2;\n      pointer-events: auto;\n      cursor: pointer; }\n      /* line 1146, stdin */\n      .root .svg .fx .body.bypass[data-v-f3a8533a] {\n        fill: #0e1011;\n        stroke: #687788; }\n      /* line 1151, stdin */\n      .root .svg .fx .body.selected[data-v-f3a8533a] {\n        fill: #0fd895;\n        stroke: #0e1011; }\n        /* line 1155, stdin */\n        .root .svg .fx .body.selected.bypass[data-v-f3a8533a] {\n          fill: #687788;\n          stroke: #0e1011; }\n    /* line 1165, stdin */\n    .root .svg .fx .text[data-v-f3a8533a] {\n      fill: #0fd895; }\n      /* line 1167, stdin */\n      .root .svg .fx .text.bypass[data-v-f3a8533a] {\n        fill: #687788; }\n      /* line 1168, stdin */\n      .root .svg .fx .text.selected[data-v-f3a8533a] {\n        fill: #0e1011; }\n    /* line 1171, stdin */\n    .root .svg .fx .side[data-v-f3a8533a] {\n      fill: rgba(0, 0, 0, 0);\n      pointer-events: auto;\n      cursor: ew-resize; }");

      (function () {
        'use strict';

        Object.defineProperty(exports, "__esModule", {
          value: true
        });

        var _log = require('babel-runtime/core-js/math/log10');

        var _log2 = _interopRequireDefault(_log);

        var _paramGui = require('../param-gui');

        var _paramGui2 = _interopRequireDefault(_paramGui);

        var _timelineFxmenu = require('./timeline-fxmenu.vue');

        var _timelineFxmenu2 = _interopRequireDefault(_timelineFxmenu);

        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : {
            default: obj
          };
        }

        var mouseEvents = function mouseEvents(move, up) {
          var u = function u(event) {
            if (up) {
              up(event);
            }

            window.removeEventListener("mousemove", move);
            window.removeEventListener("mouseup", u);
          };

          window.addEventListener("mousemove", move);
          window.addEventListener("mouseup", u);
        };

        exports.default = {
          components: {
            FxMenu: _timelineFxmenu2.default
          },
          props: ["automaton", "selectedParamName", "selectedNodeIds", "selectedFxIds"],
          data: function data() {
            return {
              width: 100,
              height: 100,
              t0: 0.0,
              t1: this.automaton.length,
              v0: -0.25,
              v1: 1.25,
              grid: {
                x: [],
                y: []
              },
              graphPoints: '',
              fxmenuActive: false,
              fxmenuTime: 0
            };
          },
          methods: {
            updateGrid: function updateGrid() {
              this.grid = {
                x: [],
                y: []
              };
              {
                var delta = this.t1 - this.t0;
                var logDelta = (0, _log2.default)(delta);
                var scale = Math.pow(10.0, Math.floor(logDelta) - 1.0);
                var intrv = logDelta - Math.floor(logDelta);
                var num = Math.floor(this.t0 / scale);
                var begin = num * scale;
                var accent10 = num - Math.floor(num / 10) * 10;
                var accent100 = num - Math.floor(num / 100) * 100;

                for (var v = begin; v < this.t1; v += scale) {
                  var op = accent100 === 0 ? 0.4 : accent10 === 0 ? 0.4 - intrv * 0.3 : 0.1 - intrv * 0.3;

                  if (0.0 < op) {
                    this.grid.x.push({
                      val: v + 1E-9,
                      pos: this.t2x(v),
                      op: op
                    });
                  }

                  accent10 = (accent10 + 1) % 10;
                  accent100 = (accent100 + 1) % 100;
                }
              }
              {
                var _delta = this.v1 - this.v0;

                var _logDelta = (0, _log2.default)(_delta);

                var _scale = Math.pow(10.0, Math.floor(_logDelta) - 1.0);

                var _intrv = _logDelta - Math.floor(_logDelta);

                var _num = Math.floor(this.v0 / _scale);

                var _begin = _num * _scale;

                var _accent = _num - Math.floor(_num / 10) * 10;

                var _accent2 = _num - Math.floor(_num / 100) * 100;

                for (var _v = _begin; _v < this.v1; _v += _scale) {
                  var _op = _accent2 === 0 ? 0.4 : _accent === 0 ? 0.4 - _intrv * 0.3 : 0.1 - _intrv * 0.3;

                  if (0.0 < _op) {
                    this.grid.y.push({
                      val: _v + 1E-9,
                      pos: this.v2y(_v),
                      op: _op
                    });
                  }

                  _accent = (_accent + 1) % 10;
                  _accent2 = (_accent2 + 1) % 100;
                }
              }
            },
            updateGraph: function updateGraph() {
              var param = this.selectedParam;

              if (!param) {
                return;
              }

              var points = '';

              for (var x = 0; x <= this.width; x++) {
                var t = this.x2t(x);
                var v = param.getValue(t);
                var y = this.v2y(v);
                points += x + ' ' + y + ' ';
              }

              this.graphPoints = points;
            },
            x2t: function x2t(x) {
              var u = x / this.width;
              return u * (this.t1 - this.t0) + this.t0;
            },
            t2x: function t2x(t) {
              var u = (t - this.t0) / (this.t1 - this.t0);
              return u * this.width;
            },
            y2v: function y2v(y) {
              var u = 1.0 - y / this.height;
              return u * (this.v1 - this.v0) + this.v0;
            },
            v2y: function v2y(v) {
              var u = 1.0 - (v - this.v0) / (this.v1 - this.v0);
              return u * this.height;
            },
            moveView: function moveView(dx, dy) {
              var dt = this.x2t(0.0) - this.x2t(dx);
              var dv = this.y2v(0.0) - this.y2v(dy);
              dt = Math.min(Math.max(dt, -this.t0), this.automaton.length - this.t1);
              this.t0 += dt;
              this.t1 += dt;
              this.v0 += dv;
              this.v1 += dv;
              this.updateGrid();
              this.updateGraph();
            },
            zoomView: function zoomView(ct, cv, dx, dy) {
              var rt = (ct - this.t0) / (this.t1 - this.t0);
              var rv = (cv - this.v0) / (this.v1 - this.v0);
              var dt = this.t1 - this.t0;
              dt *= Math.pow((this.width + 1.0) / this.width, dx * 2.0);
              dt = Math.min(Math.max(dt, 0.01), 1000.0);
              var dv = this.v1 - this.v0;
              dv *= Math.pow((this.width + 1.0) / this.width, dy * 2.0);
              dv = Math.min(Math.max(dv, 0.01), 1000.0);
              this.t0 = ct - rt * dt;
              this.t1 = ct + (1.0 - rt) * dt;
              this.v0 = cv - rv * dv;
              this.v1 = cv + (1.0 - rv) * dv;

              if (this.t0 < 0.0) {
                this.t1 = Math.max(this.t1 - this.t0, this.t1);
              }

              if (this.automaton.length < this.t1) {
                this.t0 += this.automaton.length - this.t1;
              }

              if (this.t0 < 0.0) {
                this.t0 = 0.0;
              }

              if (this.automaton.length < this.t1) {
                this.t1 = this.automaton.length;
              }

              this.updateGrid();
              this.updateGraph();
            },
            createNode: function createNode(t, v) {
              var param = this.selectedParam;

              if (!param) {
                return;
              }

              var id = param.createNode(t, v);
              var data = param.dumpNode(id);
              this.$emit('nodeSelected', [id]);
              this.$emit('fxSelected', []);
              this.automaton.pushHistory('Create Node', function () {
                return param.createNodeFromData(data);
              }, function () {
                return param.removeNode(id);
              });
            },
            removeNode: function removeNode(id) {
              var param = this.selectedParam;

              if (!param) {
                return;
              }

              var node = param.dumpNode(id);

              if (!(node.in && node.out)) {
                return;
              }

              this.automaton.pushHistory('Remove Node', function () {
                return param.removeNode(id);
              }, function () {
                return param.createNodeFromData(node);
              }, true);
              this.$emit('nodeSelected', []);
            },
            removeHandle: function removeHandle(id, isOut) {
              var param = this.selectedParam;

              if (!param) {
                return;
              }

              var node = param.dumpNode(id);
              var t0 = isOut ? node.out.time : node.in.time;
              var v0 = isOut ? node.out.value : node.in.value;
              param.moveHandle(id, isOut, 0.0, 0.0);
              this.automaton.pushHistory('Remove Handle', function () {
                return param.moveHandle(id, isOut, 0.0, 0.0);
              }, function () {
                return param.moveHandle(id, isOut, t0, v0);
              }, true);
            },
            resetHandles: function resetHandles(id) {
              var param = this.selectedParam;

              if (!param) {
                return;
              }

              var node = param.dumpNode(id);
              this.automaton.pushHistory('Reset Handle', function () {
                param.resetHandle(id, false);
                param.resetHandle(id, true);
              }, function () {
                param.moveHandle(id, false, node.in.time, node.in.value);
                param.moveHandle(id, true, node.out.time, node.out.value);
              }, true);
            },
            grabHelper: function grabHelper(event, callback) {
              var _this = this;

              var x0 = event.clientX;
              var y0 = event.clientY;
              var t0 = this.x2t(x0);
              var v0 = this.y2v(y0);
              var moved = false;

              var move = function move(event) {
                var dt = _this.x2t(event.clientX) - t0;
                var dv = _this.y2v(event.clientY) - v0;
                moved = true;
                callback(dt, dv, event);
              };

              var up = function up(event) {
                if (moved) {
                  var dt = _this.x2t(event.clientX) - t0;
                  var dv = _this.y2v(event.clientY) - v0;
                  callback(dt, dv, event, true);
                }

                window.removeEventListener('mousemove', move);
                window.removeEventListener('mouseup', up);
              };

              window.addEventListener('mousemove', move);
              window.addEventListener('mouseup', up);
            },
            snapTime: function snapTime(time) {
              if (!this.automaton.guiSettings.snapActive) {
                return time;
              }

              var interval = this.automaton.guiSettings.snapTime;
              var width = 5.0 / this.width * (this.t1 - this.t0);
              var nearest = Math.round(time / interval) * interval;
              return Math.abs(time - nearest) < width ? nearest : time;
            },
            snapValue: function snapValue(value) {
              if (!this.automaton.guiSettings.snapActive) {
                return value;
              }

              var interval = this.automaton.guiSettings.snapValue;
              var width = 5.0 / this.height * (this.v1 - this.v0);
              var nearest = Math.round(value / interval) * interval;
              return Math.abs(value - nearest) < width ? nearest : value;
            },
            grabNode: function grabNode(id, event) {
              var _this2 = this;

              var param = this.selectedParam;

              if (!param) {
                return;
              }

              this.$emit('nodeSelected', [id]);
              this.$emit('fxSelected', []);
              var node = param.dumpNode(id);
              var t0 = node.time;
              var v0 = node.value;
              this.grabHelper(event, function (dt, dv, event, isUp) {
                var t = t0 + dt;
                var v = v0 + dv;

                if (!event.altKey) {
                  t = _this2.snapTime(t);
                  v = _this2.snapValue(v);
                }

                if (event.shiftKey) {
                  v = v0;
                } else if (event.ctrlKey || event.metaKey) {
                  t = t0;
                }

                param.moveNode(id, t, v);

                if (isUp) {
                  _this2.automaton.pushHistory('Move Node', function () {
                    return param.moveNode(id, t, v);
                  }, function () {
                    return param.moveNode(id, t0, v0);
                  });
                }
              });
            },
            grabHandle: function grabHandle(id, isOut, event) {
              var _this3 = this;

              var param = this.selectedParam;

              if (!param) {
                return;
              }

              var node = param.dumpNode(id);
              var handle = isOut ? node.out : node.in;
              var t0 = handle.time;
              var v0 = handle.value;
              var len0 = Math.sqrt(t0 * t0 + v0 * v0);
              var nt0 = t0 / len0;
              var nv0 = v0 / len0;
              var handleOp = isOut ? node.in : node.out;
              var tOp0 = handleOp ? handleOp.time : 0.0;
              var vOp0 = handleOp ? handleOp.value : 0.0;
              this.grabHelper(event, function (dt, dv, event, isUp) {
                var t = t0 + dt;
                var v = v0 + dv;
                var tOp = tOp0;
                var vOp = vOp0;

                if (event.shiftKey) {
                  var dot = t * nt0 + v * nv0;
                  t = dot * nt0;
                  v = dot * nv0;
                } else if (event.ctrlKey || event.metaKey) {
                  tOp = -t;
                  vOp = -v;
                }

                param.moveHandle(id, isOut, t, v);
                param.moveHandle(id, !isOut, tOp, vOp);

                if (isUp) {
                  _this3.automaton.pushHistory('Move Handle', function () {
                    param.moveHandle(id, isOut, t, v);
                    param.moveHandle(id, !isOut, tOp, vOp);
                  }, function () {
                    param.moveHandle(id, isOut, t0, v0);
                    param.moveHandle(id, !isOut, tOp0, vOp0);
                  });
                }
              });
            },
            openFxMenu: function openFxMenu(time) {
              this.fxmenuActive = true;
              this.fxmenuTime = time;
            },
            createFx: function createFx(event, name) {
              var param = this.selectedParam;

              if (!param) {
                return;
              }

              var t = this.fxmenuTime;
              var l = Math.min(1.0, this.automaton.length - this.fxmenuTime);
              var id = param.createFx(t, l, name);
              var data = param.dumpFx(id);

              if (!id) {
                return;
              }

              this.$emit('nodeSelected', []);
              this.$emit('fxSelected', [id]);
              this.automaton.pushHistory('Create Fx', function () {
                return param.createFxFromData(data);
              }, function () {
                return param.removeFx(id);
              });
            },
            removeFx: function removeFx(id) {
              var param = this.selectedParam;

              if (!param) {
                return;
              }

              var fx = param.dumpFx(id);
              this.automaton.pushHistory('Remove Fx', function () {
                return param.removeFx(id);
              }, function () {
                return param.createFxFromData(fx);
              }, true);
              this.$emit('fxSelected', []);
            },
            grabFxBody: function grabFxBody(id, event) {
              var _this4 = this;

              var param = this.selectedParam;

              if (!param) {
                return;
              }

              this.$emit('nodeSelected', []);
              this.$emit('fxSelected', [id]);
              var fx = param.dumpFx(id);
              var t0 = fx.time;
              var r0 = fx.row;
              var y0 = event.clientY;
              this.grabHelper(event, function (dt, dv, event, isUp) {
                var dy = event.clientY - y0;
                var newRow = Math.min(Math.max(r0 + Math.round(dy / 16.0), 0), _paramGui2.default.FX_ROW_MAX);
                var t = t0 + dt;

                if (!event.altKey) {
                  t = _this4.snapTime(t);
                }

                param.moveFx(id, t);
                param.changeFxRow(id, newRow);

                if (isUp) {
                  _this4.automaton.pushHistory('Move Fx', function () {
                    return param.forceMoveFx(id, t, newRow);
                  }, function () {
                    return param.forceMoveFx(id, t0, r0);
                  });
                }
              });
            },
            grabFxLeft: function grabFxLeft(id, event) {
              var _this5 = this;

              var param = this.selectedParam;

              if (!param) {
                return;
              }

              this.$emit('nodeSelected', []);
              this.$emit('fxSelected', [id]);
              var fx = param.dumpFx(id);
              var l0 = fx.length;
              var end0 = fx.time + l0;
              this.grabHelper(event, function (dt, dv, event, isUp) {
                var l = l0 - dt;

                if (!event.altKey) {
                  l = _this5.snapTime(l - end0) + end0;
                }

                param.resizeFxByLeft(id, l);

                if (isUp) {
                  _this5.automaton.pushHistory('Resize Fx', function () {
                    return param.resizeFxByLeft(id, l);
                  }, function () {
                    return param.resizeFxByLeft(id, l0);
                  });
                }
              });
            },
            grabFxRight: function grabFxRight(id, event) {
              var _this6 = this;

              var param = this.selectedParam;

              if (!param) {
                return;
              }

              this.$emit('nodeSelected', []);
              this.$emit('fxSelected', [id]);
              var fx = param.dumpFx(id);
              var l0 = fx.length;
              var t0 = fx.time;
              this.grabHelper(event, function (dt, dv, event, isUp) {
                var l = l0 + dt;

                if (!event.altKey) {
                  l = _this6.snapTime(l + t0) - t0;
                }

                param.resizeFx(id, l);

                if (isUp) {
                  _this6.automaton.pushHistory('Resize Fx', function () {
                    return param.resizeFx(id, l);
                  }, function () {
                    return param.resizeFx(id, l0);
                  });
                }
              });
            },
            dragBg: function dragBg(event) {
              var _this7 = this;

              var t0 = this.x2t(event.offsetX);
              var v0 = this.y2v(event.offsetY);
              var which = event.which;
              var shiftKey = event.shiftKey;
              var altKey = event.altKey;
              var x0 = event.clientX;
              var y0 = event.clientY;
              var xPrev = x0;
              var yPrev = y0;
              var isPlaying0 = this.automaton.isPlaying;

              if (altKey) {
                this.automaton.seek(t0);

                if (isPlaying0) {
                  this.automaton.pause();
                }
              }

              var move = function move(event) {
                var x = event.clientX;
                var y = event.clientY;
                var dx = event.clientX - xPrev;
                var dy = event.clientY - yPrev;

                if (which === 1) {
                  if (altKey) {
                    _this7.automaton.seek(t0 + _this7.x2t(x - x0));
                  }
                } else if (which === 2) {
                  if (shiftKey) {
                    _this7.zoomView(t0, v0, -dx, dy);
                  } else {
                    _this7.moveView(dx, dy);
                  }
                }

                xPrev = x;
                yPrev = y;
              };

              var up = function up(event) {
                if (altKey && isPlaying0) {
                  _this7.automaton.play();
                }

                window.removeEventListener('mousemove', move);
                window.removeEventListener('mouseup', up);
              };

              window.addEventListener('mousemove', move);
              window.addEventListener('mouseup', up);
            },
            contextBg: function contextBg(event) {
              var _this8 = this;

              if (!this.selectedParam) {
                return;
              }

              var t = this.x2t(event.offsetX);
              var v = this.y2v(event.offsetY);
              this.$emit('context', {
                clientX: event.clientX,
                clientY: event.clientY,
                commands: [{
                  text: 'Add Node',
                  func: function func() {
                    _this8.createNode(t, v);
                  }
                }, {
                  text: 'Add Fx',
                  func: function func() {
                    _this8.openFxMenu(t);
                  }
                }]
              });
            },
            onWheel: function onWheel(event) {
              var t0 = this.x2t(event.offsetX);
              var v0 = this.y2v(event.offsetY);

              if (event.shiftKey) {
                this.zoomView(t0, v0, -event.deltaY, 0);
              } else if (event.ctrlKey || event.metaKey) {
                this.zoomView(t0, v0, 0, -event.deltaY);
              } else {
                this.moveView(event.deltaX, -event.deltaY);
              }

              this.updateGrid();
              this.updateGraph();
            },
            onResize: function onResize() {
              var _this9 = this;

              var el = this.$refs.root;
              this.width = el.clientWidth;
              this.height = el.clientHeight - 4;
              this.$nextTick(function () {
                _this9.updateGrid();

                _this9.updateGraph();
              });
            }
          },
          computed: {
            selectedParam: function selectedParam() {
              return this.automaton.getParam(this.selectedParamName);
            }
          },
          watch: {
            selectedParamName: function selectedParamName() {
              this.updateGraph();
            }
          },
          mounted: function mounted() {
            var _this10 = this;

            this.$root.$on('loaded', function () {
              _this10.t0 = 0.0;
              _this10.t1 = _this10.automaton.length;
            });
            this.$root.$on('changedLength', function () {
              _this10.t0 = 0.0;
              _this10.t1 = _this10.automaton.length;

              _this10.updateGraph();
            });
            this.$root.$on('poke', function () {
              _this10.updateGraph();
            });
            this.$nextTick(function () {
              _this10.onResize();
            });
            window.addEventListener('resize', this.onResize);
          },
          beforeDestroy: function beforeDestroy() {
            window.removeEventListener('resize', this.onResize);
          }
        };
      })();

      if (module.exports.__esModule) module.exports = module.exports.default;

      var __vue__options__ = typeof module.exports === "function" ? module.exports.options : module.exports;

      if (__vue__options__.functional) {
        console.error("[vueify] functional components are not supported and should be defined in plain js files using render functions.");
      }

      __vue__options__.render = function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', [_c('div', {
          ref: "root",
          staticClass: "root",
          on: {
            "wheel": function wheel($event) {
              $event.preventDefault();
              return _vm.onWheel($event);
            },
            "dragstart": function dragstart($event) {
              $event.preventDefault();
            },
            "mousedown": function mousedown($event) {
              $event.preventDefault();
              $event.stopPropagation();
              return _vm.dragBg($event);
            },
            "dblclick": function dblclick($event) {
              if (!('button' in $event) && _vm._k($event.keyCode, "left", 37, $event.key, ["Left", "ArrowLeft"])) {
                return null;
              }

              if ('button' in $event && $event.button !== 0) {
                return null;
              }

              $event.stopPropagation();

              _vm.createNode(_vm.x2t($event.offsetX), _vm.y2v($event.offsetY));
            },
            "contextmenu": function contextmenu($event) {
              $event.stopPropagation();
              $event.preventDefault();
              return _vm.contextBg($event);
            }
          }
        }, [_c('div', {
          staticClass: "hbar"
        }, [_c('div', {
          staticClass: "vision",
          style: {
            left: _vm.t0 / _vm.automaton.length * _vm.width + "px",
            width: (_vm.t1 - _vm.t0) / _vm.automaton.length * _vm.width + "px"
          }
        })]), _vm._v(" "), _c('svg', {
          staticClass: "svg",
          attrs: {
            "width": _vm.width,
            "height": _vm.height,
            "viewBox": "0 0 " + _vm.width + " " + _vm.height
          }
        }, [_vm._l(_vm.grid.x, function (line, index) {
          return _c('line', {
            key: 'grid-x' + index,
            staticClass: "grid",
            attrs: {
              "x1": line.pos,
              "y1": 0,
              "x2": line.pos,
              "y2": _vm.height,
              "opacity": line.op
            }
          });
        }), _vm._v(" "), _vm._l(_vm.grid.y, function (line, index) {
          return _c('line', {
            key: 'grid-y' + index,
            staticClass: "grid",
            attrs: {
              "x1": 0,
              "y1": line.pos,
              "x2": _vm.width,
              "y2": line.pos,
              "opacity": line.op
            }
          });
        }), _vm._v(" "), _vm._l(_vm.grid.x, function (line, index) {
          return _c('text', {
            key: 'grid-text-x' + index,
            staticClass: "grid-text",
            attrs: {
              "x": line.pos + 2,
              "y": _vm.height - 2,
              "opacity": line.op
            }
          }, [_vm._v(_vm._s(line.val.toFixed(3)))]);
        }), _vm._v(" "), _vm._l(_vm.grid.y, function (line, index) {
          return _c('text', {
            key: 'grid-text-y' + index,
            staticClass: "grid-text",
            attrs: {
              "x": "2",
              "y": line.pos - 2,
              "opacity": line.op
            }
          }, [_vm._v(_vm._s(line.val.toFixed(3)))]);
        }), _vm._v(" "), _vm.selectedParam ? _c('g', [_vm._l(_vm.selectedParam.dumpFxs(), function (fx) {
          return _c('g', {
            key: fx.$id,
            staticClass: "fx"
          }, [_c('line', {
            staticClass: "line",
            attrs: {
              "x1": _vm.t2x(fx.time),
              "y1": "4",
              "x2": _vm.t2x(fx.time),
              "y2": _vm.height
            }
          }), _vm._v(" "), _c('line', {
            staticClass: "line",
            attrs: {
              "x1": _vm.t2x(fx.time + fx.length),
              "y1": "4",
              "x2": _vm.t2x(fx.time + fx.length),
              "y2": _vm.height
            }
          }), _vm._v(" "), _c('rect', {
            staticClass: "fill",
            attrs: {
              "x": _vm.t2x(fx.time),
              "y": "0",
              "width": _vm.t2x(fx.time + fx.length) - _vm.t2x(fx.time),
              "height": _vm.height
            }
          }), _vm._v(" "), _c('g', {
            attrs: {
              "transform": 'translate(0,' + (1 + 16 * fx.row) + ')'
            }
          }, [_c('rect', {
            staticClass: "body",
            class: {
              selected: _vm.selectedFxIds.some(function (id) {
                return id === fx.$id;
              }),
              bypass: fx.bypass
            },
            attrs: {
              "x": _vm.t2x(fx.time),
              "width": _vm.t2x(fx.time + fx.length) - _vm.t2x(fx.time),
              "height": "16",
              "rx": "5",
              "ry": "5"
            },
            on: {
              "mousedown": function mousedown($event) {
                if (!('button' in $event) && _vm._k($event.keyCode, "left", 37, $event.key, ["Left", "ArrowLeft"])) {
                  return null;
                }

                if ('button' in $event && $event.button !== 0) {
                  return null;
                }

                $event.stopPropagation();

                _vm.grabFxBody(fx.$id, $event);
              },
              "dblclick": function dblclick($event) {
                $event.stopPropagation();

                _vm.removeFx(fx.$id);
              }
            }
          }), _vm._v(" "), _c('rect', {
            staticClass: "side",
            attrs: {
              "x": _vm.t2x(fx.time) - 1,
              "width": "6",
              "height": "16"
            },
            on: {
              "mousedown": function mousedown($event) {
                if (!('button' in $event) && _vm._k($event.keyCode, "left", 37, $event.key, ["Left", "ArrowLeft"])) {
                  return null;
                }

                if ('button' in $event && $event.button !== 0) {
                  return null;
                }

                $event.stopPropagation();

                _vm.grabFxLeft(fx.$id, $event);
              }
            }
          }), _vm._v(" "), _c('rect', {
            staticClass: "side",
            attrs: {
              "x": _vm.t2x(fx.time + fx.length) - 5,
              "width": "6",
              "height": "16"
            },
            on: {
              "mousedown": function mousedown($event) {
                if (!('button' in $event) && _vm._k($event.keyCode, "left", 37, $event.key, ["Left", "ArrowLeft"])) {
                  return null;
                }

                if ('button' in $event && $event.button !== 0) {
                  return null;
                }

                $event.stopPropagation();

                _vm.grabFxRight(fx.$id, $event);
              }
            }
          }), _vm._v(" "), _c('clipPath', {
            attrs: {
              "id": 'fxclip' + fx.$id
            }
          }, [_c('rect', {
            attrs: {
              "x": _vm.t2x(fx.time),
              "width": _vm.t2x(fx.time + fx.length) - _vm.t2x(fx.time),
              "height": "16"
            }
          })]), _vm._v(" "), _c('g', {
            attrs: {
              "clip-path": 'url(#fxclip' + fx.$id + ')'
            }
          }, [_c('text', {
            staticClass: "text",
            class: {
              selected: _vm.selectedFxIds.some(function (id) {
                return id === fx.$id;
              }),
              bypass: fx.bypass
            },
            attrs: {
              "x": _vm.t2x(fx.time) + 4,
              "y": "12"
            }
          }, [_vm._v(_vm._s(_vm.automaton.getFxDefinitionName(fx.def)))])])])]);
        }), _vm._v(" "), _vm.selectedParam ? _c('polyline', {
          staticClass: "graph",
          attrs: {
            "points": _vm.graphPoints
          }
        }) : _vm._e(), _vm._v(" "), _c('line', {
          staticClass: "currentLine",
          attrs: {
            "x1": _vm.t2x(_vm.automaton.time),
            "y1": "0",
            "x2": _vm.t2x(_vm.automaton.time),
            "y2": _vm.height
          }
        }), _vm._v(" "), _c('text', {
          staticClass: "currentText",
          attrs: {
            "x": _vm.t2x(_vm.automaton.time) + 2,
            "y": _vm.height - 2
          }
        }, [_vm._v(_vm._s(_vm.automaton.time.toFixed(3)))]), _vm._v(" "), _vm.selectedParam ? _c('g', [_c('line', {
          staticClass: "currentLine",
          attrs: {
            "x1": "0",
            "y1": _vm.v2y(_vm.selectedParam.getValue()),
            "x2": _vm.width,
            "y2": _vm.v2y(_vm.selectedParam.getValue())
          }
        }), _vm._v(" "), _c('text', {
          staticClass: "currentText",
          attrs: {
            "x": "2",
            "y": _vm.v2y(_vm.selectedParam.getValue()) - 2
          }
        }, [_vm._v(_vm._s(_vm.selectedParam.getValue().toFixed(3)))]), _vm._v(" "), _c('circle', {
          staticClass: "currentPoint",
          attrs: {
            "r": "5",
            "cx": _vm.t2x(_vm.automaton.time),
            "cy": _vm.v2y(_vm.selectedParam.getValue())
          }
        })]) : _vm._e()], 2) : _vm._e(), _vm._v(" "), _vm.selectedParam ? _c('g', _vm._l(_vm.selectedParam.dumpNodes(), function (node) {
          return _c('g', {
            key: node.$id,
            staticClass: "node"
          }, [_c('g', {
            staticClass: "handle"
          }, [node.in ? _c('line', {
            staticClass: "line",
            attrs: {
              "x1": _vm.t2x(node.time),
              "y1": _vm.v2y(node.value),
              "x2": _vm.t2x(node.time + node.in.time),
              "y2": _vm.v2y(node.value + node.in.value)
            }
          }) : _vm._e(), _vm._v(" "), node.in ? _c('circle', {
            staticClass: "circle",
            attrs: {
              "r": "4",
              "transform": 'translate(' + _vm.t2x(node.time + node.in.time) + ',' + _vm.v2y(node.value + node.in.value) + ')'
            },
            on: {
              "mousedown": function mousedown($event) {
                if (!('button' in $event) && _vm._k($event.keyCode, "left", 37, $event.key, ["Left", "ArrowLeft"])) {
                  return null;
                }

                if ('button' in $event && $event.button !== 0) {
                  return null;
                }

                $event.stopPropagation();

                _vm.grabHandle(node.$id, false, $event);
              },
              "dblclick": function dblclick($event) {
                $event.stopPropagation();

                _vm.removeHandle(node.$id, false);
              }
            }
          }) : _vm._e(), _vm._v(" "), node.out ? _c('line', {
            staticClass: "line",
            attrs: {
              "x1": _vm.t2x(node.time),
              "y1": _vm.v2y(node.value),
              "x2": _vm.t2x(node.time + node.out.time),
              "y2": _vm.v2y(node.value + node.out.value)
            }
          }) : _vm._e(), _vm._v(" "), node.out ? _c('circle', {
            staticClass: "circle",
            attrs: {
              "r": "4",
              "transform": 'translate(' + _vm.t2x(node.time + node.out.time) + ',' + _vm.v2y(node.value + node.out.value) + ')'
            },
            on: {
              "mousedown": function mousedown($event) {
                if (!('button' in $event) && _vm._k($event.keyCode, "left", 37, $event.key, ["Left", "ArrowLeft"])) {
                  return null;
                }

                if ('button' in $event && $event.button !== 0) {
                  return null;
                }

                $event.stopPropagation();

                _vm.grabHandle(node.$id, true, $event);
              },
              "dblclick": function dblclick($event) {
                $event.stopPropagation();

                _vm.removeHandle(node.$id, true);
              }
            }
          }) : _vm._e()]), _vm._v(" "), _c('g', {
            staticClass: "body",
            class: {
              selected: _vm.selectedNodeIds.some(function (id) {
                return id === node.$id;
              })
            },
            on: {
              "dblclick": function dblclick($event) {
                $event.stopPropagation();

                _vm.removeNode(node.$id);
              },
              "mousedown": [function ($event) {
                if (!('button' in $event) && _vm._k($event.keyCode, "left", 37, $event.key, ["Left", "ArrowLeft"])) {
                  return null;
                }

                if ('button' in $event && $event.button !== 0) {
                  return null;
                }

                if (!$event.shiftKey) {
                  return null;
                }

                $event.stopPropagation();

                _vm.resetHandles(node.$id);
              }, function ($event) {
                if (!('button' in $event) && _vm._k($event.keyCode, "left", 37, $event.key, ["Left", "ArrowLeft"])) {
                  return null;
                }

                if ('button' in $event && $event.button !== 0) {
                  return null;
                }

                $event.stopPropagation();

                _vm.grabNode(node.$id, $event);
              }]
            }
          }, [_vm.v0 <= node.value && node.value <= _vm.v1 ? _c('circle', {
            staticClass: "circle",
            attrs: {
              "transform": 'translate(' + _vm.t2x(node.time) + ',' + _vm.v2y(node.value) + ')',
              "r": "5"
            }
          }) : _vm._e(), _vm._v(" "), node.value < _vm.v0 ? _c('path', {
            staticClass: "triangle",
            attrs: {
              "transform": 'translate(' + _vm.t2x(node.time) + ',' + _vm.height + ')',
              "d": "M 0 -4 L 5 -12 L -5 -12 z"
            }
          }) : _vm._e(), _vm._v(" "), _vm.v1 < node.value ? _c('path', {
            staticClass: "triangle",
            attrs: {
              "transform": 'translate(' + _vm.t2x(node.time) + ',0)',
              "d": "M 0 4 L -5 12 L 5 12 z"
            }
          }) : _vm._e()])]);
        })) : _vm._e()], 2), _vm._v(" "), _c('FxMenu', {
          attrs: {
            "automaton": _vm.automaton,
            "active": _vm.fxmenuActive
          },
          on: {
            "selected": function selected($event) {
              _vm.createFx(_vm.fxmenuTime, $event);
            },
            "blur": function blur($event) {
              _vm.fxmenuActive = false;
            }
          }
        })], 1)]);
      };

      __vue__options__.staticRenderFns = [];
      __vue__options__._scopeId = "data-v-f3a8533a";

      if (module.hot) {
        (function () {
          var hotAPI = require("vue-hot-reload-api");

          hotAPI.install(require("vue"), true);
          if (!hotAPI.compatible) return;
          module.hot.accept();
          module.hot.dispose(__vueify_style_dispose__);

          if (!module.hot.data) {
            hotAPI.createRecord("data-v-f3a8533a", __vue__options__);
          } else {
            hotAPI.rerender("data-v-f3a8533a", __vue__options__);
          }
        })();
      }
    }, {
      "../param-gui": 100,
      "./timeline-fxmenu.vue": 111,
      "babel-runtime/core-js/math/log10": 2,
      "vue": 65,
      "vue-hot-reload-api": 64,
      "vueify/lib/insert-css": 66
    }]
  }, {}, [98])(98);
});
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/base64-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.byteLength = byteLength;
exports.toByteArray = toByteArray;
exports.fromByteArray = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i];
  revLookup[code.charCodeAt(i)] = i;
} // Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications


revLookup['-'.charCodeAt(0)] = 62;
revLookup['_'.charCodeAt(0)] = 63;

function getLens(b64) {
  var len = b64.length;

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4');
  } // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42


  var validLen = b64.indexOf('=');
  if (validLen === -1) validLen = len;
  var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
  return [validLen, placeHoldersLen];
} // base64 is 4/3 + up to two characters of the original data


function byteLength(b64) {
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}

function _byteLength(b64, validLen, placeHoldersLen) {
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}

function toByteArray(b64) {
  var tmp;
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
  var curByte = 0; // if there are placeholders, only get up to the last complete 4 chars

  var len = placeHoldersLen > 0 ? validLen - 4 : validLen;

  for (var i = 0; i < len; i += 4) {
    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
    arr[curByte++] = tmp >> 16 & 0xFF;
    arr[curByte++] = tmp >> 8 & 0xFF;
    arr[curByte++] = tmp & 0xFF;
  }

  if (placeHoldersLen === 2) {
    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
    arr[curByte++] = tmp & 0xFF;
  }

  if (placeHoldersLen === 1) {
    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
    arr[curByte++] = tmp >> 8 & 0xFF;
    arr[curByte++] = tmp & 0xFF;
  }

  return arr;
}

function tripletToBase64(num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
}

function encodeChunk(uint8, start, end) {
  var tmp;
  var output = [];

  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);
    output.push(tripletToBase64(tmp));
  }

  return output.join('');
}

function fromByteArray(uint8) {
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes

  var parts = [];
  var maxChunkLength = 16383; // must be multiple of 3
  // go through the array every three bytes, we'll deal with trailing stuff later

  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  } // pad the end with zeros, but make sure to not forget the extra bytes


  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 0x3F] + '==');
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 0x3F] + lookup[tmp << 2 & 0x3F] + '=');
  }

  return parts.join('');
}

/***/ }),

/***/ "./node_modules/buffer/index.js":
/*!**************************************!*\
  !*** ./node_modules/buffer/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */

/* eslint-disable no-proto */


var base64 = __webpack_require__(/*! base64-js */ "./node_modules/base64-js/index.js");

var ieee754 = __webpack_require__(/*! ieee754 */ "./node_modules/ieee754/index.js");

var isArray = __webpack_require__(/*! isarray */ "./node_modules/isarray/index.js");

exports.Buffer = Buffer;
exports.SlowBuffer = SlowBuffer;
exports.INSPECT_MAX_BYTES = 50;
/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */

Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined ? global.TYPED_ARRAY_SUPPORT : typedArraySupport();
/*
 * Export kMaxLength after typed array support is determined.
 */

exports.kMaxLength = kMaxLength();

function typedArraySupport() {
  try {
    var arr = new Uint8Array(1);
    arr.__proto__ = {
      __proto__: Uint8Array.prototype,
      foo: function foo() {
        return 42;
      }
    };
    return arr.foo() === 42 && // typed array instances can be augmented
    typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
    arr.subarray(1, 1).byteLength === 0; // ie10 has broken `subarray`
  } catch (e) {
    return false;
  }
}

function kMaxLength() {
  return Buffer.TYPED_ARRAY_SUPPORT ? 0x7fffffff : 0x3fffffff;
}

function createBuffer(that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length');
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length);
    that.__proto__ = Buffer.prototype;
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length);
    }

    that.length = length;
  }

  return that;
}
/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */


function Buffer(arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length);
  } // Common case.


  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error('If encoding is specified then the first argument must be a string');
    }

    return allocUnsafe(this, arg);
  }

  return from(this, arg, encodingOrOffset, length);
}

Buffer.poolSize = 8192; // not used by this implementation
// TODO: Legacy, not needed anymore. Remove in next major version.

Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype;
  return arr;
};

function from(that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number');
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length);
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset);
  }

  return fromObject(that, value);
}
/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/


Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length);
};

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype;
  Buffer.__proto__ = Uint8Array;

  if (typeof Symbol !== 'undefined' && Symbol.species && Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    });
  }
}

function assertSize(size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number');
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative');
  }
}

function alloc(that, size, fill, encoding) {
  assertSize(size);

  if (size <= 0) {
    return createBuffer(that, size);
  }

  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string' ? createBuffer(that, size).fill(fill, encoding) : createBuffer(that, size).fill(fill);
  }

  return createBuffer(that, size);
}
/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/


Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding);
};

function allocUnsafe(that, size) {
  assertSize(size);
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);

  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0;
    }
  }

  return that;
}
/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */


Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size);
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */


Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size);
};

function fromString(that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8';
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding');
  }

  var length = byteLength(string, encoding) | 0;
  that = createBuffer(that, length);
  var actual = that.write(string, encoding);

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual);
  }

  return that;
}

function fromArrayLike(that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0;
  that = createBuffer(that, length);

  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255;
  }

  return that;
}

function fromArrayBuffer(that, array, byteOffset, length) {
  array.byteLength; // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds');
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds');
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array);
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset);
  } else {
    array = new Uint8Array(array, byteOffset, length);
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array;
    that.__proto__ = Buffer.prototype;
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array);
  }

  return that;
}

function fromObject(that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0;
    that = createBuffer(that, len);

    if (that.length === 0) {
      return that;
    }

    obj.copy(that, 0, 0, len);
    return that;
  }

  if (obj) {
    if (typeof ArrayBuffer !== 'undefined' && obj.buffer instanceof ArrayBuffer || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0);
      }

      return fromArrayLike(that, obj);
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data);
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.');
}

function checked(length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + kMaxLength().toString(16) + ' bytes');
  }

  return length | 0;
}

function SlowBuffer(length) {
  if (+length != length) {
    // eslint-disable-line eqeqeq
    length = 0;
  }

  return Buffer.alloc(+length);
}

Buffer.isBuffer = function isBuffer(b) {
  return !!(b != null && b._isBuffer);
};

Buffer.compare = function compare(a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers');
  }

  if (a === b) return 0;
  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }

  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
};

Buffer.isEncoding = function isEncoding(encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true;

    default:
      return false;
  }
};

Buffer.concat = function concat(list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers');
  }

  if (list.length === 0) {
    return Buffer.alloc(0);
  }

  var i;

  if (length === undefined) {
    length = 0;

    for (i = 0; i < list.length; ++i) {
      length += list[i].length;
    }
  }

  var buffer = Buffer.allocUnsafe(length);
  var pos = 0;

  for (i = 0; i < list.length; ++i) {
    var buf = list[i];

    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }

    buf.copy(buffer, pos);
    pos += buf.length;
  }

  return buffer;
};

function byteLength(string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length;
  }

  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength;
  }

  if (typeof string !== 'string') {
    string = '' + string;
  }

  var len = string.length;
  if (len === 0) return 0; // Use a for loop to avoid recursion

  var loweredCase = false;

  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len;

      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length;

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2;

      case 'hex':
        return len >>> 1;

      case 'base64':
        return base64ToBytes(string).length;

      default:
        if (loweredCase) return utf8ToBytes(string).length; // assume utf8

        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}

Buffer.byteLength = byteLength;

function slowToString(encoding, start, end) {
  var loweredCase = false; // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.
  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.

  if (start === undefined || start < 0) {
    start = 0;
  } // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.


  if (start > this.length) {
    return '';
  }

  if (end === undefined || end > this.length) {
    end = this.length;
  }

  if (end <= 0) {
    return '';
  } // Force coersion to uint32. This will also coerce falsey/NaN values to 0.


  end >>>= 0;
  start >>>= 0;

  if (end <= start) {
    return '';
  }

  if (!encoding) encoding = 'utf8';

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end);

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end);

      case 'ascii':
        return asciiSlice(this, start, end);

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end);

      case 'base64':
        return base64Slice(this, start, end);

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end);

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = (encoding + '').toLowerCase();
        loweredCase = true;
    }
  }
} // The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.


Buffer.prototype._isBuffer = true;

function swap(b, n, m) {
  var i = b[n];
  b[n] = b[m];
  b[m] = i;
}

Buffer.prototype.swap16 = function swap16() {
  var len = this.length;

  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits');
  }

  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1);
  }

  return this;
};

Buffer.prototype.swap32 = function swap32() {
  var len = this.length;

  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits');
  }

  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3);
    swap(this, i + 1, i + 2);
  }

  return this;
};

Buffer.prototype.swap64 = function swap64() {
  var len = this.length;

  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits');
  }

  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7);
    swap(this, i + 1, i + 6);
    swap(this, i + 2, i + 5);
    swap(this, i + 3, i + 4);
  }

  return this;
};

Buffer.prototype.toString = function toString() {
  var length = this.length | 0;
  if (length === 0) return '';
  if (arguments.length === 0) return utf8Slice(this, 0, length);
  return slowToString.apply(this, arguments);
};

Buffer.prototype.equals = function equals(b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');
  if (this === b) return true;
  return Buffer.compare(this, b) === 0;
};

Buffer.prototype.inspect = function inspect() {
  var str = '';
  var max = exports.INSPECT_MAX_BYTES;

  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
    if (this.length > max) str += ' ... ';
  }

  return '<Buffer ' + str + '>';
};

Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer');
  }

  if (start === undefined) {
    start = 0;
  }

  if (end === undefined) {
    end = target ? target.length : 0;
  }

  if (thisStart === undefined) {
    thisStart = 0;
  }

  if (thisEnd === undefined) {
    thisEnd = this.length;
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index');
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0;
  }

  if (thisStart >= thisEnd) {
    return -1;
  }

  if (start >= end) {
    return 1;
  }

  start >>>= 0;
  end >>>= 0;
  thisStart >>>= 0;
  thisEnd >>>= 0;
  if (this === target) return 0;
  var x = thisEnd - thisStart;
  var y = end - start;
  var len = Math.min(x, y);
  var thisCopy = this.slice(thisStart, thisEnd);
  var targetCopy = target.slice(start, end);

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i];
      y = targetCopy[i];
      break;
    }
  }

  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
}; // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf


function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1; // Normalize byteOffset

  if (typeof byteOffset === 'string') {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff;
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000;
  }

  byteOffset = +byteOffset; // Coerce to Number.

  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : buffer.length - 1;
  } // Normalize byteOffset: negative offsets start from the end of the buffer


  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;

  if (byteOffset >= buffer.length) {
    if (dir) return -1;else byteOffset = buffer.length - 1;
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0;else return -1;
  } // Normalize val


  if (typeof val === 'string') {
    val = Buffer.from(val, encoding);
  } // Finally, search either indexOf (if dir is true) or lastIndexOf


  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1;
    }

    return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
  } else if (typeof val === 'number') {
    val = val & 0xFF; // Search for a byte value [0-255]

    if (Buffer.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
      }
    }

    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
  }

  throw new TypeError('val must be string, number or Buffer');
}

function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase();

    if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1;
      }

      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }

  function read(buf, i) {
    if (indexSize === 1) {
      return buf[i];
    } else {
      return buf.readUInt16BE(i * indexSize);
    }
  }

  var i;

  if (dir) {
    var foundIndex = -1;

    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i;
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
      } else {
        if (foundIndex !== -1) i -= i - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;

    for (i = byteOffset; i >= 0; i--) {
      var found = true;

      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false;
          break;
        }
      }

      if (found) return i;
    }
  }

  return -1;
}

Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1;
};

Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};

Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};

function hexWrite(buf, string, offset, length) {
  offset = Number(offset) || 0;
  var remaining = buf.length - offset;

  if (!length) {
    length = remaining;
  } else {
    length = Number(length);

    if (length > remaining) {
      length = remaining;
    }
  } // must be an even number of digits


  var strLen = string.length;
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string');

  if (length > strLen / 2) {
    length = strLen / 2;
  }

  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(parsed)) return i;
    buf[offset + i] = parsed;
  }

  return i;
}

function utf8Write(buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
}

function asciiWrite(buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length);
}

function latin1Write(buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length);
}

function base64Write(buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length);
}

function ucs2Write(buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}

Buffer.prototype.write = function write(string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8';
    length = this.length;
    offset = 0; // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset;
    length = this.length;
    offset = 0; // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0;

    if (isFinite(length)) {
      length = length | 0;
      if (encoding === undefined) encoding = 'utf8';
    } else {
      encoding = length;
      length = undefined;
    } // legacy write(string, encoding, offset, length) - remove in v0.13

  } else {
    throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
  }

  var remaining = this.length - offset;
  if (length === undefined || length > remaining) length = remaining;

  if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds');
  }

  if (!encoding) encoding = 'utf8';
  var loweredCase = false;

  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length);

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length);

      case 'ascii':
        return asciiWrite(this, string, offset, length);

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length);

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length);

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length);

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
};

Buffer.prototype.toJSON = function toJSON() {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  };
};

function base64Slice(buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf);
  } else {
    return base64.fromByteArray(buf.slice(start, end));
  }
}

function utf8Slice(buf, start, end) {
  end = Math.min(buf.length, end);
  var res = [];
  var i = start;

  while (i < end) {
    var firstByte = buf[i];
    var codePoint = null;
    var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte;
          }

          break;

        case 2:
          secondByte = buf[i + 1];

          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;

            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint;
            }
          }

          break;

        case 3:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];

          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;

            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint;
            }
          }

          break;

        case 4:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          fourthByte = buf[i + 3];

          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;

            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint;
            }
          }

      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD;
      bytesPerSequence = 1;
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000;
      res.push(codePoint >>> 10 & 0x3FF | 0xD800);
      codePoint = 0xDC00 | codePoint & 0x3FF;
    }

    res.push(codePoint);
    i += bytesPerSequence;
  }

  return decodeCodePointsArray(res);
} // Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety


var MAX_ARGUMENTS_LENGTH = 0x1000;

function decodeCodePointsArray(codePoints) {
  var len = codePoints.length;

  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints); // avoid extra slice()
  } // Decode in chunks to avoid "call stack size exceeded".


  var res = '';
  var i = 0;

  while (i < len) {
    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
  }

  return res;
}

function asciiSlice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F);
  }

  return ret;
}

function latin1Slice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i]);
  }

  return ret;
}

function hexSlice(buf, start, end) {
  var len = buf.length;
  if (!start || start < 0) start = 0;
  if (!end || end < 0 || end > len) end = len;
  var out = '';

  for (var i = start; i < end; ++i) {
    out += toHex(buf[i]);
  }

  return out;
}

function utf16leSlice(buf, start, end) {
  var bytes = buf.slice(start, end);
  var res = '';

  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
  }

  return res;
}

Buffer.prototype.slice = function slice(start, end) {
  var len = this.length;
  start = ~~start;
  end = end === undefined ? len : ~~end;

  if (start < 0) {
    start += len;
    if (start < 0) start = 0;
  } else if (start > len) {
    start = len;
  }

  if (end < 0) {
    end += len;
    if (end < 0) end = 0;
  } else if (end > len) {
    end = len;
  }

  if (end < start) end = start;
  var newBuf;

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end);
    newBuf.__proto__ = Buffer.prototype;
  } else {
    var sliceLen = end - start;
    newBuf = new Buffer(sliceLen, undefined);

    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start];
    }
  }

  return newBuf;
};
/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */


function checkOffset(offset, ext, length) {
  if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
}

Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);
  var val = this[offset];
  var mul = 1;
  var i = 0;

  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }

  return val;
};

Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;

  if (!noAssert) {
    checkOffset(offset, byteLength, this.length);
  }

  var val = this[offset + --byteLength];
  var mul = 1;

  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul;
  }

  return val;
};

Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length);
  return this[offset];
};

Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] | this[offset + 1] << 8;
};

Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] << 8 | this[offset + 1];
};

Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
};

Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
};

Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);
  var val = this[offset];
  var mul = 1;
  var i = 0;

  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }

  mul *= 0x80;
  if (val >= mul) val -= Math.pow(2, 8 * byteLength);
  return val;
};

Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);
  var i = byteLength;
  var mul = 1;
  var val = this[offset + --i];

  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul;
  }

  mul *= 0x80;
  if (val >= mul) val -= Math.pow(2, 8 * byteLength);
  return val;
};

Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length);
  if (!(this[offset] & 0x80)) return this[offset];
  return (0xff - this[offset] + 1) * -1;
};

Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset] | this[offset + 1] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};

Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset + 1] | this[offset] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};

Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
};

Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
};

Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return ieee754.read(this, offset, true, 23, 4);
};

Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return ieee754.read(this, offset, false, 23, 4);
};

Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length);
  return ieee754.read(this, offset, true, 52, 8);
};

Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length);
  return ieee754.read(this, offset, false, 52, 8);
};

function checkInt(buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
}

Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength = byteLength | 0;

  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var mul = 1;
  var i = 0;
  this[offset] = value & 0xFF;

  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength = byteLength | 0;

  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var i = byteLength - 1;
  var mul = 1;
  this[offset + i] = value & 0xFF;

  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
  this[offset] = value & 0xff;
  return offset + 1;
};

function objectWriteUInt16(buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1;

  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & 0xff << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
  } else {
    objectWriteUInt16(this, value, offset, true);
  }

  return offset + 2;
};

Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
  } else {
    objectWriteUInt16(this, value, offset, false);
  }

  return offset + 2;
};

function objectWriteUInt32(buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1;

  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 0xff;
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, true);
  }

  return offset + 4;
};

Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, false);
  }

  return offset + 4;
};

Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;

  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);
    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = 0;
  var mul = 1;
  var sub = 0;
  this[offset] = value & 0xFF;

  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1;
    }

    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;

  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);
    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = byteLength - 1;
  var mul = 1;
  var sub = 0;
  this[offset + i] = value & 0xFF;

  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1;
    }

    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
  if (value < 0) value = 0xff + value + 1;
  this[offset] = value & 0xff;
  return offset + 1;
};

Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
  } else {
    objectWriteUInt16(this, value, offset, true);
  }

  return offset + 2;
};

Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
  } else {
    objectWriteUInt16(this, value, offset, false);
  }

  return offset + 2;
};

Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
  } else {
    objectWriteUInt32(this, value, offset, true);
  }

  return offset + 4;
};

Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  if (value < 0) value = 0xffffffff + value + 1;

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, false);
  }

  return offset + 4;
};

function checkIEEE754(buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
  if (offset < 0) throw new RangeError('Index out of range');
}

function writeFloat(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);
  }

  ieee754.write(buf, value, offset, littleEndian, 23, 4);
  return offset + 4;
}

Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert);
};

Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert);
};

function writeDouble(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);
  }

  ieee754.write(buf, value, offset, littleEndian, 52, 8);
  return offset + 8;
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert);
};

Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert);
}; // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)


Buffer.prototype.copy = function copy(target, targetStart, start, end) {
  if (!start) start = 0;
  if (!end && end !== 0) end = this.length;
  if (targetStart >= target.length) targetStart = target.length;
  if (!targetStart) targetStart = 0;
  if (end > 0 && end < start) end = start; // Copy 0 bytes; we're done

  if (end === start) return 0;
  if (target.length === 0 || this.length === 0) return 0; // Fatal error conditions

  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds');
  }

  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds');
  if (end < 0) throw new RangeError('sourceEnd out of bounds'); // Are we oob?

  if (end > this.length) end = this.length;

  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start;
  }

  var len = end - start;
  var i;

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start];
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start];
    }
  } else {
    Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);
  }

  return len;
}; // Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])


Buffer.prototype.fill = function fill(val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start;
      start = 0;
      end = this.length;
    } else if (typeof end === 'string') {
      encoding = end;
      end = this.length;
    }

    if (val.length === 1) {
      var code = val.charCodeAt(0);

      if (code < 256) {
        val = code;
      }
    }

    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string');
    }

    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding);
    }
  } else if (typeof val === 'number') {
    val = val & 255;
  } // Invalid ranges are not set to a default, so can range check early.


  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index');
  }

  if (end <= start) {
    return this;
  }

  start = start >>> 0;
  end = end === undefined ? this.length : end >>> 0;
  if (!val) val = 0;
  var i;

  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val;
    }
  } else {
    var bytes = Buffer.isBuffer(val) ? val : utf8ToBytes(new Buffer(val, encoding).toString());
    var len = bytes.length;

    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len];
    }
  }

  return this;
}; // HELPER FUNCTIONS
// ================


var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

function base64clean(str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, ''); // Node converts strings with length < 2 to ''

  if (str.length < 2) return ''; // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not

  while (str.length % 4 !== 0) {
    str = str + '=';
  }

  return str;
}

function stringtrim(str) {
  if (str.trim) return str.trim();
  return str.replace(/^\s+|\s+$/g, '');
}

function toHex(n) {
  if (n < 16) return '0' + n.toString(16);
  return n.toString(16);
}

function utf8ToBytes(string, units) {
  units = units || Infinity;
  var codePoint;
  var length = string.length;
  var leadSurrogate = null;
  var bytes = [];

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i); // is surrogate component

    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        } // valid lead


        leadSurrogate = codePoint;
        continue;
      } // 2 leads in a row


      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        leadSurrogate = codePoint;
        continue;
      } // valid surrogate pair


      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
    }

    leadSurrogate = null; // encode utf8

    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break;
      bytes.push(codePoint);
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break;
      bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break;
      bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break;
      bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else {
      throw new Error('Invalid code point');
    }
  }

  return bytes;
}

function asciiToBytes(str) {
  var byteArray = [];

  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF);
  }

  return byteArray;
}

function utf16leToBytes(str, units) {
  var c, hi, lo;
  var byteArray = [];

  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break;
    c = str.charCodeAt(i);
    hi = c >> 8;
    lo = c % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }

  return byteArray;
}

function base64ToBytes(str) {
  return base64.toByteArray(base64clean(str));
}

function blitBuffer(src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if (i + offset >= dst.length || i >= src.length) break;
    dst[i + offset] = src[i];
  }

  return i;
}

function isnan(val) {
  return val !== val; // eslint-disable-line no-self-compare
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/core-util-is/lib/util.js":
/*!***********************************************!*\
  !*** ./node_modules/core-util-is/lib/util.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }

  return objectToString(arg) === '[object Array]';
}

exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}

exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}

exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}

exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}

exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}

exports.isString = isString;

function isSymbol(arg) {
  return _typeof(arg) === 'symbol';
}

exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}

exports.isUndefined = isUndefined;

function isRegExp(re) {
  return objectToString(re) === '[object RegExp]';
}

exports.isRegExp = isRegExp;

function isObject(arg) {
  return _typeof(arg) === 'object' && arg !== null;
}

exports.isObject = isObject;

function isDate(d) {
  return objectToString(d) === '[object Date]';
}

exports.isDate = isDate;

function isError(e) {
  return objectToString(e) === '[object Error]' || e instanceof Error;
}

exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}

exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || _typeof(arg) === 'symbol' || // ES6 symbol
  typeof arg === 'undefined';
}

exports.isPrimitive = isPrimitive;
exports.isBuffer = Buffer.isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../buffer/index.js */ "./node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/css-loader/index.js!./node_modules/sass-loader/lib/loader.js!./src/styles/main.scss":
/*!*************************************************************************************************!*\
  !*** ./node_modules/css-loader!./node_modules/sass-loader/lib/loader.js!./src/styles/main.scss ***!
  \*************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../node_modules/css-loader/lib/css-base.js */ "./node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, "body {\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n  font: 500 10px 'Wt-Position', sans-serif;\n  background: #000;\n  color: #fff; }\n  body #divActive {\n    position: fixed;\n    left: 8px;\n    bottom: 248px; }\n  body #divMidi {\n    position: fixed;\n    left: 8px;\n    bottom: 248px; }\n  body #divPath {\n    position: fixed;\n    right: 8px;\n    bottom: 248px;\n    text-align: right; }\n  body #divAutomaton {\n    position: fixed;\n    left: 0;\n    bottom: 0;\n    width: 100%;\n    height: 240px; }\n  body #canvas {\n    position: fixed;\n    left: 0;\n    top: 0; }\n", ""]);

// exports


/***/ }),

/***/ "./node_modules/css-loader/lib/css-base.js":
/*!*************************************************!*\
  !*** ./node_modules/css-loader/lib/css-base.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
module.exports = function (useSourceMap) {
  var list = []; // return the list of modules as css string

  list.toString = function toString() {
    return this.map(function (item) {
      var content = cssWithMappingToString(item, useSourceMap);

      if (item[2]) {
        return "@media " + item[2] + "{" + content + "}";
      } else {
        return content;
      }
    }).join("");
  }; // import a list of modules into the list


  list.i = function (modules, mediaQuery) {
    if (typeof modules === "string") modules = [[null, modules, ""]];
    var alreadyImportedModules = {};

    for (var i = 0; i < this.length; i++) {
      var id = this[i][0];
      if (typeof id === "number") alreadyImportedModules[id] = true;
    }

    for (i = 0; i < modules.length; i++) {
      var item = modules[i]; // skip already imported module
      // this implementation is not 100% perfect for weird media query combinations
      //  when a module is imported multiple times with different media queries.
      //  I hope this will never occur (Hey this way we have smaller bundles)

      if (typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
        if (mediaQuery && !item[2]) {
          item[2] = mediaQuery;
        } else if (mediaQuery) {
          item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
        }

        list.push(item);
      }
    }
  };

  return list;
};

function cssWithMappingToString(item, useSourceMap) {
  var content = item[1] || '';
  var cssMapping = item[3];

  if (!cssMapping) {
    return content;
  }

  if (useSourceMap && typeof btoa === 'function') {
    var sourceMapping = toComment(cssMapping);
    var sourceURLs = cssMapping.sources.map(function (source) {
      return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */';
    });
    return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
  }

  return [content].join('\n');
} // Adapted from convert-source-map (MIT)


function toComment(sourceMap) {
  // eslint-disable-next-line no-undef
  var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
  var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;
  return '/*# ' + data + ' */';
}

/***/ }),

/***/ "./node_modules/events/events.js":
/*!***************************************!*\
  !*** ./node_modules/events/events.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}

module.exports = EventEmitter; // Backwards-compat with node 0.10.x

EventEmitter.EventEmitter = EventEmitter;
EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined; // By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.

EventEmitter.defaultMaxListeners = 10; // Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.

EventEmitter.prototype.setMaxListeners = function (n) {
  if (!isNumber(n) || n < 0 || isNaN(n)) throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function (type) {
  var er, handler, len, args, i, listeners;
  if (!this._events) this._events = {}; // If there is no 'error' event listener then throw.

  if (type === 'error') {
    if (!this._events.error || isObject(this._events.error) && !this._events.error.length) {
      er = arguments[1];

      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      } else {
        // At least give some kind of context to the user
        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
        err.context = er;
        throw err;
      }
    }
  }

  handler = this._events[type];
  if (isUndefined(handler)) return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;

      case 2:
        handler.call(this, arguments[1]);
        break;

      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower

      default:
        args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    args = Array.prototype.slice.call(arguments, 1);
    listeners = handler.slice();
    len = listeners.length;

    for (i = 0; i < len; i++) {
      listeners[i].apply(this, args);
    }
  }

  return true;
};

EventEmitter.prototype.addListener = function (type, listener) {
  var m;
  if (!isFunction(listener)) throw TypeError('listener must be a function');
  if (!this._events) this._events = {}; // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".

  if (this._events.newListener) this.emit('newListener', type, isFunction(listener.listener) ? listener.listener : listener);
  if (!this._events[type]) // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;else if (isObject(this._events[type])) // If we've already got an array, just append.
    this._events[type].push(listener);else // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener]; // Check for listener leak

  if (isObject(this._events[type]) && !this._events[type].warned) {
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' + 'leak detected. %d listeners added. ' + 'Use emitter.setMaxListeners() to increase limit.', this._events[type].length);

      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function (type, listener) {
  if (!isFunction(listener)) throw TypeError('listener must be a function');
  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);
  return this;
}; // emits a 'removeListener' event iff the listener was removed


EventEmitter.prototype.removeListener = function (type, listener) {
  var list, position, length, i;
  if (!isFunction(listener)) throw TypeError('listener must be a function');
  if (!this._events || !this._events[type]) return this;
  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener || isFunction(list.listener) && list.listener === listener) {
    delete this._events[type];
    if (this._events.removeListener) this.emit('removeListener', type, listener);
  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener || list[i].listener && list[i].listener === listener) {
        position = i;
        break;
      }
    }

    if (position < 0) return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener) this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function (type) {
  var key, listeners;
  if (!this._events) return this; // not listening for removeListener, no need to emit

  if (!this._events.removeListener) {
    if (arguments.length === 0) this._events = {};else if (this._events[type]) delete this._events[type];
    return this;
  } // emit removeListener for all listeners on all events


  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }

    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else if (listeners) {
    // LIFO order
    while (listeners.length) {
      this.removeListener(type, listeners[listeners.length - 1]);
    }
  }

  delete this._events[type];
  return this;
};

EventEmitter.prototype.listeners = function (type) {
  var ret;
  if (!this._events || !this._events[type]) ret = [];else if (isFunction(this._events[type])) ret = [this._events[type]];else ret = this._events[type].slice();
  return ret;
};

EventEmitter.prototype.listenerCount = function (type) {
  if (this._events) {
    var evlistener = this._events[type];
    if (isFunction(evlistener)) return 1;else if (evlistener) return evlistener.length;
  }

  return 0;
};

EventEmitter.listenerCount = function (emitter, type) {
  return emitter.listenerCount(type);
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return _typeof(arg) === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

/***/ }),

/***/ "./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? nBytes - 1 : 0;
  var d = isLE ? -1 : 1;
  var s = buffer[offset + i];
  i += d;
  e = s & (1 << -nBits) - 1;
  s >>= -nBits;
  nBits += eLen;

  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;

  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : (s ? -1 : 1) * Infinity;
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }

  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE ? 0 : nBytes - 1;
  var d = isLE ? 1 : -1;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);

    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }

    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }

    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = e << mLen | m;
  eLen += mLen;

  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128;
};

/***/ }),

/***/ "./node_modules/immediate/lib/browser.js":
/*!***********************************************!*\
  !*** ./node_modules/immediate/lib/browser.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

var Mutation = global.MutationObserver || global.WebKitMutationObserver;
var scheduleDrain;
{
  if (Mutation) {
    var called = 0;
    var observer = new Mutation(nextTick);
    var element = global.document.createTextNode('');
    observer.observe(element, {
      characterData: true
    });

    scheduleDrain = function scheduleDrain() {
      element.data = called = ++called % 2;
    };
  } else if (!global.setImmediate && typeof global.MessageChannel !== 'undefined') {
    var channel = new global.MessageChannel();
    channel.port1.onmessage = nextTick;

    scheduleDrain = function scheduleDrain() {
      channel.port2.postMessage(0);
    };
  } else if ('document' in global && 'onreadystatechange' in global.document.createElement('script')) {
    scheduleDrain = function scheduleDrain() {
      // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
      // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
      var scriptEl = global.document.createElement('script');

      scriptEl.onreadystatechange = function () {
        nextTick();
        scriptEl.onreadystatechange = null;
        scriptEl.parentNode.removeChild(scriptEl);
        scriptEl = null;
      };

      global.document.documentElement.appendChild(scriptEl);
    };
  } else {
    scheduleDrain = function scheduleDrain() {
      setTimeout(nextTick, 0);
    };
  }
}
var draining;
var queue = []; //named nextTick for less confusing stack traces

function nextTick() {
  draining = true;
  var i, oldQueue;
  var len = queue.length;

  while (len) {
    oldQueue = queue;
    queue = [];
    i = -1;

    while (++i < len) {
      oldQueue[i]();
    }

    len = queue.length;
  }

  draining = false;
}

module.exports = immediate;

function immediate(task) {
  if (queue.push(task) === 1 && !draining) {
    scheduleDrain();
  }
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/inherits/inherits_browser.js":
/*!***************************************************!*\
  !*** ./node_modules/inherits/inherits_browser.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor;
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor;

    var TempCtor = function TempCtor() {};

    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  };
}

/***/ }),

/***/ "./node_modules/isarray/index.js":
/*!***************************************!*\
  !*** ./node_modules/isarray/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

/***/ }),

/***/ "./node_modules/jszip/lib/base64.js":
/*!******************************************!*\
  !*** ./node_modules/jszip/lib/base64.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./utils */ "./node_modules/jszip/lib/utils.js");

var support = __webpack_require__(/*! ./support */ "./node_modules/jszip/lib/support.js"); // private property


var _keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="; // public method for encoding

exports.encode = function (input) {
  var output = [];
  var chr1, chr2, chr3, enc1, enc2, enc3, enc4;
  var i = 0,
      len = input.length,
      remainingBytes = len;
  var isArray = utils.getTypeOf(input) !== "string";

  while (i < input.length) {
    remainingBytes = len - i;

    if (!isArray) {
      chr1 = input.charCodeAt(i++);
      chr2 = i < len ? input.charCodeAt(i++) : 0;
      chr3 = i < len ? input.charCodeAt(i++) : 0;
    } else {
      chr1 = input[i++];
      chr2 = i < len ? input[i++] : 0;
      chr3 = i < len ? input[i++] : 0;
    }

    enc1 = chr1 >> 2;
    enc2 = (chr1 & 3) << 4 | chr2 >> 4;
    enc3 = remainingBytes > 1 ? (chr2 & 15) << 2 | chr3 >> 6 : 64;
    enc4 = remainingBytes > 2 ? chr3 & 63 : 64;
    output.push(_keyStr.charAt(enc1) + _keyStr.charAt(enc2) + _keyStr.charAt(enc3) + _keyStr.charAt(enc4));
  }

  return output.join("");
}; // public method for decoding


exports.decode = function (input) {
  var chr1, chr2, chr3;
  var enc1, enc2, enc3, enc4;
  var i = 0,
      resultIndex = 0;
  var dataUrlPrefix = "data:";

  if (input.substr(0, dataUrlPrefix.length) === dataUrlPrefix) {
    // This is a common error: people give a data url
    // (data:image/png;base64,iVBOR...) with a {base64: true} and
    // wonders why things don't work.
    // We can detect that the string input looks like a data url but we
    // *can't* be sure it is one: removing everything up to the comma would
    // be too dangerous.
    throw new Error("Invalid base64 input, it looks like a data url.");
  }

  input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
  var totalLength = input.length * 3 / 4;

  if (input.charAt(input.length - 1) === _keyStr.charAt(64)) {
    totalLength--;
  }

  if (input.charAt(input.length - 2) === _keyStr.charAt(64)) {
    totalLength--;
  }

  if (totalLength % 1 !== 0) {
    // totalLength is not an integer, the length does not match a valid
    // base64 content. That can happen if:
    // - the input is not a base64 content
    // - the input is *almost* a base64 content, with a extra chars at the
    //   beginning or at the end
    // - the input uses a base64 variant (base64url for example)
    throw new Error("Invalid base64 input, bad content length.");
  }

  var output;

  if (support.uint8array) {
    output = new Uint8Array(totalLength | 0);
  } else {
    output = new Array(totalLength | 0);
  }

  while (i < input.length) {
    enc1 = _keyStr.indexOf(input.charAt(i++));
    enc2 = _keyStr.indexOf(input.charAt(i++));
    enc3 = _keyStr.indexOf(input.charAt(i++));
    enc4 = _keyStr.indexOf(input.charAt(i++));
    chr1 = enc1 << 2 | enc2 >> 4;
    chr2 = (enc2 & 15) << 4 | enc3 >> 2;
    chr3 = (enc3 & 3) << 6 | enc4;
    output[resultIndex++] = chr1;

    if (enc3 !== 64) {
      output[resultIndex++] = chr2;
    }

    if (enc4 !== 64) {
      output[resultIndex++] = chr3;
    }
  }

  return output;
};

/***/ }),

/***/ "./node_modules/jszip/lib/compressedObject.js":
/*!****************************************************!*\
  !*** ./node_modules/jszip/lib/compressedObject.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var external = __webpack_require__(/*! ./external */ "./node_modules/jszip/lib/external.js");

var DataWorker = __webpack_require__(/*! ./stream/DataWorker */ "./node_modules/jszip/lib/stream/DataWorker.js");

var DataLengthProbe = __webpack_require__(/*! ./stream/DataLengthProbe */ "./node_modules/jszip/lib/stream/DataLengthProbe.js");

var Crc32Probe = __webpack_require__(/*! ./stream/Crc32Probe */ "./node_modules/jszip/lib/stream/Crc32Probe.js");

var DataLengthProbe = __webpack_require__(/*! ./stream/DataLengthProbe */ "./node_modules/jszip/lib/stream/DataLengthProbe.js");
/**
 * Represent a compressed object, with everything needed to decompress it.
 * @constructor
 * @param {number} compressedSize the size of the data compressed.
 * @param {number} uncompressedSize the size of the data after decompression.
 * @param {number} crc32 the crc32 of the decompressed file.
 * @param {object} compression the type of compression, see lib/compressions.js.
 * @param {String|ArrayBuffer|Uint8Array|Buffer} data the compressed data.
 */


function CompressedObject(compressedSize, uncompressedSize, crc32, compression, data) {
  this.compressedSize = compressedSize;
  this.uncompressedSize = uncompressedSize;
  this.crc32 = crc32;
  this.compression = compression;
  this.compressedContent = data;
}

CompressedObject.prototype = {
  /**
   * Create a worker to get the uncompressed content.
   * @return {GenericWorker} the worker.
   */
  getContentWorker: function getContentWorker() {
    var worker = new DataWorker(external.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new DataLengthProbe("data_length"));
    var that = this;
    worker.on("end", function () {
      if (this.streamInfo['data_length'] !== that.uncompressedSize) {
        throw new Error("Bug : uncompressed data size mismatch");
      }
    });
    return worker;
  },

  /**
   * Create a worker to get the compressed content.
   * @return {GenericWorker} the worker.
   */
  getCompressedWorker: function getCompressedWorker() {
    return new DataWorker(external.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
  }
};
/**
 * Chain the given worker with other workers to compress the content with the
 * given compresion.
 * @param {GenericWorker} uncompressedWorker the worker to pipe.
 * @param {Object} compression the compression object.
 * @param {Object} compressionOptions the options to use when compressing.
 * @return {GenericWorker} the new worker compressing the content.
 */

CompressedObject.createWorkerFrom = function (uncompressedWorker, compression, compressionOptions) {
  return uncompressedWorker.pipe(new Crc32Probe()).pipe(new DataLengthProbe("uncompressedSize")).pipe(compression.compressWorker(compressionOptions)).pipe(new DataLengthProbe("compressedSize")).withStreamInfo("compression", compression);
};

module.exports = CompressedObject;

/***/ }),

/***/ "./node_modules/jszip/lib/compressions.js":
/*!************************************************!*\
  !*** ./node_modules/jszip/lib/compressions.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var GenericWorker = __webpack_require__(/*! ./stream/GenericWorker */ "./node_modules/jszip/lib/stream/GenericWorker.js");

exports.STORE = {
  magic: "\x00\x00",
  compressWorker: function compressWorker(compressionOptions) {
    return new GenericWorker("STORE compression");
  },
  uncompressWorker: function uncompressWorker() {
    return new GenericWorker("STORE decompression");
  }
};
exports.DEFLATE = __webpack_require__(/*! ./flate */ "./node_modules/jszip/lib/flate.js");

/***/ }),

/***/ "./node_modules/jszip/lib/crc32.js":
/*!*****************************************!*\
  !*** ./node_modules/jszip/lib/crc32.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./utils */ "./node_modules/jszip/lib/utils.js");
/**
 * The following functions come from pako, from pako/lib/zlib/crc32.js
 * released under the MIT license, see pako https://github.com/nodeca/pako/
 */
// Use ordinary array, since untyped makes no boost here


function makeTable() {
  var c,
      table = [];

  for (var n = 0; n < 256; n++) {
    c = n;

    for (var k = 0; k < 8; k++) {
      c = c & 1 ? 0xEDB88320 ^ c >>> 1 : c >>> 1;
    }

    table[n] = c;
  }

  return table;
} // Create table on load. Just 255 signed longs. Not a problem.


var crcTable = makeTable();

function crc32(crc, buf, len, pos) {
  var t = crcTable,
      end = pos + len;
  crc = crc ^ -1;

  for (var i = pos; i < end; i++) {
    crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 0xFF];
  }

  return crc ^ -1; // >>> 0;
} // That's all for the pako functions.

/**
 * Compute the crc32 of a string.
 * This is almost the same as the function crc32, but for strings. Using the
 * same function for the two use cases leads to horrible performances.
 * @param {Number} crc the starting value of the crc.
 * @param {String} str the string to use.
 * @param {Number} len the length of the string.
 * @param {Number} pos the starting position for the crc32 computation.
 * @return {Number} the computed crc32.
 */


function crc32str(crc, str, len, pos) {
  var t = crcTable,
      end = pos + len;
  crc = crc ^ -1;

  for (var i = pos; i < end; i++) {
    crc = crc >>> 8 ^ t[(crc ^ str.charCodeAt(i)) & 0xFF];
  }

  return crc ^ -1; // >>> 0;
}

module.exports = function crc32wrapper(input, crc) {
  if (typeof input === "undefined" || !input.length) {
    return 0;
  }

  var isArray = utils.getTypeOf(input) !== "string";

  if (isArray) {
    return crc32(crc | 0, input, input.length, 0);
  } else {
    return crc32str(crc | 0, input, input.length, 0);
  }
};

/***/ }),

/***/ "./node_modules/jszip/lib/defaults.js":
/*!********************************************!*\
  !*** ./node_modules/jszip/lib/defaults.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.base64 = false;
exports.binary = false;
exports.dir = false;
exports.createFolders = true;
exports.date = null;
exports.compression = null;
exports.compressionOptions = null;
exports.comment = null;
exports.unixPermissions = null;
exports.dosPermissions = null;

/***/ }),

/***/ "./node_modules/jszip/lib/external.js":
/*!********************************************!*\
  !*** ./node_modules/jszip/lib/external.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* global Promise */
 // load the global object first:
// - it should be better integrated in the system (unhandledRejection in node)
// - the environment may have a custom Promise implementation (see zone.js)

var ES6Promise = null;

if (typeof Promise !== "undefined") {
  ES6Promise = Promise;
} else {
  ES6Promise = __webpack_require__(/*! lie */ "./node_modules/lie/lib/browser.js");
}
/**
 * Let the user use/change some implementations.
 */


module.exports = {
  Promise: ES6Promise
};

/***/ }),

/***/ "./node_modules/jszip/lib/flate.js":
/*!*****************************************!*\
  !*** ./node_modules/jszip/lib/flate.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var USE_TYPEDARRAY = typeof Uint8Array !== 'undefined' && typeof Uint16Array !== 'undefined' && typeof Uint32Array !== 'undefined';

var pako = __webpack_require__(/*! pako */ "./node_modules/pako/index.js");

var utils = __webpack_require__(/*! ./utils */ "./node_modules/jszip/lib/utils.js");

var GenericWorker = __webpack_require__(/*! ./stream/GenericWorker */ "./node_modules/jszip/lib/stream/GenericWorker.js");

var ARRAY_TYPE = USE_TYPEDARRAY ? "uint8array" : "array";
exports.magic = "\x08\x00";
/**
 * Create a worker that uses pako to inflate/deflate.
 * @constructor
 * @param {String} action the name of the pako function to call : either "Deflate" or "Inflate".
 * @param {Object} options the options to use when (de)compressing.
 */

function FlateWorker(action, options) {
  GenericWorker.call(this, "FlateWorker/" + action);
  this._pako = null;
  this._pakoAction = action;
  this._pakoOptions = options; // the `meta` object from the last chunk received
  // this allow this worker to pass around metadata

  this.meta = {};
}

utils.inherits(FlateWorker, GenericWorker);
/**
 * @see GenericWorker.processChunk
 */

FlateWorker.prototype.processChunk = function (chunk) {
  this.meta = chunk.meta;

  if (this._pako === null) {
    this._createPako();
  }

  this._pako.push(utils.transformTo(ARRAY_TYPE, chunk.data), false);
};
/**
 * @see GenericWorker.flush
 */


FlateWorker.prototype.flush = function () {
  GenericWorker.prototype.flush.call(this);

  if (this._pako === null) {
    this._createPako();
  }

  this._pako.push([], true);
};
/**
 * @see GenericWorker.cleanUp
 */


FlateWorker.prototype.cleanUp = function () {
  GenericWorker.prototype.cleanUp.call(this);
  this._pako = null;
};
/**
 * Create the _pako object.
 * TODO: lazy-loading this object isn't the best solution but it's the
 * quickest. The best solution is to lazy-load the worker list. See also the
 * issue #446.
 */


FlateWorker.prototype._createPako = function () {
  this._pako = new pako[this._pakoAction]({
    raw: true,
    level: this._pakoOptions.level || -1 // default compression

  });
  var self = this;

  this._pako.onData = function (data) {
    self.push({
      data: data,
      meta: self.meta
    });
  };
};

exports.compressWorker = function (compressionOptions) {
  return new FlateWorker("Deflate", compressionOptions);
};

exports.uncompressWorker = function () {
  return new FlateWorker("Inflate", {});
};

/***/ }),

/***/ "./node_modules/jszip/lib/generate/ZipFileWorker.js":
/*!**********************************************************!*\
  !*** ./node_modules/jszip/lib/generate/ZipFileWorker.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/jszip/lib/utils.js");

var GenericWorker = __webpack_require__(/*! ../stream/GenericWorker */ "./node_modules/jszip/lib/stream/GenericWorker.js");

var utf8 = __webpack_require__(/*! ../utf8 */ "./node_modules/jszip/lib/utf8.js");

var crc32 = __webpack_require__(/*! ../crc32 */ "./node_modules/jszip/lib/crc32.js");

var signature = __webpack_require__(/*! ../signature */ "./node_modules/jszip/lib/signature.js");
/**
 * Transform an integer into a string in hexadecimal.
 * @private
 * @param {number} dec the number to convert.
 * @param {number} bytes the number of bytes to generate.
 * @returns {string} the result.
 */


var decToHex = function decToHex(dec, bytes) {
  var hex = "",
      i;

  for (i = 0; i < bytes; i++) {
    hex += String.fromCharCode(dec & 0xff);
    dec = dec >>> 8;
  }

  return hex;
};
/**
 * Generate the UNIX part of the external file attributes.
 * @param {Object} unixPermissions the unix permissions or null.
 * @param {Boolean} isDir true if the entry is a directory, false otherwise.
 * @return {Number} a 32 bit integer.
 *
 * adapted from http://unix.stackexchange.com/questions/14705/the-zip-formats-external-file-attribute :
 *
 * TTTTsstrwxrwxrwx0000000000ADVSHR
 * ^^^^____________________________ file type, see zipinfo.c (UNX_*)
 *     ^^^_________________________ setuid, setgid, sticky
 *        ^^^^^^^^^________________ permissions
 *                 ^^^^^^^^^^______ not used ?
 *                           ^^^^^^ DOS attribute bits : Archive, Directory, Volume label, System file, Hidden, Read only
 */


var generateUnixExternalFileAttr = function generateUnixExternalFileAttr(unixPermissions, isDir) {
  var result = unixPermissions;

  if (!unixPermissions) {
    // I can't use octal values in strict mode, hence the hexa.
    //  040775 => 0x41fd
    // 0100664 => 0x81b4
    result = isDir ? 0x41fd : 0x81b4;
  }

  return (result & 0xFFFF) << 16;
};
/**
 * Generate the DOS part of the external file attributes.
 * @param {Object} dosPermissions the dos permissions or null.
 * @param {Boolean} isDir true if the entry is a directory, false otherwise.
 * @return {Number} a 32 bit integer.
 *
 * Bit 0     Read-Only
 * Bit 1     Hidden
 * Bit 2     System
 * Bit 3     Volume Label
 * Bit 4     Directory
 * Bit 5     Archive
 */


var generateDosExternalFileAttr = function generateDosExternalFileAttr(dosPermissions, isDir) {
  // the dir flag is already set for compatibility
  return (dosPermissions || 0) & 0x3F;
};
/**
 * Generate the various parts used in the construction of the final zip file.
 * @param {Object} streamInfo the hash with informations about the compressed file.
 * @param {Boolean} streamedContent is the content streamed ?
 * @param {Boolean} streamingEnded is the stream finished ?
 * @param {number} offset the current offset from the start of the zip file.
 * @param {String} platform let's pretend we are this platform (change platform dependents fields)
 * @param {Function} encodeFileName the function to encode the file name / comment.
 * @return {Object} the zip parts.
 */


var generateZipParts = function generateZipParts(streamInfo, streamedContent, streamingEnded, offset, platform, encodeFileName) {
  var file = streamInfo['file'],
      compression = streamInfo['compression'],
      useCustomEncoding = encodeFileName !== utf8.utf8encode,
      encodedFileName = utils.transformTo("string", encodeFileName(file.name)),
      utfEncodedFileName = utils.transformTo("string", utf8.utf8encode(file.name)),
      comment = file.comment,
      encodedComment = utils.transformTo("string", encodeFileName(comment)),
      utfEncodedComment = utils.transformTo("string", utf8.utf8encode(comment)),
      useUTF8ForFileName = utfEncodedFileName.length !== file.name.length,
      useUTF8ForComment = utfEncodedComment.length !== comment.length,
      dosTime,
      dosDate,
      extraFields = "",
      unicodePathExtraField = "",
      unicodeCommentExtraField = "",
      dir = file.dir,
      date = file.date;
  var dataInfo = {
    crc32: 0,
    compressedSize: 0,
    uncompressedSize: 0
  }; // if the content is streamed, the sizes/crc32 are only available AFTER
  // the end of the stream.

  if (!streamedContent || streamingEnded) {
    dataInfo.crc32 = streamInfo['crc32'];
    dataInfo.compressedSize = streamInfo['compressedSize'];
    dataInfo.uncompressedSize = streamInfo['uncompressedSize'];
  }

  var bitflag = 0;

  if (streamedContent) {
    // Bit 3: the sizes/crc32 are set to zero in the local header.
    // The correct values are put in the data descriptor immediately
    // following the compressed data.
    bitflag |= 0x0008;
  }

  if (!useCustomEncoding && (useUTF8ForFileName || useUTF8ForComment)) {
    // Bit 11: Language encoding flag (EFS).
    bitflag |= 0x0800;
  }

  var extFileAttr = 0;
  var versionMadeBy = 0;

  if (dir) {
    // dos or unix, we set the dos dir flag
    extFileAttr |= 0x00010;
  }

  if (platform === "UNIX") {
    versionMadeBy = 0x031E; // UNIX, version 3.0

    extFileAttr |= generateUnixExternalFileAttr(file.unixPermissions, dir);
  } else {
    // DOS or other, fallback to DOS
    versionMadeBy = 0x0014; // DOS, version 2.0

    extFileAttr |= generateDosExternalFileAttr(file.dosPermissions, dir);
  } // date
  // @see http://www.delorie.com/djgpp/doc/rbinter/it/52/13.html
  // @see http://www.delorie.com/djgpp/doc/rbinter/it/65/16.html
  // @see http://www.delorie.com/djgpp/doc/rbinter/it/66/16.html


  dosTime = date.getUTCHours();
  dosTime = dosTime << 6;
  dosTime = dosTime | date.getUTCMinutes();
  dosTime = dosTime << 5;
  dosTime = dosTime | date.getUTCSeconds() / 2;
  dosDate = date.getUTCFullYear() - 1980;
  dosDate = dosDate << 4;
  dosDate = dosDate | date.getUTCMonth() + 1;
  dosDate = dosDate << 5;
  dosDate = dosDate | date.getUTCDate();

  if (useUTF8ForFileName) {
    // set the unicode path extra field. unzip needs at least one extra
    // field to correctly handle unicode path, so using the path is as good
    // as any other information. This could improve the situation with
    // other archive managers too.
    // This field is usually used without the utf8 flag, with a non
    // unicode path in the header (winrar, winzip). This helps (a bit)
    // with the messy Windows' default compressed folders feature but
    // breaks on p7zip which doesn't seek the unicode path extra field.
    // So for now, UTF-8 everywhere !
    unicodePathExtraField = // Version
    decToHex(1, 1) + // NameCRC32
    decToHex(crc32(encodedFileName), 4) + // UnicodeName
    utfEncodedFileName;
    extraFields += // Info-ZIP Unicode Path Extra Field
    "\x75\x70" + // size
    decToHex(unicodePathExtraField.length, 2) + // content
    unicodePathExtraField;
  }

  if (useUTF8ForComment) {
    unicodeCommentExtraField = // Version
    decToHex(1, 1) + // CommentCRC32
    decToHex(crc32(encodedComment), 4) + // UnicodeName
    utfEncodedComment;
    extraFields += // Info-ZIP Unicode Path Extra Field
    "\x75\x63" + // size
    decToHex(unicodeCommentExtraField.length, 2) + // content
    unicodeCommentExtraField;
  }

  var header = ""; // version needed to extract

  header += "\x0A\x00"; // general purpose bit flag

  header += decToHex(bitflag, 2); // compression method

  header += compression.magic; // last mod file time

  header += decToHex(dosTime, 2); // last mod file date

  header += decToHex(dosDate, 2); // crc-32

  header += decToHex(dataInfo.crc32, 4); // compressed size

  header += decToHex(dataInfo.compressedSize, 4); // uncompressed size

  header += decToHex(dataInfo.uncompressedSize, 4); // file name length

  header += decToHex(encodedFileName.length, 2); // extra field length

  header += decToHex(extraFields.length, 2);
  var fileRecord = signature.LOCAL_FILE_HEADER + header + encodedFileName + extraFields;
  var dirRecord = signature.CENTRAL_FILE_HEADER + // version made by (00: DOS)
  decToHex(versionMadeBy, 2) + // file header (common to file and central directory)
  header + // file comment length
  decToHex(encodedComment.length, 2) + // disk number start
  "\x00\x00" + // internal file attributes TODO
  "\x00\x00" + // external file attributes
  decToHex(extFileAttr, 4) + // relative offset of local header
  decToHex(offset, 4) + // file name
  encodedFileName + // extra field
  extraFields + // file comment
  encodedComment;
  return {
    fileRecord: fileRecord,
    dirRecord: dirRecord
  };
};
/**
 * Generate the EOCD record.
 * @param {Number} entriesCount the number of entries in the zip file.
 * @param {Number} centralDirLength the length (in bytes) of the central dir.
 * @param {Number} localDirLength the length (in bytes) of the local dir.
 * @param {String} comment the zip file comment as a binary string.
 * @param {Function} encodeFileName the function to encode the comment.
 * @return {String} the EOCD record.
 */


var generateCentralDirectoryEnd = function generateCentralDirectoryEnd(entriesCount, centralDirLength, localDirLength, comment, encodeFileName) {
  var dirEnd = "";
  var encodedComment = utils.transformTo("string", encodeFileName(comment)); // end of central dir signature

  dirEnd = signature.CENTRAL_DIRECTORY_END + // number of this disk
  "\x00\x00" + // number of the disk with the start of the central directory
  "\x00\x00" + // total number of entries in the central directory on this disk
  decToHex(entriesCount, 2) + // total number of entries in the central directory
  decToHex(entriesCount, 2) + // size of the central directory   4 bytes
  decToHex(centralDirLength, 4) + // offset of start of central directory with respect to the starting disk number
  decToHex(localDirLength, 4) + // .ZIP file comment length
  decToHex(encodedComment.length, 2) + // .ZIP file comment
  encodedComment;
  return dirEnd;
};
/**
 * Generate data descriptors for a file entry.
 * @param {Object} streamInfo the hash generated by a worker, containing informations
 * on the file entry.
 * @return {String} the data descriptors.
 */


var generateDataDescriptors = function generateDataDescriptors(streamInfo) {
  var descriptor = "";
  descriptor = signature.DATA_DESCRIPTOR + // crc-32                          4 bytes
  decToHex(streamInfo['crc32'], 4) + // compressed size                 4 bytes
  decToHex(streamInfo['compressedSize'], 4) + // uncompressed size               4 bytes
  decToHex(streamInfo['uncompressedSize'], 4);
  return descriptor;
};
/**
 * A worker to concatenate other workers to create a zip file.
 * @param {Boolean} streamFiles `true` to stream the content of the files,
 * `false` to accumulate it.
 * @param {String} comment the comment to use.
 * @param {String} platform the platform to use, "UNIX" or "DOS".
 * @param {Function} encodeFileName the function to encode file names and comments.
 */


function ZipFileWorker(streamFiles, comment, platform, encodeFileName) {
  GenericWorker.call(this, "ZipFileWorker"); // The number of bytes written so far. This doesn't count accumulated chunks.

  this.bytesWritten = 0; // The comment of the zip file

  this.zipComment = comment; // The platform "generating" the zip file.

  this.zipPlatform = platform; // the function to encode file names and comments.

  this.encodeFileName = encodeFileName; // Should we stream the content of the files ?

  this.streamFiles = streamFiles; // If `streamFiles` is false, we will need to accumulate the content of the
  // files to calculate sizes / crc32 (and write them *before* the content).
  // This boolean indicates if we are accumulating chunks (it will change a lot
  // during the lifetime of this worker).

  this.accumulate = false; // The buffer receiving chunks when accumulating content.

  this.contentBuffer = []; // The list of generated directory records.

  this.dirRecords = []; // The offset (in bytes) from the beginning of the zip file for the current source.

  this.currentSourceOffset = 0; // The total number of entries in this zip file.

  this.entriesCount = 0; // the name of the file currently being added, null when handling the end of the zip file.
  // Used for the emited metadata.

  this.currentFile = null;
  this._sources = [];
}

utils.inherits(ZipFileWorker, GenericWorker);
/**
 * @see GenericWorker.push
 */

ZipFileWorker.prototype.push = function (chunk) {
  var currentFilePercent = chunk.meta.percent || 0;
  var entriesCount = this.entriesCount;
  var remainingFiles = this._sources.length;

  if (this.accumulate) {
    this.contentBuffer.push(chunk);
  } else {
    this.bytesWritten += chunk.data.length;
    GenericWorker.prototype.push.call(this, {
      data: chunk.data,
      meta: {
        currentFile: this.currentFile,
        percent: entriesCount ? (currentFilePercent + 100 * (entriesCount - remainingFiles - 1)) / entriesCount : 100
      }
    });
  }
};
/**
 * The worker started a new source (an other worker).
 * @param {Object} streamInfo the streamInfo object from the new source.
 */


ZipFileWorker.prototype.openedSource = function (streamInfo) {
  this.currentSourceOffset = this.bytesWritten;
  this.currentFile = streamInfo['file'].name;
  var streamedContent = this.streamFiles && !streamInfo['file'].dir; // don't stream folders (because they don't have any content)

  if (streamedContent) {
    var record = generateZipParts(streamInfo, streamedContent, false, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
    this.push({
      data: record.fileRecord,
      meta: {
        percent: 0
      }
    });
  } else {
    // we need to wait for the whole file before pushing anything
    this.accumulate = true;
  }
};
/**
 * The worker finished a source (an other worker).
 * @param {Object} streamInfo the streamInfo object from the finished source.
 */


ZipFileWorker.prototype.closedSource = function (streamInfo) {
  this.accumulate = false;
  var streamedContent = this.streamFiles && !streamInfo['file'].dir;
  var record = generateZipParts(streamInfo, streamedContent, true, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
  this.dirRecords.push(record.dirRecord);

  if (streamedContent) {
    // after the streamed file, we put data descriptors
    this.push({
      data: generateDataDescriptors(streamInfo),
      meta: {
        percent: 100
      }
    });
  } else {
    // the content wasn't streamed, we need to push everything now
    // first the file record, then the content
    this.push({
      data: record.fileRecord,
      meta: {
        percent: 0
      }
    });

    while (this.contentBuffer.length) {
      this.push(this.contentBuffer.shift());
    }
  }

  this.currentFile = null;
};
/**
 * @see GenericWorker.flush
 */


ZipFileWorker.prototype.flush = function () {
  var localDirLength = this.bytesWritten;

  for (var i = 0; i < this.dirRecords.length; i++) {
    this.push({
      data: this.dirRecords[i],
      meta: {
        percent: 100
      }
    });
  }

  var centralDirLength = this.bytesWritten - localDirLength;
  var dirEnd = generateCentralDirectoryEnd(this.dirRecords.length, centralDirLength, localDirLength, this.zipComment, this.encodeFileName);
  this.push({
    data: dirEnd,
    meta: {
      percent: 100
    }
  });
};
/**
 * Prepare the next source to be read.
 */


ZipFileWorker.prototype.prepareNextSource = function () {
  this.previous = this._sources.shift();
  this.openedSource(this.previous.streamInfo);

  if (this.isPaused) {
    this.previous.pause();
  } else {
    this.previous.resume();
  }
};
/**
 * @see GenericWorker.registerPrevious
 */


ZipFileWorker.prototype.registerPrevious = function (previous) {
  this._sources.push(previous);

  var self = this;
  previous.on('data', function (chunk) {
    self.processChunk(chunk);
  });
  previous.on('end', function () {
    self.closedSource(self.previous.streamInfo);

    if (self._sources.length) {
      self.prepareNextSource();
    } else {
      self.end();
    }
  });
  previous.on('error', function (e) {
    self.error(e);
  });
  return this;
};
/**
 * @see GenericWorker.resume
 */


ZipFileWorker.prototype.resume = function () {
  if (!GenericWorker.prototype.resume.call(this)) {
    return false;
  }

  if (!this.previous && this._sources.length) {
    this.prepareNextSource();
    return true;
  }

  if (!this.previous && !this._sources.length && !this.generatedError) {
    this.end();
    return true;
  }
};
/**
 * @see GenericWorker.error
 */


ZipFileWorker.prototype.error = function (e) {
  var sources = this._sources;

  if (!GenericWorker.prototype.error.call(this, e)) {
    return false;
  }

  for (var i = 0; i < sources.length; i++) {
    try {
      sources[i].error(e);
    } catch (e) {// the `error` exploded, nothing to do
    }
  }

  return true;
};
/**
 * @see GenericWorker.lock
 */


ZipFileWorker.prototype.lock = function () {
  GenericWorker.prototype.lock.call(this);
  var sources = this._sources;

  for (var i = 0; i < sources.length; i++) {
    sources[i].lock();
  }
};

module.exports = ZipFileWorker;

/***/ }),

/***/ "./node_modules/jszip/lib/generate/index.js":
/*!**************************************************!*\
  !*** ./node_modules/jszip/lib/generate/index.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var compressions = __webpack_require__(/*! ../compressions */ "./node_modules/jszip/lib/compressions.js");

var ZipFileWorker = __webpack_require__(/*! ./ZipFileWorker */ "./node_modules/jszip/lib/generate/ZipFileWorker.js");
/**
 * Find the compression to use.
 * @param {String} fileCompression the compression defined at the file level, if any.
 * @param {String} zipCompression the compression defined at the load() level.
 * @return {Object} the compression object to use.
 */


var getCompression = function getCompression(fileCompression, zipCompression) {
  var compressionName = fileCompression || zipCompression;
  var compression = compressions[compressionName];

  if (!compression) {
    throw new Error(compressionName + " is not a valid compression method !");
  }

  return compression;
};
/**
 * Create a worker to generate a zip file.
 * @param {JSZip} zip the JSZip instance at the right root level.
 * @param {Object} options to generate the zip file.
 * @param {String} comment the comment to use.
 */


exports.generateWorker = function (zip, options, comment) {
  var zipFileWorker = new ZipFileWorker(options.streamFiles, comment, options.platform, options.encodeFileName);
  var entriesCount = 0;

  try {
    zip.forEach(function (relativePath, file) {
      entriesCount++;
      var compression = getCompression(file.options.compression, options.compression);
      var compressionOptions = file.options.compressionOptions || options.compressionOptions || {};
      var dir = file.dir,
          date = file.date;

      file._compressWorker(compression, compressionOptions).withStreamInfo("file", {
        name: relativePath,
        dir: dir,
        date: date,
        comment: file.comment || "",
        unixPermissions: file.unixPermissions,
        dosPermissions: file.dosPermissions
      }).pipe(zipFileWorker);
    });
    zipFileWorker.entriesCount = entriesCount;
  } catch (e) {
    zipFileWorker.error(e);
  }

  return zipFileWorker;
};

/***/ }),

/***/ "./node_modules/jszip/lib/index.js":
/*!*****************************************!*\
  !*** ./node_modules/jszip/lib/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Representation a of zip file in js
 * @constructor
 */

function JSZip() {
  // if this constructor is used without `new`, it adds `new` before itself:
  if (!(this instanceof JSZip)) {
    return new JSZip();
  }

  if (arguments.length) {
    throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
  } // object containing the files :
  // {
  //   "folder/" : {...},
  //   "folder/data.txt" : {...}
  // }


  this.files = {};
  this.comment = null; // Where we are in the hierarchy

  this.root = "";

  this.clone = function () {
    var newObj = new JSZip();

    for (var i in this) {
      if (typeof this[i] !== "function") {
        newObj[i] = this[i];
      }
    }

    return newObj;
  };
}

JSZip.prototype = __webpack_require__(/*! ./object */ "./node_modules/jszip/lib/object.js");
JSZip.prototype.loadAsync = __webpack_require__(/*! ./load */ "./node_modules/jszip/lib/load.js");
JSZip.support = __webpack_require__(/*! ./support */ "./node_modules/jszip/lib/support.js");
JSZip.defaults = __webpack_require__(/*! ./defaults */ "./node_modules/jszip/lib/defaults.js"); // TODO find a better way to handle this version,
// a require('package.json').version doesn't work with webpack, see #327

JSZip.version = "3.1.5";

JSZip.loadAsync = function (content, options) {
  return new JSZip().loadAsync(content, options);
};

JSZip.external = __webpack_require__(/*! ./external */ "./node_modules/jszip/lib/external.js");
module.exports = JSZip;

/***/ }),

/***/ "./node_modules/jszip/lib/load.js":
/*!****************************************!*\
  !*** ./node_modules/jszip/lib/load.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./utils */ "./node_modules/jszip/lib/utils.js");

var external = __webpack_require__(/*! ./external */ "./node_modules/jszip/lib/external.js");

var utf8 = __webpack_require__(/*! ./utf8 */ "./node_modules/jszip/lib/utf8.js");

var utils = __webpack_require__(/*! ./utils */ "./node_modules/jszip/lib/utils.js");

var ZipEntries = __webpack_require__(/*! ./zipEntries */ "./node_modules/jszip/lib/zipEntries.js");

var Crc32Probe = __webpack_require__(/*! ./stream/Crc32Probe */ "./node_modules/jszip/lib/stream/Crc32Probe.js");

var nodejsUtils = __webpack_require__(/*! ./nodejsUtils */ "./node_modules/jszip/lib/nodejsUtils.js");
/**
 * Check the CRC32 of an entry.
 * @param {ZipEntry} zipEntry the zip entry to check.
 * @return {Promise} the result.
 */


function checkEntryCRC32(zipEntry) {
  return new external.Promise(function (resolve, reject) {
    var worker = zipEntry.decompressed.getContentWorker().pipe(new Crc32Probe());
    worker.on("error", function (e) {
      reject(e);
    }).on("end", function () {
      if (worker.streamInfo.crc32 !== zipEntry.decompressed.crc32) {
        reject(new Error("Corrupted zip : CRC32 mismatch"));
      } else {
        resolve();
      }
    }).resume();
  });
}

module.exports = function (data, options) {
  var zip = this;
  options = utils.extend(options || {}, {
    base64: false,
    checkCRC32: false,
    optimizedBinaryString: false,
    createFolders: false,
    decodeFileName: utf8.utf8decode
  });

  if (nodejsUtils.isNode && nodejsUtils.isStream(data)) {
    return external.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file."));
  }

  return utils.prepareContent("the loaded zip file", data, true, options.optimizedBinaryString, options.base64).then(function (data) {
    var zipEntries = new ZipEntries(options);
    zipEntries.load(data);
    return zipEntries;
  }).then(function checkCRC32(zipEntries) {
    var promises = [external.Promise.resolve(zipEntries)];
    var files = zipEntries.files;

    if (options.checkCRC32) {
      for (var i = 0; i < files.length; i++) {
        promises.push(checkEntryCRC32(files[i]));
      }
    }

    return external.Promise.all(promises);
  }).then(function addFiles(results) {
    var zipEntries = results.shift();
    var files = zipEntries.files;

    for (var i = 0; i < files.length; i++) {
      var input = files[i];
      zip.file(input.fileNameStr, input.decompressed, {
        binary: true,
        optimizedBinaryString: true,
        date: input.date,
        dir: input.dir,
        comment: input.fileCommentStr.length ? input.fileCommentStr : null,
        unixPermissions: input.unixPermissions,
        dosPermissions: input.dosPermissions,
        createFolders: options.createFolders
      });
    }

    if (zipEntries.zipComment.length) {
      zip.comment = zipEntries.zipComment;
    }

    return zip;
  });
};

/***/ }),

/***/ "./node_modules/jszip/lib/nodejs/NodejsStreamInputAdapter.js":
/*!*******************************************************************!*\
  !*** ./node_modules/jszip/lib/nodejs/NodejsStreamInputAdapter.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/jszip/lib/utils.js");

var GenericWorker = __webpack_require__(/*! ../stream/GenericWorker */ "./node_modules/jszip/lib/stream/GenericWorker.js");
/**
 * A worker that use a nodejs stream as source.
 * @constructor
 * @param {String} filename the name of the file entry for this stream.
 * @param {Readable} stream the nodejs stream.
 */


function NodejsStreamInputAdapter(filename, stream) {
  GenericWorker.call(this, "Nodejs stream input adapter for " + filename);
  this._upstreamEnded = false;

  this._bindStream(stream);
}

utils.inherits(NodejsStreamInputAdapter, GenericWorker);
/**
 * Prepare the stream and bind the callbacks on it.
 * Do this ASAP on node 0.10 ! A lazy binding doesn't always work.
 * @param {Stream} stream the nodejs stream to use.
 */

NodejsStreamInputAdapter.prototype._bindStream = function (stream) {
  var self = this;
  this._stream = stream;
  stream.pause();
  stream.on("data", function (chunk) {
    self.push({
      data: chunk,
      meta: {
        percent: 0
      }
    });
  }).on("error", function (e) {
    if (self.isPaused) {
      this.generatedError = e;
    } else {
      self.error(e);
    }
  }).on("end", function () {
    if (self.isPaused) {
      self._upstreamEnded = true;
    } else {
      self.end();
    }
  });
};

NodejsStreamInputAdapter.prototype.pause = function () {
  if (!GenericWorker.prototype.pause.call(this)) {
    return false;
  }

  this._stream.pause();

  return true;
};

NodejsStreamInputAdapter.prototype.resume = function () {
  if (!GenericWorker.prototype.resume.call(this)) {
    return false;
  }

  if (this._upstreamEnded) {
    this.end();
  } else {
    this._stream.resume();
  }

  return true;
};

module.exports = NodejsStreamInputAdapter;

/***/ }),

/***/ "./node_modules/jszip/lib/nodejs/NodejsStreamOutputAdapter.js":
/*!********************************************************************!*\
  !*** ./node_modules/jszip/lib/nodejs/NodejsStreamOutputAdapter.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Readable = __webpack_require__(/*! readable-stream */ "./node_modules/jszip/lib/readable-stream-browser.js").Readable;

var utils = __webpack_require__(/*! ../utils */ "./node_modules/jszip/lib/utils.js");

utils.inherits(NodejsStreamOutputAdapter, Readable);
/**
* A nodejs stream using a worker as source.
* @see the SourceWrapper in http://nodejs.org/api/stream.html
* @constructor
* @param {StreamHelper} helper the helper wrapping the worker
* @param {Object} options the nodejs stream options
* @param {Function} updateCb the update callback.
*/

function NodejsStreamOutputAdapter(helper, options, updateCb) {
  Readable.call(this, options);
  this._helper = helper;
  var self = this;
  helper.on("data", function (data, meta) {
    if (!self.push(data)) {
      self._helper.pause();
    }

    if (updateCb) {
      updateCb(meta);
    }
  }).on("error", function (e) {
    self.emit('error', e);
  }).on("end", function () {
    self.push(null);
  });
}

NodejsStreamOutputAdapter.prototype._read = function () {
  this._helper.resume();
};

module.exports = NodejsStreamOutputAdapter;

/***/ }),

/***/ "./node_modules/jszip/lib/nodejsUtils.js":
/*!***********************************************!*\
  !*** ./node_modules/jszip/lib/nodejsUtils.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

module.exports = {
  /**
   * True if this is running in Nodejs, will be undefined in a browser.
   * In a browser, browserify won't include this file and the whole module
   * will be resolved an empty object.
   */
  isNode: typeof Buffer !== "undefined",

  /**
   * Create a new nodejs Buffer from an existing content.
   * @param {Object} data the data to pass to the constructor.
   * @param {String} encoding the encoding to use.
   * @return {Buffer} a new Buffer.
   */
  newBufferFrom: function newBufferFrom(data, encoding) {
    // XXX We can't use `Buffer.from` which comes from `Uint8Array.from`
    // in nodejs v4 (< v.4.5). It's not the expected implementation (and
    // has a different signature).
    // see https://github.com/nodejs/node/issues/8053
    // A condition on nodejs' version won't solve the issue as we don't
    // control the Buffer polyfills that may or may not be used.
    return new Buffer(data, encoding);
  },

  /**
   * Create a new nodejs Buffer with the specified size.
   * @param {Integer} size the size of the buffer.
   * @return {Buffer} a new Buffer.
   */
  allocBuffer: function allocBuffer(size) {
    if (Buffer.alloc) {
      return Buffer.alloc(size);
    } else {
      return new Buffer(size);
    }
  },

  /**
   * Find out if an object is a Buffer.
   * @param {Object} b the object to test.
   * @return {Boolean} true if the object is a Buffer, false otherwise.
   */
  isBuffer: function isBuffer(b) {
    return Buffer.isBuffer(b);
  },
  isStream: function isStream(obj) {
    return obj && typeof obj.on === "function" && typeof obj.pause === "function" && typeof obj.resume === "function";
  }
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../buffer/index.js */ "./node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/jszip/lib/object.js":
/*!******************************************!*\
  !*** ./node_modules/jszip/lib/object.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utf8 = __webpack_require__(/*! ./utf8 */ "./node_modules/jszip/lib/utf8.js");

var utils = __webpack_require__(/*! ./utils */ "./node_modules/jszip/lib/utils.js");

var GenericWorker = __webpack_require__(/*! ./stream/GenericWorker */ "./node_modules/jszip/lib/stream/GenericWorker.js");

var StreamHelper = __webpack_require__(/*! ./stream/StreamHelper */ "./node_modules/jszip/lib/stream/StreamHelper.js");

var defaults = __webpack_require__(/*! ./defaults */ "./node_modules/jszip/lib/defaults.js");

var CompressedObject = __webpack_require__(/*! ./compressedObject */ "./node_modules/jszip/lib/compressedObject.js");

var ZipObject = __webpack_require__(/*! ./zipObject */ "./node_modules/jszip/lib/zipObject.js");

var generate = __webpack_require__(/*! ./generate */ "./node_modules/jszip/lib/generate/index.js");

var nodejsUtils = __webpack_require__(/*! ./nodejsUtils */ "./node_modules/jszip/lib/nodejsUtils.js");

var NodejsStreamInputAdapter = __webpack_require__(/*! ./nodejs/NodejsStreamInputAdapter */ "./node_modules/jszip/lib/nodejs/NodejsStreamInputAdapter.js");
/**
 * Add a file in the current folder.
 * @private
 * @param {string} name the name of the file
 * @param {String|ArrayBuffer|Uint8Array|Buffer} data the data of the file
 * @param {Object} originalOptions the options of the file
 * @return {Object} the new file.
 */


var fileAdd = function fileAdd(name, data, originalOptions) {
  // be sure sub folders exist
  var dataType = utils.getTypeOf(data),
      parent;
  /*
   * Correct options.
   */

  var o = utils.extend(originalOptions || {}, defaults);
  o.date = o.date || new Date();

  if (o.compression !== null) {
    o.compression = o.compression.toUpperCase();
  }

  if (typeof o.unixPermissions === "string") {
    o.unixPermissions = parseInt(o.unixPermissions, 8);
  } // UNX_IFDIR  0040000 see zipinfo.c


  if (o.unixPermissions && o.unixPermissions & 0x4000) {
    o.dir = true;
  } // Bit 4    Directory


  if (o.dosPermissions && o.dosPermissions & 0x0010) {
    o.dir = true;
  }

  if (o.dir) {
    name = forceTrailingSlash(name);
  }

  if (o.createFolders && (parent = parentFolder(name))) {
    folderAdd.call(this, parent, true);
  }

  var isUnicodeString = dataType === "string" && o.binary === false && o.base64 === false;

  if (!originalOptions || typeof originalOptions.binary === "undefined") {
    o.binary = !isUnicodeString;
  }

  var isCompressedEmpty = data instanceof CompressedObject && data.uncompressedSize === 0;

  if (isCompressedEmpty || o.dir || !data || data.length === 0) {
    o.base64 = false;
    o.binary = true;
    data = "";
    o.compression = "STORE";
    dataType = "string";
  }
  /*
   * Convert content to fit.
   */


  var zipObjectContent = null;

  if (data instanceof CompressedObject || data instanceof GenericWorker) {
    zipObjectContent = data;
  } else if (nodejsUtils.isNode && nodejsUtils.isStream(data)) {
    zipObjectContent = new NodejsStreamInputAdapter(name, data);
  } else {
    zipObjectContent = utils.prepareContent(name, data, o.binary, o.optimizedBinaryString, o.base64);
  }

  var object = new ZipObject(name, zipObjectContent, o);
  this.files[name] = object;
  /*
  TODO: we can't throw an exception because we have async promises
  (we can have a promise of a Date() for example) but returning a
  promise is useless because file(name, data) returns the JSZip
  object for chaining. Should we break that to allow the user
  to catch the error ?
   return external.Promise.resolve(zipObjectContent)
  .then(function () {
      return object;
  });
  */
};
/**
 * Find the parent folder of the path.
 * @private
 * @param {string} path the path to use
 * @return {string} the parent folder, or ""
 */


var parentFolder = function parentFolder(path) {
  if (path.slice(-1) === '/') {
    path = path.substring(0, path.length - 1);
  }

  var lastSlash = path.lastIndexOf('/');
  return lastSlash > 0 ? path.substring(0, lastSlash) : "";
};
/**
 * Returns the path with a slash at the end.
 * @private
 * @param {String} path the path to check.
 * @return {String} the path with a trailing slash.
 */


var forceTrailingSlash = function forceTrailingSlash(path) {
  // Check the name ends with a /
  if (path.slice(-1) !== "/") {
    path += "/"; // IE doesn't like substr(-1)
  }

  return path;
};
/**
 * Add a (sub) folder in the current folder.
 * @private
 * @param {string} name the folder's name
 * @param {boolean=} [createFolders] If true, automatically create sub
 *  folders. Defaults to false.
 * @return {Object} the new folder.
 */


var folderAdd = function folderAdd(name, createFolders) {
  createFolders = typeof createFolders !== 'undefined' ? createFolders : defaults.createFolders;
  name = forceTrailingSlash(name); // Does this folder already exist?

  if (!this.files[name]) {
    fileAdd.call(this, name, null, {
      dir: true,
      createFolders: createFolders
    });
  }

  return this.files[name];
};
/**
* Cross-window, cross-Node-context regular expression detection
* @param  {Object}  object Anything
* @return {Boolean}        true if the object is a regular expression,
* false otherwise
*/


function isRegExp(object) {
  return Object.prototype.toString.call(object) === "[object RegExp]";
} // return the actual prototype of JSZip


var out = {
  /**
   * @see loadAsync
   */
  load: function load() {
    throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
  },

  /**
   * Call a callback function for each entry at this folder level.
   * @param {Function} cb the callback function:
   * function (relativePath, file) {...}
   * It takes 2 arguments : the relative path and the file.
   */
  forEach: function forEach(cb) {
    var filename, relativePath, file;

    for (filename in this.files) {
      if (!this.files.hasOwnProperty(filename)) {
        continue;
      }

      file = this.files[filename];
      relativePath = filename.slice(this.root.length, filename.length);

      if (relativePath && filename.slice(0, this.root.length) === this.root) {
        // the file is in the current root
        cb(relativePath, file); // TODO reverse the parameters ? need to be clean AND consistent with the filter search fn...
      }
    }
  },

  /**
   * Filter nested files/folders with the specified function.
   * @param {Function} search the predicate to use :
   * function (relativePath, file) {...}
   * It takes 2 arguments : the relative path and the file.
   * @return {Array} An array of matching elements.
   */
  filter: function filter(search) {
    var result = [];
    this.forEach(function (relativePath, entry) {
      if (search(relativePath, entry)) {
        // the file matches the function
        result.push(entry);
      }
    });
    return result;
  },

  /**
   * Add a file to the zip file, or search a file.
   * @param   {string|RegExp} name The name of the file to add (if data is defined),
   * the name of the file to find (if no data) or a regex to match files.
   * @param   {String|ArrayBuffer|Uint8Array|Buffer} data  The file data, either raw or base64 encoded
   * @param   {Object} o     File options
   * @return  {JSZip|Object|Array} this JSZip object (when adding a file),
   * a file (when searching by string) or an array of files (when searching by regex).
   */
  file: function file(name, data, o) {
    if (arguments.length === 1) {
      if (isRegExp(name)) {
        var regexp = name;
        return this.filter(function (relativePath, file) {
          return !file.dir && regexp.test(relativePath);
        });
      } else {
        // text
        var obj = this.files[this.root + name];

        if (obj && !obj.dir) {
          return obj;
        } else {
          return null;
        }
      }
    } else {
      // more than one argument : we have data !
      name = this.root + name;
      fileAdd.call(this, name, data, o);
    }

    return this;
  },

  /**
   * Add a directory to the zip file, or search.
   * @param   {String|RegExp} arg The name of the directory to add, or a regex to search folders.
   * @return  {JSZip} an object with the new directory as the root, or an array containing matching folders.
   */
  folder: function folder(arg) {
    if (!arg) {
      return this;
    }

    if (isRegExp(arg)) {
      return this.filter(function (relativePath, file) {
        return file.dir && arg.test(relativePath);
      });
    } // else, name is a new folder


    var name = this.root + arg;
    var newFolder = folderAdd.call(this, name); // Allow chaining by returning a new object with this folder as the root

    var ret = this.clone();
    ret.root = newFolder.name;
    return ret;
  },

  /**
   * Delete a file, or a directory and all sub-files, from the zip
   * @param {string} name the name of the file to delete
   * @return {JSZip} this JSZip object
   */
  remove: function remove(name) {
    name = this.root + name;
    var file = this.files[name];

    if (!file) {
      // Look for any folders
      if (name.slice(-1) !== "/") {
        name += "/";
      }

      file = this.files[name];
    }

    if (file && !file.dir) {
      // file
      delete this.files[name];
    } else {
      // maybe a folder, delete recursively
      var kids = this.filter(function (relativePath, file) {
        return file.name.slice(0, name.length) === name;
      });

      for (var i = 0; i < kids.length; i++) {
        delete this.files[kids[i].name];
      }
    }

    return this;
  },

  /**
   * Generate the complete zip file
   * @param {Object} options the options to generate the zip file :
   * - compression, "STORE" by default.
   * - type, "base64" by default. Values are : string, base64, uint8array, arraybuffer, blob.
   * @return {String|Uint8Array|ArrayBuffer|Buffer|Blob} the zip file
   */
  generate: function generate(options) {
    throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
  },

  /**
   * Generate the complete zip file as an internal stream.
   * @param {Object} options the options to generate the zip file :
   * - compression, "STORE" by default.
   * - type, "base64" by default. Values are : string, base64, uint8array, arraybuffer, blob.
   * @return {StreamHelper} the streamed zip file.
   */
  generateInternalStream: function generateInternalStream(options) {
    var worker,
        opts = {};

    try {
      opts = utils.extend(options || {}, {
        streamFiles: false,
        compression: "STORE",
        compressionOptions: null,
        type: "",
        platform: "DOS",
        comment: null,
        mimeType: 'application/zip',
        encodeFileName: utf8.utf8encode
      });
      opts.type = opts.type.toLowerCase();
      opts.compression = opts.compression.toUpperCase(); // "binarystring" is prefered but the internals use "string".

      if (opts.type === "binarystring") {
        opts.type = "string";
      }

      if (!opts.type) {
        throw new Error("No output type specified.");
      }

      utils.checkSupport(opts.type); // accept nodejs `process.platform`

      if (opts.platform === 'darwin' || opts.platform === 'freebsd' || opts.platform === 'linux' || opts.platform === 'sunos') {
        opts.platform = "UNIX";
      }

      if (opts.platform === 'win32') {
        opts.platform = "DOS";
      }

      var comment = opts.comment || this.comment || "";
      worker = generate.generateWorker(this, opts, comment);
    } catch (e) {
      worker = new GenericWorker("error");
      worker.error(e);
    }

    return new StreamHelper(worker, opts.type || "string", opts.mimeType);
  },

  /**
   * Generate the complete zip file asynchronously.
   * @see generateInternalStream
   */
  generateAsync: function generateAsync(options, onUpdate) {
    return this.generateInternalStream(options).accumulate(onUpdate);
  },

  /**
   * Generate the complete zip file asynchronously.
   * @see generateInternalStream
   */
  generateNodeStream: function generateNodeStream(options, onUpdate) {
    options = options || {};

    if (!options.type) {
      options.type = "nodebuffer";
    }

    return this.generateInternalStream(options).toNodejsStream(onUpdate);
  }
};
module.exports = out;

/***/ }),

/***/ "./node_modules/jszip/lib/readable-stream-browser.js":
/*!***********************************************************!*\
  !*** ./node_modules/jszip/lib/readable-stream-browser.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*
 * This file is used by module bundlers (browserify/webpack/etc) when
 * including a stream implementation. We use "readable-stream" to get a
 * consistent behavior between nodejs versions but bundlers often have a shim
 * for "stream". Using this shim greatly improve the compatibility and greatly
 * reduce the final size of the bundle (only one stream implementation, not
 * two).
 */
module.exports = __webpack_require__(/*! stream */ "./node_modules/stream-browserify/index.js");

/***/ }),

/***/ "./node_modules/jszip/lib/reader/ArrayReader.js":
/*!******************************************************!*\
  !*** ./node_modules/jszip/lib/reader/ArrayReader.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var DataReader = __webpack_require__(/*! ./DataReader */ "./node_modules/jszip/lib/reader/DataReader.js");

var utils = __webpack_require__(/*! ../utils */ "./node_modules/jszip/lib/utils.js");

function ArrayReader(data) {
  DataReader.call(this, data);

  for (var i = 0; i < this.data.length; i++) {
    data[i] = data[i] & 0xFF;
  }
}

utils.inherits(ArrayReader, DataReader);
/**
 * @see DataReader.byteAt
 */

ArrayReader.prototype.byteAt = function (i) {
  return this.data[this.zero + i];
};
/**
 * @see DataReader.lastIndexOfSignature
 */


ArrayReader.prototype.lastIndexOfSignature = function (sig) {
  var sig0 = sig.charCodeAt(0),
      sig1 = sig.charCodeAt(1),
      sig2 = sig.charCodeAt(2),
      sig3 = sig.charCodeAt(3);

  for (var i = this.length - 4; i >= 0; --i) {
    if (this.data[i] === sig0 && this.data[i + 1] === sig1 && this.data[i + 2] === sig2 && this.data[i + 3] === sig3) {
      return i - this.zero;
    }
  }

  return -1;
};
/**
 * @see DataReader.readAndCheckSignature
 */


ArrayReader.prototype.readAndCheckSignature = function (sig) {
  var sig0 = sig.charCodeAt(0),
      sig1 = sig.charCodeAt(1),
      sig2 = sig.charCodeAt(2),
      sig3 = sig.charCodeAt(3),
      data = this.readData(4);
  return sig0 === data[0] && sig1 === data[1] && sig2 === data[2] && sig3 === data[3];
};
/**
 * @see DataReader.readData
 */


ArrayReader.prototype.readData = function (size) {
  this.checkOffset(size);

  if (size === 0) {
    return [];
  }

  var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
  this.index += size;
  return result;
};

module.exports = ArrayReader;

/***/ }),

/***/ "./node_modules/jszip/lib/reader/DataReader.js":
/*!*****************************************************!*\
  !*** ./node_modules/jszip/lib/reader/DataReader.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/jszip/lib/utils.js");

function DataReader(data) {
  this.data = data; // type : see implementation

  this.length = data.length;
  this.index = 0;
  this.zero = 0;
}

DataReader.prototype = {
  /**
   * Check that the offset will not go too far.
   * @param {string} offset the additional offset to check.
   * @throws {Error} an Error if the offset is out of bounds.
   */
  checkOffset: function checkOffset(offset) {
    this.checkIndex(this.index + offset);
  },

  /**
   * Check that the specified index will not be too far.
   * @param {string} newIndex the index to check.
   * @throws {Error} an Error if the index is out of bounds.
   */
  checkIndex: function checkIndex(newIndex) {
    if (this.length < this.zero + newIndex || newIndex < 0) {
      throw new Error("End of data reached (data length = " + this.length + ", asked index = " + newIndex + "). Corrupted zip ?");
    }
  },

  /**
   * Change the index.
   * @param {number} newIndex The new index.
   * @throws {Error} if the new index is out of the data.
   */
  setIndex: function setIndex(newIndex) {
    this.checkIndex(newIndex);
    this.index = newIndex;
  },

  /**
   * Skip the next n bytes.
   * @param {number} n the number of bytes to skip.
   * @throws {Error} if the new index is out of the data.
   */
  skip: function skip(n) {
    this.setIndex(this.index + n);
  },

  /**
   * Get the byte at the specified index.
   * @param {number} i the index to use.
   * @return {number} a byte.
   */
  byteAt: function byteAt(i) {// see implementations
  },

  /**
   * Get the next number with a given byte size.
   * @param {number} size the number of bytes to read.
   * @return {number} the corresponding number.
   */
  readInt: function readInt(size) {
    var result = 0,
        i;
    this.checkOffset(size);

    for (i = this.index + size - 1; i >= this.index; i--) {
      result = (result << 8) + this.byteAt(i);
    }

    this.index += size;
    return result;
  },

  /**
   * Get the next string with a given byte size.
   * @param {number} size the number of bytes to read.
   * @return {string} the corresponding string.
   */
  readString: function readString(size) {
    return utils.transformTo("string", this.readData(size));
  },

  /**
   * Get raw data without conversion, <size> bytes.
   * @param {number} size the number of bytes to read.
   * @return {Object} the raw data, implementation specific.
   */
  readData: function readData(size) {// see implementations
  },

  /**
   * Find the last occurence of a zip signature (4 bytes).
   * @param {string} sig the signature to find.
   * @return {number} the index of the last occurence, -1 if not found.
   */
  lastIndexOfSignature: function lastIndexOfSignature(sig) {// see implementations
  },

  /**
   * Read the signature (4 bytes) at the current position and compare it with sig.
   * @param {string} sig the expected signature
   * @return {boolean} true if the signature matches, false otherwise.
   */
  readAndCheckSignature: function readAndCheckSignature(sig) {// see implementations
  },

  /**
   * Get the next date.
   * @return {Date} the date.
   */
  readDate: function readDate() {
    var dostime = this.readInt(4);
    return new Date(Date.UTC((dostime >> 25 & 0x7f) + 1980, // year
    (dostime >> 21 & 0x0f) - 1, // month
    dostime >> 16 & 0x1f, // day
    dostime >> 11 & 0x1f, // hour
    dostime >> 5 & 0x3f, // minute
    (dostime & 0x1f) << 1)); // second
  }
};
module.exports = DataReader;

/***/ }),

/***/ "./node_modules/jszip/lib/reader/NodeBufferReader.js":
/*!***********************************************************!*\
  !*** ./node_modules/jszip/lib/reader/NodeBufferReader.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Uint8ArrayReader = __webpack_require__(/*! ./Uint8ArrayReader */ "./node_modules/jszip/lib/reader/Uint8ArrayReader.js");

var utils = __webpack_require__(/*! ../utils */ "./node_modules/jszip/lib/utils.js");

function NodeBufferReader(data) {
  Uint8ArrayReader.call(this, data);
}

utils.inherits(NodeBufferReader, Uint8ArrayReader);
/**
 * @see DataReader.readData
 */

NodeBufferReader.prototype.readData = function (size) {
  this.checkOffset(size);
  var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
  this.index += size;
  return result;
};

module.exports = NodeBufferReader;

/***/ }),

/***/ "./node_modules/jszip/lib/reader/StringReader.js":
/*!*******************************************************!*\
  !*** ./node_modules/jszip/lib/reader/StringReader.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var DataReader = __webpack_require__(/*! ./DataReader */ "./node_modules/jszip/lib/reader/DataReader.js");

var utils = __webpack_require__(/*! ../utils */ "./node_modules/jszip/lib/utils.js");

function StringReader(data) {
  DataReader.call(this, data);
}

utils.inherits(StringReader, DataReader);
/**
 * @see DataReader.byteAt
 */

StringReader.prototype.byteAt = function (i) {
  return this.data.charCodeAt(this.zero + i);
};
/**
 * @see DataReader.lastIndexOfSignature
 */


StringReader.prototype.lastIndexOfSignature = function (sig) {
  return this.data.lastIndexOf(sig) - this.zero;
};
/**
 * @see DataReader.readAndCheckSignature
 */


StringReader.prototype.readAndCheckSignature = function (sig) {
  var data = this.readData(4);
  return sig === data;
};
/**
 * @see DataReader.readData
 */


StringReader.prototype.readData = function (size) {
  this.checkOffset(size); // this will work because the constructor applied the "& 0xff" mask.

  var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
  this.index += size;
  return result;
};

module.exports = StringReader;

/***/ }),

/***/ "./node_modules/jszip/lib/reader/Uint8ArrayReader.js":
/*!***********************************************************!*\
  !*** ./node_modules/jszip/lib/reader/Uint8ArrayReader.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var ArrayReader = __webpack_require__(/*! ./ArrayReader */ "./node_modules/jszip/lib/reader/ArrayReader.js");

var utils = __webpack_require__(/*! ../utils */ "./node_modules/jszip/lib/utils.js");

function Uint8ArrayReader(data) {
  ArrayReader.call(this, data);
}

utils.inherits(Uint8ArrayReader, ArrayReader);
/**
 * @see DataReader.readData
 */

Uint8ArrayReader.prototype.readData = function (size) {
  this.checkOffset(size);

  if (size === 0) {
    // in IE10, when using subarray(idx, idx), we get the array [0x00] instead of [].
    return new Uint8Array(0);
  }

  var result = this.data.subarray(this.zero + this.index, this.zero + this.index + size);
  this.index += size;
  return result;
};

module.exports = Uint8ArrayReader;

/***/ }),

/***/ "./node_modules/jszip/lib/reader/readerFor.js":
/*!****************************************************!*\
  !*** ./node_modules/jszip/lib/reader/readerFor.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/jszip/lib/utils.js");

var support = __webpack_require__(/*! ../support */ "./node_modules/jszip/lib/support.js");

var ArrayReader = __webpack_require__(/*! ./ArrayReader */ "./node_modules/jszip/lib/reader/ArrayReader.js");

var StringReader = __webpack_require__(/*! ./StringReader */ "./node_modules/jszip/lib/reader/StringReader.js");

var NodeBufferReader = __webpack_require__(/*! ./NodeBufferReader */ "./node_modules/jszip/lib/reader/NodeBufferReader.js");

var Uint8ArrayReader = __webpack_require__(/*! ./Uint8ArrayReader */ "./node_modules/jszip/lib/reader/Uint8ArrayReader.js");
/**
 * Create a reader adapted to the data.
 * @param {String|ArrayBuffer|Uint8Array|Buffer} data the data to read.
 * @return {DataReader} the data reader.
 */


module.exports = function (data) {
  var type = utils.getTypeOf(data);
  utils.checkSupport(type);

  if (type === "string" && !support.uint8array) {
    return new StringReader(data);
  }

  if (type === "nodebuffer") {
    return new NodeBufferReader(data);
  }

  if (support.uint8array) {
    return new Uint8ArrayReader(utils.transformTo("uint8array", data));
  }

  return new ArrayReader(utils.transformTo("array", data));
};

/***/ }),

/***/ "./node_modules/jszip/lib/signature.js":
/*!*********************************************!*\
  !*** ./node_modules/jszip/lib/signature.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.LOCAL_FILE_HEADER = "PK\x03\x04";
exports.CENTRAL_FILE_HEADER = "PK\x01\x02";
exports.CENTRAL_DIRECTORY_END = "PK\x05\x06";
exports.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x06\x07";
exports.ZIP64_CENTRAL_DIRECTORY_END = "PK\x06\x06";
exports.DATA_DESCRIPTOR = "PK\x07\x08";

/***/ }),

/***/ "./node_modules/jszip/lib/stream/ConvertWorker.js":
/*!********************************************************!*\
  !*** ./node_modules/jszip/lib/stream/ConvertWorker.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var GenericWorker = __webpack_require__(/*! ./GenericWorker */ "./node_modules/jszip/lib/stream/GenericWorker.js");

var utils = __webpack_require__(/*! ../utils */ "./node_modules/jszip/lib/utils.js");
/**
 * A worker which convert chunks to a specified type.
 * @constructor
 * @param {String} destType the destination type.
 */


function ConvertWorker(destType) {
  GenericWorker.call(this, "ConvertWorker to " + destType);
  this.destType = destType;
}

utils.inherits(ConvertWorker, GenericWorker);
/**
 * @see GenericWorker.processChunk
 */

ConvertWorker.prototype.processChunk = function (chunk) {
  this.push({
    data: utils.transformTo(this.destType, chunk.data),
    meta: chunk.meta
  });
};

module.exports = ConvertWorker;

/***/ }),

/***/ "./node_modules/jszip/lib/stream/Crc32Probe.js":
/*!*****************************************************!*\
  !*** ./node_modules/jszip/lib/stream/Crc32Probe.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var GenericWorker = __webpack_require__(/*! ./GenericWorker */ "./node_modules/jszip/lib/stream/GenericWorker.js");

var crc32 = __webpack_require__(/*! ../crc32 */ "./node_modules/jszip/lib/crc32.js");

var utils = __webpack_require__(/*! ../utils */ "./node_modules/jszip/lib/utils.js");
/**
 * A worker which calculate the crc32 of the data flowing through.
 * @constructor
 */


function Crc32Probe() {
  GenericWorker.call(this, "Crc32Probe");
  this.withStreamInfo("crc32", 0);
}

utils.inherits(Crc32Probe, GenericWorker);
/**
 * @see GenericWorker.processChunk
 */

Crc32Probe.prototype.processChunk = function (chunk) {
  this.streamInfo.crc32 = crc32(chunk.data, this.streamInfo.crc32 || 0);
  this.push(chunk);
};

module.exports = Crc32Probe;

/***/ }),

/***/ "./node_modules/jszip/lib/stream/DataLengthProbe.js":
/*!**********************************************************!*\
  !*** ./node_modules/jszip/lib/stream/DataLengthProbe.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/jszip/lib/utils.js");

var GenericWorker = __webpack_require__(/*! ./GenericWorker */ "./node_modules/jszip/lib/stream/GenericWorker.js");
/**
 * A worker which calculate the total length of the data flowing through.
 * @constructor
 * @param {String} propName the name used to expose the length
 */


function DataLengthProbe(propName) {
  GenericWorker.call(this, "DataLengthProbe for " + propName);
  this.propName = propName;
  this.withStreamInfo(propName, 0);
}

utils.inherits(DataLengthProbe, GenericWorker);
/**
 * @see GenericWorker.processChunk
 */

DataLengthProbe.prototype.processChunk = function (chunk) {
  if (chunk) {
    var length = this.streamInfo[this.propName] || 0;
    this.streamInfo[this.propName] = length + chunk.data.length;
  }

  GenericWorker.prototype.processChunk.call(this, chunk);
};

module.exports = DataLengthProbe;

/***/ }),

/***/ "./node_modules/jszip/lib/stream/DataWorker.js":
/*!*****************************************************!*\
  !*** ./node_modules/jszip/lib/stream/DataWorker.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/jszip/lib/utils.js");

var GenericWorker = __webpack_require__(/*! ./GenericWorker */ "./node_modules/jszip/lib/stream/GenericWorker.js"); // the size of the generated chunks
// TODO expose this as a public variable


var DEFAULT_BLOCK_SIZE = 16 * 1024;
/**
 * A worker that reads a content and emits chunks.
 * @constructor
 * @param {Promise} dataP the promise of the data to split
 */

function DataWorker(dataP) {
  GenericWorker.call(this, "DataWorker");
  var self = this;
  this.dataIsReady = false;
  this.index = 0;
  this.max = 0;
  this.data = null;
  this.type = "";
  this._tickScheduled = false;
  dataP.then(function (data) {
    self.dataIsReady = true;
    self.data = data;
    self.max = data && data.length || 0;
    self.type = utils.getTypeOf(data);

    if (!self.isPaused) {
      self._tickAndRepeat();
    }
  }, function (e) {
    self.error(e);
  });
}

utils.inherits(DataWorker, GenericWorker);
/**
 * @see GenericWorker.cleanUp
 */

DataWorker.prototype.cleanUp = function () {
  GenericWorker.prototype.cleanUp.call(this);
  this.data = null;
};
/**
 * @see GenericWorker.resume
 */


DataWorker.prototype.resume = function () {
  if (!GenericWorker.prototype.resume.call(this)) {
    return false;
  }

  if (!this._tickScheduled && this.dataIsReady) {
    this._tickScheduled = true;
    utils.delay(this._tickAndRepeat, [], this);
  }

  return true;
};
/**
 * Trigger a tick a schedule an other call to this function.
 */


DataWorker.prototype._tickAndRepeat = function () {
  this._tickScheduled = false;

  if (this.isPaused || this.isFinished) {
    return;
  }

  this._tick();

  if (!this.isFinished) {
    utils.delay(this._tickAndRepeat, [], this);
    this._tickScheduled = true;
  }
};
/**
 * Read and push a chunk.
 */


DataWorker.prototype._tick = function () {
  if (this.isPaused || this.isFinished) {
    return false;
  }

  var size = DEFAULT_BLOCK_SIZE;
  var data = null,
      nextIndex = Math.min(this.max, this.index + size);

  if (this.index >= this.max) {
    // EOF
    return this.end();
  } else {
    switch (this.type) {
      case "string":
        data = this.data.substring(this.index, nextIndex);
        break;

      case "uint8array":
        data = this.data.subarray(this.index, nextIndex);
        break;

      case "array":
      case "nodebuffer":
        data = this.data.slice(this.index, nextIndex);
        break;
    }

    this.index = nextIndex;
    return this.push({
      data: data,
      meta: {
        percent: this.max ? this.index / this.max * 100 : 0
      }
    });
  }
};

module.exports = DataWorker;

/***/ }),

/***/ "./node_modules/jszip/lib/stream/GenericWorker.js":
/*!********************************************************!*\
  !*** ./node_modules/jszip/lib/stream/GenericWorker.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * A worker that does nothing but passing chunks to the next one. This is like
 * a nodejs stream but with some differences. On the good side :
 * - it works on IE 6-9 without any issue / polyfill
 * - it weights less than the full dependencies bundled with browserify
 * - it forwards errors (no need to declare an error handler EVERYWHERE)
 *
 * A chunk is an object with 2 attributes : `meta` and `data`. The former is an
 * object containing anything (`percent` for example), see each worker for more
 * details. The latter is the real data (String, Uint8Array, etc).
 *
 * @constructor
 * @param {String} name the name of the stream (mainly used for debugging purposes)
 */

function GenericWorker(name) {
  // the name of the worker
  this.name = name || "default"; // an object containing metadata about the workers chain

  this.streamInfo = {}; // an error which happened when the worker was paused

  this.generatedError = null; // an object containing metadata to be merged by this worker into the general metadata

  this.extraStreamInfo = {}; // true if the stream is paused (and should not do anything), false otherwise

  this.isPaused = true; // true if the stream is finished (and should not do anything), false otherwise

  this.isFinished = false; // true if the stream is locked to prevent further structure updates (pipe), false otherwise

  this.isLocked = false; // the event listeners

  this._listeners = {
    'data': [],
    'end': [],
    'error': []
  }; // the previous worker, if any

  this.previous = null;
}

GenericWorker.prototype = {
  /**
   * Push a chunk to the next workers.
   * @param {Object} chunk the chunk to push
   */
  push: function push(chunk) {
    this.emit("data", chunk);
  },

  /**
   * End the stream.
   * @return {Boolean} true if this call ended the worker, false otherwise.
   */
  end: function end() {
    if (this.isFinished) {
      return false;
    }

    this.flush();

    try {
      this.emit("end");
      this.cleanUp();
      this.isFinished = true;
    } catch (e) {
      this.emit("error", e);
    }

    return true;
  },

  /**
   * End the stream with an error.
   * @param {Error} e the error which caused the premature end.
   * @return {Boolean} true if this call ended the worker with an error, false otherwise.
   */
  error: function error(e) {
    if (this.isFinished) {
      return false;
    }

    if (this.isPaused) {
      this.generatedError = e;
    } else {
      this.isFinished = true;
      this.emit("error", e); // in the workers chain exploded in the middle of the chain,
      // the error event will go downward but we also need to notify
      // workers upward that there has been an error.

      if (this.previous) {
        this.previous.error(e);
      }

      this.cleanUp();
    }

    return true;
  },

  /**
   * Add a callback on an event.
   * @param {String} name the name of the event (data, end, error)
   * @param {Function} listener the function to call when the event is triggered
   * @return {GenericWorker} the current object for chainability
   */
  on: function on(name, listener) {
    this._listeners[name].push(listener);

    return this;
  },

  /**
   * Clean any references when a worker is ending.
   */
  cleanUp: function cleanUp() {
    this.streamInfo = this.generatedError = this.extraStreamInfo = null;
    this._listeners = [];
  },

  /**
   * Trigger an event. This will call registered callback with the provided arg.
   * @param {String} name the name of the event (data, end, error)
   * @param {Object} arg the argument to call the callback with.
   */
  emit: function emit(name, arg) {
    if (this._listeners[name]) {
      for (var i = 0; i < this._listeners[name].length; i++) {
        this._listeners[name][i].call(this, arg);
      }
    }
  },

  /**
   * Chain a worker with an other.
   * @param {Worker} next the worker receiving events from the current one.
   * @return {worker} the next worker for chainability
   */
  pipe: function pipe(next) {
    return next.registerPrevious(this);
  },

  /**
   * Same as `pipe` in the other direction.
   * Using an API with `pipe(next)` is very easy.
   * Implementing the API with the point of view of the next one registering
   * a source is easier, see the ZipFileWorker.
   * @param {Worker} previous the previous worker, sending events to this one
   * @return {Worker} the current worker for chainability
   */
  registerPrevious: function registerPrevious(previous) {
    if (this.isLocked) {
      throw new Error("The stream '" + this + "' has already been used.");
    } // sharing the streamInfo...


    this.streamInfo = previous.streamInfo; // ... and adding our own bits

    this.mergeStreamInfo();
    this.previous = previous;
    var self = this;
    previous.on('data', function (chunk) {
      self.processChunk(chunk);
    });
    previous.on('end', function () {
      self.end();
    });
    previous.on('error', function (e) {
      self.error(e);
    });
    return this;
  },

  /**
   * Pause the stream so it doesn't send events anymore.
   * @return {Boolean} true if this call paused the worker, false otherwise.
   */
  pause: function pause() {
    if (this.isPaused || this.isFinished) {
      return false;
    }

    this.isPaused = true;

    if (this.previous) {
      this.previous.pause();
    }

    return true;
  },

  /**
   * Resume a paused stream.
   * @return {Boolean} true if this call resumed the worker, false otherwise.
   */
  resume: function resume() {
    if (!this.isPaused || this.isFinished) {
      return false;
    }

    this.isPaused = false; // if true, the worker tried to resume but failed

    var withError = false;

    if (this.generatedError) {
      this.error(this.generatedError);
      withError = true;
    }

    if (this.previous) {
      this.previous.resume();
    }

    return !withError;
  },

  /**
   * Flush any remaining bytes as the stream is ending.
   */
  flush: function flush() {},

  /**
   * Process a chunk. This is usually the method overridden.
   * @param {Object} chunk the chunk to process.
   */
  processChunk: function processChunk(chunk) {
    this.push(chunk);
  },

  /**
   * Add a key/value to be added in the workers chain streamInfo once activated.
   * @param {String} key the key to use
   * @param {Object} value the associated value
   * @return {Worker} the current worker for chainability
   */
  withStreamInfo: function withStreamInfo(key, value) {
    this.extraStreamInfo[key] = value;
    this.mergeStreamInfo();
    return this;
  },

  /**
   * Merge this worker's streamInfo into the chain's streamInfo.
   */
  mergeStreamInfo: function mergeStreamInfo() {
    for (var key in this.extraStreamInfo) {
      if (!this.extraStreamInfo.hasOwnProperty(key)) {
        continue;
      }

      this.streamInfo[key] = this.extraStreamInfo[key];
    }
  },

  /**
   * Lock the stream to prevent further updates on the workers chain.
   * After calling this method, all calls to pipe will fail.
   */
  lock: function lock() {
    if (this.isLocked) {
      throw new Error("The stream '" + this + "' has already been used.");
    }

    this.isLocked = true;

    if (this.previous) {
      this.previous.lock();
    }
  },

  /**
   *
   * Pretty print the workers chain.
   */
  toString: function toString() {
    var me = "Worker " + this.name;

    if (this.previous) {
      return this.previous + " -> " + me;
    } else {
      return me;
    }
  }
};
module.exports = GenericWorker;

/***/ }),

/***/ "./node_modules/jszip/lib/stream/StreamHelper.js":
/*!*******************************************************!*\
  !*** ./node_modules/jszip/lib/stream/StreamHelper.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

var utils = __webpack_require__(/*! ../utils */ "./node_modules/jszip/lib/utils.js");

var ConvertWorker = __webpack_require__(/*! ./ConvertWorker */ "./node_modules/jszip/lib/stream/ConvertWorker.js");

var GenericWorker = __webpack_require__(/*! ./GenericWorker */ "./node_modules/jszip/lib/stream/GenericWorker.js");

var base64 = __webpack_require__(/*! ../base64 */ "./node_modules/jszip/lib/base64.js");

var support = __webpack_require__(/*! ../support */ "./node_modules/jszip/lib/support.js");

var external = __webpack_require__(/*! ../external */ "./node_modules/jszip/lib/external.js");

var NodejsStreamOutputAdapter = null;

if (support.nodestream) {
  try {
    NodejsStreamOutputAdapter = __webpack_require__(/*! ../nodejs/NodejsStreamOutputAdapter */ "./node_modules/jszip/lib/nodejs/NodejsStreamOutputAdapter.js");
  } catch (e) {}
}
/**
 * Apply the final transformation of the data. If the user wants a Blob for
 * example, it's easier to work with an U8intArray and finally do the
 * ArrayBuffer/Blob conversion.
 * @param {String} type the name of the final type
 * @param {String|Uint8Array|Buffer} content the content to transform
 * @param {String} mimeType the mime type of the content, if applicable.
 * @return {String|Uint8Array|ArrayBuffer|Buffer|Blob} the content in the right format.
 */


function transformZipOutput(type, content, mimeType) {
  switch (type) {
    case "blob":
      return utils.newBlob(utils.transformTo("arraybuffer", content), mimeType);

    case "base64":
      return base64.encode(content);

    default:
      return utils.transformTo(type, content);
  }
}
/**
 * Concatenate an array of data of the given type.
 * @param {String} type the type of the data in the given array.
 * @param {Array} dataArray the array containing the data chunks to concatenate
 * @return {String|Uint8Array|Buffer} the concatenated data
 * @throws Error if the asked type is unsupported
 */


function concat(type, dataArray) {
  var i,
      index = 0,
      res = null,
      totalLength = 0;

  for (i = 0; i < dataArray.length; i++) {
    totalLength += dataArray[i].length;
  }

  switch (type) {
    case "string":
      return dataArray.join("");

    case "array":
      return Array.prototype.concat.apply([], dataArray);

    case "uint8array":
      res = new Uint8Array(totalLength);

      for (i = 0; i < dataArray.length; i++) {
        res.set(dataArray[i], index);
        index += dataArray[i].length;
      }

      return res;

    case "nodebuffer":
      return Buffer.concat(dataArray);

    default:
      throw new Error("concat : unsupported type '" + type + "'");
  }
}
/**
 * Listen a StreamHelper, accumulate its content and concatenate it into a
 * complete block.
 * @param {StreamHelper} helper the helper to use.
 * @param {Function} updateCallback a callback called on each update. Called
 * with one arg :
 * - the metadata linked to the update received.
 * @return Promise the promise for the accumulation.
 */


function _accumulate(helper, updateCallback) {
  return new external.Promise(function (resolve, reject) {
    var dataArray = [];
    var chunkType = helper._internalType,
        resultType = helper._outputType,
        mimeType = helper._mimeType;
    helper.on('data', function (data, meta) {
      dataArray.push(data);

      if (updateCallback) {
        updateCallback(meta);
      }
    }).on('error', function (err) {
      dataArray = [];
      reject(err);
    }).on('end', function () {
      try {
        var result = transformZipOutput(resultType, concat(chunkType, dataArray), mimeType);
        resolve(result);
      } catch (e) {
        reject(e);
      }

      dataArray = [];
    }).resume();
  });
}
/**
 * An helper to easily use workers outside of JSZip.
 * @constructor
 * @param {Worker} worker the worker to wrap
 * @param {String} outputType the type of data expected by the use
 * @param {String} mimeType the mime type of the content, if applicable.
 */


function StreamHelper(worker, outputType, mimeType) {
  var internalType = outputType;

  switch (outputType) {
    case "blob":
    case "arraybuffer":
      internalType = "uint8array";
      break;

    case "base64":
      internalType = "string";
      break;
  }

  try {
    // the type used internally
    this._internalType = internalType; // the type used to output results

    this._outputType = outputType; // the mime type

    this._mimeType = mimeType;
    utils.checkSupport(internalType);
    this._worker = worker.pipe(new ConvertWorker(internalType)); // the last workers can be rewired without issues but we need to
    // prevent any updates on previous workers.

    worker.lock();
  } catch (e) {
    this._worker = new GenericWorker("error");

    this._worker.error(e);
  }
}

StreamHelper.prototype = {
  /**
   * Listen a StreamHelper, accumulate its content and concatenate it into a
   * complete block.
   * @param {Function} updateCb the update callback.
   * @return Promise the promise for the accumulation.
   */
  accumulate: function accumulate(updateCb) {
    return _accumulate(this, updateCb);
  },

  /**
   * Add a listener on an event triggered on a stream.
   * @param {String} evt the name of the event
   * @param {Function} fn the listener
   * @return {StreamHelper} the current helper.
   */
  on: function on(evt, fn) {
    var self = this;

    if (evt === "data") {
      this._worker.on(evt, function (chunk) {
        fn.call(self, chunk.data, chunk.meta);
      });
    } else {
      this._worker.on(evt, function () {
        utils.delay(fn, arguments, self);
      });
    }

    return this;
  },

  /**
   * Resume the flow of chunks.
   * @return {StreamHelper} the current helper.
   */
  resume: function resume() {
    utils.delay(this._worker.resume, [], this._worker);
    return this;
  },

  /**
   * Pause the flow of chunks.
   * @return {StreamHelper} the current helper.
   */
  pause: function pause() {
    this._worker.pause();

    return this;
  },

  /**
   * Return a nodejs stream for this helper.
   * @param {Function} updateCb the update callback.
   * @return {NodejsStreamOutputAdapter} the nodejs stream.
   */
  toNodejsStream: function toNodejsStream(updateCb) {
    utils.checkSupport("nodestream");

    if (this._outputType !== "nodebuffer") {
      // an object stream containing blob/arraybuffer/uint8array/string
      // is strange and I don't know if it would be useful.
      // I you find this comment and have a good usecase, please open a
      // bug report !
      throw new Error(this._outputType + " is not supported by this method");
    }

    return new NodejsStreamOutputAdapter(this, {
      objectMode: this._outputType !== "nodebuffer"
    }, updateCb);
  }
};
module.exports = StreamHelper;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../buffer/index.js */ "./node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/jszip/lib/support.js":
/*!*******************************************!*\
  !*** ./node_modules/jszip/lib/support.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

exports.base64 = true;
exports.array = true;
exports.string = true;
exports.arraybuffer = typeof ArrayBuffer !== "undefined" && typeof Uint8Array !== "undefined";
exports.nodebuffer = typeof Buffer !== "undefined"; // contains true if JSZip can read/generate Uint8Array, false otherwise.

exports.uint8array = typeof Uint8Array !== "undefined";

if (typeof ArrayBuffer === "undefined") {
  exports.blob = false;
} else {
  var buffer = new ArrayBuffer(0);

  try {
    exports.blob = new Blob([buffer], {
      type: "application/zip"
    }).size === 0;
  } catch (e) {
    try {
      var Builder = self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder;
      var builder = new Builder();
      builder.append(buffer);
      exports.blob = builder.getBlob('application/zip').size === 0;
    } catch (e) {
      exports.blob = false;
    }
  }
}

try {
  exports.nodestream = !!__webpack_require__(/*! readable-stream */ "./node_modules/jszip/lib/readable-stream-browser.js").Readable;
} catch (e) {
  exports.nodestream = false;
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../buffer/index.js */ "./node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/jszip/lib/utf8.js":
/*!****************************************!*\
  !*** ./node_modules/jszip/lib/utf8.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./utils */ "./node_modules/jszip/lib/utils.js");

var support = __webpack_require__(/*! ./support */ "./node_modules/jszip/lib/support.js");

var nodejsUtils = __webpack_require__(/*! ./nodejsUtils */ "./node_modules/jszip/lib/nodejsUtils.js");

var GenericWorker = __webpack_require__(/*! ./stream/GenericWorker */ "./node_modules/jszip/lib/stream/GenericWorker.js");
/**
 * The following functions come from pako, from pako/lib/utils/strings
 * released under the MIT license, see pako https://github.com/nodeca/pako/
 */
// Table with utf8 lengths (calculated by first byte of sequence)
// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,
// because max possible codepoint is 0x10ffff


var _utf8len = new Array(256);

for (var i = 0; i < 256; i++) {
  _utf8len[i] = i >= 252 ? 6 : i >= 248 ? 5 : i >= 240 ? 4 : i >= 224 ? 3 : i >= 192 ? 2 : 1;
}

_utf8len[254] = _utf8len[254] = 1; // Invalid sequence start
// convert string to array (typed, when possible)

var string2buf = function string2buf(str) {
  var buf,
      c,
      c2,
      m_pos,
      i,
      str_len = str.length,
      buf_len = 0; // count binary size

  for (m_pos = 0; m_pos < str_len; m_pos++) {
    c = str.charCodeAt(m_pos);

    if ((c & 0xfc00) === 0xd800 && m_pos + 1 < str_len) {
      c2 = str.charCodeAt(m_pos + 1);

      if ((c2 & 0xfc00) === 0xdc00) {
        c = 0x10000 + (c - 0xd800 << 10) + (c2 - 0xdc00);
        m_pos++;
      }
    }

    buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;
  } // allocate buffer


  if (support.uint8array) {
    buf = new Uint8Array(buf_len);
  } else {
    buf = new Array(buf_len);
  } // convert


  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
    c = str.charCodeAt(m_pos);

    if ((c & 0xfc00) === 0xd800 && m_pos + 1 < str_len) {
      c2 = str.charCodeAt(m_pos + 1);

      if ((c2 & 0xfc00) === 0xdc00) {
        c = 0x10000 + (c - 0xd800 << 10) + (c2 - 0xdc00);
        m_pos++;
      }
    }

    if (c < 0x80) {
      /* one byte */
      buf[i++] = c;
    } else if (c < 0x800) {
      /* two bytes */
      buf[i++] = 0xC0 | c >>> 6;
      buf[i++] = 0x80 | c & 0x3f;
    } else if (c < 0x10000) {
      /* three bytes */
      buf[i++] = 0xE0 | c >>> 12;
      buf[i++] = 0x80 | c >>> 6 & 0x3f;
      buf[i++] = 0x80 | c & 0x3f;
    } else {
      /* four bytes */
      buf[i++] = 0xf0 | c >>> 18;
      buf[i++] = 0x80 | c >>> 12 & 0x3f;
      buf[i++] = 0x80 | c >>> 6 & 0x3f;
      buf[i++] = 0x80 | c & 0x3f;
    }
  }

  return buf;
}; // Calculate max possible position in utf8 buffer,
// that will not break sequence. If that's not possible
// - (very small limits) return max size as is.
//
// buf[] - utf8 bytes array
// max   - length limit (mandatory);


var utf8border = function utf8border(buf, max) {
  var pos;
  max = max || buf.length;

  if (max > buf.length) {
    max = buf.length;
  } // go back from last position, until start of sequence found


  pos = max - 1;

  while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) {
    pos--;
  } // Fuckup - very small and broken sequence,
  // return max, because we should return something anyway.


  if (pos < 0) {
    return max;
  } // If we came to start of buffer - that means vuffer is too small,
  // return max too.


  if (pos === 0) {
    return max;
  }

  return pos + _utf8len[buf[pos]] > max ? pos : max;
}; // convert array to string


var buf2string = function buf2string(buf) {
  var str, i, out, c, c_len;
  var len = buf.length; // Reserve max possible length (2 words per char)
  // NB: by unknown reasons, Array is significantly faster for
  //     String.fromCharCode.apply than Uint16Array.

  var utf16buf = new Array(len * 2);

  for (out = 0, i = 0; i < len;) {
    c = buf[i++]; // quick process ascii

    if (c < 0x80) {
      utf16buf[out++] = c;
      continue;
    }

    c_len = _utf8len[c]; // skip 5 & 6 byte codes

    if (c_len > 4) {
      utf16buf[out++] = 0xfffd;
      i += c_len - 1;
      continue;
    } // apply mask on first byte


    c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07; // join the rest

    while (c_len > 1 && i < len) {
      c = c << 6 | buf[i++] & 0x3f;
      c_len--;
    } // terminated by end of string?


    if (c_len > 1) {
      utf16buf[out++] = 0xfffd;
      continue;
    }

    if (c < 0x10000) {
      utf16buf[out++] = c;
    } else {
      c -= 0x10000;
      utf16buf[out++] = 0xd800 | c >> 10 & 0x3ff;
      utf16buf[out++] = 0xdc00 | c & 0x3ff;
    }
  } // shrinkBuf(utf16buf, out)


  if (utf16buf.length !== out) {
    if (utf16buf.subarray) {
      utf16buf = utf16buf.subarray(0, out);
    } else {
      utf16buf.length = out;
    }
  } // return String.fromCharCode.apply(null, utf16buf);


  return utils.applyFromCharCode(utf16buf);
}; // That's all for the pako functions.

/**
 * Transform a javascript string into an array (typed if possible) of bytes,
 * UTF-8 encoded.
 * @param {String} str the string to encode
 * @return {Array|Uint8Array|Buffer} the UTF-8 encoded string.
 */


exports.utf8encode = function utf8encode(str) {
  if (support.nodebuffer) {
    return nodejsUtils.newBufferFrom(str, "utf-8");
  }

  return string2buf(str);
};
/**
 * Transform a bytes array (or a representation) representing an UTF-8 encoded
 * string into a javascript string.
 * @param {Array|Uint8Array|Buffer} buf the data de decode
 * @return {String} the decoded string.
 */


exports.utf8decode = function utf8decode(buf) {
  if (support.nodebuffer) {
    return utils.transformTo("nodebuffer", buf).toString("utf-8");
  }

  buf = utils.transformTo(support.uint8array ? "uint8array" : "array", buf);
  return buf2string(buf);
};
/**
 * A worker to decode utf8 encoded binary chunks into string chunks.
 * @constructor
 */


function Utf8DecodeWorker() {
  GenericWorker.call(this, "utf-8 decode"); // the last bytes if a chunk didn't end with a complete codepoint.

  this.leftOver = null;
}

utils.inherits(Utf8DecodeWorker, GenericWorker);
/**
 * @see GenericWorker.processChunk
 */

Utf8DecodeWorker.prototype.processChunk = function (chunk) {
  var data = utils.transformTo(support.uint8array ? "uint8array" : "array", chunk.data); // 1st step, re-use what's left of the previous chunk

  if (this.leftOver && this.leftOver.length) {
    if (support.uint8array) {
      var previousData = data;
      data = new Uint8Array(previousData.length + this.leftOver.length);
      data.set(this.leftOver, 0);
      data.set(previousData, this.leftOver.length);
    } else {
      data = this.leftOver.concat(data);
    }

    this.leftOver = null;
  }

  var nextBoundary = utf8border(data);
  var usableData = data;

  if (nextBoundary !== data.length) {
    if (support.uint8array) {
      usableData = data.subarray(0, nextBoundary);
      this.leftOver = data.subarray(nextBoundary, data.length);
    } else {
      usableData = data.slice(0, nextBoundary);
      this.leftOver = data.slice(nextBoundary, data.length);
    }
  }

  this.push({
    data: exports.utf8decode(usableData),
    meta: chunk.meta
  });
};
/**
 * @see GenericWorker.flush
 */


Utf8DecodeWorker.prototype.flush = function () {
  if (this.leftOver && this.leftOver.length) {
    this.push({
      data: exports.utf8decode(this.leftOver),
      meta: {}
    });
    this.leftOver = null;
  }
};

exports.Utf8DecodeWorker = Utf8DecodeWorker;
/**
 * A worker to endcode string chunks into utf8 encoded binary chunks.
 * @constructor
 */

function Utf8EncodeWorker() {
  GenericWorker.call(this, "utf-8 encode");
}

utils.inherits(Utf8EncodeWorker, GenericWorker);
/**
 * @see GenericWorker.processChunk
 */

Utf8EncodeWorker.prototype.processChunk = function (chunk) {
  this.push({
    data: exports.utf8encode(chunk.data),
    meta: chunk.meta
  });
};

exports.Utf8EncodeWorker = Utf8EncodeWorker;

/***/ }),

/***/ "./node_modules/jszip/lib/utils.js":
/*!*****************************************!*\
  !*** ./node_modules/jszip/lib/utils.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var support = __webpack_require__(/*! ./support */ "./node_modules/jszip/lib/support.js");

var base64 = __webpack_require__(/*! ./base64 */ "./node_modules/jszip/lib/base64.js");

var nodejsUtils = __webpack_require__(/*! ./nodejsUtils */ "./node_modules/jszip/lib/nodejsUtils.js");

var setImmediate = __webpack_require__(/*! core-js/library/fn/set-immediate */ "./node_modules/jszip/node_modules/core-js/library/fn/set-immediate.js");

var external = __webpack_require__(/*! ./external */ "./node_modules/jszip/lib/external.js");
/**
 * Convert a string that pass as a "binary string": it should represent a byte
 * array but may have > 255 char codes. Be sure to take only the first byte
 * and returns the byte array.
 * @param {String} str the string to transform.
 * @return {Array|Uint8Array} the string in a binary format.
 */


function string2binary(str) {
  var result = null;

  if (support.uint8array) {
    result = new Uint8Array(str.length);
  } else {
    result = new Array(str.length);
  }

  return stringToArrayLike(str, result);
}
/**
 * Create a new blob with the given content and the given type.
 * @param {String|ArrayBuffer} part the content to put in the blob. DO NOT use
 * an Uint8Array because the stock browser of android 4 won't accept it (it
 * will be silently converted to a string, "[object Uint8Array]").
 *
 * Use only ONE part to build the blob to avoid a memory leak in IE11 / Edge:
 * when a large amount of Array is used to create the Blob, the amount of
 * memory consumed is nearly 100 times the original data amount.
 *
 * @param {String} type the mime type of the blob.
 * @return {Blob} the created blob.
 */


exports.newBlob = function (part, type) {
  exports.checkSupport("blob");

  try {
    // Blob constructor
    return new Blob([part], {
      type: type
    });
  } catch (e) {
    try {
      // deprecated, browser only, old way
      var Builder = self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder;
      var builder = new Builder();
      builder.append(part);
      return builder.getBlob(type);
    } catch (e) {
      // well, fuck ?!
      throw new Error("Bug : can't construct the Blob.");
    }
  }
};
/**
 * The identity function.
 * @param {Object} input the input.
 * @return {Object} the same input.
 */


function identity(input) {
  return input;
}
/**
 * Fill in an array with a string.
 * @param {String} str the string to use.
 * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to fill in (will be mutated).
 * @return {Array|ArrayBuffer|Uint8Array|Buffer} the updated array.
 */


function stringToArrayLike(str, array) {
  for (var i = 0; i < str.length; ++i) {
    array[i] = str.charCodeAt(i) & 0xFF;
  }

  return array;
}
/**
 * An helper for the function arrayLikeToString.
 * This contains static informations and functions that
 * can be optimized by the browser JIT compiler.
 */


var arrayToStringHelper = {
  /**
   * Transform an array of int into a string, chunk by chunk.
   * See the performances notes on arrayLikeToString.
   * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.
   * @param {String} type the type of the array.
   * @param {Integer} chunk the chunk size.
   * @return {String} the resulting string.
   * @throws Error if the chunk is too big for the stack.
   */
  stringifyByChunk: function stringifyByChunk(array, type, chunk) {
    var result = [],
        k = 0,
        len = array.length; // shortcut

    if (len <= chunk) {
      return String.fromCharCode.apply(null, array);
    }

    while (k < len) {
      if (type === "array" || type === "nodebuffer") {
        result.push(String.fromCharCode.apply(null, array.slice(k, Math.min(k + chunk, len))));
      } else {
        result.push(String.fromCharCode.apply(null, array.subarray(k, Math.min(k + chunk, len))));
      }

      k += chunk;
    }

    return result.join("");
  },

  /**
   * Call String.fromCharCode on every item in the array.
   * This is the naive implementation, which generate A LOT of intermediate string.
   * This should be used when everything else fail.
   * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.
   * @return {String} the result.
   */
  stringifyByChar: function stringifyByChar(array) {
    var resultStr = "";

    for (var i = 0; i < array.length; i++) {
      resultStr += String.fromCharCode(array[i]);
    }

    return resultStr;
  },
  applyCanBeUsed: {
    /**
     * true if the browser accepts to use String.fromCharCode on Uint8Array
     */
    uint8array: function () {
      try {
        return support.uint8array && String.fromCharCode.apply(null, new Uint8Array(1)).length === 1;
      } catch (e) {
        return false;
      }
    }(),

    /**
     * true if the browser accepts to use String.fromCharCode on nodejs Buffer.
     */
    nodebuffer: function () {
      try {
        return support.nodebuffer && String.fromCharCode.apply(null, nodejsUtils.allocBuffer(1)).length === 1;
      } catch (e) {
        return false;
      }
    }()
  }
};
/**
 * Transform an array-like object to a string.
 * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.
 * @return {String} the result.
 */

function arrayLikeToString(array) {
  // Performances notes :
  // --------------------
  // String.fromCharCode.apply(null, array) is the fastest, see
  // see http://jsperf.com/converting-a-uint8array-to-a-string/2
  // but the stack is limited (and we can get huge arrays !).
  //
  // result += String.fromCharCode(array[i]); generate too many strings !
  //
  // This code is inspired by http://jsperf.com/arraybuffer-to-string-apply-performance/2
  // TODO : we now have workers that split the work. Do we still need that ?
  var chunk = 65536,
      type = exports.getTypeOf(array),
      canUseApply = true;

  if (type === "uint8array") {
    canUseApply = arrayToStringHelper.applyCanBeUsed.uint8array;
  } else if (type === "nodebuffer") {
    canUseApply = arrayToStringHelper.applyCanBeUsed.nodebuffer;
  }

  if (canUseApply) {
    while (chunk > 1) {
      try {
        return arrayToStringHelper.stringifyByChunk(array, type, chunk);
      } catch (e) {
        chunk = Math.floor(chunk / 2);
      }
    }
  } // no apply or chunk error : slow and painful algorithm
  // default browser on android 4.*


  return arrayToStringHelper.stringifyByChar(array);
}

exports.applyFromCharCode = arrayLikeToString;
/**
 * Copy the data from an array-like to an other array-like.
 * @param {Array|ArrayBuffer|Uint8Array|Buffer} arrayFrom the origin array.
 * @param {Array|ArrayBuffer|Uint8Array|Buffer} arrayTo the destination array which will be mutated.
 * @return {Array|ArrayBuffer|Uint8Array|Buffer} the updated destination array.
 */

function arrayLikeToArrayLike(arrayFrom, arrayTo) {
  for (var i = 0; i < arrayFrom.length; i++) {
    arrayTo[i] = arrayFrom[i];
  }

  return arrayTo;
} // a matrix containing functions to transform everything into everything.


var transform = {}; // string to ?

transform["string"] = {
  "string": identity,
  "array": function array(input) {
    return stringToArrayLike(input, new Array(input.length));
  },
  "arraybuffer": function arraybuffer(input) {
    return transform["string"]["uint8array"](input).buffer;
  },
  "uint8array": function uint8array(input) {
    return stringToArrayLike(input, new Uint8Array(input.length));
  },
  "nodebuffer": function nodebuffer(input) {
    return stringToArrayLike(input, nodejsUtils.allocBuffer(input.length));
  }
}; // array to ?

transform["array"] = {
  "string": arrayLikeToString,
  "array": identity,
  "arraybuffer": function arraybuffer(input) {
    return new Uint8Array(input).buffer;
  },
  "uint8array": function uint8array(input) {
    return new Uint8Array(input);
  },
  "nodebuffer": function nodebuffer(input) {
    return nodejsUtils.newBufferFrom(input);
  }
}; // arraybuffer to ?

transform["arraybuffer"] = {
  "string": function string(input) {
    return arrayLikeToString(new Uint8Array(input));
  },
  "array": function array(input) {
    return arrayLikeToArrayLike(new Uint8Array(input), new Array(input.byteLength));
  },
  "arraybuffer": identity,
  "uint8array": function uint8array(input) {
    return new Uint8Array(input);
  },
  "nodebuffer": function nodebuffer(input) {
    return nodejsUtils.newBufferFrom(new Uint8Array(input));
  }
}; // uint8array to ?

transform["uint8array"] = {
  "string": arrayLikeToString,
  "array": function array(input) {
    return arrayLikeToArrayLike(input, new Array(input.length));
  },
  "arraybuffer": function arraybuffer(input) {
    return input.buffer;
  },
  "uint8array": identity,
  "nodebuffer": function nodebuffer(input) {
    return nodejsUtils.newBufferFrom(input);
  }
}; // nodebuffer to ?

transform["nodebuffer"] = {
  "string": arrayLikeToString,
  "array": function array(input) {
    return arrayLikeToArrayLike(input, new Array(input.length));
  },
  "arraybuffer": function arraybuffer(input) {
    return transform["nodebuffer"]["uint8array"](input).buffer;
  },
  "uint8array": function uint8array(input) {
    return arrayLikeToArrayLike(input, new Uint8Array(input.length));
  },
  "nodebuffer": identity
};
/**
 * Transform an input into any type.
 * The supported output type are : string, array, uint8array, arraybuffer, nodebuffer.
 * If no output type is specified, the unmodified input will be returned.
 * @param {String} outputType the output type.
 * @param {String|Array|ArrayBuffer|Uint8Array|Buffer} input the input to convert.
 * @throws {Error} an Error if the browser doesn't support the requested output type.
 */

exports.transformTo = function (outputType, input) {
  if (!input) {
    // undefined, null, etc
    // an empty string won't harm.
    input = "";
  }

  if (!outputType) {
    return input;
  }

  exports.checkSupport(outputType);
  var inputType = exports.getTypeOf(input);
  var result = transform[inputType][outputType](input);
  return result;
};
/**
 * Return the type of the input.
 * The type will be in a format valid for JSZip.utils.transformTo : string, array, uint8array, arraybuffer.
 * @param {Object} input the input to identify.
 * @return {String} the (lowercase) type of the input.
 */


exports.getTypeOf = function (input) {
  if (typeof input === "string") {
    return "string";
  }

  if (Object.prototype.toString.call(input) === "[object Array]") {
    return "array";
  }

  if (support.nodebuffer && nodejsUtils.isBuffer(input)) {
    return "nodebuffer";
  }

  if (support.uint8array && input instanceof Uint8Array) {
    return "uint8array";
  }

  if (support.arraybuffer && input instanceof ArrayBuffer) {
    return "arraybuffer";
  }
};
/**
 * Throw an exception if the type is not supported.
 * @param {String} type the type to check.
 * @throws {Error} an Error if the browser doesn't support the requested type.
 */


exports.checkSupport = function (type) {
  var supported = support[type.toLowerCase()];

  if (!supported) {
    throw new Error(type + " is not supported by this platform");
  }
};

exports.MAX_VALUE_16BITS = 65535;
exports.MAX_VALUE_32BITS = -1; // well, "\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF" is parsed as -1

/**
 * Prettify a string read as binary.
 * @param {string} str the string to prettify.
 * @return {string} a pretty string.
 */

exports.pretty = function (str) {
  var res = '',
      code,
      i;

  for (i = 0; i < (str || "").length; i++) {
    code = str.charCodeAt(i);
    res += '\\x' + (code < 16 ? "0" : "") + code.toString(16).toUpperCase();
  }

  return res;
};
/**
 * Defer the call of a function.
 * @param {Function} callback the function to call asynchronously.
 * @param {Array} args the arguments to give to the callback.
 */


exports.delay = function (callback, args, self) {
  setImmediate(function () {
    callback.apply(self || null, args || []);
  });
};
/**
 * Extends a prototype with an other, without calling a constructor with
 * side effects. Inspired by nodejs' `utils.inherits`
 * @param {Function} ctor the constructor to augment
 * @param {Function} superCtor the parent constructor to use
 */


exports.inherits = function (ctor, superCtor) {
  var Obj = function Obj() {};

  Obj.prototype = superCtor.prototype;
  ctor.prototype = new Obj();
};
/**
 * Merge the objects passed as parameters into a new one.
 * @private
 * @param {...Object} var_args All objects to merge.
 * @return {Object} a new object with the data of the others.
 */


exports.extend = function () {
  var result = {},
      i,
      attr;

  for (i = 0; i < arguments.length; i++) {
    // arguments is not enumerable in some browsers
    for (attr in arguments[i]) {
      if (arguments[i].hasOwnProperty(attr) && typeof result[attr] === "undefined") {
        result[attr] = arguments[i][attr];
      }
    }
  }

  return result;
};
/**
 * Transform arbitrary content into a Promise.
 * @param {String} name a name for the content being processed.
 * @param {Object} inputData the content to process.
 * @param {Boolean} isBinary true if the content is not an unicode string
 * @param {Boolean} isOptimizedBinaryString true if the string content only has one byte per character.
 * @param {Boolean} isBase64 true if the string content is encoded with base64.
 * @return {Promise} a promise in a format usable by JSZip.
 */


exports.prepareContent = function (name, inputData, isBinary, isOptimizedBinaryString, isBase64) {
  // if inputData is already a promise, this flatten it.
  var promise = external.Promise.resolve(inputData).then(function (data) {
    var isBlob = support.blob && (data instanceof Blob || ['[object File]', '[object Blob]'].indexOf(Object.prototype.toString.call(data)) !== -1);

    if (isBlob && typeof FileReader !== "undefined") {
      return new external.Promise(function (resolve, reject) {
        var reader = new FileReader();

        reader.onload = function (e) {
          resolve(e.target.result);
        };

        reader.onerror = function (e) {
          reject(e.target.error);
        };

        reader.readAsArrayBuffer(data);
      });
    } else {
      return data;
    }
  });
  return promise.then(function (data) {
    var dataType = exports.getTypeOf(data);

    if (!dataType) {
      return external.Promise.reject(new Error("Can't read the data of '" + name + "'. Is it " + "in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"));
    } // special case : it's way easier to work with Uint8Array than with ArrayBuffer


    if (dataType === "arraybuffer") {
      data = exports.transformTo("uint8array", data);
    } else if (dataType === "string") {
      if (isBase64) {
        data = base64.decode(data);
      } else if (isBinary) {
        // optimizedBinaryString === true means that the file has already been filtered with a 0xFF mask
        if (isOptimizedBinaryString !== true) {
          // this is a string, not in a base64 format.
          // Be sure that this is a correct "binary string"
          data = string2binary(data);
        }
      }
    }

    return data;
  });
};

/***/ }),

/***/ "./node_modules/jszip/lib/zipEntries.js":
/*!**********************************************!*\
  !*** ./node_modules/jszip/lib/zipEntries.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var readerFor = __webpack_require__(/*! ./reader/readerFor */ "./node_modules/jszip/lib/reader/readerFor.js");

var utils = __webpack_require__(/*! ./utils */ "./node_modules/jszip/lib/utils.js");

var sig = __webpack_require__(/*! ./signature */ "./node_modules/jszip/lib/signature.js");

var ZipEntry = __webpack_require__(/*! ./zipEntry */ "./node_modules/jszip/lib/zipEntry.js");

var utf8 = __webpack_require__(/*! ./utf8 */ "./node_modules/jszip/lib/utf8.js");

var support = __webpack_require__(/*! ./support */ "./node_modules/jszip/lib/support.js"); //  class ZipEntries {{{

/**
 * All the entries in the zip file.
 * @constructor
 * @param {Object} loadOptions Options for loading the stream.
 */


function ZipEntries(loadOptions) {
  this.files = [];
  this.loadOptions = loadOptions;
}

ZipEntries.prototype = {
  /**
   * Check that the reader is on the specified signature.
   * @param {string} expectedSignature the expected signature.
   * @throws {Error} if it is an other signature.
   */
  checkSignature: function checkSignature(expectedSignature) {
    if (!this.reader.readAndCheckSignature(expectedSignature)) {
      this.reader.index -= 4;
      var signature = this.reader.readString(4);
      throw new Error("Corrupted zip or bug: unexpected signature " + "(" + utils.pretty(signature) + ", expected " + utils.pretty(expectedSignature) + ")");
    }
  },

  /**
   * Check if the given signature is at the given index.
   * @param {number} askedIndex the index to check.
   * @param {string} expectedSignature the signature to expect.
   * @return {boolean} true if the signature is here, false otherwise.
   */
  isSignature: function isSignature(askedIndex, expectedSignature) {
    var currentIndex = this.reader.index;
    this.reader.setIndex(askedIndex);
    var signature = this.reader.readString(4);
    var result = signature === expectedSignature;
    this.reader.setIndex(currentIndex);
    return result;
  },

  /**
   * Read the end of the central directory.
   */
  readBlockEndOfCentral: function readBlockEndOfCentral() {
    this.diskNumber = this.reader.readInt(2);
    this.diskWithCentralDirStart = this.reader.readInt(2);
    this.centralDirRecordsOnThisDisk = this.reader.readInt(2);
    this.centralDirRecords = this.reader.readInt(2);
    this.centralDirSize = this.reader.readInt(4);
    this.centralDirOffset = this.reader.readInt(4);
    this.zipCommentLength = this.reader.readInt(2); // warning : the encoding depends of the system locale
    // On a linux machine with LANG=en_US.utf8, this field is utf8 encoded.
    // On a windows machine, this field is encoded with the localized windows code page.

    var zipComment = this.reader.readData(this.zipCommentLength);
    var decodeParamType = support.uint8array ? "uint8array" : "array"; // To get consistent behavior with the generation part, we will assume that
    // this is utf8 encoded unless specified otherwise.

    var decodeContent = utils.transformTo(decodeParamType, zipComment);
    this.zipComment = this.loadOptions.decodeFileName(decodeContent);
  },

  /**
   * Read the end of the Zip 64 central directory.
   * Not merged with the method readEndOfCentral :
   * The end of central can coexist with its Zip64 brother,
   * I don't want to read the wrong number of bytes !
   */
  readBlockZip64EndOfCentral: function readBlockZip64EndOfCentral() {
    this.zip64EndOfCentralSize = this.reader.readInt(8);
    this.reader.skip(4); // this.versionMadeBy = this.reader.readString(2);
    // this.versionNeeded = this.reader.readInt(2);

    this.diskNumber = this.reader.readInt(4);
    this.diskWithCentralDirStart = this.reader.readInt(4);
    this.centralDirRecordsOnThisDisk = this.reader.readInt(8);
    this.centralDirRecords = this.reader.readInt(8);
    this.centralDirSize = this.reader.readInt(8);
    this.centralDirOffset = this.reader.readInt(8);
    this.zip64ExtensibleData = {};
    var extraDataSize = this.zip64EndOfCentralSize - 44,
        index = 0,
        extraFieldId,
        extraFieldLength,
        extraFieldValue;

    while (index < extraDataSize) {
      extraFieldId = this.reader.readInt(2);
      extraFieldLength = this.reader.readInt(4);
      extraFieldValue = this.reader.readData(extraFieldLength);
      this.zip64ExtensibleData[extraFieldId] = {
        id: extraFieldId,
        length: extraFieldLength,
        value: extraFieldValue
      };
    }
  },

  /**
   * Read the end of the Zip 64 central directory locator.
   */
  readBlockZip64EndOfCentralLocator: function readBlockZip64EndOfCentralLocator() {
    this.diskWithZip64CentralDirStart = this.reader.readInt(4);
    this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8);
    this.disksCount = this.reader.readInt(4);

    if (this.disksCount > 1) {
      throw new Error("Multi-volumes zip are not supported");
    }
  },

  /**
   * Read the local files, based on the offset read in the central part.
   */
  readLocalFiles: function readLocalFiles() {
    var i, file;

    for (i = 0; i < this.files.length; i++) {
      file = this.files[i];
      this.reader.setIndex(file.localHeaderOffset);
      this.checkSignature(sig.LOCAL_FILE_HEADER);
      file.readLocalPart(this.reader);
      file.handleUTF8();
      file.processAttributes();
    }
  },

  /**
   * Read the central directory.
   */
  readCentralDir: function readCentralDir() {
    var file;
    this.reader.setIndex(this.centralDirOffset);

    while (this.reader.readAndCheckSignature(sig.CENTRAL_FILE_HEADER)) {
      file = new ZipEntry({
        zip64: this.zip64
      }, this.loadOptions);
      file.readCentralPart(this.reader);
      this.files.push(file);
    }

    if (this.centralDirRecords !== this.files.length) {
      if (this.centralDirRecords !== 0 && this.files.length === 0) {
        // We expected some records but couldn't find ANY.
        // This is really suspicious, as if something went wrong.
        throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
      } else {// We found some records but not all.
        // Something is wrong but we got something for the user: no error here.
        // console.warn("expected", this.centralDirRecords, "records in central dir, got", this.files.length);
      }
    }
  },

  /**
   * Read the end of central directory.
   */
  readEndOfCentral: function readEndOfCentral() {
    var offset = this.reader.lastIndexOfSignature(sig.CENTRAL_DIRECTORY_END);

    if (offset < 0) {
      // Check if the content is a truncated zip or complete garbage.
      // A "LOCAL_FILE_HEADER" is not required at the beginning (auto
      // extractible zip for example) but it can give a good hint.
      // If an ajax request was used without responseType, we will also
      // get unreadable data.
      var isGarbage = !this.isSignature(0, sig.LOCAL_FILE_HEADER);

      if (isGarbage) {
        throw new Error("Can't find end of central directory : is this a zip file ? " + "If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html");
      } else {
        throw new Error("Corrupted zip: can't find end of central directory");
      }
    }

    this.reader.setIndex(offset);
    var endOfCentralDirOffset = offset;
    this.checkSignature(sig.CENTRAL_DIRECTORY_END);
    this.readBlockEndOfCentral();
    /* extract from the zip spec :
        4)  If one of the fields in the end of central directory
            record is too small to hold required data, the field
            should be set to -1 (0xFFFF or 0xFFFFFFFF) and the
            ZIP64 format record should be created.
        5)  The end of central directory record and the
            Zip64 end of central directory locator record must
            reside on the same disk when splitting or spanning
            an archive.
     */

    if (this.diskNumber === utils.MAX_VALUE_16BITS || this.diskWithCentralDirStart === utils.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === utils.MAX_VALUE_16BITS || this.centralDirRecords === utils.MAX_VALUE_16BITS || this.centralDirSize === utils.MAX_VALUE_32BITS || this.centralDirOffset === utils.MAX_VALUE_32BITS) {
      this.zip64 = true;
      /*
      Warning : the zip64 extension is supported, but ONLY if the 64bits integer read from
      the zip file can fit into a 32bits integer. This cannot be solved : JavaScript represents
      all numbers as 64-bit double precision IEEE 754 floating point numbers.
      So, we have 53bits for integers and bitwise operations treat everything as 32bits.
      see https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Operators/Bitwise_Operators
      and http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-262.pdf section 8.5
      */
      // should look for a zip64 EOCD locator

      offset = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);

      if (offset < 0) {
        throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
      }

      this.reader.setIndex(offset);
      this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);
      this.readBlockZip64EndOfCentralLocator(); // now the zip64 EOCD record

      if (!this.isSignature(this.relativeOffsetEndOfZip64CentralDir, sig.ZIP64_CENTRAL_DIRECTORY_END)) {
        // console.warn("ZIP64 end of central directory not where expected.");
        this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);

        if (this.relativeOffsetEndOfZip64CentralDir < 0) {
          throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
        }
      }

      this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir);
      this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);
      this.readBlockZip64EndOfCentral();
    }

    var expectedEndOfCentralDirOffset = this.centralDirOffset + this.centralDirSize;

    if (this.zip64) {
      expectedEndOfCentralDirOffset += 20; // end of central dir 64 locator

      expectedEndOfCentralDirOffset += 12
      /* should not include the leading 12 bytes */
      + this.zip64EndOfCentralSize;
    }

    var extraBytes = endOfCentralDirOffset - expectedEndOfCentralDirOffset;

    if (extraBytes > 0) {
      // console.warn(extraBytes, "extra bytes at beginning or within zipfile");
      if (this.isSignature(endOfCentralDirOffset, sig.CENTRAL_FILE_HEADER)) {// The offsets seem wrong, but we have something at the specified offset.
        // So… we keep it.
      } else {
        // the offset is wrong, update the "zero" of the reader
        // this happens if data has been prepended (crx files for example)
        this.reader.zero = extraBytes;
      }
    } else if (extraBytes < 0) {
      throw new Error("Corrupted zip: missing " + Math.abs(extraBytes) + " bytes.");
    }
  },
  prepareReader: function prepareReader(data) {
    this.reader = readerFor(data);
  },

  /**
   * Read a zip file and create ZipEntries.
   * @param {String|ArrayBuffer|Uint8Array|Buffer} data the binary string representing a zip file.
   */
  load: function load(data) {
    this.prepareReader(data);
    this.readEndOfCentral();
    this.readCentralDir();
    this.readLocalFiles();
  }
}; // }}} end of ZipEntries

module.exports = ZipEntries;

/***/ }),

/***/ "./node_modules/jszip/lib/zipEntry.js":
/*!********************************************!*\
  !*** ./node_modules/jszip/lib/zipEntry.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var readerFor = __webpack_require__(/*! ./reader/readerFor */ "./node_modules/jszip/lib/reader/readerFor.js");

var utils = __webpack_require__(/*! ./utils */ "./node_modules/jszip/lib/utils.js");

var CompressedObject = __webpack_require__(/*! ./compressedObject */ "./node_modules/jszip/lib/compressedObject.js");

var crc32fn = __webpack_require__(/*! ./crc32 */ "./node_modules/jszip/lib/crc32.js");

var utf8 = __webpack_require__(/*! ./utf8 */ "./node_modules/jszip/lib/utf8.js");

var compressions = __webpack_require__(/*! ./compressions */ "./node_modules/jszip/lib/compressions.js");

var support = __webpack_require__(/*! ./support */ "./node_modules/jszip/lib/support.js");

var MADE_BY_DOS = 0x00;
var MADE_BY_UNIX = 0x03;
/**
 * Find a compression registered in JSZip.
 * @param {string} compressionMethod the method magic to find.
 * @return {Object|null} the JSZip compression object, null if none found.
 */

var findCompression = function findCompression(compressionMethod) {
  for (var method in compressions) {
    if (!compressions.hasOwnProperty(method)) {
      continue;
    }

    if (compressions[method].magic === compressionMethod) {
      return compressions[method];
    }
  }

  return null;
}; // class ZipEntry {{{

/**
 * An entry in the zip file.
 * @constructor
 * @param {Object} options Options of the current file.
 * @param {Object} loadOptions Options for loading the stream.
 */


function ZipEntry(options, loadOptions) {
  this.options = options;
  this.loadOptions = loadOptions;
}

ZipEntry.prototype = {
  /**
   * say if the file is encrypted.
   * @return {boolean} true if the file is encrypted, false otherwise.
   */
  isEncrypted: function isEncrypted() {
    // bit 1 is set
    return (this.bitFlag & 0x0001) === 0x0001;
  },

  /**
   * say if the file has utf-8 filename/comment.
   * @return {boolean} true if the filename/comment is in utf-8, false otherwise.
   */
  useUTF8: function useUTF8() {
    // bit 11 is set
    return (this.bitFlag & 0x0800) === 0x0800;
  },

  /**
   * Read the local part of a zip file and add the info in this object.
   * @param {DataReader} reader the reader to use.
   */
  readLocalPart: function readLocalPart(reader) {
    var compression, localExtraFieldsLength; // we already know everything from the central dir !
    // If the central dir data are false, we are doomed.
    // On the bright side, the local part is scary  : zip64, data descriptors, both, etc.
    // The less data we get here, the more reliable this should be.
    // Let's skip the whole header and dash to the data !

    reader.skip(22); // in some zip created on windows, the filename stored in the central dir contains \ instead of /.
    // Strangely, the filename here is OK.
    // I would love to treat these zip files as corrupted (see http://www.info-zip.org/FAQ.html#backslashes
    // or APPNOTE#4.4.17.1, "All slashes MUST be forward slashes '/'") but there are a lot of bad zip generators...
    // Search "unzip mismatching "local" filename continuing with "central" filename version" on
    // the internet.
    //
    // I think I see the logic here : the central directory is used to display
    // content and the local directory is used to extract the files. Mixing / and \
    // may be used to display \ to windows users and use / when extracting the files.
    // Unfortunately, this lead also to some issues : http://seclists.org/fulldisclosure/2009/Sep/394

    this.fileNameLength = reader.readInt(2);
    localExtraFieldsLength = reader.readInt(2); // can't be sure this will be the same as the central dir
    // the fileName is stored as binary data, the handleUTF8 method will take care of the encoding.

    this.fileName = reader.readData(this.fileNameLength);
    reader.skip(localExtraFieldsLength);

    if (this.compressedSize === -1 || this.uncompressedSize === -1) {
      throw new Error("Bug or corrupted zip : didn't get enough informations from the central directory " + "(compressedSize === -1 || uncompressedSize === -1)");
    }

    compression = findCompression(this.compressionMethod);

    if (compression === null) {
      // no compression found
      throw new Error("Corrupted zip : compression " + utils.pretty(this.compressionMethod) + " unknown (inner file : " + utils.transformTo("string", this.fileName) + ")");
    }

    this.decompressed = new CompressedObject(this.compressedSize, this.uncompressedSize, this.crc32, compression, reader.readData(this.compressedSize));
  },

  /**
   * Read the central part of a zip file and add the info in this object.
   * @param {DataReader} reader the reader to use.
   */
  readCentralPart: function readCentralPart(reader) {
    this.versionMadeBy = reader.readInt(2);
    reader.skip(2); // this.versionNeeded = reader.readInt(2);

    this.bitFlag = reader.readInt(2);
    this.compressionMethod = reader.readString(2);
    this.date = reader.readDate();
    this.crc32 = reader.readInt(4);
    this.compressedSize = reader.readInt(4);
    this.uncompressedSize = reader.readInt(4);
    var fileNameLength = reader.readInt(2);
    this.extraFieldsLength = reader.readInt(2);
    this.fileCommentLength = reader.readInt(2);
    this.diskNumberStart = reader.readInt(2);
    this.internalFileAttributes = reader.readInt(2);
    this.externalFileAttributes = reader.readInt(4);
    this.localHeaderOffset = reader.readInt(4);

    if (this.isEncrypted()) {
      throw new Error("Encrypted zip are not supported");
    } // will be read in the local part, see the comments there


    reader.skip(fileNameLength);
    this.readExtraFields(reader);
    this.parseZIP64ExtraField(reader);
    this.fileComment = reader.readData(this.fileCommentLength);
  },

  /**
   * Parse the external file attributes and get the unix/dos permissions.
   */
  processAttributes: function processAttributes() {
    this.unixPermissions = null;
    this.dosPermissions = null;
    var madeBy = this.versionMadeBy >> 8; // Check if we have the DOS directory flag set.
    // We look for it in the DOS and UNIX permissions
    // but some unknown platform could set it as a compatibility flag.

    this.dir = this.externalFileAttributes & 0x0010 ? true : false;

    if (madeBy === MADE_BY_DOS) {
      // first 6 bits (0 to 5)
      this.dosPermissions = this.externalFileAttributes & 0x3F;
    }

    if (madeBy === MADE_BY_UNIX) {
      this.unixPermissions = this.externalFileAttributes >> 16 & 0xFFFF; // the octal permissions are in (this.unixPermissions & 0x01FF).toString(8);
    } // fail safe : if the name ends with a / it probably means a folder


    if (!this.dir && this.fileNameStr.slice(-1) === '/') {
      this.dir = true;
    }
  },

  /**
   * Parse the ZIP64 extra field and merge the info in the current ZipEntry.
   * @param {DataReader} reader the reader to use.
   */
  parseZIP64ExtraField: function parseZIP64ExtraField(reader) {
    if (!this.extraFields[0x0001]) {
      return;
    } // should be something, preparing the extra reader


    var extraReader = readerFor(this.extraFields[0x0001].value); // I really hope that these 64bits integer can fit in 32 bits integer, because js
    // won't let us have more.

    if (this.uncompressedSize === utils.MAX_VALUE_32BITS) {
      this.uncompressedSize = extraReader.readInt(8);
    }

    if (this.compressedSize === utils.MAX_VALUE_32BITS) {
      this.compressedSize = extraReader.readInt(8);
    }

    if (this.localHeaderOffset === utils.MAX_VALUE_32BITS) {
      this.localHeaderOffset = extraReader.readInt(8);
    }

    if (this.diskNumberStart === utils.MAX_VALUE_32BITS) {
      this.diskNumberStart = extraReader.readInt(4);
    }
  },

  /**
   * Read the central part of a zip file and add the info in this object.
   * @param {DataReader} reader the reader to use.
   */
  readExtraFields: function readExtraFields(reader) {
    var end = reader.index + this.extraFieldsLength,
        extraFieldId,
        extraFieldLength,
        extraFieldValue;

    if (!this.extraFields) {
      this.extraFields = {};
    }

    while (reader.index < end) {
      extraFieldId = reader.readInt(2);
      extraFieldLength = reader.readInt(2);
      extraFieldValue = reader.readData(extraFieldLength);
      this.extraFields[extraFieldId] = {
        id: extraFieldId,
        length: extraFieldLength,
        value: extraFieldValue
      };
    }
  },

  /**
   * Apply an UTF8 transformation if needed.
   */
  handleUTF8: function handleUTF8() {
    var decodeParamType = support.uint8array ? "uint8array" : "array";

    if (this.useUTF8()) {
      this.fileNameStr = utf8.utf8decode(this.fileName);
      this.fileCommentStr = utf8.utf8decode(this.fileComment);
    } else {
      var upath = this.findExtraFieldUnicodePath();

      if (upath !== null) {
        this.fileNameStr = upath;
      } else {
        // ASCII text or unsupported code page
        var fileNameByteArray = utils.transformTo(decodeParamType, this.fileName);
        this.fileNameStr = this.loadOptions.decodeFileName(fileNameByteArray);
      }

      var ucomment = this.findExtraFieldUnicodeComment();

      if (ucomment !== null) {
        this.fileCommentStr = ucomment;
      } else {
        // ASCII text or unsupported code page
        var commentByteArray = utils.transformTo(decodeParamType, this.fileComment);
        this.fileCommentStr = this.loadOptions.decodeFileName(commentByteArray);
      }
    }
  },

  /**
   * Find the unicode path declared in the extra field, if any.
   * @return {String} the unicode path, null otherwise.
   */
  findExtraFieldUnicodePath: function findExtraFieldUnicodePath() {
    var upathField = this.extraFields[0x7075];

    if (upathField) {
      var extraReader = readerFor(upathField.value); // wrong version

      if (extraReader.readInt(1) !== 1) {
        return null;
      } // the crc of the filename changed, this field is out of date.


      if (crc32fn(this.fileName) !== extraReader.readInt(4)) {
        return null;
      }

      return utf8.utf8decode(extraReader.readData(upathField.length - 5));
    }

    return null;
  },

  /**
   * Find the unicode comment declared in the extra field, if any.
   * @return {String} the unicode comment, null otherwise.
   */
  findExtraFieldUnicodeComment: function findExtraFieldUnicodeComment() {
    var ucommentField = this.extraFields[0x6375];

    if (ucommentField) {
      var extraReader = readerFor(ucommentField.value); // wrong version

      if (extraReader.readInt(1) !== 1) {
        return null;
      } // the crc of the comment changed, this field is out of date.


      if (crc32fn(this.fileComment) !== extraReader.readInt(4)) {
        return null;
      }

      return utf8.utf8decode(extraReader.readData(ucommentField.length - 5));
    }

    return null;
  }
};
module.exports = ZipEntry;

/***/ }),

/***/ "./node_modules/jszip/lib/zipObject.js":
/*!*********************************************!*\
  !*** ./node_modules/jszip/lib/zipObject.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var StreamHelper = __webpack_require__(/*! ./stream/StreamHelper */ "./node_modules/jszip/lib/stream/StreamHelper.js");

var DataWorker = __webpack_require__(/*! ./stream/DataWorker */ "./node_modules/jszip/lib/stream/DataWorker.js");

var utf8 = __webpack_require__(/*! ./utf8 */ "./node_modules/jszip/lib/utf8.js");

var CompressedObject = __webpack_require__(/*! ./compressedObject */ "./node_modules/jszip/lib/compressedObject.js");

var GenericWorker = __webpack_require__(/*! ./stream/GenericWorker */ "./node_modules/jszip/lib/stream/GenericWorker.js");
/**
 * A simple object representing a file in the zip file.
 * @constructor
 * @param {string} name the name of the file
 * @param {String|ArrayBuffer|Uint8Array|Buffer} data the data
 * @param {Object} options the options of the file
 */


var ZipObject = function ZipObject(name, data, options) {
  this.name = name;
  this.dir = options.dir;
  this.date = options.date;
  this.comment = options.comment;
  this.unixPermissions = options.unixPermissions;
  this.dosPermissions = options.dosPermissions;
  this._data = data;
  this._dataBinary = options.binary; // keep only the compression

  this.options = {
    compression: options.compression,
    compressionOptions: options.compressionOptions
  };
};

ZipObject.prototype = {
  /**
   * Create an internal stream for the content of this object.
   * @param {String} type the type of each chunk.
   * @return StreamHelper the stream.
   */
  internalStream: function internalStream(type) {
    var result = null,
        outputType = "string";

    try {
      if (!type) {
        throw new Error("No output type specified.");
      }

      outputType = type.toLowerCase();
      var askUnicodeString = outputType === "string" || outputType === "text";

      if (outputType === "binarystring" || outputType === "text") {
        outputType = "string";
      }

      result = this._decompressWorker();
      var isUnicodeString = !this._dataBinary;

      if (isUnicodeString && !askUnicodeString) {
        result = result.pipe(new utf8.Utf8EncodeWorker());
      }

      if (!isUnicodeString && askUnicodeString) {
        result = result.pipe(new utf8.Utf8DecodeWorker());
      }
    } catch (e) {
      result = new GenericWorker("error");
      result.error(e);
    }

    return new StreamHelper(result, outputType, "");
  },

  /**
   * Prepare the content in the asked type.
   * @param {String} type the type of the result.
   * @param {Function} onUpdate a function to call on each internal update.
   * @return Promise the promise of the result.
   */
  async: function async(type, onUpdate) {
    return this.internalStream(type).accumulate(onUpdate);
  },

  /**
   * Prepare the content as a nodejs stream.
   * @param {String} type the type of each chunk.
   * @param {Function} onUpdate a function to call on each internal update.
   * @return Stream the stream.
   */
  nodeStream: function nodeStream(type, onUpdate) {
    return this.internalStream(type || "nodebuffer").toNodejsStream(onUpdate);
  },

  /**
   * Return a worker for the compressed content.
   * @private
   * @param {Object} compression the compression object to use.
   * @param {Object} compressionOptions the options to use when compressing.
   * @return Worker the worker.
   */
  _compressWorker: function _compressWorker(compression, compressionOptions) {
    if (this._data instanceof CompressedObject && this._data.compression.magic === compression.magic) {
      return this._data.getCompressedWorker();
    } else {
      var result = this._decompressWorker();

      if (!this._dataBinary) {
        result = result.pipe(new utf8.Utf8EncodeWorker());
      }

      return CompressedObject.createWorkerFrom(result, compression, compressionOptions);
    }
  },

  /**
   * Return a worker for the decompressed content.
   * @private
   * @return Worker the worker.
   */
  _decompressWorker: function _decompressWorker() {
    if (this._data instanceof CompressedObject) {
      return this._data.getContentWorker();
    } else if (this._data instanceof GenericWorker) {
      return this._data;
    } else {
      return new DataWorker(this._data);
    }
  }
};
var removedMethods = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"];

var removedFn = function removedFn() {
  throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
};

for (var i = 0; i < removedMethods.length; i++) {
  ZipObject.prototype[removedMethods[i]] = removedFn;
}

module.exports = ZipObject;

/***/ }),

/***/ "./node_modules/jszip/node_modules/core-js/library/fn/set-immediate.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/jszip/node_modules/core-js/library/fn/set-immediate.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ../modules/web.immediate */ "./node_modules/jszip/node_modules/core-js/library/modules/web.immediate.js");

module.exports = __webpack_require__(/*! ../modules/_core */ "./node_modules/jszip/node_modules/core-js/library/modules/_core.js").setImmediate;

/***/ }),

/***/ "./node_modules/jszip/node_modules/core-js/library/modules/_a-function.js":
/*!********************************************************************************!*\
  !*** ./node_modules/jszip/node_modules/core-js/library/modules/_a-function.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};

/***/ }),

/***/ "./node_modules/jszip/node_modules/core-js/library/modules/_an-object.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/jszip/node_modules/core-js/library/modules/_an-object.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/jszip/node_modules/core-js/library/modules/_is-object.js");

module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};

/***/ }),

/***/ "./node_modules/jszip/node_modules/core-js/library/modules/_cof.js":
/*!*************************************************************************!*\
  !*** ./node_modules/jszip/node_modules/core-js/library/modules/_cof.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};

/***/ }),

/***/ "./node_modules/jszip/node_modules/core-js/library/modules/_core.js":
/*!**************************************************************************!*\
  !*** ./node_modules/jszip/node_modules/core-js/library/modules/_core.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var core = module.exports = {
  version: '2.3.0'
};
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef

/***/ }),

/***/ "./node_modules/jszip/node_modules/core-js/library/modules/_ctx.js":
/*!*************************************************************************!*\
  !*** ./node_modules/jszip/node_modules/core-js/library/modules/_ctx.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// optional / simple context binding
var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/jszip/node_modules/core-js/library/modules/_a-function.js");

module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;

  switch (length) {
    case 1:
      return function (a) {
        return fn.call(that, a);
      };

    case 2:
      return function (a, b) {
        return fn.call(that, a, b);
      };

    case 3:
      return function (a, b, c) {
        return fn.call(that, a, b, c);
      };
  }

  return function ()
  /* ...args */
  {
    return fn.apply(that, arguments);
  };
};

/***/ }),

/***/ "./node_modules/jszip/node_modules/core-js/library/modules/_descriptors.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/jszip/node_modules/core-js/library/modules/_descriptors.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Thank's IE8 for his funny defineProperty
module.exports = !__webpack_require__(/*! ./_fails */ "./node_modules/jszip/node_modules/core-js/library/modules/_fails.js")(function () {
  return Object.defineProperty({}, 'a', {
    get: function get() {
      return 7;
    }
  }).a != 7;
});

/***/ }),

/***/ "./node_modules/jszip/node_modules/core-js/library/modules/_dom-create.js":
/*!********************************************************************************!*\
  !*** ./node_modules/jszip/node_modules/core-js/library/modules/_dom-create.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/jszip/node_modules/core-js/library/modules/_is-object.js"),
    document = __webpack_require__(/*! ./_global */ "./node_modules/jszip/node_modules/core-js/library/modules/_global.js").document // in old IE typeof document.createElement is 'object'
,
    is = isObject(document) && isObject(document.createElement);

module.exports = function (it) {
  return is ? document.createElement(it) : {};
};

/***/ }),

/***/ "./node_modules/jszip/node_modules/core-js/library/modules/_export.js":
/*!****************************************************************************!*\
  !*** ./node_modules/jszip/node_modules/core-js/library/modules/_export.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ./_global */ "./node_modules/jszip/node_modules/core-js/library/modules/_global.js"),
    core = __webpack_require__(/*! ./_core */ "./node_modules/jszip/node_modules/core-js/library/modules/_core.js"),
    ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/jszip/node_modules/core-js/library/modules/_ctx.js"),
    hide = __webpack_require__(/*! ./_hide */ "./node_modules/jszip/node_modules/core-js/library/modules/_hide.js"),
    PROTOTYPE = 'prototype';

var $export = function $export(type, name, source) {
  var IS_FORCED = type & $export.F,
      IS_GLOBAL = type & $export.G,
      IS_STATIC = type & $export.S,
      IS_PROTO = type & $export.P,
      IS_BIND = type & $export.B,
      IS_WRAP = type & $export.W,
      exports = IS_GLOBAL ? core : core[name] || (core[name] = {}),
      expProto = exports[PROTOTYPE],
      target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE],
      key,
      own,
      out;
  if (IS_GLOBAL) source = name;

  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    if (own && key in exports) continue; // export native or passed

    out = own ? target[key] : source[key]; // prevent global pollution for namespaces

    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key] // bind timers to global for call from export context
    : IS_BIND && own ? ctx(out, global) // wrap global constructors for prevent change them in library
    : IS_WRAP && target[key] == out ? function (C) {
      var F = function F(a, b, c) {
        if (this instanceof C) {
          switch (arguments.length) {
            case 0:
              return new C();

            case 1:
              return new C(a);

            case 2:
              return new C(a, b);
          }

          return new C(a, b, c);
        }

        return C.apply(this, arguments);
      };

      F[PROTOTYPE] = C[PROTOTYPE];
      return F; // make static versions for prototype methods
    }(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out; // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%

    if (IS_PROTO) {
      (exports.virtual || (exports.virtual = {}))[key] = out; // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%

      if (type & $export.R && expProto && !expProto[key]) hide(expProto, key, out);
    }
  }
}; // type bitmap


$export.F = 1; // forced

$export.G = 2; // global

$export.S = 4; // static

$export.P = 8; // proto

$export.B = 16; // bind

$export.W = 32; // wrap

$export.U = 64; // safe

$export.R = 128; // real proto method for `library` 

module.exports = $export;

/***/ }),

/***/ "./node_modules/jszip/node_modules/core-js/library/modules/_fails.js":
/*!***************************************************************************!*\
  !*** ./node_modules/jszip/node_modules/core-js/library/modules/_fails.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};

/***/ }),

/***/ "./node_modules/jszip/node_modules/core-js/library/modules/_global.js":
/*!****************************************************************************!*\
  !*** ./node_modules/jszip/node_modules/core-js/library/modules/_global.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef

/***/ }),

/***/ "./node_modules/jszip/node_modules/core-js/library/modules/_hide.js":
/*!**************************************************************************!*\
  !*** ./node_modules/jszip/node_modules/core-js/library/modules/_hide.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(/*! ./_object-dp */ "./node_modules/jszip/node_modules/core-js/library/modules/_object-dp.js"),
    createDesc = __webpack_require__(/*! ./_property-desc */ "./node_modules/jszip/node_modules/core-js/library/modules/_property-desc.js");

module.exports = __webpack_require__(/*! ./_descriptors */ "./node_modules/jszip/node_modules/core-js/library/modules/_descriptors.js") ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};

/***/ }),

/***/ "./node_modules/jszip/node_modules/core-js/library/modules/_html.js":
/*!**************************************************************************!*\
  !*** ./node_modules/jszip/node_modules/core-js/library/modules/_html.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./_global */ "./node_modules/jszip/node_modules/core-js/library/modules/_global.js").document && document.documentElement;

/***/ }),

/***/ "./node_modules/jszip/node_modules/core-js/library/modules/_ie8-dom-define.js":
/*!************************************************************************************!*\
  !*** ./node_modules/jszip/node_modules/core-js/library/modules/_ie8-dom-define.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = !__webpack_require__(/*! ./_descriptors */ "./node_modules/jszip/node_modules/core-js/library/modules/_descriptors.js") && !__webpack_require__(/*! ./_fails */ "./node_modules/jszip/node_modules/core-js/library/modules/_fails.js")(function () {
  return Object.defineProperty(__webpack_require__(/*! ./_dom-create */ "./node_modules/jszip/node_modules/core-js/library/modules/_dom-create.js")('div'), 'a', {
    get: function get() {
      return 7;
    }
  }).a != 7;
});

/***/ }),

/***/ "./node_modules/jszip/node_modules/core-js/library/modules/_invoke.js":
/*!****************************************************************************!*\
  !*** ./node_modules/jszip/node_modules/core-js/library/modules/_invoke.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// fast apply, http://jsperf.lnkit.com/fast-apply/5
module.exports = function (fn, args, that) {
  var un = that === undefined;

  switch (args.length) {
    case 0:
      return un ? fn() : fn.call(that);

    case 1:
      return un ? fn(args[0]) : fn.call(that, args[0]);

    case 2:
      return un ? fn(args[0], args[1]) : fn.call(that, args[0], args[1]);

    case 3:
      return un ? fn(args[0], args[1], args[2]) : fn.call(that, args[0], args[1], args[2]);

    case 4:
      return un ? fn(args[0], args[1], args[2], args[3]) : fn.call(that, args[0], args[1], args[2], args[3]);
  }

  return fn.apply(that, args);
};

/***/ }),

/***/ "./node_modules/jszip/node_modules/core-js/library/modules/_is-object.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/jszip/node_modules/core-js/library/modules/_is-object.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

module.exports = function (it) {
  return _typeof(it) === 'object' ? it !== null : typeof it === 'function';
};

/***/ }),

/***/ "./node_modules/jszip/node_modules/core-js/library/modules/_object-dp.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/jszip/node_modules/core-js/library/modules/_object-dp.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/jszip/node_modules/core-js/library/modules/_an-object.js"),
    IE8_DOM_DEFINE = __webpack_require__(/*! ./_ie8-dom-define */ "./node_modules/jszip/node_modules/core-js/library/modules/_ie8-dom-define.js"),
    toPrimitive = __webpack_require__(/*! ./_to-primitive */ "./node_modules/jszip/node_modules/core-js/library/modules/_to-primitive.js"),
    dP = Object.defineProperty;

exports.f = __webpack_require__(/*! ./_descriptors */ "./node_modules/jszip/node_modules/core-js/library/modules/_descriptors.js") ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) {
    /* empty */
  }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};

/***/ }),

/***/ "./node_modules/jszip/node_modules/core-js/library/modules/_property-desc.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/jszip/node_modules/core-js/library/modules/_property-desc.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};

/***/ }),

/***/ "./node_modules/jszip/node_modules/core-js/library/modules/_task.js":
/*!**************************************************************************!*\
  !*** ./node_modules/jszip/node_modules/core-js/library/modules/_task.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/jszip/node_modules/core-js/library/modules/_ctx.js"),
    invoke = __webpack_require__(/*! ./_invoke */ "./node_modules/jszip/node_modules/core-js/library/modules/_invoke.js"),
    html = __webpack_require__(/*! ./_html */ "./node_modules/jszip/node_modules/core-js/library/modules/_html.js"),
    cel = __webpack_require__(/*! ./_dom-create */ "./node_modules/jszip/node_modules/core-js/library/modules/_dom-create.js"),
    global = __webpack_require__(/*! ./_global */ "./node_modules/jszip/node_modules/core-js/library/modules/_global.js"),
    process = global.process,
    setTask = global.setImmediate,
    clearTask = global.clearImmediate,
    MessageChannel = global.MessageChannel,
    counter = 0,
    queue = {},
    ONREADYSTATECHANGE = 'onreadystatechange',
    defer,
    channel,
    port;

var run = function run() {
  var id = +this;

  if (queue.hasOwnProperty(id)) {
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};

var listener = function listener(event) {
  run.call(event.data);
}; // Node.js 0.9+ & IE10+ has setImmediate, otherwise:


if (!setTask || !clearTask) {
  setTask = function setImmediate(fn) {
    var args = [],
        i = 1;

    while (arguments.length > i) {
      args.push(arguments[i++]);
    }

    queue[++counter] = function () {
      invoke(typeof fn == 'function' ? fn : Function(fn), args);
    };

    defer(counter);
    return counter;
  };

  clearTask = function clearImmediate(id) {
    delete queue[id];
  }; // Node.js 0.8-


  if (__webpack_require__(/*! ./_cof */ "./node_modules/jszip/node_modules/core-js/library/modules/_cof.js")(process) == 'process') {
    defer = function defer(id) {
      process.nextTick(ctx(run, id, 1));
    }; // Browsers with MessageChannel, includes WebWorkers

  } else if (MessageChannel) {
    channel = new MessageChannel();
    port = channel.port2;
    channel.port1.onmessage = listener;
    defer = ctx(port.postMessage, port, 1); // Browsers with postMessage, skip WebWorkers
    // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {
    defer = function defer(id) {
      global.postMessage(id + '', '*');
    };

    global.addEventListener('message', listener, false); // IE8-
  } else if (ONREADYSTATECHANGE in cel('script')) {
    defer = function defer(id) {
      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function () {
        html.removeChild(this);
        run.call(id);
      };
    }; // Rest old browsers

  } else {
    defer = function defer(id) {
      setTimeout(ctx(run, id, 1), 0);
    };
  }
}

module.exports = {
  set: setTask,
  clear: clearTask
};

/***/ }),

/***/ "./node_modules/jszip/node_modules/core-js/library/modules/_to-primitive.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/jszip/node_modules/core-js/library/modules/_to-primitive.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/jszip/node_modules/core-js/library/modules/_is-object.js"); // instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string


module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};

/***/ }),

/***/ "./node_modules/jszip/node_modules/core-js/library/modules/web.immediate.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/jszip/node_modules/core-js/library/modules/web.immediate.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "./node_modules/jszip/node_modules/core-js/library/modules/_export.js"),
    $task = __webpack_require__(/*! ./_task */ "./node_modules/jszip/node_modules/core-js/library/modules/_task.js");

$export($export.G + $export.B, {
  setImmediate: $task.set,
  clearImmediate: $task.clear
});

/***/ }),

/***/ "./node_modules/lie/lib/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/lie/lib/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var immediate = __webpack_require__(/*! immediate */ "./node_modules/immediate/lib/browser.js");
/* istanbul ignore next */


function INTERNAL() {}

var handlers = {};
var REJECTED = ['REJECTED'];
var FULFILLED = ['FULFILLED'];
var PENDING = ['PENDING'];
module.exports = Promise;

function Promise(resolver) {
  if (typeof resolver !== 'function') {
    throw new TypeError('resolver must be a function');
  }

  this.state = PENDING;
  this.queue = [];
  this.outcome = void 0;

  if (resolver !== INTERNAL) {
    safelyResolveThenable(this, resolver);
  }
}

Promise.prototype["catch"] = function (onRejected) {
  return this.then(null, onRejected);
};

Promise.prototype.then = function (onFulfilled, onRejected) {
  if (typeof onFulfilled !== 'function' && this.state === FULFILLED || typeof onRejected !== 'function' && this.state === REJECTED) {
    return this;
  }

  var promise = new this.constructor(INTERNAL);

  if (this.state !== PENDING) {
    var resolver = this.state === FULFILLED ? onFulfilled : onRejected;
    unwrap(promise, resolver, this.outcome);
  } else {
    this.queue.push(new QueueItem(promise, onFulfilled, onRejected));
  }

  return promise;
};

function QueueItem(promise, onFulfilled, onRejected) {
  this.promise = promise;

  if (typeof onFulfilled === 'function') {
    this.onFulfilled = onFulfilled;
    this.callFulfilled = this.otherCallFulfilled;
  }

  if (typeof onRejected === 'function') {
    this.onRejected = onRejected;
    this.callRejected = this.otherCallRejected;
  }
}

QueueItem.prototype.callFulfilled = function (value) {
  handlers.resolve(this.promise, value);
};

QueueItem.prototype.otherCallFulfilled = function (value) {
  unwrap(this.promise, this.onFulfilled, value);
};

QueueItem.prototype.callRejected = function (value) {
  handlers.reject(this.promise, value);
};

QueueItem.prototype.otherCallRejected = function (value) {
  unwrap(this.promise, this.onRejected, value);
};

function unwrap(promise, func, value) {
  immediate(function () {
    var returnValue;

    try {
      returnValue = func(value);
    } catch (e) {
      return handlers.reject(promise, e);
    }

    if (returnValue === promise) {
      handlers.reject(promise, new TypeError('Cannot resolve promise with itself'));
    } else {
      handlers.resolve(promise, returnValue);
    }
  });
}

handlers.resolve = function (self, value) {
  var result = tryCatch(getThen, value);

  if (result.status === 'error') {
    return handlers.reject(self, result.value);
  }

  var thenable = result.value;

  if (thenable) {
    safelyResolveThenable(self, thenable);
  } else {
    self.state = FULFILLED;
    self.outcome = value;
    var i = -1;
    var len = self.queue.length;

    while (++i < len) {
      self.queue[i].callFulfilled(value);
    }
  }

  return self;
};

handlers.reject = function (self, error) {
  self.state = REJECTED;
  self.outcome = error;
  var i = -1;
  var len = self.queue.length;

  while (++i < len) {
    self.queue[i].callRejected(error);
  }

  return self;
};

function getThen(obj) {
  // Make sure we only access the accessor once as required by the spec
  var then = obj && obj.then;

  if (obj && (_typeof(obj) === 'object' || typeof obj === 'function') && typeof then === 'function') {
    return function appyThen() {
      then.apply(obj, arguments);
    };
  }
}

function safelyResolveThenable(self, thenable) {
  // Either fulfill, reject or reject with error
  var called = false;

  function onError(value) {
    if (called) {
      return;
    }

    called = true;
    handlers.reject(self, value);
  }

  function onSuccess(value) {
    if (called) {
      return;
    }

    called = true;
    handlers.resolve(self, value);
  }

  function tryToUnwrap() {
    thenable(onSuccess, onError);
  }

  var result = tryCatch(tryToUnwrap);

  if (result.status === 'error') {
    onError(result.value);
  }
}

function tryCatch(func, value) {
  var out = {};

  try {
    out.value = func(value);
    out.status = 'success';
  } catch (e) {
    out.status = 'error';
    out.value = e;
  }

  return out;
}

Promise.resolve = resolve;

function resolve(value) {
  if (value instanceof this) {
    return value;
  }

  return handlers.resolve(new this(INTERNAL), value);
}

Promise.reject = reject;

function reject(reason) {
  var promise = new this(INTERNAL);
  return handlers.reject(promise, reason);
}

Promise.all = all;

function all(iterable) {
  var self = this;

  if (Object.prototype.toString.call(iterable) !== '[object Array]') {
    return this.reject(new TypeError('must be an array'));
  }

  var len = iterable.length;
  var called = false;

  if (!len) {
    return this.resolve([]);
  }

  var values = new Array(len);
  var resolved = 0;
  var i = -1;
  var promise = new this(INTERNAL);

  while (++i < len) {
    allResolver(iterable[i], i);
  }

  return promise;

  function allResolver(value, i) {
    self.resolve(value).then(resolveFromAll, function (error) {
      if (!called) {
        called = true;
        handlers.reject(promise, error);
      }
    });

    function resolveFromAll(outValue) {
      values[i] = outValue;

      if (++resolved === len && !called) {
        called = true;
        handlers.resolve(promise, values);
      }
    }
  }
}

Promise.race = race;

function race(iterable) {
  var self = this;

  if (Object.prototype.toString.call(iterable) !== '[object Array]') {
    return this.reject(new TypeError('must be an array'));
  }

  var len = iterable.length;
  var called = false;

  if (!len) {
    return this.resolve([]);
  }

  var i = -1;
  var promise = new this(INTERNAL);

  while (++i < len) {
    resolver(iterable[i]);
  }

  return promise;

  function resolver(value) {
    self.resolve(value).then(function (response) {
      if (!called) {
        called = true;
        handlers.resolve(promise, response);
      }
    }, function (error) {
      if (!called) {
        called = true;
        handlers.reject(promise, error);
      }
    });
  }
}

/***/ }),

/***/ "./node_modules/node-libs-browser/node_modules/string_decoder/lib/string_decoder.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/node-libs-browser/node_modules/string_decoder/lib/string_decoder.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

/*<replacement>*/

var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer;
/*</replacement>*/


var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;

  switch (encoding && encoding.toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
    case 'raw':
      return true;

    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;

  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';

      case 'latin1':
      case 'binary':
        return 'latin1';

      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;

      default:
        if (retried) return; // undefined

        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
}

; // Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings

function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);

  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
} // StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.


exports.StringDecoder = StringDecoder;

function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;

  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;

    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;

    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;

    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }

  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;

  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }

  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End; // Returns only complete characters in a Buffer

StringDecoder.prototype.text = utf8Text; // Attempts to complete a partial non-UTF-8 character using bytes from a Buffer

StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }

  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
}; // Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.


function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return byte >> 6 === 0x02 ? -1 : -2;
} // Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.


function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);

  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }

  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);

  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }

  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);

  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }

    return nb;
  }

  return 0;
} // Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.


function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return "\uFFFD";
  }

  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return "\uFFFD";
    }

    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return "\uFFFD";
      }
    }
  }
} // Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.


function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;

  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }

  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
} // Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.


function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
} // For UTF-8, a replacement character is added when ending on a partial
// character.


function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + "\uFFFD";
  return r;
} // UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.


function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);

    if (r) {
      var c = r.charCodeAt(r.length - 1);

      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }

    return r;
  }

  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
} // For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.


function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';

  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }

  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;

  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }

  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
} // Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)


function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}

/***/ }),

/***/ "./node_modules/pako/index.js":
/*!************************************!*\
  !*** ./node_modules/pako/index.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Top level file is just a mixin of submodules & constants


var assign = __webpack_require__(/*! ./lib/utils/common */ "./node_modules/pako/lib/utils/common.js").assign;

var deflate = __webpack_require__(/*! ./lib/deflate */ "./node_modules/pako/lib/deflate.js");

var inflate = __webpack_require__(/*! ./lib/inflate */ "./node_modules/pako/lib/inflate.js");

var constants = __webpack_require__(/*! ./lib/zlib/constants */ "./node_modules/pako/lib/zlib/constants.js");

var pako = {};
assign(pako, deflate, inflate, constants);
module.exports = pako;

/***/ }),

/***/ "./node_modules/pako/lib/deflate.js":
/*!******************************************!*\
  !*** ./node_modules/pako/lib/deflate.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var zlib_deflate = __webpack_require__(/*! ./zlib/deflate */ "./node_modules/pako/lib/zlib/deflate.js");

var utils = __webpack_require__(/*! ./utils/common */ "./node_modules/pako/lib/utils/common.js");

var strings = __webpack_require__(/*! ./utils/strings */ "./node_modules/pako/lib/utils/strings.js");

var msg = __webpack_require__(/*! ./zlib/messages */ "./node_modules/pako/lib/zlib/messages.js");

var ZStream = __webpack_require__(/*! ./zlib/zstream */ "./node_modules/pako/lib/zlib/zstream.js");

var toString = Object.prototype.toString;
/* Public constants ==========================================================*/

/* ===========================================================================*/

var Z_NO_FLUSH = 0;
var Z_FINISH = 4;
var Z_OK = 0;
var Z_STREAM_END = 1;
var Z_SYNC_FLUSH = 2;
var Z_DEFAULT_COMPRESSION = -1;
var Z_DEFAULT_STRATEGY = 0;
var Z_DEFLATED = 8;
/* ===========================================================================*/

/**
 * class Deflate
 *
 * Generic JS-style wrapper for zlib calls. If you don't need
 * streaming behaviour - use more simple functions: [[deflate]],
 * [[deflateRaw]] and [[gzip]].
 **/

/* internal
 * Deflate.chunks -> Array
 *
 * Chunks of output data, if [[Deflate#onData]] not overridden.
 **/

/**
 * Deflate.result -> Uint8Array|Array
 *
 * Compressed result, generated by default [[Deflate#onData]]
 * and [[Deflate#onEnd]] handlers. Filled after you push last chunk
 * (call [[Deflate#push]] with `Z_FINISH` / `true` param)  or if you
 * push a chunk with explicit flush (call [[Deflate#push]] with
 * `Z_SYNC_FLUSH` param).
 **/

/**
 * Deflate.err -> Number
 *
 * Error code after deflate finished. 0 (Z_OK) on success.
 * You will not need it in real life, because deflate errors
 * are possible only on wrong options or bad `onData` / `onEnd`
 * custom handlers.
 **/

/**
 * Deflate.msg -> String
 *
 * Error message, if [[Deflate.err]] != 0
 **/

/**
 * new Deflate(options)
 * - options (Object): zlib deflate options.
 *
 * Creates new deflator instance with specified params. Throws exception
 * on bad params. Supported options:
 *
 * - `level`
 * - `windowBits`
 * - `memLevel`
 * - `strategy`
 * - `dictionary`
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Additional options, for internal needs:
 *
 * - `chunkSize` - size of generated data chunks (16K by default)
 * - `raw` (Boolean) - do raw deflate
 * - `gzip` (Boolean) - create gzip wrapper
 * - `to` (String) - if equal to 'string', then result will be "binary string"
 *    (each char code [0..255])
 * - `header` (Object) - custom header for gzip
 *   - `text` (Boolean) - true if compressed data believed to be text
 *   - `time` (Number) - modification time, unix timestamp
 *   - `os` (Number) - operation system code
 *   - `extra` (Array) - array of bytes with extra data (max 65536)
 *   - `name` (String) - file name (binary string)
 *   - `comment` (String) - comment (binary string)
 *   - `hcrc` (Boolean) - true if header crc should be added
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])
 *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);
 *
 * var deflate = new pako.Deflate({ level: 3});
 *
 * deflate.push(chunk1, false);
 * deflate.push(chunk2, true);  // true -> last chunk
 *
 * if (deflate.err) { throw new Error(deflate.err); }
 *
 * console.log(deflate.result);
 * ```
 **/

function Deflate(options) {
  if (!(this instanceof Deflate)) return new Deflate(options);
  this.options = utils.assign({
    level: Z_DEFAULT_COMPRESSION,
    method: Z_DEFLATED,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: Z_DEFAULT_STRATEGY,
    to: ''
  }, options || {});
  var opt = this.options;

  if (opt.raw && opt.windowBits > 0) {
    opt.windowBits = -opt.windowBits;
  } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
    opt.windowBits += 16;
  }

  this.err = 0; // error code, if happens (0 = Z_OK)

  this.msg = ''; // error message

  this.ended = false; // used to avoid multiple onEnd() calls

  this.chunks = []; // chunks of compressed data

  this.strm = new ZStream();
  this.strm.avail_out = 0;
  var status = zlib_deflate.deflateInit2(this.strm, opt.level, opt.method, opt.windowBits, opt.memLevel, opt.strategy);

  if (status !== Z_OK) {
    throw new Error(msg[status]);
  }

  if (opt.header) {
    zlib_deflate.deflateSetHeader(this.strm, opt.header);
  }

  if (opt.dictionary) {
    var dict; // Convert data if needed

    if (typeof opt.dictionary === 'string') {
      // If we need to compress text, change encoding to utf8.
      dict = strings.string2buf(opt.dictionary);
    } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {
      dict = new Uint8Array(opt.dictionary);
    } else {
      dict = opt.dictionary;
    }

    status = zlib_deflate.deflateSetDictionary(this.strm, dict);

    if (status !== Z_OK) {
      throw new Error(msg[status]);
    }

    this._dict_set = true;
  }
}
/**
 * Deflate#push(data[, mode]) -> Boolean
 * - data (Uint8Array|Array|ArrayBuffer|String): input data. Strings will be
 *   converted to utf8 byte sequence.
 * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
 *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.
 *
 * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with
 * new compressed chunks. Returns `true` on success. The last data block must have
 * mode Z_FINISH (or `true`). That will flush internal pending buffers and call
 * [[Deflate#onEnd]]. For interim explicit flushes (without ending the stream) you
 * can use mode Z_SYNC_FLUSH, keeping the compression context.
 *
 * On fail call [[Deflate#onEnd]] with error code and return false.
 *
 * We strongly recommend to use `Uint8Array` on input for best speed (output
 * array format is detected automatically). Also, don't skip last param and always
 * use the same type in your code (boolean or number). That will improve JS speed.
 *
 * For regular `Array`-s make sure all elements are [0..255].
 *
 * ##### Example
 *
 * ```javascript
 * push(chunk, false); // push one of data chunks
 * ...
 * push(chunk, true);  // push last chunk
 * ```
 **/


Deflate.prototype.push = function (data, mode) {
  var strm = this.strm;
  var chunkSize = this.options.chunkSize;

  var status, _mode;

  if (this.ended) {
    return false;
  }

  _mode = mode === ~~mode ? mode : mode === true ? Z_FINISH : Z_NO_FLUSH; // Convert data if needed

  if (typeof data === 'string') {
    // If we need to compress text, change encoding to utf8.
    strm.input = strings.string2buf(data);
  } else if (toString.call(data) === '[object ArrayBuffer]') {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }

  strm.next_in = 0;
  strm.avail_in = strm.input.length;

  do {
    if (strm.avail_out === 0) {
      strm.output = new utils.Buf8(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }

    status = zlib_deflate.deflate(strm, _mode);
    /* no bad return value */

    if (status !== Z_STREAM_END && status !== Z_OK) {
      this.onEnd(status);
      this.ended = true;
      return false;
    }

    if (strm.avail_out === 0 || strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH)) {
      if (this.options.to === 'string') {
        this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));
      } else {
        this.onData(utils.shrinkBuf(strm.output, strm.next_out));
      }
    }
  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END); // Finalize on the last chunk.


  if (_mode === Z_FINISH) {
    status = zlib_deflate.deflateEnd(this.strm);
    this.onEnd(status);
    this.ended = true;
    return status === Z_OK;
  } // callback interim results if Z_SYNC_FLUSH.


  if (_mode === Z_SYNC_FLUSH) {
    this.onEnd(Z_OK);
    strm.avail_out = 0;
    return true;
  }

  return true;
};
/**
 * Deflate#onData(chunk) -> Void
 * - chunk (Uint8Array|Array|String): output data. Type of array depends
 *   on js engine support. When string output requested, each chunk
 *   will be string.
 *
 * By default, stores data blocks in `chunks[]` property and glue
 * those in `onEnd`. Override this handler, if you need another behaviour.
 **/


Deflate.prototype.onData = function (chunk) {
  this.chunks.push(chunk);
};
/**
 * Deflate#onEnd(status) -> Void
 * - status (Number): deflate status. 0 (Z_OK) on success,
 *   other if not.
 *
 * Called once after you tell deflate that the input stream is
 * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)
 * or if an error happened. By default - join collected chunks,
 * free memory and fill `results` / `err` properties.
 **/


Deflate.prototype.onEnd = function (status) {
  // On success - join
  if (status === Z_OK) {
    if (this.options.to === 'string') {
      this.result = this.chunks.join('');
    } else {
      this.result = utils.flattenChunks(this.chunks);
    }
  }

  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};
/**
 * deflate(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * Compress `data` with deflate algorithm and `options`.
 *
 * Supported options are:
 *
 * - level
 * - windowBits
 * - memLevel
 * - strategy
 * - dictionary
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Sugar (options):
 *
 * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
 *   negative windowBits implicitly.
 * - `to` (String) - if equal to 'string', then result will be "binary string"
 *    (each char code [0..255])
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , data = Uint8Array([1,2,3,4,5,6,7,8,9]);
 *
 * console.log(pako.deflate(data));
 * ```
 **/


function deflate(input, options) {
  var deflator = new Deflate(options);
  deflator.push(input, true); // That will never happens, if you don't cheat with options :)

  if (deflator.err) {
    throw deflator.msg || msg[deflator.err];
  }

  return deflator.result;
}
/**
 * deflateRaw(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * The same as [[deflate]], but creates raw data, without wrapper
 * (header and adler32 crc).
 **/


function deflateRaw(input, options) {
  options = options || {};
  options.raw = true;
  return deflate(input, options);
}
/**
 * gzip(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * The same as [[deflate]], but create gzip wrapper instead of
 * deflate one.
 **/


function gzip(input, options) {
  options = options || {};
  options.gzip = true;
  return deflate(input, options);
}

exports.Deflate = Deflate;
exports.deflate = deflate;
exports.deflateRaw = deflateRaw;
exports.gzip = gzip;

/***/ }),

/***/ "./node_modules/pako/lib/inflate.js":
/*!******************************************!*\
  !*** ./node_modules/pako/lib/inflate.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var zlib_inflate = __webpack_require__(/*! ./zlib/inflate */ "./node_modules/pako/lib/zlib/inflate.js");

var utils = __webpack_require__(/*! ./utils/common */ "./node_modules/pako/lib/utils/common.js");

var strings = __webpack_require__(/*! ./utils/strings */ "./node_modules/pako/lib/utils/strings.js");

var c = __webpack_require__(/*! ./zlib/constants */ "./node_modules/pako/lib/zlib/constants.js");

var msg = __webpack_require__(/*! ./zlib/messages */ "./node_modules/pako/lib/zlib/messages.js");

var ZStream = __webpack_require__(/*! ./zlib/zstream */ "./node_modules/pako/lib/zlib/zstream.js");

var GZheader = __webpack_require__(/*! ./zlib/gzheader */ "./node_modules/pako/lib/zlib/gzheader.js");

var toString = Object.prototype.toString;
/**
 * class Inflate
 *
 * Generic JS-style wrapper for zlib calls. If you don't need
 * streaming behaviour - use more simple functions: [[inflate]]
 * and [[inflateRaw]].
 **/

/* internal
 * inflate.chunks -> Array
 *
 * Chunks of output data, if [[Inflate#onData]] not overridden.
 **/

/**
 * Inflate.result -> Uint8Array|Array|String
 *
 * Uncompressed result, generated by default [[Inflate#onData]]
 * and [[Inflate#onEnd]] handlers. Filled after you push last chunk
 * (call [[Inflate#push]] with `Z_FINISH` / `true` param) or if you
 * push a chunk with explicit flush (call [[Inflate#push]] with
 * `Z_SYNC_FLUSH` param).
 **/

/**
 * Inflate.err -> Number
 *
 * Error code after inflate finished. 0 (Z_OK) on success.
 * Should be checked if broken data possible.
 **/

/**
 * Inflate.msg -> String
 *
 * Error message, if [[Inflate.err]] != 0
 **/

/**
 * new Inflate(options)
 * - options (Object): zlib inflate options.
 *
 * Creates new inflator instance with specified params. Throws exception
 * on bad params. Supported options:
 *
 * - `windowBits`
 * - `dictionary`
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Additional options, for internal needs:
 *
 * - `chunkSize` - size of generated data chunks (16K by default)
 * - `raw` (Boolean) - do raw inflate
 * - `to` (String) - if equal to 'string', then result will be converted
 *   from utf8 to utf16 (javascript) string. When string output requested,
 *   chunk length can differ from `chunkSize`, depending on content.
 *
 * By default, when no options set, autodetect deflate/gzip data format via
 * wrapper header.
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])
 *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);
 *
 * var inflate = new pako.Inflate({ level: 3});
 *
 * inflate.push(chunk1, false);
 * inflate.push(chunk2, true);  // true -> last chunk
 *
 * if (inflate.err) { throw new Error(inflate.err); }
 *
 * console.log(inflate.result);
 * ```
 **/

function Inflate(options) {
  if (!(this instanceof Inflate)) return new Inflate(options);
  this.options = utils.assign({
    chunkSize: 16384,
    windowBits: 0,
    to: ''
  }, options || {});
  var opt = this.options; // Force window size for `raw` data, if not set directly,
  // because we have no header for autodetect.

  if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
    opt.windowBits = -opt.windowBits;

    if (opt.windowBits === 0) {
      opt.windowBits = -15;
    }
  } // If `windowBits` not defined (and mode not raw) - set autodetect flag for gzip/deflate


  if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
    opt.windowBits += 32;
  } // Gzip header has no info about windows size, we can do autodetect only
  // for deflate. So, if window size not set, force it to max when gzip possible


  if (opt.windowBits > 15 && opt.windowBits < 48) {
    // bit 3 (16) -> gzipped data
    // bit 4 (32) -> autodetect gzip/deflate
    if ((opt.windowBits & 15) === 0) {
      opt.windowBits |= 15;
    }
  }

  this.err = 0; // error code, if happens (0 = Z_OK)

  this.msg = ''; // error message

  this.ended = false; // used to avoid multiple onEnd() calls

  this.chunks = []; // chunks of compressed data

  this.strm = new ZStream();
  this.strm.avail_out = 0;
  var status = zlib_inflate.inflateInit2(this.strm, opt.windowBits);

  if (status !== c.Z_OK) {
    throw new Error(msg[status]);
  }

  this.header = new GZheader();
  zlib_inflate.inflateGetHeader(this.strm, this.header);
}
/**
 * Inflate#push(data[, mode]) -> Boolean
 * - data (Uint8Array|Array|ArrayBuffer|String): input data
 * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
 *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.
 *
 * Sends input data to inflate pipe, generating [[Inflate#onData]] calls with
 * new output chunks. Returns `true` on success. The last data block must have
 * mode Z_FINISH (or `true`). That will flush internal pending buffers and call
 * [[Inflate#onEnd]]. For interim explicit flushes (without ending the stream) you
 * can use mode Z_SYNC_FLUSH, keeping the decompression context.
 *
 * On fail call [[Inflate#onEnd]] with error code and return false.
 *
 * We strongly recommend to use `Uint8Array` on input for best speed (output
 * format is detected automatically). Also, don't skip last param and always
 * use the same type in your code (boolean or number). That will improve JS speed.
 *
 * For regular `Array`-s make sure all elements are [0..255].
 *
 * ##### Example
 *
 * ```javascript
 * push(chunk, false); // push one of data chunks
 * ...
 * push(chunk, true);  // push last chunk
 * ```
 **/


Inflate.prototype.push = function (data, mode) {
  var strm = this.strm;
  var chunkSize = this.options.chunkSize;
  var dictionary = this.options.dictionary;

  var status, _mode;

  var next_out_utf8, tail, utf8str;
  var dict; // Flag to properly process Z_BUF_ERROR on testing inflate call
  // when we check that all output data was flushed.

  var allowBufError = false;

  if (this.ended) {
    return false;
  }

  _mode = mode === ~~mode ? mode : mode === true ? c.Z_FINISH : c.Z_NO_FLUSH; // Convert data if needed

  if (typeof data === 'string') {
    // Only binary strings can be decompressed on practice
    strm.input = strings.binstring2buf(data);
  } else if (toString.call(data) === '[object ArrayBuffer]') {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }

  strm.next_in = 0;
  strm.avail_in = strm.input.length;

  do {
    if (strm.avail_out === 0) {
      strm.output = new utils.Buf8(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }

    status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH);
    /* no bad return value */

    if (status === c.Z_NEED_DICT && dictionary) {
      // Convert data if needed
      if (typeof dictionary === 'string') {
        dict = strings.string2buf(dictionary);
      } else if (toString.call(dictionary) === '[object ArrayBuffer]') {
        dict = new Uint8Array(dictionary);
      } else {
        dict = dictionary;
      }

      status = zlib_inflate.inflateSetDictionary(this.strm, dict);
    }

    if (status === c.Z_BUF_ERROR && allowBufError === true) {
      status = c.Z_OK;
      allowBufError = false;
    }

    if (status !== c.Z_STREAM_END && status !== c.Z_OK) {
      this.onEnd(status);
      this.ended = true;
      return false;
    }

    if (strm.next_out) {
      if (strm.avail_out === 0 || status === c.Z_STREAM_END || strm.avail_in === 0 && (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH)) {
        if (this.options.to === 'string') {
          next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
          tail = strm.next_out - next_out_utf8;
          utf8str = strings.buf2string(strm.output, next_out_utf8); // move tail

          strm.next_out = tail;
          strm.avail_out = chunkSize - tail;

          if (tail) {
            utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0);
          }

          this.onData(utf8str);
        } else {
          this.onData(utils.shrinkBuf(strm.output, strm.next_out));
        }
      }
    } // When no more input data, we should check that internal inflate buffers
    // are flushed. The only way to do it when avail_out = 0 - run one more
    // inflate pass. But if output data not exists, inflate return Z_BUF_ERROR.
    // Here we set flag to process this error properly.
    //
    // NOTE. Deflate does not return error in this case and does not needs such
    // logic.


    if (strm.avail_in === 0 && strm.avail_out === 0) {
      allowBufError = true;
    }
  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c.Z_STREAM_END);

  if (status === c.Z_STREAM_END) {
    _mode = c.Z_FINISH;
  } // Finalize on the last chunk.


  if (_mode === c.Z_FINISH) {
    status = zlib_inflate.inflateEnd(this.strm);
    this.onEnd(status);
    this.ended = true;
    return status === c.Z_OK;
  } // callback interim results if Z_SYNC_FLUSH.


  if (_mode === c.Z_SYNC_FLUSH) {
    this.onEnd(c.Z_OK);
    strm.avail_out = 0;
    return true;
  }

  return true;
};
/**
 * Inflate#onData(chunk) -> Void
 * - chunk (Uint8Array|Array|String): output data. Type of array depends
 *   on js engine support. When string output requested, each chunk
 *   will be string.
 *
 * By default, stores data blocks in `chunks[]` property and glue
 * those in `onEnd`. Override this handler, if you need another behaviour.
 **/


Inflate.prototype.onData = function (chunk) {
  this.chunks.push(chunk);
};
/**
 * Inflate#onEnd(status) -> Void
 * - status (Number): inflate status. 0 (Z_OK) on success,
 *   other if not.
 *
 * Called either after you tell inflate that the input stream is
 * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)
 * or if an error happened. By default - join collected chunks,
 * free memory and fill `results` / `err` properties.
 **/


Inflate.prototype.onEnd = function (status) {
  // On success - join
  if (status === c.Z_OK) {
    if (this.options.to === 'string') {
      // Glue & convert here, until we teach pako to send
      // utf8 aligned strings to onData
      this.result = this.chunks.join('');
    } else {
      this.result = utils.flattenChunks(this.chunks);
    }
  }

  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};
/**
 * inflate(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * Decompress `data` with inflate/ungzip and `options`. Autodetect
 * format via wrapper header by default. That's why we don't provide
 * separate `ungzip` method.
 *
 * Supported options are:
 *
 * - windowBits
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information.
 *
 * Sugar (options):
 *
 * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
 *   negative windowBits implicitly.
 * - `to` (String) - if equal to 'string', then result will be converted
 *   from utf8 to utf16 (javascript) string. When string output requested,
 *   chunk length can differ from `chunkSize`, depending on content.
 *
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , input = pako.deflate([1,2,3,4,5,6,7,8,9])
 *   , output;
 *
 * try {
 *   output = pako.inflate(input);
 * } catch (err)
 *   console.log(err);
 * }
 * ```
 **/


function inflate(input, options) {
  var inflator = new Inflate(options);
  inflator.push(input, true); // That will never happens, if you don't cheat with options :)

  if (inflator.err) {
    throw inflator.msg || msg[inflator.err];
  }

  return inflator.result;
}
/**
 * inflateRaw(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * The same as [[inflate]], but creates raw data, without wrapper
 * (header and adler32 crc).
 **/


function inflateRaw(input, options) {
  options = options || {};
  options.raw = true;
  return inflate(input, options);
}
/**
 * ungzip(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * Just shortcut to [[inflate]], because it autodetects format
 * by header.content. Done for convenience.
 **/


exports.Inflate = Inflate;
exports.inflate = inflate;
exports.inflateRaw = inflateRaw;
exports.ungzip = inflate;

/***/ }),

/***/ "./node_modules/pako/lib/utils/common.js":
/*!***********************************************!*\
  !*** ./node_modules/pako/lib/utils/common.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var TYPED_OK = typeof Uint8Array !== 'undefined' && typeof Uint16Array !== 'undefined' && typeof Int32Array !== 'undefined';

function _has(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}

exports.assign = function (obj
/*from1, from2, from3, ...*/
) {
  var sources = Array.prototype.slice.call(arguments, 1);

  while (sources.length) {
    var source = sources.shift();

    if (!source) {
      continue;
    }

    if (_typeof(source) !== 'object') {
      throw new TypeError(source + 'must be non-object');
    }

    for (var p in source) {
      if (_has(source, p)) {
        obj[p] = source[p];
      }
    }
  }

  return obj;
}; // reduce buffer size, avoiding mem copy


exports.shrinkBuf = function (buf, size) {
  if (buf.length === size) {
    return buf;
  }

  if (buf.subarray) {
    return buf.subarray(0, size);
  }

  buf.length = size;
  return buf;
};

var fnTyped = {
  arraySet: function arraySet(dest, src, src_offs, len, dest_offs) {
    if (src.subarray && dest.subarray) {
      dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
      return;
    } // Fallback to ordinary array


    for (var i = 0; i < len; i++) {
      dest[dest_offs + i] = src[src_offs + i];
    }
  },
  // Join array of chunks to single array.
  flattenChunks: function flattenChunks(chunks) {
    var i, l, len, pos, chunk, result; // calculate data length

    len = 0;

    for (i = 0, l = chunks.length; i < l; i++) {
      len += chunks[i].length;
    } // join chunks


    result = new Uint8Array(len);
    pos = 0;

    for (i = 0, l = chunks.length; i < l; i++) {
      chunk = chunks[i];
      result.set(chunk, pos);
      pos += chunk.length;
    }

    return result;
  }
};
var fnUntyped = {
  arraySet: function arraySet(dest, src, src_offs, len, dest_offs) {
    for (var i = 0; i < len; i++) {
      dest[dest_offs + i] = src[src_offs + i];
    }
  },
  // Join array of chunks to single array.
  flattenChunks: function flattenChunks(chunks) {
    return [].concat.apply([], chunks);
  }
}; // Enable/Disable typed arrays use, for testing
//

exports.setTyped = function (on) {
  if (on) {
    exports.Buf8 = Uint8Array;
    exports.Buf16 = Uint16Array;
    exports.Buf32 = Int32Array;
    exports.assign(exports, fnTyped);
  } else {
    exports.Buf8 = Array;
    exports.Buf16 = Array;
    exports.Buf32 = Array;
    exports.assign(exports, fnUntyped);
  }
};

exports.setTyped(TYPED_OK);

/***/ }),

/***/ "./node_modules/pako/lib/utils/strings.js":
/*!************************************************!*\
  !*** ./node_modules/pako/lib/utils/strings.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// String encode/decode helpers


var utils = __webpack_require__(/*! ./common */ "./node_modules/pako/lib/utils/common.js"); // Quick check if we can use fast array to bin string conversion
//
// - apply(Array) can fail on Android 2.2
// - apply(Uint8Array) can fail on iOS 5.1 Safari
//


var STR_APPLY_OK = true;
var STR_APPLY_UIA_OK = true;

try {
  String.fromCharCode.apply(null, [0]);
} catch (__) {
  STR_APPLY_OK = false;
}

try {
  String.fromCharCode.apply(null, new Uint8Array(1));
} catch (__) {
  STR_APPLY_UIA_OK = false;
} // Table with utf8 lengths (calculated by first byte of sequence)
// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,
// because max possible codepoint is 0x10ffff


var _utf8len = new utils.Buf8(256);

for (var q = 0; q < 256; q++) {
  _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
}

_utf8len[254] = _utf8len[254] = 1; // Invalid sequence start
// convert string to array (typed, when possible)

exports.string2buf = function (str) {
  var buf,
      c,
      c2,
      m_pos,
      i,
      str_len = str.length,
      buf_len = 0; // count binary size

  for (m_pos = 0; m_pos < str_len; m_pos++) {
    c = str.charCodeAt(m_pos);

    if ((c & 0xfc00) === 0xd800 && m_pos + 1 < str_len) {
      c2 = str.charCodeAt(m_pos + 1);

      if ((c2 & 0xfc00) === 0xdc00) {
        c = 0x10000 + (c - 0xd800 << 10) + (c2 - 0xdc00);
        m_pos++;
      }
    }

    buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;
  } // allocate buffer


  buf = new utils.Buf8(buf_len); // convert

  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
    c = str.charCodeAt(m_pos);

    if ((c & 0xfc00) === 0xd800 && m_pos + 1 < str_len) {
      c2 = str.charCodeAt(m_pos + 1);

      if ((c2 & 0xfc00) === 0xdc00) {
        c = 0x10000 + (c - 0xd800 << 10) + (c2 - 0xdc00);
        m_pos++;
      }
    }

    if (c < 0x80) {
      /* one byte */
      buf[i++] = c;
    } else if (c < 0x800) {
      /* two bytes */
      buf[i++] = 0xC0 | c >>> 6;
      buf[i++] = 0x80 | c & 0x3f;
    } else if (c < 0x10000) {
      /* three bytes */
      buf[i++] = 0xE0 | c >>> 12;
      buf[i++] = 0x80 | c >>> 6 & 0x3f;
      buf[i++] = 0x80 | c & 0x3f;
    } else {
      /* four bytes */
      buf[i++] = 0xf0 | c >>> 18;
      buf[i++] = 0x80 | c >>> 12 & 0x3f;
      buf[i++] = 0x80 | c >>> 6 & 0x3f;
      buf[i++] = 0x80 | c & 0x3f;
    }
  }

  return buf;
}; // Helper (used in 2 places)


function buf2binstring(buf, len) {
  // use fallback for big arrays to avoid stack overflow
  if (len < 65537) {
    if (buf.subarray && STR_APPLY_UIA_OK || !buf.subarray && STR_APPLY_OK) {
      return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));
    }
  }

  var result = '';

  for (var i = 0; i < len; i++) {
    result += String.fromCharCode(buf[i]);
  }

  return result;
} // Convert byte array to binary string


exports.buf2binstring = function (buf) {
  return buf2binstring(buf, buf.length);
}; // Convert binary string (typed, when possible)


exports.binstring2buf = function (str) {
  var buf = new utils.Buf8(str.length);

  for (var i = 0, len = buf.length; i < len; i++) {
    buf[i] = str.charCodeAt(i);
  }

  return buf;
}; // convert array to string


exports.buf2string = function (buf, max) {
  var i, out, c, c_len;
  var len = max || buf.length; // Reserve max possible length (2 words per char)
  // NB: by unknown reasons, Array is significantly faster for
  //     String.fromCharCode.apply than Uint16Array.

  var utf16buf = new Array(len * 2);

  for (out = 0, i = 0; i < len;) {
    c = buf[i++]; // quick process ascii

    if (c < 0x80) {
      utf16buf[out++] = c;
      continue;
    }

    c_len = _utf8len[c]; // skip 5 & 6 byte codes

    if (c_len > 4) {
      utf16buf[out++] = 0xfffd;
      i += c_len - 1;
      continue;
    } // apply mask on first byte


    c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07; // join the rest

    while (c_len > 1 && i < len) {
      c = c << 6 | buf[i++] & 0x3f;
      c_len--;
    } // terminated by end of string?


    if (c_len > 1) {
      utf16buf[out++] = 0xfffd;
      continue;
    }

    if (c < 0x10000) {
      utf16buf[out++] = c;
    } else {
      c -= 0x10000;
      utf16buf[out++] = 0xd800 | c >> 10 & 0x3ff;
      utf16buf[out++] = 0xdc00 | c & 0x3ff;
    }
  }

  return buf2binstring(utf16buf, out);
}; // Calculate max possible position in utf8 buffer,
// that will not break sequence. If that's not possible
// - (very small limits) return max size as is.
//
// buf[] - utf8 bytes array
// max   - length limit (mandatory);


exports.utf8border = function (buf, max) {
  var pos;
  max = max || buf.length;

  if (max > buf.length) {
    max = buf.length;
  } // go back from last position, until start of sequence found


  pos = max - 1;

  while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) {
    pos--;
  } // Very small and broken sequence,
  // return max, because we should return something anyway.


  if (pos < 0) {
    return max;
  } // If we came to start of buffer - that means buffer is too small,
  // return max too.


  if (pos === 0) {
    return max;
  }

  return pos + _utf8len[buf[pos]] > max ? pos : max;
};

/***/ }),

/***/ "./node_modules/pako/lib/zlib/adler32.js":
/*!***********************************************!*\
  !*** ./node_modules/pako/lib/zlib/adler32.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // Note: adler32 takes 12% for level 0 and 2% for level 6.
// It isn't worth it to make additional optimizations as in original.
// Small size is preferable.
// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function adler32(adler, buf, len, pos) {
  var s1 = adler & 0xffff | 0,
      s2 = adler >>> 16 & 0xffff | 0,
      n = 0;

  while (len !== 0) {
    // Set limit ~ twice less than 5552, to keep
    // s2 in 31-bits, because we force signed ints.
    // in other case %= will fail.
    n = len > 2000 ? 2000 : len;
    len -= n;

    do {
      s1 = s1 + buf[pos++] | 0;
      s2 = s2 + s1 | 0;
    } while (--n);

    s1 %= 65521;
    s2 %= 65521;
  }

  return s1 | s2 << 16 | 0;
}

module.exports = adler32;

/***/ }),

/***/ "./node_modules/pako/lib/zlib/constants.js":
/*!*************************************************!*\
  !*** ./node_modules/pako/lib/zlib/constants.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

module.exports = {
  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH: 0,
  Z_PARTIAL_FLUSH: 1,
  Z_SYNC_FLUSH: 2,
  Z_FULL_FLUSH: 3,
  Z_FINISH: 4,
  Z_BLOCK: 5,
  Z_TREES: 6,

  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK: 0,
  Z_STREAM_END: 1,
  Z_NEED_DICT: 2,
  Z_ERRNO: -1,
  Z_STREAM_ERROR: -2,
  Z_DATA_ERROR: -3,
  //Z_MEM_ERROR:     -4,
  Z_BUF_ERROR: -5,
  //Z_VERSION_ERROR: -6,

  /* compression levels */
  Z_NO_COMPRESSION: 0,
  Z_BEST_SPEED: 1,
  Z_BEST_COMPRESSION: 9,
  Z_DEFAULT_COMPRESSION: -1,
  Z_FILTERED: 1,
  Z_HUFFMAN_ONLY: 2,
  Z_RLE: 3,
  Z_FIXED: 4,
  Z_DEFAULT_STRATEGY: 0,

  /* Possible values of the data_type field (though see inflate()) */
  Z_BINARY: 0,
  Z_TEXT: 1,
  //Z_ASCII:                1, // = Z_TEXT (deprecated)
  Z_UNKNOWN: 2,

  /* The deflate compression method */
  Z_DEFLATED: 8 //Z_NULL:                 null // Use -1 or null inline, depending on var type

};

/***/ }),

/***/ "./node_modules/pako/lib/zlib/crc32.js":
/*!*********************************************!*\
  !*** ./node_modules/pako/lib/zlib/crc32.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // Note: we can't get significant speed boost here.
// So write code to minimize size - no pregenerated tables
// and array tools dependencies.
// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.
// Use ordinary array, since untyped makes no boost here

function makeTable() {
  var c,
      table = [];

  for (var n = 0; n < 256; n++) {
    c = n;

    for (var k = 0; k < 8; k++) {
      c = c & 1 ? 0xEDB88320 ^ c >>> 1 : c >>> 1;
    }

    table[n] = c;
  }

  return table;
} // Create table on load. Just 255 signed longs. Not a problem.


var crcTable = makeTable();

function crc32(crc, buf, len, pos) {
  var t = crcTable,
      end = pos + len;
  crc ^= -1;

  for (var i = pos; i < end; i++) {
    crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 0xFF];
  }

  return crc ^ -1; // >>> 0;
}

module.exports = crc32;

/***/ }),

/***/ "./node_modules/pako/lib/zlib/deflate.js":
/*!***********************************************!*\
  !*** ./node_modules/pako/lib/zlib/deflate.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var utils = __webpack_require__(/*! ../utils/common */ "./node_modules/pako/lib/utils/common.js");

var trees = __webpack_require__(/*! ./trees */ "./node_modules/pako/lib/zlib/trees.js");

var adler32 = __webpack_require__(/*! ./adler32 */ "./node_modules/pako/lib/zlib/adler32.js");

var crc32 = __webpack_require__(/*! ./crc32 */ "./node_modules/pako/lib/zlib/crc32.js");

var msg = __webpack_require__(/*! ./messages */ "./node_modules/pako/lib/zlib/messages.js");
/* Public constants ==========================================================*/

/* ===========================================================================*/

/* Allowed flush values; see deflate() and inflate() below for details */


var Z_NO_FLUSH = 0;
var Z_PARTIAL_FLUSH = 1; //var Z_SYNC_FLUSH    = 2;

var Z_FULL_FLUSH = 3;
var Z_FINISH = 4;
var Z_BLOCK = 5; //var Z_TREES         = 6;

/* Return codes for the compression/decompression functions. Negative values
 * are errors, positive values are used for special but normal events.
 */

var Z_OK = 0;
var Z_STREAM_END = 1; //var Z_NEED_DICT     = 2;
//var Z_ERRNO         = -1;

var Z_STREAM_ERROR = -2;
var Z_DATA_ERROR = -3; //var Z_MEM_ERROR     = -4;

var Z_BUF_ERROR = -5; //var Z_VERSION_ERROR = -6;

/* compression levels */
//var Z_NO_COMPRESSION      = 0;
//var Z_BEST_SPEED          = 1;
//var Z_BEST_COMPRESSION    = 9;

var Z_DEFAULT_COMPRESSION = -1;
var Z_FILTERED = 1;
var Z_HUFFMAN_ONLY = 2;
var Z_RLE = 3;
var Z_FIXED = 4;
var Z_DEFAULT_STRATEGY = 0;
/* Possible values of the data_type field (though see inflate()) */
//var Z_BINARY              = 0;
//var Z_TEXT                = 1;
//var Z_ASCII               = 1; // = Z_TEXT

var Z_UNKNOWN = 2;
/* The deflate compression method */

var Z_DEFLATED = 8;
/*============================================================================*/

var MAX_MEM_LEVEL = 9;
/* Maximum value for memLevel in deflateInit2 */

var MAX_WBITS = 15;
/* 32K LZ77 window */

var DEF_MEM_LEVEL = 8;
var LENGTH_CODES = 29;
/* number of length codes, not counting the special END_BLOCK code */

var LITERALS = 256;
/* number of literal bytes 0..255 */

var L_CODES = LITERALS + 1 + LENGTH_CODES;
/* number of Literal or Length codes, including the END_BLOCK code */

var D_CODES = 30;
/* number of distance codes */

var BL_CODES = 19;
/* number of codes used to transfer the bit lengths */

var HEAP_SIZE = 2 * L_CODES + 1;
/* maximum heap size */

var MAX_BITS = 15;
/* All codes must not exceed MAX_BITS bits */

var MIN_MATCH = 3;
var MAX_MATCH = 258;
var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
var PRESET_DICT = 0x20;
var INIT_STATE = 42;
var EXTRA_STATE = 69;
var NAME_STATE = 73;
var COMMENT_STATE = 91;
var HCRC_STATE = 103;
var BUSY_STATE = 113;
var FINISH_STATE = 666;
var BS_NEED_MORE = 1;
/* block not completed, need more input or more output */

var BS_BLOCK_DONE = 2;
/* block flush performed */

var BS_FINISH_STARTED = 3;
/* finish started, need only more output at next deflate */

var BS_FINISH_DONE = 4;
/* finish done, accept no more input or output */

var OS_CODE = 0x03; // Unix :) . Don't detect, use this default.

function err(strm, errorCode) {
  strm.msg = msg[errorCode];
  return errorCode;
}

function rank(f) {
  return (f << 1) - (f > 4 ? 9 : 0);
}

function zero(buf) {
  var len = buf.length;

  while (--len >= 0) {
    buf[len] = 0;
  }
}
/* =========================================================================
 * Flush as much pending output as possible. All deflate() output goes
 * through this function so some applications may wish to modify it
 * to avoid allocating a large strm->output buffer and copying into it.
 * (See also read_buf()).
 */


function flush_pending(strm) {
  var s = strm.state; //_tr_flush_bits(s);

  var len = s.pending;

  if (len > strm.avail_out) {
    len = strm.avail_out;
  }

  if (len === 0) {
    return;
  }

  utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
  strm.next_out += len;
  s.pending_out += len;
  strm.total_out += len;
  strm.avail_out -= len;
  s.pending -= len;

  if (s.pending === 0) {
    s.pending_out = 0;
  }
}

function flush_block_only(s, last) {
  trees._tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);

  s.block_start = s.strstart;
  flush_pending(s.strm);
}

function put_byte(s, b) {
  s.pending_buf[s.pending++] = b;
}
/* =========================================================================
 * Put a short in the pending buffer. The 16-bit value is put in MSB order.
 * IN assertion: the stream state is correct and there is enough room in
 * pending_buf.
 */


function putShortMSB(s, b) {
  //  put_byte(s, (Byte)(b >> 8));
  //  put_byte(s, (Byte)(b & 0xff));
  s.pending_buf[s.pending++] = b >>> 8 & 0xff;
  s.pending_buf[s.pending++] = b & 0xff;
}
/* ===========================================================================
 * Read a new buffer from the current input stream, update the adler32
 * and total number of bytes read.  All deflate() input goes through
 * this function so some applications may wish to modify it to avoid
 * allocating a large strm->input buffer and copying from it.
 * (See also flush_pending()).
 */


function read_buf(strm, buf, start, size) {
  var len = strm.avail_in;

  if (len > size) {
    len = size;
  }

  if (len === 0) {
    return 0;
  }

  strm.avail_in -= len; // zmemcpy(buf, strm->next_in, len);

  utils.arraySet(buf, strm.input, strm.next_in, len, start);

  if (strm.state.wrap === 1) {
    strm.adler = adler32(strm.adler, buf, len, start);
  } else if (strm.state.wrap === 2) {
    strm.adler = crc32(strm.adler, buf, len, start);
  }

  strm.next_in += len;
  strm.total_in += len;
  return len;
}
/* ===========================================================================
 * Set match_start to the longest match starting at the given string and
 * return its length. Matches shorter or equal to prev_length are discarded,
 * in which case the result is equal to prev_length and match_start is
 * garbage.
 * IN assertions: cur_match is the head of the hash chain for the current
 *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
 * OUT assertion: the match length is not greater than s->lookahead.
 */


function longest_match(s, cur_match) {
  var chain_length = s.max_chain_length;
  /* max hash chain length */

  var scan = s.strstart;
  /* current string */

  var match;
  /* matched string */

  var len;
  /* length of current match */

  var best_len = s.prev_length;
  /* best match length so far */

  var nice_match = s.nice_match;
  /* stop if match long enough */

  var limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0
  /*NIL*/
  ;
  var _win = s.window; // shortcut

  var wmask = s.w_mask;
  var prev = s.prev;
  /* Stop when cur_match becomes <= limit. To simplify the code,
   * we prevent matches with the string of window index 0.
   */

  var strend = s.strstart + MAX_MATCH;
  var scan_end1 = _win[scan + best_len - 1];
  var scan_end = _win[scan + best_len];
  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
   * It is easy to get rid of this optimization if necessary.
   */
  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");

  /* Do not waste too much time if we already have a good match: */

  if (s.prev_length >= s.good_match) {
    chain_length >>= 2;
  }
  /* Do not look for matches beyond the end of the input. This is necessary
   * to make deflate deterministic.
   */


  if (nice_match > s.lookahead) {
    nice_match = s.lookahead;
  } // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");


  do {
    // Assert(cur_match < s->strstart, "no future");
    match = cur_match;
    /* Skip to next match if the match length cannot increase
     * or if the match length is less than 2.  Note that the checks below
     * for insufficient lookahead only occur occasionally for performance
     * reasons.  Therefore uninitialized memory will be accessed, and
     * conditional jumps will be made that depend on those values.
     * However the length of the match is limited to the lookahead, so
     * the output of deflate is not affected by the uninitialized values.
     */

    if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
      continue;
    }
    /* The check at best_len-1 can be removed because it will be made
     * again later. (This heuristic is not always a win.)
     * It is not necessary to compare scan[2] and match[2] since they
     * are always equal when the other bytes match, given that
     * the hash keys are equal and that HASH_BITS >= 8.
     */


    scan += 2;
    match++; // Assert(*scan == *match, "match[2]?");

    /* We check for insufficient lookahead only every 8th comparison;
     * the 256th check will be made at strstart+258.
     */

    do {
      /*jshint noempty:false*/
    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend); // Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");


    len = MAX_MATCH - (strend - scan);
    scan = strend - MAX_MATCH;

    if (len > best_len) {
      s.match_start = cur_match;
      best_len = len;

      if (len >= nice_match) {
        break;
      }

      scan_end1 = _win[scan + best_len - 1];
      scan_end = _win[scan + best_len];
    }
  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);

  if (best_len <= s.lookahead) {
    return best_len;
  }

  return s.lookahead;
}
/* ===========================================================================
 * Fill the window when the lookahead becomes insufficient.
 * Updates strstart and lookahead.
 *
 * IN assertion: lookahead < MIN_LOOKAHEAD
 * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
 *    At least one byte has been read, or avail_in == 0; reads are
 *    performed for at least two bytes (required for the zip translate_eol
 *    option -- not supported here).
 */


function fill_window(s) {
  var _w_size = s.w_size;
  var p, n, m, more, str; //Assert(s->lookahead < MIN_LOOKAHEAD, "already enough lookahead");

  do {
    more = s.window_size - s.lookahead - s.strstart; // JS ints have 32 bit, block below not needed

    /* Deal with !@#$% 64K limit: */
    //if (sizeof(int) <= 2) {
    //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
    //        more = wsize;
    //
    //  } else if (more == (unsigned)(-1)) {
    //        /* Very unlikely, but possible on 16 bit machine if
    //         * strstart == 0 && lookahead == 1 (input done a byte at time)
    //         */
    //        more--;
    //    }
    //}

    /* If the window is almost full and there is insufficient lookahead,
     * move the upper half to the lower one to make room in the upper half.
     */

    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
      utils.arraySet(s.window, s.window, _w_size, _w_size, 0);
      s.match_start -= _w_size;
      s.strstart -= _w_size;
      /* we now have strstart >= MAX_DIST */

      s.block_start -= _w_size;
      /* Slide the hash table (could be avoided with 32 bit values
       at the expense of memory usage). We slide even when level == 0
       to keep the hash table consistent if we switch back to level > 0
       later. (Using level 0 permanently is not an optimal usage of
       zlib, so we don't care about this pathological case.)
       */

      n = s.hash_size;
      p = n;

      do {
        m = s.head[--p];
        s.head[p] = m >= _w_size ? m - _w_size : 0;
      } while (--n);

      n = _w_size;
      p = n;

      do {
        m = s.prev[--p];
        s.prev[p] = m >= _w_size ? m - _w_size : 0;
        /* If n is not on any hash chain, prev[n] is garbage but
         * its value will never be used.
         */
      } while (--n);

      more += _w_size;
    }

    if (s.strm.avail_in === 0) {
      break;
    }
    /* If there was no sliding:
     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
     *    more == window_size - lookahead - strstart
     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
     * => more >= window_size - 2*WSIZE + 2
     * In the BIG_MEM or MMAP case (not yet supported),
     *   window_size == input_size + MIN_LOOKAHEAD  &&
     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
     * Otherwise, window_size == 2*WSIZE so more >= 2.
     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
     */
    //Assert(more >= 2, "more < 2");


    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
    s.lookahead += n;
    /* Initialize the hash value now that we have some input: */

    if (s.lookahead + s.insert >= MIN_MATCH) {
      str = s.strstart - s.insert;
      s.ins_h = s.window[str];
      /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */

      s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + 1]) & s.hash_mask; //#if MIN_MATCH != 3
      //        Call update_hash() MIN_MATCH-3 more times
      //#endif

      while (s.insert) {
        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
        s.insert--;

        if (s.lookahead + s.insert < MIN_MATCH) {
          break;
        }
      }
    }
    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
     * but this is not important since only literal bytes will be emitted.
     */

  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
  /* If the WIN_INIT bytes after the end of the current data have never been
   * written, then zero those bytes in order to avoid memory check reports of
   * the use of uninitialized (or uninitialised as Julian writes) bytes by
   * the longest match routines.  Update the high water mark for the next
   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match
   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
   */
  //  if (s.high_water < s.window_size) {
  //    var curr = s.strstart + s.lookahead;
  //    var init = 0;
  //
  //    if (s.high_water < curr) {
  //      /* Previous high water mark below current data -- zero WIN_INIT
  //       * bytes or up to end of window, whichever is less.
  //       */
  //      init = s.window_size - curr;
  //      if (init > WIN_INIT)
  //        init = WIN_INIT;
  //      zmemzero(s->window + curr, (unsigned)init);
  //      s->high_water = curr + init;
  //    }
  //    else if (s->high_water < (ulg)curr + WIN_INIT) {
  //      /* High water mark at or above current data, but below current data
  //       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up
  //       * to end of window, whichever is less.
  //       */
  //      init = (ulg)curr + WIN_INIT - s->high_water;
  //      if (init > s->window_size - s->high_water)
  //        init = s->window_size - s->high_water;
  //      zmemzero(s->window + s->high_water, (unsigned)init);
  //      s->high_water += init;
  //    }
  //  }
  //
  //  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,
  //    "not enough room for search");

}
/* ===========================================================================
 * Copy without compression as much as possible from the input stream, return
 * the current block state.
 * This function does not insert new strings in the dictionary since
 * uncompressible data is probably not useful. This function is used
 * only for the level=0 compression option.
 * NOTE: this function should be optimized to avoid extra copying from
 * window to pending_buf.
 */


function deflate_stored(s, flush) {
  /* Stored blocks are limited to 0xffff bytes, pending_buf is limited
   * to pending_buf_size, and each stored block has a 5 byte header:
   */
  var max_block_size = 0xffff;

  if (max_block_size > s.pending_buf_size - 5) {
    max_block_size = s.pending_buf_size - 5;
  }
  /* Copy as much as possible from input to output: */


  for (;;) {
    /* Fill the window as much as possible: */
    if (s.lookahead <= 1) {
      //Assert(s->strstart < s->w_size+MAX_DIST(s) ||
      //  s->block_start >= (long)s->w_size, "slide too late");
      //      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||
      //        s.block_start >= s.w_size)) {
      //        throw  new Error("slide too late");
      //      }
      fill_window(s);

      if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }

      if (s.lookahead === 0) {
        break;
      }
      /* flush the current block */

    } //Assert(s->block_start >= 0L, "block gone");
    //    if (s.block_start < 0) throw new Error("block gone");


    s.strstart += s.lookahead;
    s.lookahead = 0;
    /* Emit a stored block if pending_buf will be full: */

    var max_start = s.block_start + max_block_size;

    if (s.strstart === 0 || s.strstart >= max_start) {
      /* strstart == 0 is possible when wraparound on 16-bit machine */
      s.lookahead = s.strstart - max_start;
      s.strstart = max_start;
      /*** FLUSH_BLOCK(s, 0); ***/

      flush_block_only(s, false);

      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/

    }
    /* Flush if we may have to slide, otherwise block_start may become
     * negative and the data will be gone:
     */


    if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);

      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/

    }
  }

  s.insert = 0;

  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);

    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/


    return BS_FINISH_DONE;
  }

  if (s.strstart > s.block_start) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);

    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/

  }

  return BS_NEED_MORE;
}
/* ===========================================================================
 * Compress as much as possible from the input stream, return the current
 * block state.
 * This function does not perform lazy evaluation of matches and inserts
 * new strings in the dictionary only for unmatched strings or for short
 * matches. It is used only for the fast compression options.
 */


function deflate_fast(s, flush) {
  var hash_head;
  /* head of the hash chain */

  var bflush;
  /* set if current block must be flushed */

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);

      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }

      if (s.lookahead === 0) {
        break;
        /* flush the current block */
      }
    }
    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */


    hash_head = 0
    /*NIL*/
    ;

    if (s.lookahead >= MIN_MATCH) {
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
      s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      /***/
    }
    /* Find the longest match, discarding those <= prev_length.
     * At this point we have always match_length < MIN_MATCH
     */


    if (hash_head !== 0
    /*NIL*/
    && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
      /* To simplify the code, we prevent matches with the string
       * of window index 0 (in particular we have to avoid a match
       * of the string with itself at the start of the input file).
       */
      s.match_length = longest_match(s, hash_head);
      /* longest_match() sets match_start */
    }

    if (s.match_length >= MIN_MATCH) {
      // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only

      /*** _tr_tally_dist(s, s.strstart - s.match_start,
                     s.match_length - MIN_MATCH, bflush); ***/
      bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
      s.lookahead -= s.match_length;
      /* Insert new strings in the hash table only if the match length
       * is not too large. This saves time but degrades compression.
       */

      if (s.match_length <= s.max_lazy_match
      /*max_insert_length*/
      && s.lookahead >= MIN_MATCH) {
        s.match_length--;
        /* string at strstart already in table */

        do {
          s.strstart++;
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/

          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/

          /* strstart never exceeds WSIZE-MAX_MATCH, so there are
           * always MIN_MATCH bytes ahead.
           */
        } while (--s.match_length !== 0);

        s.strstart++;
      } else {
        s.strstart += s.match_length;
        s.match_length = 0;
        s.ins_h = s.window[s.strstart];
        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */

        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + 1]) & s.hash_mask; //#if MIN_MATCH != 3
        //                Call UPDATE_HASH() MIN_MATCH-3 more times
        //#endif

        /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
         * matter since it will be recomputed at next deflate call.
         */
      }
    } else {
      /* No match, output a literal byte */
      //Tracevv((stderr,"%c", s.window[s.strstart]));

      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
    }

    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);

      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/

    }
  }

  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;

  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);

    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/


    return BS_FINISH_DONE;
  }

  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);

    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/

  }

  return BS_BLOCK_DONE;
}
/* ===========================================================================
 * Same as above, but achieves better compression. We use a lazy
 * evaluation for matches: a match is finally adopted only if there is
 * no better match at the next window position.
 */


function deflate_slow(s, flush) {
  var hash_head;
  /* head of hash chain */

  var bflush;
  /* set if current block must be flushed */

  var max_insert;
  /* Process the input block. */

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);

      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }

      if (s.lookahead === 0) {
        break;
      }
      /* flush the current block */

    }
    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */


    hash_head = 0
    /*NIL*/
    ;

    if (s.lookahead >= MIN_MATCH) {
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
      s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      /***/
    }
    /* Find the longest match, discarding those <= prev_length.
     */


    s.prev_length = s.match_length;
    s.prev_match = s.match_start;
    s.match_length = MIN_MATCH - 1;

    if (hash_head !== 0
    /*NIL*/
    && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD
    /*MAX_DIST(s)*/
    ) {
        /* To simplify the code, we prevent matches with the string
         * of window index 0 (in particular we have to avoid a match
         * of the string with itself at the start of the input file).
         */
        s.match_length = longest_match(s, hash_head);
        /* longest_match() sets match_start */

        if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096
        /*TOO_FAR*/
        )) {
          /* If prev_match is also MIN_MATCH, match_start is garbage
           * but we will ignore the current match anyway.
           */
          s.match_length = MIN_MATCH - 1;
        }
      }
    /* If there was a match at the previous step and the current
     * match is not better, output the previous match:
     */


    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
      max_insert = s.strstart + s.lookahead - MIN_MATCH;
      /* Do not insert strings in hash table beyond this. */
      //check_match(s, s.strstart-1, s.prev_match, s.prev_length);

      /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,
                     s.prev_length - MIN_MATCH, bflush);***/

      bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
      /* Insert in hash table all strings up to the end of the match.
       * strstart-1 and strstart are already inserted. If there is not
       * enough lookahead, the last two strings are not inserted in
       * the hash table.
       */

      s.lookahead -= s.prev_length - 1;
      s.prev_length -= 2;

      do {
        if (++s.strstart <= max_insert) {
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/
        }
      } while (--s.prev_length !== 0);

      s.match_available = 0;
      s.match_length = MIN_MATCH - 1;
      s.strstart++;

      if (bflush) {
        /*** FLUSH_BLOCK(s, 0); ***/
        flush_block_only(s, false);

        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
        /***/

      }
    } else if (s.match_available) {
      /* If there was no match at the previous position, output a
       * single literal. If there was a match but the current match
       * is longer, truncate the previous match to a single literal.
       */
      //Tracevv((stderr,"%c", s->window[s->strstart-1]));

      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);

      if (bflush) {
        /*** FLUSH_BLOCK_ONLY(s, 0) ***/
        flush_block_only(s, false);
        /***/
      }

      s.strstart++;
      s.lookahead--;

      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    } else {
      /* There is no previous match to compare with, wait for
       * the next step to decide.
       */
      s.match_available = 1;
      s.strstart++;
      s.lookahead--;
    }
  } //Assert (flush != Z_NO_FLUSH, "no flush?");


  if (s.match_available) {
    //Tracevv((stderr,"%c", s->window[s->strstart-1]));

    /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
    bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
    s.match_available = 0;
  }

  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;

  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);

    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/


    return BS_FINISH_DONE;
  }

  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);

    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/

  }

  return BS_BLOCK_DONE;
}
/* ===========================================================================
 * For Z_RLE, simply look for runs of bytes, generate matches only of distance
 * one.  Do not maintain a hash table.  (It will be regenerated if this run of
 * deflate switches away from Z_RLE.)
 */


function deflate_rle(s, flush) {
  var bflush;
  /* set if current block must be flushed */

  var prev;
  /* byte at distance one to match */

  var scan, strend;
  /* scan goes up to strend for length of run */

  var _win = s.window;

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the longest run, plus one for the unrolled loop.
     */
    if (s.lookahead <= MAX_MATCH) {
      fill_window(s);

      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }

      if (s.lookahead === 0) {
        break;
      }
      /* flush the current block */

    }
    /* See how many times the previous byte repeats */


    s.match_length = 0;

    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
      scan = s.strstart - 1;
      prev = _win[scan];

      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
        strend = s.strstart + MAX_MATCH;

        do {
          /*jshint noempty:false*/
        } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);

        s.match_length = MAX_MATCH - (strend - scan);

        if (s.match_length > s.lookahead) {
          s.match_length = s.lookahead;
        }
      } //Assert(scan <= s->window+(uInt)(s->window_size-1), "wild scan");

    }
    /* Emit match if have run of MIN_MATCH or longer, else emit literal */


    if (s.match_length >= MIN_MATCH) {
      //check_match(s, s.strstart, s.strstart - 1, s.match_length);

      /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/
      bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);
      s.lookahead -= s.match_length;
      s.strstart += s.match_length;
      s.match_length = 0;
    } else {
      /* No match, output a literal byte */
      //Tracevv((stderr,"%c", s->window[s->strstart]));

      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
    }

    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);

      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/

    }
  }

  s.insert = 0;

  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);

    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/


    return BS_FINISH_DONE;
  }

  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);

    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/

  }

  return BS_BLOCK_DONE;
}
/* ===========================================================================
 * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.
 * (It will be regenerated if this run of deflate switches away from Huffman.)
 */


function deflate_huff(s, flush) {
  var bflush;
  /* set if current block must be flushed */

  for (;;) {
    /* Make sure that we have a literal to write. */
    if (s.lookahead === 0) {
      fill_window(s);

      if (s.lookahead === 0) {
        if (flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }

        break;
        /* flush the current block */
      }
    }
    /* Output a literal byte */


    s.match_length = 0; //Tracevv((stderr,"%c", s->window[s->strstart]));

    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/

    bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
    s.lookahead--;
    s.strstart++;

    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);

      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/

    }
  }

  s.insert = 0;

  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);

    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/


    return BS_FINISH_DONE;
  }

  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);

    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/

  }

  return BS_BLOCK_DONE;
}
/* Values for max_lazy_match, good_match and max_chain_length, depending on
 * the desired pack level (0..9). The values given below have been tuned to
 * exclude worst case performance for pathological files. Better values may be
 * found for specific files.
 */


function Config(good_length, max_lazy, nice_length, max_chain, func) {
  this.good_length = good_length;
  this.max_lazy = max_lazy;
  this.nice_length = nice_length;
  this.max_chain = max_chain;
  this.func = func;
}

var configuration_table;
configuration_table = [
/*      good lazy nice chain */
new Config(0, 0, 0, 0, deflate_stored),
/* 0 store only */
new Config(4, 4, 8, 4, deflate_fast),
/* 1 max speed, no lazy matches */
new Config(4, 5, 16, 8, deflate_fast),
/* 2 */
new Config(4, 6, 32, 32, deflate_fast),
/* 3 */
new Config(4, 4, 16, 16, deflate_slow),
/* 4 lazy matches */
new Config(8, 16, 32, 32, deflate_slow),
/* 5 */
new Config(8, 16, 128, 128, deflate_slow),
/* 6 */
new Config(8, 32, 128, 256, deflate_slow),
/* 7 */
new Config(32, 128, 258, 1024, deflate_slow),
/* 8 */
new Config(32, 258, 258, 4096, deflate_slow)
/* 9 max compression */
];
/* ===========================================================================
 * Initialize the "longest match" routines for a new zlib stream
 */

function lm_init(s) {
  s.window_size = 2 * s.w_size;
  /*** CLEAR_HASH(s); ***/

  zero(s.head); // Fill with NIL (= 0);

  /* Set the default configuration parameters:
   */

  s.max_lazy_match = configuration_table[s.level].max_lazy;
  s.good_match = configuration_table[s.level].good_length;
  s.nice_match = configuration_table[s.level].nice_length;
  s.max_chain_length = configuration_table[s.level].max_chain;
  s.strstart = 0;
  s.block_start = 0;
  s.lookahead = 0;
  s.insert = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  s.ins_h = 0;
}

function DeflateState() {
  this.strm = null;
  /* pointer back to this zlib stream */

  this.status = 0;
  /* as the name implies */

  this.pending_buf = null;
  /* output still pending */

  this.pending_buf_size = 0;
  /* size of pending_buf */

  this.pending_out = 0;
  /* next pending byte to output to the stream */

  this.pending = 0;
  /* nb of bytes in the pending buffer */

  this.wrap = 0;
  /* bit 0 true for zlib, bit 1 true for gzip */

  this.gzhead = null;
  /* gzip header information to write */

  this.gzindex = 0;
  /* where in extra, name, or comment */

  this.method = Z_DEFLATED;
  /* can only be DEFLATED */

  this.last_flush = -1;
  /* value of flush param for previous deflate call */

  this.w_size = 0;
  /* LZ77 window size (32K by default) */

  this.w_bits = 0;
  /* log2(w_size)  (8..16) */

  this.w_mask = 0;
  /* w_size - 1 */

  this.window = null;
  /* Sliding window. Input bytes are read into the second half of the window,
   * and move to the first half later to keep a dictionary of at least wSize
   * bytes. With this organization, matches are limited to a distance of
   * wSize-MAX_MATCH bytes, but this ensures that IO is always
   * performed with a length multiple of the block size.
   */

  this.window_size = 0;
  /* Actual size of window: 2*wSize, except when the user input buffer
   * is directly used as sliding window.
   */

  this.prev = null;
  /* Link to older string with same hash index. To limit the size of this
   * array to 64K, this link is maintained only for the last 32K strings.
   * An index in this array is thus a window index modulo 32K.
   */

  this.head = null;
  /* Heads of the hash chains or NIL. */

  this.ins_h = 0;
  /* hash index of string to be inserted */

  this.hash_size = 0;
  /* number of elements in hash table */

  this.hash_bits = 0;
  /* log2(hash_size) */

  this.hash_mask = 0;
  /* hash_size-1 */

  this.hash_shift = 0;
  /* Number of bits by which ins_h must be shifted at each input
   * step. It must be such that after MIN_MATCH steps, the oldest
   * byte no longer takes part in the hash key, that is:
   *   hash_shift * MIN_MATCH >= hash_bits
   */

  this.block_start = 0;
  /* Window position at the beginning of the current output block. Gets
   * negative when the window is moved backwards.
   */

  this.match_length = 0;
  /* length of best match */

  this.prev_match = 0;
  /* previous match */

  this.match_available = 0;
  /* set if previous match exists */

  this.strstart = 0;
  /* start of string to insert */

  this.match_start = 0;
  /* start of matching string */

  this.lookahead = 0;
  /* number of valid bytes ahead in window */

  this.prev_length = 0;
  /* Length of the best match at previous step. Matches not greater than this
   * are discarded. This is used in the lazy match evaluation.
   */

  this.max_chain_length = 0;
  /* To speed up deflation, hash chains are never searched beyond this
   * length.  A higher limit improves compression ratio but degrades the
   * speed.
   */

  this.max_lazy_match = 0;
  /* Attempt to find a better match only when the current match is strictly
   * smaller than this value. This mechanism is used only for compression
   * levels >= 4.
   */
  // That's alias to max_lazy_match, don't use directly
  //this.max_insert_length = 0;

  /* Insert new strings in the hash table only if the match length is not
   * greater than this length. This saves time but degrades compression.
   * max_insert_length is used only for compression levels <= 3.
   */

  this.level = 0;
  /* compression level (1..9) */

  this.strategy = 0;
  /* favor or force Huffman coding*/

  this.good_match = 0;
  /* Use a faster search when the previous match is longer than this */

  this.nice_match = 0;
  /* Stop searching when current match exceeds this */

  /* used by trees.c: */

  /* Didn't use ct_data typedef below to suppress compiler warning */
  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */
  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */
  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */
  // Use flat array of DOUBLE size, with interleaved fata,
  // because JS does not support effective

  this.dyn_ltree = new utils.Buf16(HEAP_SIZE * 2);
  this.dyn_dtree = new utils.Buf16((2 * D_CODES + 1) * 2);
  this.bl_tree = new utils.Buf16((2 * BL_CODES + 1) * 2);
  zero(this.dyn_ltree);
  zero(this.dyn_dtree);
  zero(this.bl_tree);
  this.l_desc = null;
  /* desc. for literal tree */

  this.d_desc = null;
  /* desc. for distance tree */

  this.bl_desc = null;
  /* desc. for bit length tree */
  //ush bl_count[MAX_BITS+1];

  this.bl_count = new utils.Buf16(MAX_BITS + 1);
  /* number of codes at each bit length for an optimal tree */
  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */

  this.heap = new utils.Buf16(2 * L_CODES + 1);
  /* heap used to build the Huffman trees */

  zero(this.heap);
  this.heap_len = 0;
  /* number of elements in the heap */

  this.heap_max = 0;
  /* element of largest frequency */

  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
   * The same heap array is used to build all trees.
   */

  this.depth = new utils.Buf16(2 * L_CODES + 1); //uch depth[2*L_CODES+1];

  zero(this.depth);
  /* Depth of each subtree used as tie breaker for trees of equal frequency
   */

  this.l_buf = 0;
  /* buffer index for literals or lengths */

  this.lit_bufsize = 0;
  /* Size of match buffer for literals/lengths.  There are 4 reasons for
   * limiting lit_bufsize to 64K:
   *   - frequencies can be kept in 16 bit counters
   *   - if compression is not successful for the first block, all input
   *     data is still in the window so we can still emit a stored block even
   *     when input comes from standard input.  (This can also be done for
   *     all blocks if lit_bufsize is not greater than 32K.)
   *   - if compression is not successful for a file smaller than 64K, we can
   *     even emit a stored file instead of a stored block (saving 5 bytes).
   *     This is applicable only for zip (not gzip or zlib).
   *   - creating new Huffman trees less frequently may not provide fast
   *     adaptation to changes in the input data statistics. (Take for
   *     example a binary file with poorly compressible code followed by
   *     a highly compressible string table.) Smaller buffer sizes give
   *     fast adaptation but have of course the overhead of transmitting
   *     trees more frequently.
   *   - I can't count above 4
   */

  this.last_lit = 0;
  /* running index in l_buf */

  this.d_buf = 0;
  /* Buffer index for distances. To simplify the code, d_buf and l_buf have
   * the same number of elements. To use different lengths, an extra flag
   * array would be necessary.
   */

  this.opt_len = 0;
  /* bit length of current block with optimal trees */

  this.static_len = 0;
  /* bit length of current block with static trees */

  this.matches = 0;
  /* number of string matches in current block */

  this.insert = 0;
  /* bytes at end of window left to insert */

  this.bi_buf = 0;
  /* Output buffer. bits are inserted starting at the bottom (least
   * significant bits).
   */

  this.bi_valid = 0;
  /* Number of valid bits in bi_buf.  All bits above the last valid bit
   * are always zero.
   */
  // Used for window memory init. We safely ignore it for JS. That makes
  // sense only for pointers and memory check tools.
  //this.high_water = 0;

  /* High water mark offset in window for initialized bytes -- bytes above
   * this are set to zero in order to avoid memory check warnings when
   * longest match routines access bytes past the input.  This is then
   * updated to the new high water mark.
   */
}

function deflateResetKeep(strm) {
  var s;

  if (!strm || !strm.state) {
    return err(strm, Z_STREAM_ERROR);
  }

  strm.total_in = strm.total_out = 0;
  strm.data_type = Z_UNKNOWN;
  s = strm.state;
  s.pending = 0;
  s.pending_out = 0;

  if (s.wrap < 0) {
    s.wrap = -s.wrap;
    /* was made negative by deflate(..., Z_FINISH); */
  }

  s.status = s.wrap ? INIT_STATE : BUSY_STATE;
  strm.adler = s.wrap === 2 ? 0 // crc32(0, Z_NULL, 0)
  : 1; // adler32(0, Z_NULL, 0)

  s.last_flush = Z_NO_FLUSH;

  trees._tr_init(s);

  return Z_OK;
}

function deflateReset(strm) {
  var ret = deflateResetKeep(strm);

  if (ret === Z_OK) {
    lm_init(strm.state);
  }

  return ret;
}

function deflateSetHeader(strm, head) {
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }

  if (strm.state.wrap !== 2) {
    return Z_STREAM_ERROR;
  }

  strm.state.gzhead = head;
  return Z_OK;
}

function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
  if (!strm) {
    // === Z_NULL
    return Z_STREAM_ERROR;
  }

  var wrap = 1;

  if (level === Z_DEFAULT_COMPRESSION) {
    level = 6;
  }

  if (windowBits < 0) {
    /* suppress zlib wrapper */
    wrap = 0;
    windowBits = -windowBits;
  } else if (windowBits > 15) {
    wrap = 2;
    /* write gzip wrapper instead */

    windowBits -= 16;
  }

  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
    return err(strm, Z_STREAM_ERROR);
  }

  if (windowBits === 8) {
    windowBits = 9;
  }
  /* until 256-byte window bug fixed */


  var s = new DeflateState();
  strm.state = s;
  s.strm = strm;
  s.wrap = wrap;
  s.gzhead = null;
  s.w_bits = windowBits;
  s.w_size = 1 << s.w_bits;
  s.w_mask = s.w_size - 1;
  s.hash_bits = memLevel + 7;
  s.hash_size = 1 << s.hash_bits;
  s.hash_mask = s.hash_size - 1;
  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
  s.window = new utils.Buf8(s.w_size * 2);
  s.head = new utils.Buf16(s.hash_size);
  s.prev = new utils.Buf16(s.w_size); // Don't need mem init magic for JS.
  //s.high_water = 0;  /* nothing written to s->window yet */

  s.lit_bufsize = 1 << memLevel + 6;
  /* 16K elements by default */

  s.pending_buf_size = s.lit_bufsize * 4; //overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);
  //s->pending_buf = (uchf *) overlay;

  s.pending_buf = new utils.Buf8(s.pending_buf_size); // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)
  //s->d_buf = overlay + s->lit_bufsize/sizeof(ush);

  s.d_buf = 1 * s.lit_bufsize; //s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;

  s.l_buf = (1 + 2) * s.lit_bufsize;
  s.level = level;
  s.strategy = strategy;
  s.method = method;
  return deflateReset(strm);
}

function deflateInit(strm, level) {
  return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
}

function deflate(strm, flush) {
  var old_flush, s;
  var beg, val; // for gzip header write only

  if (!strm || !strm.state || flush > Z_BLOCK || flush < 0) {
    return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
  }

  s = strm.state;

  if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === FINISH_STATE && flush !== Z_FINISH) {
    return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);
  }

  s.strm = strm;
  /* just in case */

  old_flush = s.last_flush;
  s.last_flush = flush;
  /* Write the header */

  if (s.status === INIT_STATE) {
    if (s.wrap === 2) {
      // GZIP header
      strm.adler = 0; //crc32(0L, Z_NULL, 0);

      put_byte(s, 31);
      put_byte(s, 139);
      put_byte(s, 8);

      if (!s.gzhead) {
        // s->gzhead == Z_NULL
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
        put_byte(s, OS_CODE);
        s.status = BUSY_STATE;
      } else {
        put_byte(s, (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16));
        put_byte(s, s.gzhead.time & 0xff);
        put_byte(s, s.gzhead.time >> 8 & 0xff);
        put_byte(s, s.gzhead.time >> 16 & 0xff);
        put_byte(s, s.gzhead.time >> 24 & 0xff);
        put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
        put_byte(s, s.gzhead.os & 0xff);

        if (s.gzhead.extra && s.gzhead.extra.length) {
          put_byte(s, s.gzhead.extra.length & 0xff);
          put_byte(s, s.gzhead.extra.length >> 8 & 0xff);
        }

        if (s.gzhead.hcrc) {
          strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
        }

        s.gzindex = 0;
        s.status = EXTRA_STATE;
      }
    } else // DEFLATE header
      {
        var header = Z_DEFLATED + (s.w_bits - 8 << 4) << 8;
        var level_flags = -1;

        if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
          level_flags = 0;
        } else if (s.level < 6) {
          level_flags = 1;
        } else if (s.level === 6) {
          level_flags = 2;
        } else {
          level_flags = 3;
        }

        header |= level_flags << 6;

        if (s.strstart !== 0) {
          header |= PRESET_DICT;
        }

        header += 31 - header % 31;
        s.status = BUSY_STATE;
        putShortMSB(s, header);
        /* Save the adler32 of the preset dictionary: */

        if (s.strstart !== 0) {
          putShortMSB(s, strm.adler >>> 16);
          putShortMSB(s, strm.adler & 0xffff);
        }

        strm.adler = 1; // adler32(0L, Z_NULL, 0);
      }
  } //#ifdef GZIP


  if (s.status === EXTRA_STATE) {
    if (s.gzhead.extra
    /* != Z_NULL*/
    ) {
        beg = s.pending;
        /* start of bytes to update crc */

        while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {
          if (s.pending === s.pending_buf_size) {
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }

            flush_pending(strm);
            beg = s.pending;

            if (s.pending === s.pending_buf_size) {
              break;
            }
          }

          put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);
          s.gzindex++;
        }

        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
        }

        if (s.gzindex === s.gzhead.extra.length) {
          s.gzindex = 0;
          s.status = NAME_STATE;
        }
      } else {
      s.status = NAME_STATE;
    }
  }

  if (s.status === NAME_STATE) {
    if (s.gzhead.name
    /* != Z_NULL*/
    ) {
        beg = s.pending;
        /* start of bytes to update crc */
        //int val;

        do {
          if (s.pending === s.pending_buf_size) {
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }

            flush_pending(strm);
            beg = s.pending;

            if (s.pending === s.pending_buf_size) {
              val = 1;
              break;
            }
          } // JS specific: little magic to add zero terminator to end of string


          if (s.gzindex < s.gzhead.name.length) {
            val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;
          } else {
            val = 0;
          }

          put_byte(s, val);
        } while (val !== 0);

        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
        }

        if (val === 0) {
          s.gzindex = 0;
          s.status = COMMENT_STATE;
        }
      } else {
      s.status = COMMENT_STATE;
    }
  }

  if (s.status === COMMENT_STATE) {
    if (s.gzhead.comment
    /* != Z_NULL*/
    ) {
        beg = s.pending;
        /* start of bytes to update crc */
        //int val;

        do {
          if (s.pending === s.pending_buf_size) {
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }

            flush_pending(strm);
            beg = s.pending;

            if (s.pending === s.pending_buf_size) {
              val = 1;
              break;
            }
          } // JS specific: little magic to add zero terminator to end of string


          if (s.gzindex < s.gzhead.comment.length) {
            val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;
          } else {
            val = 0;
          }

          put_byte(s, val);
        } while (val !== 0);

        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
        }

        if (val === 0) {
          s.status = HCRC_STATE;
        }
      } else {
      s.status = HCRC_STATE;
    }
  }

  if (s.status === HCRC_STATE) {
    if (s.gzhead.hcrc) {
      if (s.pending + 2 > s.pending_buf_size) {
        flush_pending(strm);
      }

      if (s.pending + 2 <= s.pending_buf_size) {
        put_byte(s, strm.adler & 0xff);
        put_byte(s, strm.adler >> 8 & 0xff);
        strm.adler = 0; //crc32(0L, Z_NULL, 0);

        s.status = BUSY_STATE;
      }
    } else {
      s.status = BUSY_STATE;
    }
  } //#endif

  /* Flush as much pending output as possible */


  if (s.pending !== 0) {
    flush_pending(strm);

    if (strm.avail_out === 0) {
      /* Since avail_out is 0, deflate will be called again with
       * more output space, but possibly with both pending and
       * avail_in equal to zero. There won't be anything to do,
       * but this is not an error situation so make sure we
       * return OK instead of BUF_ERROR at next call of deflate:
       */
      s.last_flush = -1;
      return Z_OK;
    }
    /* Make sure there is something to do and avoid duplicate consecutive
     * flushes. For repeated and useless calls with Z_FINISH, we keep
     * returning Z_STREAM_END instead of Z_BUF_ERROR.
     */

  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {
    return err(strm, Z_BUF_ERROR);
  }
  /* User must not provide more input after the first FINISH: */


  if (s.status === FINISH_STATE && strm.avail_in !== 0) {
    return err(strm, Z_BUF_ERROR);
  }
  /* Start a new block or continue the current one.
   */


  if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH && s.status !== FINISH_STATE) {
    var bstate = s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);

    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
      s.status = FINISH_STATE;
    }

    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        /* avoid BUF_ERROR next call, see above */
      }

      return Z_OK;
      /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
       * of deflate should use the same flush parameter to make sure
       * that the flush is complete. So we don't have to output an
       * empty block here, this will be done at next call. This also
       * ensures that for a very small output buffer, we emit at most
       * one empty block.
       */
    }

    if (bstate === BS_BLOCK_DONE) {
      if (flush === Z_PARTIAL_FLUSH) {
        trees._tr_align(s);
      } else if (flush !== Z_BLOCK) {
        /* FULL_FLUSH or SYNC_FLUSH */
        trees._tr_stored_block(s, 0, 0, false);
        /* For a full flush, this empty block will be recognized
         * as a special marker by inflate_sync().
         */


        if (flush === Z_FULL_FLUSH) {
          /*** CLEAR_HASH(s); ***/

          /* forget history */
          zero(s.head); // Fill with NIL (= 0);

          if (s.lookahead === 0) {
            s.strstart = 0;
            s.block_start = 0;
            s.insert = 0;
          }
        }
      }

      flush_pending(strm);

      if (strm.avail_out === 0) {
        s.last_flush = -1;
        /* avoid BUF_ERROR at next call, see above */

        return Z_OK;
      }
    }
  } //Assert(strm->avail_out > 0, "bug2");
  //if (strm.avail_out <= 0) { throw new Error("bug2");}


  if (flush !== Z_FINISH) {
    return Z_OK;
  }

  if (s.wrap <= 0) {
    return Z_STREAM_END;
  }
  /* Write the trailer */


  if (s.wrap === 2) {
    put_byte(s, strm.adler & 0xff);
    put_byte(s, strm.adler >> 8 & 0xff);
    put_byte(s, strm.adler >> 16 & 0xff);
    put_byte(s, strm.adler >> 24 & 0xff);
    put_byte(s, strm.total_in & 0xff);
    put_byte(s, strm.total_in >> 8 & 0xff);
    put_byte(s, strm.total_in >> 16 & 0xff);
    put_byte(s, strm.total_in >> 24 & 0xff);
  } else {
    putShortMSB(s, strm.adler >>> 16);
    putShortMSB(s, strm.adler & 0xffff);
  }

  flush_pending(strm);
  /* If avail_out is zero, the application will call deflate again
   * to flush the rest.
   */

  if (s.wrap > 0) {
    s.wrap = -s.wrap;
  }
  /* write the trailer only once! */


  return s.pending !== 0 ? Z_OK : Z_STREAM_END;
}

function deflateEnd(strm) {
  var status;

  if (!strm
  /*== Z_NULL*/
  || !strm.state
  /*== Z_NULL*/
  ) {
      return Z_STREAM_ERROR;
    }

  status = strm.state.status;

  if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {
    return err(strm, Z_STREAM_ERROR);
  }

  strm.state = null;
  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
}
/* =========================================================================
 * Initializes the compression dictionary from the given byte
 * sequence without producing any compressed output.
 */


function deflateSetDictionary(strm, dictionary) {
  var dictLength = dictionary.length;
  var s;
  var str, n;
  var wrap;
  var avail;
  var next;
  var input;
  var tmpDict;

  if (!strm
  /*== Z_NULL*/
  || !strm.state
  /*== Z_NULL*/
  ) {
      return Z_STREAM_ERROR;
    }

  s = strm.state;
  wrap = s.wrap;

  if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) {
    return Z_STREAM_ERROR;
  }
  /* when using zlib wrappers, compute Adler-32 for provided dictionary */


  if (wrap === 1) {
    /* adler32(strm->adler, dictionary, dictLength); */
    strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
  }

  s.wrap = 0;
  /* avoid computing Adler-32 in read_buf */

  /* if dictionary would fill window, just replace the history */

  if (dictLength >= s.w_size) {
    if (wrap === 0) {
      /* already empty otherwise */

      /*** CLEAR_HASH(s); ***/
      zero(s.head); // Fill with NIL (= 0);

      s.strstart = 0;
      s.block_start = 0;
      s.insert = 0;
    }
    /* use the tail */
    // dictionary = dictionary.slice(dictLength - s.w_size);


    tmpDict = new utils.Buf8(s.w_size);
    utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);
    dictionary = tmpDict;
    dictLength = s.w_size;
  }
  /* insert dictionary into window and hash */


  avail = strm.avail_in;
  next = strm.next_in;
  input = strm.input;
  strm.avail_in = dictLength;
  strm.next_in = 0;
  strm.input = dictionary;
  fill_window(s);

  while (s.lookahead >= MIN_MATCH) {
    str = s.strstart;
    n = s.lookahead - (MIN_MATCH - 1);

    do {
      /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
      s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
      s.prev[str & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = str;
      str++;
    } while (--n);

    s.strstart = str;
    s.lookahead = MIN_MATCH - 1;
    fill_window(s);
  }

  s.strstart += s.lookahead;
  s.block_start = s.strstart;
  s.insert = s.lookahead;
  s.lookahead = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  strm.next_in = next;
  strm.input = input;
  strm.avail_in = avail;
  s.wrap = wrap;
  return Z_OK;
}

exports.deflateInit = deflateInit;
exports.deflateInit2 = deflateInit2;
exports.deflateReset = deflateReset;
exports.deflateResetKeep = deflateResetKeep;
exports.deflateSetHeader = deflateSetHeader;
exports.deflate = deflate;
exports.deflateEnd = deflateEnd;
exports.deflateSetDictionary = deflateSetDictionary;
exports.deflateInfo = 'pako deflate (from Nodeca project)';
/* Not implemented
exports.deflateBound = deflateBound;
exports.deflateCopy = deflateCopy;
exports.deflateParams = deflateParams;
exports.deflatePending = deflatePending;
exports.deflatePrime = deflatePrime;
exports.deflateTune = deflateTune;
*/

/***/ }),

/***/ "./node_modules/pako/lib/zlib/gzheader.js":
/*!************************************************!*\
  !*** ./node_modules/pako/lib/zlib/gzheader.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function GZheader() {
  /* true if compressed data believed to be text */
  this.text = 0;
  /* modification time */

  this.time = 0;
  /* extra flags (not used when writing a gzip file) */

  this.xflags = 0;
  /* operating system */

  this.os = 0;
  /* pointer to extra field or Z_NULL if none */

  this.extra = null;
  /* extra field length (valid if extra != Z_NULL) */

  this.extra_len = 0; // Actually, we don't need it in JS,
  // but leave for few code modifications
  //
  // Setup limits is not necessary because in js we should not preallocate memory
  // for inflate use constant limit in 65536 bytes
  //

  /* space at extra (only when reading header) */
  // this.extra_max  = 0;

  /* pointer to zero-terminated file name or Z_NULL */

  this.name = '';
  /* space at name (only when reading header) */
  // this.name_max   = 0;

  /* pointer to zero-terminated comment or Z_NULL */

  this.comment = '';
  /* space at comment (only when reading header) */
  // this.comm_max   = 0;

  /* true if there was or will be a header crc */

  this.hcrc = 0;
  /* true when done reading gzip header (not used when writing a gzip file) */

  this.done = false;
}

module.exports = GZheader;

/***/ }),

/***/ "./node_modules/pako/lib/zlib/inffast.js":
/*!***********************************************!*\
  !*** ./node_modules/pako/lib/zlib/inffast.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.
// See state defs from inflate.js

var BAD = 30;
/* got a data error -- remain here until reset */

var TYPE = 12;
/* i: waiting for type bits, including last-flag bit */

/*
   Decode literal, length, and distance codes and write out the resulting
   literal and match bytes until either not enough input or output is
   available, an end-of-block is encountered, or a data error is encountered.
   When large enough input and output buffers are supplied to inflate(), for
   example, a 16K input buffer and a 64K output buffer, more than 95% of the
   inflate execution time is spent in this routine.

   Entry assumptions:

        state.mode === LEN
        strm.avail_in >= 6
        strm.avail_out >= 258
        start >= strm.avail_out
        state.bits < 8

   On return, state.mode is one of:

        LEN -- ran out of enough output space or enough available input
        TYPE -- reached end of block code, inflate() to interpret next block
        BAD -- error in block data

   Notes:

    - The maximum input bits used by a length/distance pair is 15 bits for the
      length code, 5 bits for the length extra, 15 bits for the distance code,
      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
      Therefore if strm.avail_in >= 6, then there is enough input to avoid
      checking for available input while decoding.

    - The maximum bytes that a single length/distance pair can output is 258
      bytes, which is the maximum length that can be coded.  inflate_fast()
      requires strm.avail_out >= 258 for each loop to avoid checking for
      output space.
 */

module.exports = function inflate_fast(strm, start) {
  var state;

  var _in;
  /* local strm.input */


  var last;
  /* have enough input while in < last */

  var _out;
  /* local strm.output */


  var beg;
  /* inflate()'s initial strm.output */

  var end;
  /* while out < end, enough space available */
  //#ifdef INFLATE_STRICT

  var dmax;
  /* maximum distance from zlib header */
  //#endif

  var wsize;
  /* window size or zero if not using window */

  var whave;
  /* valid bytes in the window */

  var wnext;
  /* window write index */
  // Use `s_window` instead `window`, avoid conflict with instrumentation tools

  var s_window;
  /* allocated sliding window, if wsize != 0 */

  var hold;
  /* local strm.hold */

  var bits;
  /* local strm.bits */

  var lcode;
  /* local strm.lencode */

  var dcode;
  /* local strm.distcode */

  var lmask;
  /* mask for first level of length codes */

  var dmask;
  /* mask for first level of distance codes */

  var here;
  /* retrieved table entry */

  var op;
  /* code bits, operation, extra bits, or */

  /*  window position, window bytes to copy */

  var len;
  /* match length, unused bytes */

  var dist;
  /* match distance */

  var from;
  /* where to copy match from */

  var from_source;
  var input, output; // JS specific, because we have no pointers

  /* copy state to local variables */

  state = strm.state; //here = state.here;

  _in = strm.next_in;
  input = strm.input;
  last = _in + (strm.avail_in - 5);
  _out = strm.next_out;
  output = strm.output;
  beg = _out - (start - strm.avail_out);
  end = _out + (strm.avail_out - 257); //#ifdef INFLATE_STRICT

  dmax = state.dmax; //#endif

  wsize = state.wsize;
  whave = state.whave;
  wnext = state.wnext;
  s_window = state.window;
  hold = state.hold;
  bits = state.bits;
  lcode = state.lencode;
  dcode = state.distcode;
  lmask = (1 << state.lenbits) - 1;
  dmask = (1 << state.distbits) - 1;
  /* decode literals and length/distances until end-of-block or not enough
     input data or output space */

  top: do {
    if (bits < 15) {
      hold += input[_in++] << bits;
      bits += 8;
      hold += input[_in++] << bits;
      bits += 8;
    }

    here = lcode[hold & lmask];

    dolen: for (;;) {
      // Goto emulation
      op = here >>> 24
      /*here.bits*/
      ;
      hold >>>= op;
      bits -= op;
      op = here >>> 16 & 0xff
      /*here.op*/
      ;

      if (op === 0) {
        /* literal */
        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
        //        "inflate:         literal '%c'\n" :
        //        "inflate:         literal 0x%02x\n", here.val));
        output[_out++] = here & 0xffff
        /*here.val*/
        ;
      } else if (op & 16) {
        /* length base */
        len = here & 0xffff
        /*here.val*/
        ;
        op &= 15;
        /* number of extra bits */

        if (op) {
          if (bits < op) {
            hold += input[_in++] << bits;
            bits += 8;
          }

          len += hold & (1 << op) - 1;
          hold >>>= op;
          bits -= op;
        } //Tracevv((stderr, "inflate:         length %u\n", len));


        if (bits < 15) {
          hold += input[_in++] << bits;
          bits += 8;
          hold += input[_in++] << bits;
          bits += 8;
        }

        here = dcode[hold & dmask];

        dodist: for (;;) {
          // goto emulation
          op = here >>> 24
          /*here.bits*/
          ;
          hold >>>= op;
          bits -= op;
          op = here >>> 16 & 0xff
          /*here.op*/
          ;

          if (op & 16) {
            /* distance base */
            dist = here & 0xffff
            /*here.val*/
            ;
            op &= 15;
            /* number of extra bits */

            if (bits < op) {
              hold += input[_in++] << bits;
              bits += 8;

              if (bits < op) {
                hold += input[_in++] << bits;
                bits += 8;
              }
            }

            dist += hold & (1 << op) - 1; //#ifdef INFLATE_STRICT

            if (dist > dmax) {
              strm.msg = 'invalid distance too far back';
              state.mode = BAD;
              break top;
            } //#endif


            hold >>>= op;
            bits -= op; //Tracevv((stderr, "inflate:         distance %u\n", dist));

            op = _out - beg;
            /* max distance in output */

            if (dist > op) {
              /* see if copy from window */
              op = dist - op;
              /* distance back in window */

              if (op > whave) {
                if (state.sane) {
                  strm.msg = 'invalid distance too far back';
                  state.mode = BAD;
                  break top;
                } // (!) This block is disabled in zlib defaults,
                // don't enable it for binary compatibility
                //#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
                //                if (len <= op - whave) {
                //                  do {
                //                    output[_out++] = 0;
                //                  } while (--len);
                //                  continue top;
                //                }
                //                len -= op - whave;
                //                do {
                //                  output[_out++] = 0;
                //                } while (--op > whave);
                //                if (op === 0) {
                //                  from = _out - dist;
                //                  do {
                //                    output[_out++] = output[from++];
                //                  } while (--len);
                //                  continue top;
                //                }
                //#endif

              }

              from = 0; // window index

              from_source = s_window;

              if (wnext === 0) {
                /* very common case */
                from += wsize - op;

                if (op < len) {
                  /* some from window */
                  len -= op;

                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);

                  from = _out - dist;
                  /* rest from output */

                  from_source = output;
                }
              } else if (wnext < op) {
                /* wrap around window */
                from += wsize + wnext - op;
                op -= wnext;

                if (op < len) {
                  /* some from end of window */
                  len -= op;

                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);

                  from = 0;

                  if (wnext < len) {
                    /* some from start of window */
                    op = wnext;
                    len -= op;

                    do {
                      output[_out++] = s_window[from++];
                    } while (--op);

                    from = _out - dist;
                    /* rest from output */

                    from_source = output;
                  }
                }
              } else {
                /* contiguous in window */
                from += wnext - op;

                if (op < len) {
                  /* some from window */
                  len -= op;

                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);

                  from = _out - dist;
                  /* rest from output */

                  from_source = output;
                }
              }

              while (len > 2) {
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                len -= 3;
              }

              if (len) {
                output[_out++] = from_source[from++];

                if (len > 1) {
                  output[_out++] = from_source[from++];
                }
              }
            } else {
              from = _out - dist;
              /* copy direct from output */

              do {
                /* minimum length is three */
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                len -= 3;
              } while (len > 2);

              if (len) {
                output[_out++] = output[from++];

                if (len > 1) {
                  output[_out++] = output[from++];
                }
              }
            }
          } else if ((op & 64) === 0) {
            /* 2nd level distance code */
            here = dcode[(here & 0xffff) + (
            /*here.val*/
            hold & (1 << op) - 1)];
            continue dodist;
          } else {
            strm.msg = 'invalid distance code';
            state.mode = BAD;
            break top;
          }

          break; // need to emulate goto via "continue"
        }
      } else if ((op & 64) === 0) {
        /* 2nd level length code */
        here = lcode[(here & 0xffff) + (
        /*here.val*/
        hold & (1 << op) - 1)];
        continue dolen;
      } else if (op & 32) {
        /* end-of-block */
        //Tracevv((stderr, "inflate:         end of block\n"));
        state.mode = TYPE;
        break top;
      } else {
        strm.msg = 'invalid literal/length code';
        state.mode = BAD;
        break top;
      }

      break; // need to emulate goto via "continue"
    }
  } while (_in < last && _out < end);
  /* return unused bytes (on entry, bits < 8, so in won't go too far back) */


  len = bits >> 3;
  _in -= len;
  bits -= len << 3;
  hold &= (1 << bits) - 1;
  /* update state and return */

  strm.next_in = _in;
  strm.next_out = _out;
  strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
  strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
  state.hold = hold;
  state.bits = bits;
  return;
};

/***/ }),

/***/ "./node_modules/pako/lib/zlib/inflate.js":
/*!***********************************************!*\
  !*** ./node_modules/pako/lib/zlib/inflate.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var utils = __webpack_require__(/*! ../utils/common */ "./node_modules/pako/lib/utils/common.js");

var adler32 = __webpack_require__(/*! ./adler32 */ "./node_modules/pako/lib/zlib/adler32.js");

var crc32 = __webpack_require__(/*! ./crc32 */ "./node_modules/pako/lib/zlib/crc32.js");

var inflate_fast = __webpack_require__(/*! ./inffast */ "./node_modules/pako/lib/zlib/inffast.js");

var inflate_table = __webpack_require__(/*! ./inftrees */ "./node_modules/pako/lib/zlib/inftrees.js");

var CODES = 0;
var LENS = 1;
var DISTS = 2;
/* Public constants ==========================================================*/

/* ===========================================================================*/

/* Allowed flush values; see deflate() and inflate() below for details */
//var Z_NO_FLUSH      = 0;
//var Z_PARTIAL_FLUSH = 1;
//var Z_SYNC_FLUSH    = 2;
//var Z_FULL_FLUSH    = 3;

var Z_FINISH = 4;
var Z_BLOCK = 5;
var Z_TREES = 6;
/* Return codes for the compression/decompression functions. Negative values
 * are errors, positive values are used for special but normal events.
 */

var Z_OK = 0;
var Z_STREAM_END = 1;
var Z_NEED_DICT = 2; //var Z_ERRNO         = -1;

var Z_STREAM_ERROR = -2;
var Z_DATA_ERROR = -3;
var Z_MEM_ERROR = -4;
var Z_BUF_ERROR = -5; //var Z_VERSION_ERROR = -6;

/* The deflate compression method */

var Z_DEFLATED = 8;
/* STATES ====================================================================*/

/* ===========================================================================*/

var HEAD = 1;
/* i: waiting for magic header */

var FLAGS = 2;
/* i: waiting for method and flags (gzip) */

var TIME = 3;
/* i: waiting for modification time (gzip) */

var OS = 4;
/* i: waiting for extra flags and operating system (gzip) */

var EXLEN = 5;
/* i: waiting for extra length (gzip) */

var EXTRA = 6;
/* i: waiting for extra bytes (gzip) */

var NAME = 7;
/* i: waiting for end of file name (gzip) */

var COMMENT = 8;
/* i: waiting for end of comment (gzip) */

var HCRC = 9;
/* i: waiting for header crc (gzip) */

var DICTID = 10;
/* i: waiting for dictionary check value */

var DICT = 11;
/* waiting for inflateSetDictionary() call */

var TYPE = 12;
/* i: waiting for type bits, including last-flag bit */

var TYPEDO = 13;
/* i: same, but skip check to exit inflate on new block */

var STORED = 14;
/* i: waiting for stored size (length and complement) */

var COPY_ = 15;
/* i/o: same as COPY below, but only first time in */

var COPY = 16;
/* i/o: waiting for input or output to copy stored block */

var TABLE = 17;
/* i: waiting for dynamic block table lengths */

var LENLENS = 18;
/* i: waiting for code length code lengths */

var CODELENS = 19;
/* i: waiting for length/lit and distance code lengths */

var LEN_ = 20;
/* i: same as LEN below, but only first time in */

var LEN = 21;
/* i: waiting for length/lit/eob code */

var LENEXT = 22;
/* i: waiting for length extra bits */

var DIST = 23;
/* i: waiting for distance code */

var DISTEXT = 24;
/* i: waiting for distance extra bits */

var MATCH = 25;
/* o: waiting for output space to copy string */

var LIT = 26;
/* o: waiting for output space to write literal */

var CHECK = 27;
/* i: waiting for 32-bit check value */

var LENGTH = 28;
/* i: waiting for 32-bit length (gzip) */

var DONE = 29;
/* finished check, done -- remain here until reset */

var BAD = 30;
/* got a data error -- remain here until reset */

var MEM = 31;
/* got an inflate() memory error -- remain here until reset */

var SYNC = 32;
/* looking for synchronization bytes to restart inflate() */

/* ===========================================================================*/

var ENOUGH_LENS = 852;
var ENOUGH_DISTS = 592; //var ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);

var MAX_WBITS = 15;
/* 32K LZ77 window */

var DEF_WBITS = MAX_WBITS;

function zswap32(q) {
  return (q >>> 24 & 0xff) + (q >>> 8 & 0xff00) + ((q & 0xff00) << 8) + ((q & 0xff) << 24);
}

function InflateState() {
  this.mode = 0;
  /* current inflate mode */

  this.last = false;
  /* true if processing last block */

  this.wrap = 0;
  /* bit 0 true for zlib, bit 1 true for gzip */

  this.havedict = false;
  /* true if dictionary provided */

  this.flags = 0;
  /* gzip header method and flags (0 if zlib) */

  this.dmax = 0;
  /* zlib header max distance (INFLATE_STRICT) */

  this.check = 0;
  /* protected copy of check value */

  this.total = 0;
  /* protected copy of output count */
  // TODO: may be {}

  this.head = null;
  /* where to save gzip header information */

  /* sliding window */

  this.wbits = 0;
  /* log base 2 of requested window size */

  this.wsize = 0;
  /* window size or zero if not using window */

  this.whave = 0;
  /* valid bytes in the window */

  this.wnext = 0;
  /* window write index */

  this.window = null;
  /* allocated sliding window, if needed */

  /* bit accumulator */

  this.hold = 0;
  /* input bit accumulator */

  this.bits = 0;
  /* number of bits in "in" */

  /* for string and stored block copying */

  this.length = 0;
  /* literal or length of data to copy */

  this.offset = 0;
  /* distance back to copy string from */

  /* for table and code decoding */

  this.extra = 0;
  /* extra bits needed */

  /* fixed and dynamic code tables */

  this.lencode = null;
  /* starting table for length/literal codes */

  this.distcode = null;
  /* starting table for distance codes */

  this.lenbits = 0;
  /* index bits for lencode */

  this.distbits = 0;
  /* index bits for distcode */

  /* dynamic table building */

  this.ncode = 0;
  /* number of code length code lengths */

  this.nlen = 0;
  /* number of length code lengths */

  this.ndist = 0;
  /* number of distance code lengths */

  this.have = 0;
  /* number of code lengths in lens[] */

  this.next = null;
  /* next available space in codes[] */

  this.lens = new utils.Buf16(320);
  /* temporary storage for code lengths */

  this.work = new utils.Buf16(288);
  /* work area for code table building */

  /*
   because we don't have pointers in js, we use lencode and distcode directly
   as buffers so we don't need codes
  */
  //this.codes = new utils.Buf32(ENOUGH);       /* space for code tables */

  this.lendyn = null;
  /* dynamic table for length/literal codes (JS specific) */

  this.distdyn = null;
  /* dynamic table for distance codes (JS specific) */

  this.sane = 0;
  /* if false, allow invalid distance too far */

  this.back = 0;
  /* bits back of last unprocessed length/lit */

  this.was = 0;
  /* initial length of match */
}

function inflateResetKeep(strm) {
  var state;

  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }

  state = strm.state;
  strm.total_in = strm.total_out = state.total = 0;
  strm.msg = '';
  /*Z_NULL*/

  if (state.wrap) {
    /* to support ill-conceived Java test suite */
    strm.adler = state.wrap & 1;
  }

  state.mode = HEAD;
  state.last = 0;
  state.havedict = 0;
  state.dmax = 32768;
  state.head = null
  /*Z_NULL*/
  ;
  state.hold = 0;
  state.bits = 0; //state.lencode = state.distcode = state.next = state.codes;

  state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
  state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);
  state.sane = 1;
  state.back = -1; //Tracev((stderr, "inflate: reset\n"));

  return Z_OK;
}

function inflateReset(strm) {
  var state;

  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }

  state = strm.state;
  state.wsize = 0;
  state.whave = 0;
  state.wnext = 0;
  return inflateResetKeep(strm);
}

function inflateReset2(strm, windowBits) {
  var wrap;
  var state;
  /* get the state */

  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }

  state = strm.state;
  /* extract wrap request from windowBits parameter */

  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  } else {
    wrap = (windowBits >> 4) + 1;

    if (windowBits < 48) {
      windowBits &= 15;
    }
  }
  /* set number of window bits, free window if different */


  if (windowBits && (windowBits < 8 || windowBits > 15)) {
    return Z_STREAM_ERROR;
  }

  if (state.window !== null && state.wbits !== windowBits) {
    state.window = null;
  }
  /* update state and reset the rest of it */


  state.wrap = wrap;
  state.wbits = windowBits;
  return inflateReset(strm);
}

function inflateInit2(strm, windowBits) {
  var ret;
  var state;

  if (!strm) {
    return Z_STREAM_ERROR;
  } //strm.msg = Z_NULL;                 /* in case we return an error */


  state = new InflateState(); //if (state === Z_NULL) return Z_MEM_ERROR;
  //Tracev((stderr, "inflate: allocated\n"));

  strm.state = state;
  state.window = null
  /*Z_NULL*/
  ;
  ret = inflateReset2(strm, windowBits);

  if (ret !== Z_OK) {
    strm.state = null
    /*Z_NULL*/
    ;
  }

  return ret;
}

function inflateInit(strm) {
  return inflateInit2(strm, DEF_WBITS);
}
/*
 Return state with length and distance decoding tables and index sizes set to
 fixed code decoding.  Normally this returns fixed tables from inffixed.h.
 If BUILDFIXED is defined, then instead this routine builds the tables the
 first time it's called, and returns those tables the first time and
 thereafter.  This reduces the size of the code by about 2K bytes, in
 exchange for a little execution time.  However, BUILDFIXED should not be
 used for threaded applications, since the rewriting of the tables and virgin
 may not be thread-safe.
 */


var virgin = true;
var lenfix, distfix; // We have no pointers in JS, so keep tables separate

function fixedtables(state) {
  /* build fixed huffman tables if first call (may not be thread safe) */
  if (virgin) {
    var sym;
    lenfix = new utils.Buf32(512);
    distfix = new utils.Buf32(32);
    /* literal/length table */

    sym = 0;

    while (sym < 144) {
      state.lens[sym++] = 8;
    }

    while (sym < 256) {
      state.lens[sym++] = 9;
    }

    while (sym < 280) {
      state.lens[sym++] = 7;
    }

    while (sym < 288) {
      state.lens[sym++] = 8;
    }

    inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, {
      bits: 9
    });
    /* distance table */

    sym = 0;

    while (sym < 32) {
      state.lens[sym++] = 5;
    }

    inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, {
      bits: 5
    });
    /* do this just once */

    virgin = false;
  }

  state.lencode = lenfix;
  state.lenbits = 9;
  state.distcode = distfix;
  state.distbits = 5;
}
/*
 Update the window with the last wsize (normally 32K) bytes written before
 returning.  If window does not exist yet, create it.  This is only called
 when a window is already in use, or when output has been written during this
 inflate call, but the end of the deflate stream has not been reached yet.
 It is also called to create a window for dictionary data when a dictionary
 is loaded.

 Providing output buffers larger than 32K to inflate() should provide a speed
 advantage, since only the last 32K of output is copied to the sliding window
 upon return from inflate(), and since all distances after the first 32K of
 output will fall in the output data, making match copies simpler and faster.
 The advantage may be dependent on the size of the processor's data caches.
 */


function updatewindow(strm, src, end, copy) {
  var dist;
  var state = strm.state;
  /* if it hasn't been done already, allocate space for the window */

  if (state.window === null) {
    state.wsize = 1 << state.wbits;
    state.wnext = 0;
    state.whave = 0;
    state.window = new utils.Buf8(state.wsize);
  }
  /* copy state->wsize or less output bytes into the circular window */


  if (copy >= state.wsize) {
    utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
    state.wnext = 0;
    state.whave = state.wsize;
  } else {
    dist = state.wsize - state.wnext;

    if (dist > copy) {
      dist = copy;
    } //zmemcpy(state->window + state->wnext, end - copy, dist);


    utils.arraySet(state.window, src, end - copy, dist, state.wnext);
    copy -= dist;

    if (copy) {
      //zmemcpy(state->window, end - copy, copy);
      utils.arraySet(state.window, src, end - copy, copy, 0);
      state.wnext = copy;
      state.whave = state.wsize;
    } else {
      state.wnext += dist;

      if (state.wnext === state.wsize) {
        state.wnext = 0;
      }

      if (state.whave < state.wsize) {
        state.whave += dist;
      }
    }
  }

  return 0;
}

function inflate(strm, flush) {
  var state;
  var input, output; // input/output buffers

  var next;
  /* next input INDEX */

  var put;
  /* next output INDEX */

  var have, left;
  /* available input and output */

  var hold;
  /* bit buffer */

  var bits;
  /* bits in bit buffer */

  var _in, _out;
  /* save starting available input and output */


  var copy;
  /* number of stored or match bytes to copy */

  var from;
  /* where to copy match bytes from */

  var from_source;
  var here = 0;
  /* current decoding table entry */

  var here_bits, here_op, here_val; // paked "here" denormalized (JS specific)
  //var last;                   /* parent table entry */

  var last_bits, last_op, last_val; // paked "last" denormalized (JS specific)

  var len;
  /* length to copy for repeats, bits to drop */

  var ret;
  /* return code */

  var hbuf = new utils.Buf8(4);
  /* buffer for gzip header crc calculation */

  var opts;
  var n; // temporary var for NEED_BITS

  var order =
  /* permutation of code lengths */
  [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];

  if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
    return Z_STREAM_ERROR;
  }

  state = strm.state;

  if (state.mode === TYPE) {
    state.mode = TYPEDO;
  }
  /* skip check */
  //--- LOAD() ---


  put = strm.next_out;
  output = strm.output;
  left = strm.avail_out;
  next = strm.next_in;
  input = strm.input;
  have = strm.avail_in;
  hold = state.hold;
  bits = state.bits; //---

  _in = have;
  _out = left;
  ret = Z_OK;

  inf_leave: // goto emulation
  for (;;) {
    switch (state.mode) {
      case HEAD:
        if (state.wrap === 0) {
          state.mode = TYPEDO;
          break;
        } //=== NEEDBITS(16);


        while (bits < 16) {
          if (have === 0) {
            break inf_leave;
          }

          have--;
          hold += input[next++] << bits;
          bits += 8;
        } //===//


        if (state.wrap & 2 && hold === 0x8b1f) {
          /* gzip header */
          state.check = 0
          /*crc32(0L, Z_NULL, 0)*/
          ; //=== CRC2(state.check, hold);

          hbuf[0] = hold & 0xff;
          hbuf[1] = hold >>> 8 & 0xff;
          state.check = crc32(state.check, hbuf, 2, 0); //===//
          //=== INITBITS();

          hold = 0;
          bits = 0; //===//

          state.mode = FLAGS;
          break;
        }

        state.flags = 0;
        /* expect zlib header */

        if (state.head) {
          state.head.done = false;
        }

        if (!(state.wrap & 1) ||
        /* check if zlib header allowed */
        (((hold & 0xff) <<
        /*BITS(8)*/
        8) + (hold >> 8)) % 31) {
          strm.msg = 'incorrect header check';
          state.mode = BAD;
          break;
        }

        if ((hold & 0x0f) !==
        /*BITS(4)*/
        Z_DEFLATED) {
          strm.msg = 'unknown compression method';
          state.mode = BAD;
          break;
        } //--- DROPBITS(4) ---//


        hold >>>= 4;
        bits -= 4; //---//

        len = (hold & 0x0f) +
        /*BITS(4)*/
        8;

        if (state.wbits === 0) {
          state.wbits = len;
        } else if (len > state.wbits) {
          strm.msg = 'invalid window size';
          state.mode = BAD;
          break;
        }

        state.dmax = 1 << len; //Tracev((stderr, "inflate:   zlib header ok\n"));

        strm.adler = state.check = 1
        /*adler32(0L, Z_NULL, 0)*/
        ;
        state.mode = hold & 0x200 ? DICTID : TYPE; //=== INITBITS();

        hold = 0;
        bits = 0; //===//

        break;

      case FLAGS:
        //=== NEEDBITS(16); */
        while (bits < 16) {
          if (have === 0) {
            break inf_leave;
          }

          have--;
          hold += input[next++] << bits;
          bits += 8;
        } //===//


        state.flags = hold;

        if ((state.flags & 0xff) !== Z_DEFLATED) {
          strm.msg = 'unknown compression method';
          state.mode = BAD;
          break;
        }

        if (state.flags & 0xe000) {
          strm.msg = 'unknown header flags set';
          state.mode = BAD;
          break;
        }

        if (state.head) {
          state.head.text = hold >> 8 & 1;
        }

        if (state.flags & 0x0200) {
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = hold >>> 8 & 0xff;
          state.check = crc32(state.check, hbuf, 2, 0); //===//
        } //=== INITBITS();


        hold = 0;
        bits = 0; //===//

        state.mode = TIME;

      /* falls through */

      case TIME:
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) {
            break inf_leave;
          }

          have--;
          hold += input[next++] << bits;
          bits += 8;
        } //===//


        if (state.head) {
          state.head.time = hold;
        }

        if (state.flags & 0x0200) {
          //=== CRC4(state.check, hold)
          hbuf[0] = hold & 0xff;
          hbuf[1] = hold >>> 8 & 0xff;
          hbuf[2] = hold >>> 16 & 0xff;
          hbuf[3] = hold >>> 24 & 0xff;
          state.check = crc32(state.check, hbuf, 4, 0); //===
        } //=== INITBITS();


        hold = 0;
        bits = 0; //===//

        state.mode = OS;

      /* falls through */

      case OS:
        //=== NEEDBITS(16); */
        while (bits < 16) {
          if (have === 0) {
            break inf_leave;
          }

          have--;
          hold += input[next++] << bits;
          bits += 8;
        } //===//


        if (state.head) {
          state.head.xflags = hold & 0xff;
          state.head.os = hold >> 8;
        }

        if (state.flags & 0x0200) {
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = hold >>> 8 & 0xff;
          state.check = crc32(state.check, hbuf, 2, 0); //===//
        } //=== INITBITS();


        hold = 0;
        bits = 0; //===//

        state.mode = EXLEN;

      /* falls through */

      case EXLEN:
        if (state.flags & 0x0400) {
          //=== NEEDBITS(16); */
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }

            have--;
            hold += input[next++] << bits;
            bits += 8;
          } //===//


          state.length = hold;

          if (state.head) {
            state.head.extra_len = hold;
          }

          if (state.flags & 0x0200) {
            //=== CRC2(state.check, hold);
            hbuf[0] = hold & 0xff;
            hbuf[1] = hold >>> 8 & 0xff;
            state.check = crc32(state.check, hbuf, 2, 0); //===//
          } //=== INITBITS();


          hold = 0;
          bits = 0; //===//
        } else if (state.head) {
          state.head.extra = null
          /*Z_NULL*/
          ;
        }

        state.mode = EXTRA;

      /* falls through */

      case EXTRA:
        if (state.flags & 0x0400) {
          copy = state.length;

          if (copy > have) {
            copy = have;
          }

          if (copy) {
            if (state.head) {
              len = state.head.extra_len - state.length;

              if (!state.head.extra) {
                // Use untyped array for more convenient processing later
                state.head.extra = new Array(state.head.extra_len);
              }

              utils.arraySet(state.head.extra, input, next, // extra field is limited to 65536 bytes
              // - no need for additional size check
              copy,
              /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
              len); //zmemcpy(state.head.extra + len, next,
              //        len + copy > state.head.extra_max ?
              //        state.head.extra_max - len : copy);
            }

            if (state.flags & 0x0200) {
              state.check = crc32(state.check, input, copy, next);
            }

            have -= copy;
            next += copy;
            state.length -= copy;
          }

          if (state.length) {
            break inf_leave;
          }
        }

        state.length = 0;
        state.mode = NAME;

      /* falls through */

      case NAME:
        if (state.flags & 0x0800) {
          if (have === 0) {
            break inf_leave;
          }

          copy = 0;

          do {
            // TODO: 2 or 1 bytes?
            len = input[next + copy++];
            /* use constant limit because in js we should not preallocate memory */

            if (state.head && len && state.length < 65536
            /*state.head.name_max*/
            ) {
              state.head.name += String.fromCharCode(len);
            }
          } while (len && copy < have);

          if (state.flags & 0x0200) {
            state.check = crc32(state.check, input, copy, next);
          }

          have -= copy;
          next += copy;

          if (len) {
            break inf_leave;
          }
        } else if (state.head) {
          state.head.name = null;
        }

        state.length = 0;
        state.mode = COMMENT;

      /* falls through */

      case COMMENT:
        if (state.flags & 0x1000) {
          if (have === 0) {
            break inf_leave;
          }

          copy = 0;

          do {
            len = input[next + copy++];
            /* use constant limit because in js we should not preallocate memory */

            if (state.head && len && state.length < 65536
            /*state.head.comm_max*/
            ) {
              state.head.comment += String.fromCharCode(len);
            }
          } while (len && copy < have);

          if (state.flags & 0x0200) {
            state.check = crc32(state.check, input, copy, next);
          }

          have -= copy;
          next += copy;

          if (len) {
            break inf_leave;
          }
        } else if (state.head) {
          state.head.comment = null;
        }

        state.mode = HCRC;

      /* falls through */

      case HCRC:
        if (state.flags & 0x0200) {
          //=== NEEDBITS(16); */
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }

            have--;
            hold += input[next++] << bits;
            bits += 8;
          } //===//


          if (hold !== (state.check & 0xffff)) {
            strm.msg = 'header crc mismatch';
            state.mode = BAD;
            break;
          } //=== INITBITS();


          hold = 0;
          bits = 0; //===//
        }

        if (state.head) {
          state.head.hcrc = state.flags >> 9 & 1;
          state.head.done = true;
        }

        strm.adler = state.check = 0;
        state.mode = TYPE;
        break;

      case DICTID:
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) {
            break inf_leave;
          }

          have--;
          hold += input[next++] << bits;
          bits += 8;
        } //===//


        strm.adler = state.check = zswap32(hold); //=== INITBITS();

        hold = 0;
        bits = 0; //===//

        state.mode = DICT;

      /* falls through */

      case DICT:
        if (state.havedict === 0) {
          //--- RESTORE() ---
          strm.next_out = put;
          strm.avail_out = left;
          strm.next_in = next;
          strm.avail_in = have;
          state.hold = hold;
          state.bits = bits; //---

          return Z_NEED_DICT;
        }

        strm.adler = state.check = 1
        /*adler32(0L, Z_NULL, 0)*/
        ;
        state.mode = TYPE;

      /* falls through */

      case TYPE:
        if (flush === Z_BLOCK || flush === Z_TREES) {
          break inf_leave;
        }

      /* falls through */

      case TYPEDO:
        if (state.last) {
          //--- BYTEBITS() ---//
          hold >>>= bits & 7;
          bits -= bits & 7; //---//

          state.mode = CHECK;
          break;
        } //=== NEEDBITS(3); */


        while (bits < 3) {
          if (have === 0) {
            break inf_leave;
          }

          have--;
          hold += input[next++] << bits;
          bits += 8;
        } //===//


        state.last = hold & 0x01
        /*BITS(1)*/
        ; //--- DROPBITS(1) ---//

        hold >>>= 1;
        bits -= 1; //---//

        switch (hold & 0x03) {
          /*BITS(2)*/
          case 0:
            /* stored block */
            //Tracev((stderr, "inflate:     stored block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = STORED;
            break;

          case 1:
            /* fixed block */
            fixedtables(state); //Tracev((stderr, "inflate:     fixed codes block%s\n",
            //        state.last ? " (last)" : ""));

            state.mode = LEN_;
            /* decode codes */

            if (flush === Z_TREES) {
              //--- DROPBITS(2) ---//
              hold >>>= 2;
              bits -= 2; //---//

              break inf_leave;
            }

            break;

          case 2:
            /* dynamic block */
            //Tracev((stderr, "inflate:     dynamic codes block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = TABLE;
            break;

          case 3:
            strm.msg = 'invalid block type';
            state.mode = BAD;
        } //--- DROPBITS(2) ---//


        hold >>>= 2;
        bits -= 2; //---//

        break;

      case STORED:
        //--- BYTEBITS() ---// /* go to byte boundary */
        hold >>>= bits & 7;
        bits -= bits & 7; //---//
        //=== NEEDBITS(32); */

        while (bits < 32) {
          if (have === 0) {
            break inf_leave;
          }

          have--;
          hold += input[next++] << bits;
          bits += 8;
        } //===//


        if ((hold & 0xffff) !== (hold >>> 16 ^ 0xffff)) {
          strm.msg = 'invalid stored block lengths';
          state.mode = BAD;
          break;
        }

        state.length = hold & 0xffff; //Tracev((stderr, "inflate:       stored length %u\n",
        //        state.length));
        //=== INITBITS();

        hold = 0;
        bits = 0; //===//

        state.mode = COPY_;

        if (flush === Z_TREES) {
          break inf_leave;
        }

      /* falls through */

      case COPY_:
        state.mode = COPY;

      /* falls through */

      case COPY:
        copy = state.length;

        if (copy) {
          if (copy > have) {
            copy = have;
          }

          if (copy > left) {
            copy = left;
          }

          if (copy === 0) {
            break inf_leave;
          } //--- zmemcpy(put, next, copy); ---


          utils.arraySet(output, input, next, copy, put); //---//

          have -= copy;
          next += copy;
          left -= copy;
          put += copy;
          state.length -= copy;
          break;
        } //Tracev((stderr, "inflate:       stored end\n"));


        state.mode = TYPE;
        break;

      case TABLE:
        //=== NEEDBITS(14); */
        while (bits < 14) {
          if (have === 0) {
            break inf_leave;
          }

          have--;
          hold += input[next++] << bits;
          bits += 8;
        } //===//


        state.nlen = (hold & 0x1f) +
        /*BITS(5)*/
        257; //--- DROPBITS(5) ---//

        hold >>>= 5;
        bits -= 5; //---//

        state.ndist = (hold & 0x1f) +
        /*BITS(5)*/
        1; //--- DROPBITS(5) ---//

        hold >>>= 5;
        bits -= 5; //---//

        state.ncode = (hold & 0x0f) +
        /*BITS(4)*/
        4; //--- DROPBITS(4) ---//

        hold >>>= 4;
        bits -= 4; //---//
        //#ifndef PKZIP_BUG_WORKAROUND

        if (state.nlen > 286 || state.ndist > 30) {
          strm.msg = 'too many length or distance symbols';
          state.mode = BAD;
          break;
        } //#endif
        //Tracev((stderr, "inflate:       table sizes ok\n"));


        state.have = 0;
        state.mode = LENLENS;

      /* falls through */

      case LENLENS:
        while (state.have < state.ncode) {
          //=== NEEDBITS(3);
          while (bits < 3) {
            if (have === 0) {
              break inf_leave;
            }

            have--;
            hold += input[next++] << bits;
            bits += 8;
          } //===//


          state.lens[order[state.have++]] = hold & 0x07; //BITS(3);
          //--- DROPBITS(3) ---//

          hold >>>= 3;
          bits -= 3; //---//
        }

        while (state.have < 19) {
          state.lens[order[state.have++]] = 0;
        } // We have separate tables & no pointers. 2 commented lines below not needed.
        //state.next = state.codes;
        //state.lencode = state.next;
        // Switch to use dynamic table


        state.lencode = state.lendyn;
        state.lenbits = 7;
        opts = {
          bits: state.lenbits
        };
        ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
        state.lenbits = opts.bits;

        if (ret) {
          strm.msg = 'invalid code lengths set';
          state.mode = BAD;
          break;
        } //Tracev((stderr, "inflate:       code lengths ok\n"));


        state.have = 0;
        state.mode = CODELENS;

      /* falls through */

      case CODELENS:
        while (state.have < state.nlen + state.ndist) {
          for (;;) {
            here = state.lencode[hold & (1 << state.lenbits) - 1];
            /*BITS(state.lenbits)*/

            here_bits = here >>> 24;
            here_op = here >>> 16 & 0xff;
            here_val = here & 0xffff;

            if (here_bits <= bits) {
              break;
            } //--- PULLBYTE() ---//


            if (have === 0) {
              break inf_leave;
            }

            have--;
            hold += input[next++] << bits;
            bits += 8; //---//
          }

          if (here_val < 16) {
            //--- DROPBITS(here.bits) ---//
            hold >>>= here_bits;
            bits -= here_bits; //---//

            state.lens[state.have++] = here_val;
          } else {
            if (here_val === 16) {
              //=== NEEDBITS(here.bits + 2);
              n = here_bits + 2;

              while (bits < n) {
                if (have === 0) {
                  break inf_leave;
                }

                have--;
                hold += input[next++] << bits;
                bits += 8;
              } //===//
              //--- DROPBITS(here.bits) ---//


              hold >>>= here_bits;
              bits -= here_bits; //---//

              if (state.have === 0) {
                strm.msg = 'invalid bit length repeat';
                state.mode = BAD;
                break;
              }

              len = state.lens[state.have - 1];
              copy = 3 + (hold & 0x03); //BITS(2);
              //--- DROPBITS(2) ---//

              hold >>>= 2;
              bits -= 2; //---//
            } else if (here_val === 17) {
              //=== NEEDBITS(here.bits + 3);
              n = here_bits + 3;

              while (bits < n) {
                if (have === 0) {
                  break inf_leave;
                }

                have--;
                hold += input[next++] << bits;
                bits += 8;
              } //===//
              //--- DROPBITS(here.bits) ---//


              hold >>>= here_bits;
              bits -= here_bits; //---//

              len = 0;
              copy = 3 + (hold & 0x07); //BITS(3);
              //--- DROPBITS(3) ---//

              hold >>>= 3;
              bits -= 3; //---//
            } else {
              //=== NEEDBITS(here.bits + 7);
              n = here_bits + 7;

              while (bits < n) {
                if (have === 0) {
                  break inf_leave;
                }

                have--;
                hold += input[next++] << bits;
                bits += 8;
              } //===//
              //--- DROPBITS(here.bits) ---//


              hold >>>= here_bits;
              bits -= here_bits; //---//

              len = 0;
              copy = 11 + (hold & 0x7f); //BITS(7);
              //--- DROPBITS(7) ---//

              hold >>>= 7;
              bits -= 7; //---//
            }

            if (state.have + copy > state.nlen + state.ndist) {
              strm.msg = 'invalid bit length repeat';
              state.mode = BAD;
              break;
            }

            while (copy--) {
              state.lens[state.have++] = len;
            }
          }
        }
        /* handle error breaks in while */


        if (state.mode === BAD) {
          break;
        }
        /* check for end-of-block code (better have one) */


        if (state.lens[256] === 0) {
          strm.msg = 'invalid code -- missing end-of-block';
          state.mode = BAD;
          break;
        }
        /* build code tables -- note: do not change the lenbits or distbits
           values here (9 and 6) without reading the comments in inftrees.h
           concerning the ENOUGH constants, which depend on those values */


        state.lenbits = 9;
        opts = {
          bits: state.lenbits
        };
        ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts); // We have separate tables & no pointers. 2 commented lines below not needed.
        // state.next_index = opts.table_index;

        state.lenbits = opts.bits; // state.lencode = state.next;

        if (ret) {
          strm.msg = 'invalid literal/lengths set';
          state.mode = BAD;
          break;
        }

        state.distbits = 6; //state.distcode.copy(state.codes);
        // Switch to use dynamic table

        state.distcode = state.distdyn;
        opts = {
          bits: state.distbits
        };
        ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts); // We have separate tables & no pointers. 2 commented lines below not needed.
        // state.next_index = opts.table_index;

        state.distbits = opts.bits; // state.distcode = state.next;

        if (ret) {
          strm.msg = 'invalid distances set';
          state.mode = BAD;
          break;
        } //Tracev((stderr, 'inflate:       codes ok\n'));


        state.mode = LEN_;

        if (flush === Z_TREES) {
          break inf_leave;
        }

      /* falls through */

      case LEN_:
        state.mode = LEN;

      /* falls through */

      case LEN:
        if (have >= 6 && left >= 258) {
          //--- RESTORE() ---
          strm.next_out = put;
          strm.avail_out = left;
          strm.next_in = next;
          strm.avail_in = have;
          state.hold = hold;
          state.bits = bits; //---

          inflate_fast(strm, _out); //--- LOAD() ---

          put = strm.next_out;
          output = strm.output;
          left = strm.avail_out;
          next = strm.next_in;
          input = strm.input;
          have = strm.avail_in;
          hold = state.hold;
          bits = state.bits; //---

          if (state.mode === TYPE) {
            state.back = -1;
          }

          break;
        }

        state.back = 0;

        for (;;) {
          here = state.lencode[hold & (1 << state.lenbits) - 1];
          /*BITS(state.lenbits)*/

          here_bits = here >>> 24;
          here_op = here >>> 16 & 0xff;
          here_val = here & 0xffff;

          if (here_bits <= bits) {
            break;
          } //--- PULLBYTE() ---//


          if (have === 0) {
            break inf_leave;
          }

          have--;
          hold += input[next++] << bits;
          bits += 8; //---//
        }

        if (here_op && (here_op & 0xf0) === 0) {
          last_bits = here_bits;
          last_op = here_op;
          last_val = here_val;

          for (;;) {
            here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >>
            /*BITS(last.bits + last.op)*/
            last_bits)];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 0xff;
            here_val = here & 0xffff;

            if (last_bits + here_bits <= bits) {
              break;
            } //--- PULLBYTE() ---//


            if (have === 0) {
              break inf_leave;
            }

            have--;
            hold += input[next++] << bits;
            bits += 8; //---//
          } //--- DROPBITS(last.bits) ---//


          hold >>>= last_bits;
          bits -= last_bits; //---//

          state.back += last_bits;
        } //--- DROPBITS(here.bits) ---//


        hold >>>= here_bits;
        bits -= here_bits; //---//

        state.back += here_bits;
        state.length = here_val;

        if (here_op === 0) {
          //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
          //        "inflate:         literal '%c'\n" :
          //        "inflate:         literal 0x%02x\n", here.val));
          state.mode = LIT;
          break;
        }

        if (here_op & 32) {
          //Tracevv((stderr, "inflate:         end of block\n"));
          state.back = -1;
          state.mode = TYPE;
          break;
        }

        if (here_op & 64) {
          strm.msg = 'invalid literal/length code';
          state.mode = BAD;
          break;
        }

        state.extra = here_op & 15;
        state.mode = LENEXT;

      /* falls through */

      case LENEXT:
        if (state.extra) {
          //=== NEEDBITS(state.extra);
          n = state.extra;

          while (bits < n) {
            if (have === 0) {
              break inf_leave;
            }

            have--;
            hold += input[next++] << bits;
            bits += 8;
          } //===//


          state.length += hold & (1 << state.extra) - 1
          /*BITS(state.extra)*/
          ; //--- DROPBITS(state.extra) ---//

          hold >>>= state.extra;
          bits -= state.extra; //---//

          state.back += state.extra;
        } //Tracevv((stderr, "inflate:         length %u\n", state.length));


        state.was = state.length;
        state.mode = DIST;

      /* falls through */

      case DIST:
        for (;;) {
          here = state.distcode[hold & (1 << state.distbits) - 1];
          /*BITS(state.distbits)*/

          here_bits = here >>> 24;
          here_op = here >>> 16 & 0xff;
          here_val = here & 0xffff;

          if (here_bits <= bits) {
            break;
          } //--- PULLBYTE() ---//


          if (have === 0) {
            break inf_leave;
          }

          have--;
          hold += input[next++] << bits;
          bits += 8; //---//
        }

        if ((here_op & 0xf0) === 0) {
          last_bits = here_bits;
          last_op = here_op;
          last_val = here_val;

          for (;;) {
            here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >>
            /*BITS(last.bits + last.op)*/
            last_bits)];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 0xff;
            here_val = here & 0xffff;

            if (last_bits + here_bits <= bits) {
              break;
            } //--- PULLBYTE() ---//


            if (have === 0) {
              break inf_leave;
            }

            have--;
            hold += input[next++] << bits;
            bits += 8; //---//
          } //--- DROPBITS(last.bits) ---//


          hold >>>= last_bits;
          bits -= last_bits; //---//

          state.back += last_bits;
        } //--- DROPBITS(here.bits) ---//


        hold >>>= here_bits;
        bits -= here_bits; //---//

        state.back += here_bits;

        if (here_op & 64) {
          strm.msg = 'invalid distance code';
          state.mode = BAD;
          break;
        }

        state.offset = here_val;
        state.extra = here_op & 15;
        state.mode = DISTEXT;

      /* falls through */

      case DISTEXT:
        if (state.extra) {
          //=== NEEDBITS(state.extra);
          n = state.extra;

          while (bits < n) {
            if (have === 0) {
              break inf_leave;
            }

            have--;
            hold += input[next++] << bits;
            bits += 8;
          } //===//


          state.offset += hold & (1 << state.extra) - 1
          /*BITS(state.extra)*/
          ; //--- DROPBITS(state.extra) ---//

          hold >>>= state.extra;
          bits -= state.extra; //---//

          state.back += state.extra;
        } //#ifdef INFLATE_STRICT


        if (state.offset > state.dmax) {
          strm.msg = 'invalid distance too far back';
          state.mode = BAD;
          break;
        } //#endif
        //Tracevv((stderr, "inflate:         distance %u\n", state.offset));


        state.mode = MATCH;

      /* falls through */

      case MATCH:
        if (left === 0) {
          break inf_leave;
        }

        copy = _out - left;

        if (state.offset > copy) {
          /* copy from window */
          copy = state.offset - copy;

          if (copy > state.whave) {
            if (state.sane) {
              strm.msg = 'invalid distance too far back';
              state.mode = BAD;
              break;
            } // (!) This block is disabled in zlib defaults,
            // don't enable it for binary compatibility
            //#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
            //          Trace((stderr, "inflate.c too far\n"));
            //          copy -= state.whave;
            //          if (copy > state.length) { copy = state.length; }
            //          if (copy > left) { copy = left; }
            //          left -= copy;
            //          state.length -= copy;
            //          do {
            //            output[put++] = 0;
            //          } while (--copy);
            //          if (state.length === 0) { state.mode = LEN; }
            //          break;
            //#endif

          }

          if (copy > state.wnext) {
            copy -= state.wnext;
            from = state.wsize - copy;
          } else {
            from = state.wnext - copy;
          }

          if (copy > state.length) {
            copy = state.length;
          }

          from_source = state.window;
        } else {
          /* copy from output */
          from_source = output;
          from = put - state.offset;
          copy = state.length;
        }

        if (copy > left) {
          copy = left;
        }

        left -= copy;
        state.length -= copy;

        do {
          output[put++] = from_source[from++];
        } while (--copy);

        if (state.length === 0) {
          state.mode = LEN;
        }

        break;

      case LIT:
        if (left === 0) {
          break inf_leave;
        }

        output[put++] = state.length;
        left--;
        state.mode = LEN;
        break;

      case CHECK:
        if (state.wrap) {
          //=== NEEDBITS(32);
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }

            have--; // Use '|' instead of '+' to make sure that result is signed

            hold |= input[next++] << bits;
            bits += 8;
          } //===//


          _out -= left;
          strm.total_out += _out;
          state.total += _out;

          if (_out) {
            strm.adler = state.check =
            /*UPDATE(state.check, put - _out, _out);*/
            state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out);
          }

          _out = left; // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too

          if ((state.flags ? hold : zswap32(hold)) !== state.check) {
            strm.msg = 'incorrect data check';
            state.mode = BAD;
            break;
          } //=== INITBITS();


          hold = 0;
          bits = 0; //===//
          //Tracev((stderr, "inflate:   check matches trailer\n"));
        }

        state.mode = LENGTH;

      /* falls through */

      case LENGTH:
        if (state.wrap && state.flags) {
          //=== NEEDBITS(32);
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }

            have--;
            hold += input[next++] << bits;
            bits += 8;
          } //===//


          if (hold !== (state.total & 0xffffffff)) {
            strm.msg = 'incorrect length check';
            state.mode = BAD;
            break;
          } //=== INITBITS();


          hold = 0;
          bits = 0; //===//
          //Tracev((stderr, "inflate:   length matches trailer\n"));
        }

        state.mode = DONE;

      /* falls through */

      case DONE:
        ret = Z_STREAM_END;
        break inf_leave;

      case BAD:
        ret = Z_DATA_ERROR;
        break inf_leave;

      case MEM:
        return Z_MEM_ERROR;

      case SYNC:
      /* falls through */

      default:
        return Z_STREAM_ERROR;
    }
  } // inf_leave <- here is real place for "goto inf_leave", emulated via "break inf_leave"

  /*
     Return from inflate(), updating the total counts and the check value.
     If there was no progress during the inflate() call, return a buffer
     error.  Call updatewindow() to create and/or update the window state.
     Note: a memory error from inflate() is non-recoverable.
   */
  //--- RESTORE() ---


  strm.next_out = put;
  strm.avail_out = left;
  strm.next_in = next;
  strm.avail_in = have;
  state.hold = hold;
  state.bits = bits; //---

  if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH)) {
    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
      state.mode = MEM;
      return Z_MEM_ERROR;
    }
  }

  _in -= strm.avail_in;
  _out -= strm.avail_out;
  strm.total_in += _in;
  strm.total_out += _out;
  state.total += _out;

  if (state.wrap && _out) {
    strm.adler = state.check =
    /*UPDATE(state.check, strm.next_out - _out, _out);*/
    state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out);
  }

  strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);

  if ((_in === 0 && _out === 0 || flush === Z_FINISH) && ret === Z_OK) {
    ret = Z_BUF_ERROR;
  }

  return ret;
}

function inflateEnd(strm) {
  if (!strm || !strm.state
  /*|| strm->zfree == (free_func)0*/
  ) {
      return Z_STREAM_ERROR;
    }

  var state = strm.state;

  if (state.window) {
    state.window = null;
  }

  strm.state = null;
  return Z_OK;
}

function inflateGetHeader(strm, head) {
  var state;
  /* check state */

  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }

  state = strm.state;

  if ((state.wrap & 2) === 0) {
    return Z_STREAM_ERROR;
  }
  /* save header structure */


  state.head = head;
  head.done = false;
  return Z_OK;
}

function inflateSetDictionary(strm, dictionary) {
  var dictLength = dictionary.length;
  var state;
  var dictid;
  var ret;
  /* check state */

  if (!strm
  /* == Z_NULL */
  || !strm.state
  /* == Z_NULL */
  ) {
      return Z_STREAM_ERROR;
    }

  state = strm.state;

  if (state.wrap !== 0 && state.mode !== DICT) {
    return Z_STREAM_ERROR;
  }
  /* check for correct dictionary identifier */


  if (state.mode === DICT) {
    dictid = 1;
    /* adler32(0, null, 0)*/

    /* dictid = adler32(dictid, dictionary, dictLength); */

    dictid = adler32(dictid, dictionary, dictLength, 0);

    if (dictid !== state.check) {
      return Z_DATA_ERROR;
    }
  }
  /* copy dictionary to window using updatewindow(), which will amend the
   existing dictionary if appropriate */


  ret = updatewindow(strm, dictionary, dictLength, dictLength);

  if (ret) {
    state.mode = MEM;
    return Z_MEM_ERROR;
  }

  state.havedict = 1; // Tracev((stderr, "inflate:   dictionary set\n"));

  return Z_OK;
}

exports.inflateReset = inflateReset;
exports.inflateReset2 = inflateReset2;
exports.inflateResetKeep = inflateResetKeep;
exports.inflateInit = inflateInit;
exports.inflateInit2 = inflateInit2;
exports.inflate = inflate;
exports.inflateEnd = inflateEnd;
exports.inflateGetHeader = inflateGetHeader;
exports.inflateSetDictionary = inflateSetDictionary;
exports.inflateInfo = 'pako inflate (from Nodeca project)';
/* Not implemented
exports.inflateCopy = inflateCopy;
exports.inflateGetDictionary = inflateGetDictionary;
exports.inflateMark = inflateMark;
exports.inflatePrime = inflatePrime;
exports.inflateSync = inflateSync;
exports.inflateSyncPoint = inflateSyncPoint;
exports.inflateUndermine = inflateUndermine;
*/

/***/ }),

/***/ "./node_modules/pako/lib/zlib/inftrees.js":
/*!************************************************!*\
  !*** ./node_modules/pako/lib/zlib/inftrees.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var utils = __webpack_require__(/*! ../utils/common */ "./node_modules/pako/lib/utils/common.js");

var MAXBITS = 15;
var ENOUGH_LENS = 852;
var ENOUGH_DISTS = 592; //var ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);

var CODES = 0;
var LENS = 1;
var DISTS = 2;
var lbase = [
/* Length codes 257..285 base */
3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0];
var lext = [
/* Length codes 257..285 extra */
16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78];
var dbase = [
/* Distance codes 0..29 base */
1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0];
var dext = [
/* Distance codes 0..29 extra */
16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];

module.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts) {
  var bits = opts.bits; //here = opts.here; /* table entry for duplication */

  var len = 0;
  /* a code's length in bits */

  var sym = 0;
  /* index of code symbols */

  var min = 0,
      max = 0;
  /* minimum and maximum code lengths */

  var root = 0;
  /* number of index bits for root table */

  var curr = 0;
  /* number of index bits for current table */

  var drop = 0;
  /* code bits to drop for sub-table */

  var left = 0;
  /* number of prefix codes available */

  var used = 0;
  /* code entries in table used */

  var huff = 0;
  /* Huffman code */

  var incr;
  /* for incrementing code, index */

  var fill;
  /* index for replicating entries */

  var low;
  /* low bits for current root entry */

  var mask;
  /* mask for low root bits */

  var next;
  /* next available space in table */

  var base = null;
  /* base value table to use */

  var base_index = 0; //  var shoextra;    /* extra bits table to use */

  var end;
  /* use base and extra for symbol > end */

  var count = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */

  var offs = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */

  var extra = null;
  var extra_index = 0;
  var here_bits, here_op, here_val;
  /*
   Process a set of code lengths to create a canonical Huffman code.  The
   code lengths are lens[0..codes-1].  Each length corresponds to the
   symbols 0..codes-1.  The Huffman code is generated by first sorting the
   symbols by length from short to long, and retaining the symbol order
   for codes with equal lengths.  Then the code starts with all zero bits
   for the first code of the shortest length, and the codes are integer
   increments for the same length, and zeros are appended as the length
   increases.  For the deflate format, these bits are stored backwards
   from their more natural integer increment ordering, and so when the
   decoding tables are built in the large loop below, the integer codes
   are incremented backwards.
    This routine assumes, but does not check, that all of the entries in
   lens[] are in the range 0..MAXBITS.  The caller must assure this.
   1..MAXBITS is interpreted as that code length.  zero means that that
   symbol does not occur in this code.
    The codes are sorted by computing a count of codes for each length,
   creating from that a table of starting indices for each length in the
   sorted table, and then entering the symbols in order in the sorted
   table.  The sorted table is work[], with that space being provided by
   the caller.
    The length counts are used for other purposes as well, i.e. finding
   the minimum and maximum length codes, determining if there are any
   codes at all, checking for a valid set of lengths, and looking ahead
   at length counts to determine sub-table sizes when building the
   decoding tables.
   */

  /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */

  for (len = 0; len <= MAXBITS; len++) {
    count[len] = 0;
  }

  for (sym = 0; sym < codes; sym++) {
    count[lens[lens_index + sym]]++;
  }
  /* bound code lengths, force root to be within code lengths */


  root = bits;

  for (max = MAXBITS; max >= 1; max--) {
    if (count[max] !== 0) {
      break;
    }
  }

  if (root > max) {
    root = max;
  }

  if (max === 0) {
    /* no symbols to code at all */
    //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */
    //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;
    //table.val[opts.table_index++] = 0;   //here.val = (var short)0;
    table[table_index++] = 1 << 24 | 64 << 16 | 0; //table.op[opts.table_index] = 64;
    //table.bits[opts.table_index] = 1;
    //table.val[opts.table_index++] = 0;

    table[table_index++] = 1 << 24 | 64 << 16 | 0;
    opts.bits = 1;
    return 0;
    /* no symbols, but wait for decoding to report error */
  }

  for (min = 1; min < max; min++) {
    if (count[min] !== 0) {
      break;
    }
  }

  if (root < min) {
    root = min;
  }
  /* check for an over-subscribed or incomplete set of lengths */


  left = 1;

  for (len = 1; len <= MAXBITS; len++) {
    left <<= 1;
    left -= count[len];

    if (left < 0) {
      return -1;
    }
    /* over-subscribed */

  }

  if (left > 0 && (type === CODES || max !== 1)) {
    return -1;
    /* incomplete set */
  }
  /* generate offsets into symbol table for each length for sorting */


  offs[1] = 0;

  for (len = 1; len < MAXBITS; len++) {
    offs[len + 1] = offs[len] + count[len];
  }
  /* sort symbols by length, by symbol order within each length */


  for (sym = 0; sym < codes; sym++) {
    if (lens[lens_index + sym] !== 0) {
      work[offs[lens[lens_index + sym]]++] = sym;
    }
  }
  /*
   Create and fill in decoding tables.  In this loop, the table being
   filled is at next and has curr index bits.  The code being used is huff
   with length len.  That code is converted to an index by dropping drop
   bits off of the bottom.  For codes where len is less than drop + curr,
   those top drop + curr - len bits are incremented through all values to
   fill the table with replicated entries.
    root is the number of index bits for the root table.  When len exceeds
   root, sub-tables are created pointed to by the root entry with an index
   of the low root bits of huff.  This is saved in low to check for when a
   new sub-table should be started.  drop is zero when the root table is
   being filled, and drop is root when sub-tables are being filled.
    When a new sub-table is needed, it is necessary to look ahead in the
   code lengths to determine what size sub-table is needed.  The length
   counts are used for this, and so count[] is decremented as codes are
   entered in the tables.
    used keeps track of how many table entries have been allocated from the
   provided *table space.  It is checked for LENS and DIST tables against
   the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
   the initial root table size constants.  See the comments in inftrees.h
   for more information.
    sym increments through all symbols, and the loop terminates when
   all codes of length max, i.e. all codes, have been processed.  This
   routine permits incomplete codes, so another loop after this one fills
   in the rest of the decoding tables with invalid code markers.
   */

  /* set up for code type */
  // poor man optimization - use if-else instead of switch,
  // to avoid deopts in old v8


  if (type === CODES) {
    base = extra = work;
    /* dummy value--not used */

    end = 19;
  } else if (type === LENS) {
    base = lbase;
    base_index -= 257;
    extra = lext;
    extra_index -= 257;
    end = 256;
  } else {
    /* DISTS */
    base = dbase;
    extra = dext;
    end = -1;
  }
  /* initialize opts for loop */


  huff = 0;
  /* starting code */

  sym = 0;
  /* starting code symbol */

  len = min;
  /* starting code length */

  next = table_index;
  /* current table to fill in */

  curr = root;
  /* current table index bits */

  drop = 0;
  /* current bits to drop from code for index */

  low = -1;
  /* trigger new sub-table when len > root */

  used = 1 << root;
  /* use root table entries */

  mask = used - 1;
  /* mask for comparing low */

  /* check available table space */

  if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
    return 1;
  }
  /* process all codes and make table entries */


  for (;;) {
    /* create table entry */
    here_bits = len - drop;

    if (work[sym] < end) {
      here_op = 0;
      here_val = work[sym];
    } else if (work[sym] > end) {
      here_op = extra[extra_index + work[sym]];
      here_val = base[base_index + work[sym]];
    } else {
      here_op = 32 + 64;
      /* end of block */

      here_val = 0;
    }
    /* replicate for those indices with low len bits equal to huff */


    incr = 1 << len - drop;
    fill = 1 << curr;
    min = fill;
    /* save offset to next table */

    do {
      fill -= incr;
      table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
    } while (fill !== 0);
    /* backwards increment the len-bit code huff */


    incr = 1 << len - 1;

    while (huff & incr) {
      incr >>= 1;
    }

    if (incr !== 0) {
      huff &= incr - 1;
      huff += incr;
    } else {
      huff = 0;
    }
    /* go to next symbol, update count, len */


    sym++;

    if (--count[len] === 0) {
      if (len === max) {
        break;
      }

      len = lens[lens_index + work[sym]];
    }
    /* create new sub-table if needed */


    if (len > root && (huff & mask) !== low) {
      /* if first time, transition to sub-tables */
      if (drop === 0) {
        drop = root;
      }
      /* increment past last table */


      next += min;
      /* here min is 1 << curr */

      /* determine length of next table */

      curr = len - drop;
      left = 1 << curr;

      while (curr + drop < max) {
        left -= count[curr + drop];

        if (left <= 0) {
          break;
        }

        curr++;
        left <<= 1;
      }
      /* check for enough space */


      used += 1 << curr;

      if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
        return 1;
      }
      /* point entry in root table to sub-table */


      low = huff & mask;
      /*table.op[low] = curr;
      table.bits[low] = root;
      table.val[low] = next - opts.table_index;*/

      table[low] = root << 24 | curr << 16 | next - table_index | 0;
    }
  }
  /* fill in remaining table entry if code is incomplete (guaranteed to have
   at most one remaining entry, since if the code is incomplete, the
   maximum code length that was allowed to get this far is one bit) */


  if (huff !== 0) {
    //table.op[next + huff] = 64;            /* invalid code marker */
    //table.bits[next + huff] = len - drop;
    //table.val[next + huff] = 0;
    table[next + huff] = len - drop << 24 | 64 << 16 | 0;
  }
  /* set return parameters */
  //opts.table_index += used;


  opts.bits = root;
  return 0;
};

/***/ }),

/***/ "./node_modules/pako/lib/zlib/messages.js":
/*!************************************************!*\
  !*** ./node_modules/pako/lib/zlib/messages.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

module.exports = {
  2: 'need dictionary',

  /* Z_NEED_DICT       2  */
  1: 'stream end',

  /* Z_STREAM_END      1  */
  0: '',

  /* Z_OK              0  */
  '-1': 'file error',

  /* Z_ERRNO         (-1) */
  '-2': 'stream error',

  /* Z_STREAM_ERROR  (-2) */
  '-3': 'data error',

  /* Z_DATA_ERROR    (-3) */
  '-4': 'insufficient memory',

  /* Z_MEM_ERROR     (-4) */
  '-5': 'buffer error',

  /* Z_BUF_ERROR     (-5) */
  '-6': 'incompatible version'
  /* Z_VERSION_ERROR (-6) */

};

/***/ }),

/***/ "./node_modules/pako/lib/zlib/trees.js":
/*!*********************************************!*\
  !*** ./node_modules/pako/lib/zlib/trees.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var utils = __webpack_require__(/*! ../utils/common */ "./node_modules/pako/lib/utils/common.js");
/* Public constants ==========================================================*/

/* ===========================================================================*/
//var Z_FILTERED          = 1;
//var Z_HUFFMAN_ONLY      = 2;
//var Z_RLE               = 3;


var Z_FIXED = 4; //var Z_DEFAULT_STRATEGY  = 0;

/* Possible values of the data_type field (though see inflate()) */

var Z_BINARY = 0;
var Z_TEXT = 1; //var Z_ASCII             = 1; // = Z_TEXT

var Z_UNKNOWN = 2;
/*============================================================================*/

function zero(buf) {
  var len = buf.length;

  while (--len >= 0) {
    buf[len] = 0;
  }
} // From zutil.h


var STORED_BLOCK = 0;
var STATIC_TREES = 1;
var DYN_TREES = 2;
/* The three kinds of block type */

var MIN_MATCH = 3;
var MAX_MATCH = 258;
/* The minimum and maximum match lengths */
// From deflate.h

/* ===========================================================================
 * Internal compression state.
 */

var LENGTH_CODES = 29;
/* number of length codes, not counting the special END_BLOCK code */

var LITERALS = 256;
/* number of literal bytes 0..255 */

var L_CODES = LITERALS + 1 + LENGTH_CODES;
/* number of Literal or Length codes, including the END_BLOCK code */

var D_CODES = 30;
/* number of distance codes */

var BL_CODES = 19;
/* number of codes used to transfer the bit lengths */

var HEAP_SIZE = 2 * L_CODES + 1;
/* maximum heap size */

var MAX_BITS = 15;
/* All codes must not exceed MAX_BITS bits */

var Buf_size = 16;
/* size of bit buffer in bi_buf */

/* ===========================================================================
 * Constants
 */

var MAX_BL_BITS = 7;
/* Bit length codes must not exceed MAX_BL_BITS bits */

var END_BLOCK = 256;
/* end of block literal code */

var REP_3_6 = 16;
/* repeat previous bit length 3-6 times (2 bits of repeat count) */

var REPZ_3_10 = 17;
/* repeat a zero length 3-10 times  (3 bits of repeat count) */

var REPZ_11_138 = 18;
/* repeat a zero length 11-138 times  (7 bits of repeat count) */

/* eslint-disable comma-spacing,array-bracket-spacing */

var extra_lbits =
/* extra bits for each length code */
[0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0];
var extra_dbits =
/* extra bits for each distance code */
[0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];
var extra_blbits =
/* extra bits for each bit length code */
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7];
var bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
/* eslint-enable comma-spacing,array-bracket-spacing */

/* The lengths of the bit length codes are sent in order of decreasing
 * probability, to avoid transmitting the lengths for unused bit length codes.
 */

/* ===========================================================================
 * Local data. These are initialized only once.
 */
// We pre-fill arrays with 0 to avoid uninitialized gaps

var DIST_CODE_LEN = 512;
/* see definition of array dist_code below */
// !!!! Use flat array instead of structure, Freq = i*2, Len = i*2+1

var static_ltree = new Array((L_CODES + 2) * 2);
zero(static_ltree);
/* The static literal tree. Since the bit lengths are imposed, there is no
 * need for the L_CODES extra codes used during heap construction. However
 * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
 * below).
 */

var static_dtree = new Array(D_CODES * 2);
zero(static_dtree);
/* The static distance tree. (Actually a trivial tree since all codes use
 * 5 bits.)
 */

var _dist_code = new Array(DIST_CODE_LEN);

zero(_dist_code);
/* Distance codes. The first 256 values correspond to the distances
 * 3 .. 258, the last 256 values correspond to the top 8 bits of
 * the 15 bit distances.
 */

var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);

zero(_length_code);
/* length code for each normalized match length (0 == MIN_MATCH) */

var base_length = new Array(LENGTH_CODES);
zero(base_length);
/* First normalized length for each code (0 = MIN_MATCH) */

var base_dist = new Array(D_CODES);
zero(base_dist);
/* First normalized distance for each code (0 = distance of 1) */

function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
  this.static_tree = static_tree;
  /* static tree or NULL */

  this.extra_bits = extra_bits;
  /* extra bits for each code or NULL */

  this.extra_base = extra_base;
  /* base index for extra_bits */

  this.elems = elems;
  /* max number of elements in the tree */

  this.max_length = max_length;
  /* max bit length for the codes */
  // show if `static_tree` has data or dummy - needed for monomorphic objects

  this.has_stree = static_tree && static_tree.length;
}

var static_l_desc;
var static_d_desc;
var static_bl_desc;

function TreeDesc(dyn_tree, stat_desc) {
  this.dyn_tree = dyn_tree;
  /* the dynamic tree */

  this.max_code = 0;
  /* largest code with non zero frequency */

  this.stat_desc = stat_desc;
  /* the corresponding static tree */
}

function d_code(dist) {
  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
}
/* ===========================================================================
 * Output a short LSB first on the stream.
 * IN assertion: there is enough room in pendingBuf.
 */


function put_short(s, w) {
  //    put_byte(s, (uch)((w) & 0xff));
  //    put_byte(s, (uch)((ush)(w) >> 8));
  s.pending_buf[s.pending++] = w & 0xff;
  s.pending_buf[s.pending++] = w >>> 8 & 0xff;
}
/* ===========================================================================
 * Send a value on a given number of bits.
 * IN assertion: length <= 16 and value fits in length bits.
 */


function send_bits(s, value, length) {
  if (s.bi_valid > Buf_size - length) {
    s.bi_buf |= value << s.bi_valid & 0xffff;
    put_short(s, s.bi_buf);
    s.bi_buf = value >> Buf_size - s.bi_valid;
    s.bi_valid += length - Buf_size;
  } else {
    s.bi_buf |= value << s.bi_valid & 0xffff;
    s.bi_valid += length;
  }
}

function send_code(s, c, tree) {
  send_bits(s, tree[c * 2]
  /*.Code*/
  , tree[c * 2 + 1]
  /*.Len*/
  );
}
/* ===========================================================================
 * Reverse the first len bits of a code, using straightforward code (a faster
 * method would use a table)
 * IN assertion: 1 <= len <= 15
 */


function bi_reverse(code, len) {
  var res = 0;

  do {
    res |= code & 1;
    code >>>= 1;
    res <<= 1;
  } while (--len > 0);

  return res >>> 1;
}
/* ===========================================================================
 * Flush the bit buffer, keeping at most 7 bits in it.
 */


function bi_flush(s) {
  if (s.bi_valid === 16) {
    put_short(s, s.bi_buf);
    s.bi_buf = 0;
    s.bi_valid = 0;
  } else if (s.bi_valid >= 8) {
    s.pending_buf[s.pending++] = s.bi_buf & 0xff;
    s.bi_buf >>= 8;
    s.bi_valid -= 8;
  }
}
/* ===========================================================================
 * Compute the optimal bit lengths for a tree and update the total bit length
 * for the current block.
 * IN assertion: the fields freq and dad are set, heap[heap_max] and
 *    above are the tree nodes sorted by increasing frequency.
 * OUT assertions: the field len is set to the optimal bit length, the
 *     array bl_count contains the frequencies for each bit length.
 *     The length opt_len is updated; static_len is also updated if stree is
 *     not null.
 */


function gen_bitlen(s, desc) //    deflate_state *s;
//    tree_desc *desc;    /* the tree descriptor */
{
  var tree = desc.dyn_tree;
  var max_code = desc.max_code;
  var stree = desc.stat_desc.static_tree;
  var has_stree = desc.stat_desc.has_stree;
  var extra = desc.stat_desc.extra_bits;
  var base = desc.stat_desc.extra_base;
  var max_length = desc.stat_desc.max_length;
  var h;
  /* heap index */

  var n, m;
  /* iterate over the tree elements */

  var bits;
  /* bit length */

  var xbits;
  /* extra bits */

  var f;
  /* frequency */

  var overflow = 0;
  /* number of elements with bit length too large */

  for (bits = 0; bits <= MAX_BITS; bits++) {
    s.bl_count[bits] = 0;
  }
  /* In a first pass, compute the optimal bit lengths (which may
   * overflow in the case of the bit length tree).
   */


  tree[s.heap[s.heap_max] * 2 + 1]
  /*.Len*/
  = 0;
  /* root of the heap */

  for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
    n = s.heap[h];
    bits = tree[tree[n * 2 + 1]
    /*.Dad*/
    * 2 + 1]
    /*.Len*/
    + 1;

    if (bits > max_length) {
      bits = max_length;
      overflow++;
    }

    tree[n * 2 + 1]
    /*.Len*/
    = bits;
    /* We overwrite tree[n].Dad which is no longer needed */

    if (n > max_code) {
      continue;
    }
    /* not a leaf node */


    s.bl_count[bits]++;
    xbits = 0;

    if (n >= base) {
      xbits = extra[n - base];
    }

    f = tree[n * 2]
    /*.Freq*/
    ;
    s.opt_len += f * (bits + xbits);

    if (has_stree) {
      s.static_len += f * (stree[n * 2 + 1]
      /*.Len*/
      + xbits);
    }
  }

  if (overflow === 0) {
    return;
  } // Trace((stderr,"\nbit length overflow\n"));

  /* This happens for example on obj2 and pic of the Calgary corpus */

  /* Find the first bit length which could increase: */


  do {
    bits = max_length - 1;

    while (s.bl_count[bits] === 0) {
      bits--;
    }

    s.bl_count[bits]--;
    /* move one leaf down the tree */

    s.bl_count[bits + 1] += 2;
    /* move one overflow item as its brother */

    s.bl_count[max_length]--;
    /* The brother of the overflow item also moves one step up,
     * but this does not affect bl_count[max_length]
     */

    overflow -= 2;
  } while (overflow > 0);
  /* Now recompute all bit lengths, scanning in increasing frequency.
   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
   * lengths instead of fixing only the wrong ones. This idea is taken
   * from 'ar' written by Haruhiko Okumura.)
   */


  for (bits = max_length; bits !== 0; bits--) {
    n = s.bl_count[bits];

    while (n !== 0) {
      m = s.heap[--h];

      if (m > max_code) {
        continue;
      }

      if (tree[m * 2 + 1]
      /*.Len*/
      !== bits) {
        // Trace((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
        s.opt_len += (bits - tree[m * 2 + 1]
        /*.Len*/
        ) * tree[m * 2]
        /*.Freq*/
        ;
        tree[m * 2 + 1]
        /*.Len*/
        = bits;
      }

      n--;
    }
  }
}
/* ===========================================================================
 * Generate the codes for a given tree and bit counts (which need not be
 * optimal).
 * IN assertion: the array bl_count contains the bit length statistics for
 * the given tree and the field len is set for all tree elements.
 * OUT assertion: the field code is set for all tree elements of non
 *     zero code length.
 */


function gen_codes(tree, max_code, bl_count) //    ct_data *tree;             /* the tree to decorate */
//    int max_code;              /* largest code with non zero frequency */
//    ushf *bl_count;            /* number of codes at each bit length */
{
  var next_code = new Array(MAX_BITS + 1);
  /* next code value for each bit length */

  var code = 0;
  /* running code value */

  var bits;
  /* bit index */

  var n;
  /* code index */

  /* The distribution counts are first used to generate the code values
   * without bit reversal.
   */

  for (bits = 1; bits <= MAX_BITS; bits++) {
    next_code[bits] = code = code + bl_count[bits - 1] << 1;
  }
  /* Check that the bit counts in bl_count are consistent. The last code
   * must be all ones.
   */
  //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
  //        "inconsistent bit counts");
  //Tracev((stderr,"\ngen_codes: max_code %d ", max_code));


  for (n = 0; n <= max_code; n++) {
    var len = tree[n * 2 + 1]
    /*.Len*/
    ;

    if (len === 0) {
      continue;
    }
    /* Now reverse the bits */


    tree[n * 2]
    /*.Code*/
    = bi_reverse(next_code[len]++, len); //Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
    //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
  }
}
/* ===========================================================================
 * Initialize the various 'constant' tables.
 */


function tr_static_init() {
  var n;
  /* iterates over tree elements */

  var bits;
  /* bit counter */

  var length;
  /* length value */

  var code;
  /* code value */

  var dist;
  /* distance index */

  var bl_count = new Array(MAX_BITS + 1);
  /* number of codes at each bit length for an optimal tree */
  // do check in _tr_init()
  //if (static_init_done) return;

  /* For some embedded targets, global variables are not initialized: */

  /*#ifdef NO_INIT_GLOBAL_POINTERS
    static_l_desc.static_tree = static_ltree;
    static_l_desc.extra_bits = extra_lbits;
    static_d_desc.static_tree = static_dtree;
    static_d_desc.extra_bits = extra_dbits;
    static_bl_desc.extra_bits = extra_blbits;
  #endif*/

  /* Initialize the mapping length (0..255) -> length code (0..28) */

  length = 0;

  for (code = 0; code < LENGTH_CODES - 1; code++) {
    base_length[code] = length;

    for (n = 0; n < 1 << extra_lbits[code]; n++) {
      _length_code[length++] = code;
    }
  } //Assert (length == 256, "tr_static_init: length != 256");

  /* Note that the length 255 (match length 258) can be represented
   * in two different ways: code 284 + 5 bits or code 285, so we
   * overwrite length_code[255] to use the best encoding:
   */


  _length_code[length - 1] = code;
  /* Initialize the mapping dist (0..32K) -> dist code (0..29) */

  dist = 0;

  for (code = 0; code < 16; code++) {
    base_dist[code] = dist;

    for (n = 0; n < 1 << extra_dbits[code]; n++) {
      _dist_code[dist++] = code;
    }
  } //Assert (dist == 256, "tr_static_init: dist != 256");


  dist >>= 7;
  /* from now on, all distances are divided by 128 */

  for (; code < D_CODES; code++) {
    base_dist[code] = dist << 7;

    for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {
      _dist_code[256 + dist++] = code;
    }
  } //Assert (dist == 256, "tr_static_init: 256+dist != 512");

  /* Construct the codes of the static literal tree */


  for (bits = 0; bits <= MAX_BITS; bits++) {
    bl_count[bits] = 0;
  }

  n = 0;

  while (n <= 143) {
    static_ltree[n * 2 + 1]
    /*.Len*/
    = 8;
    n++;
    bl_count[8]++;
  }

  while (n <= 255) {
    static_ltree[n * 2 + 1]
    /*.Len*/
    = 9;
    n++;
    bl_count[9]++;
  }

  while (n <= 279) {
    static_ltree[n * 2 + 1]
    /*.Len*/
    = 7;
    n++;
    bl_count[7]++;
  }

  while (n <= 287) {
    static_ltree[n * 2 + 1]
    /*.Len*/
    = 8;
    n++;
    bl_count[8]++;
  }
  /* Codes 286 and 287 do not exist, but we must include them in the
   * tree construction to get a canonical Huffman tree (longest code
   * all ones)
   */


  gen_codes(static_ltree, L_CODES + 1, bl_count);
  /* The static distance tree is trivial: */

  for (n = 0; n < D_CODES; n++) {
    static_dtree[n * 2 + 1]
    /*.Len*/
    = 5;
    static_dtree[n * 2]
    /*.Code*/
    = bi_reverse(n, 5);
  } // Now data ready and we can init static trees


  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);
  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS); //static_init_done = true;
}
/* ===========================================================================
 * Initialize a new block.
 */


function init_block(s) {
  var n;
  /* iterates over tree elements */

  /* Initialize the trees. */

  for (n = 0; n < L_CODES; n++) {
    s.dyn_ltree[n * 2]
    /*.Freq*/
    = 0;
  }

  for (n = 0; n < D_CODES; n++) {
    s.dyn_dtree[n * 2]
    /*.Freq*/
    = 0;
  }

  for (n = 0; n < BL_CODES; n++) {
    s.bl_tree[n * 2]
    /*.Freq*/
    = 0;
  }

  s.dyn_ltree[END_BLOCK * 2]
  /*.Freq*/
  = 1;
  s.opt_len = s.static_len = 0;
  s.last_lit = s.matches = 0;
}
/* ===========================================================================
 * Flush the bit buffer and align the output on a byte boundary
 */


function bi_windup(s) {
  if (s.bi_valid > 8) {
    put_short(s, s.bi_buf);
  } else if (s.bi_valid > 0) {
    //put_byte(s, (Byte)s->bi_buf);
    s.pending_buf[s.pending++] = s.bi_buf;
  }

  s.bi_buf = 0;
  s.bi_valid = 0;
}
/* ===========================================================================
 * Copy a stored block, storing first the length and its
 * one's complement if requested.
 */


function copy_block(s, buf, len, header) //DeflateState *s;
//charf    *buf;    /* the input data */
//unsigned len;     /* its length */
//int      header;  /* true if block header must be written */
{
  bi_windup(s);
  /* align on byte boundary */

  if (header) {
    put_short(s, len);
    put_short(s, ~len);
  } //  while (len--) {
  //    put_byte(s, *buf++);
  //  }


  utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);
  s.pending += len;
}
/* ===========================================================================
 * Compares to subtrees, using the tree depth as tie breaker when
 * the subtrees have equal frequency. This minimizes the worst case length.
 */


function smaller(tree, n, m, depth) {
  var _n2 = n * 2;

  var _m2 = m * 2;

  return tree[_n2]
  /*.Freq*/
  < tree[_m2]
  /*.Freq*/
  || tree[_n2]
  /*.Freq*/
  === tree[_m2]
  /*.Freq*/
  && depth[n] <= depth[m];
}
/* ===========================================================================
 * Restore the heap property by moving down the tree starting at node k,
 * exchanging a node with the smallest of its two sons if necessary, stopping
 * when the heap property is re-established (each father smaller than its
 * two sons).
 */


function pqdownheap(s, tree, k) //    deflate_state *s;
//    ct_data *tree;  /* the tree to restore */
//    int k;               /* node to move down */
{
  var v = s.heap[k];
  var j = k << 1;
  /* left son of k */

  while (j <= s.heap_len) {
    /* Set j to the smallest of the two sons: */
    if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
      j++;
    }
    /* Exit if v is smaller than both sons */


    if (smaller(tree, v, s.heap[j], s.depth)) {
      break;
    }
    /* Exchange v with the smallest son */


    s.heap[k] = s.heap[j];
    k = j;
    /* And continue down the tree, setting j to the left son of k */

    j <<= 1;
  }

  s.heap[k] = v;
} // inlined manually
// var SMALLEST = 1;

/* ===========================================================================
 * Send the block data compressed using the given Huffman trees
 */


function compress_block(s, ltree, dtree) //    deflate_state *s;
//    const ct_data *ltree; /* literal tree */
//    const ct_data *dtree; /* distance tree */
{
  var dist;
  /* distance of matched string */

  var lc;
  /* match length or unmatched char (if dist == 0) */

  var lx = 0;
  /* running index in l_buf */

  var code;
  /* the code to send */

  var extra;
  /* number of extra bits to send */

  if (s.last_lit !== 0) {
    do {
      dist = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];
      lc = s.pending_buf[s.l_buf + lx];
      lx++;

      if (dist === 0) {
        send_code(s, lc, ltree);
        /* send a literal byte */
        //Tracecv(isgraph(lc), (stderr," '%c' ", lc));
      } else {
        /* Here, lc is the match length - MIN_MATCH */
        code = _length_code[lc];
        send_code(s, code + LITERALS + 1, ltree);
        /* send the length code */

        extra = extra_lbits[code];

        if (extra !== 0) {
          lc -= base_length[code];
          send_bits(s, lc, extra);
          /* send the extra length bits */
        }

        dist--;
        /* dist is now the match distance - 1 */

        code = d_code(dist); //Assert (code < D_CODES, "bad d_code");

        send_code(s, code, dtree);
        /* send the distance code */

        extra = extra_dbits[code];

        if (extra !== 0) {
          dist -= base_dist[code];
          send_bits(s, dist, extra);
          /* send the extra distance bits */
        }
      }
      /* literal or match pair ? */

      /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */
      //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,
      //       "pendingBuf overflow");

    } while (lx < s.last_lit);
  }

  send_code(s, END_BLOCK, ltree);
}
/* ===========================================================================
 * Construct one Huffman tree and assigns the code bit strings and lengths.
 * Update the total bit length for the current block.
 * IN assertion: the field freq is set for all tree elements.
 * OUT assertions: the fields len and code are set to the optimal bit length
 *     and corresponding code. The length opt_len is updated; static_len is
 *     also updated if stree is not null. The field max_code is set.
 */


function build_tree(s, desc) //    deflate_state *s;
//    tree_desc *desc; /* the tree descriptor */
{
  var tree = desc.dyn_tree;
  var stree = desc.stat_desc.static_tree;
  var has_stree = desc.stat_desc.has_stree;
  var elems = desc.stat_desc.elems;
  var n, m;
  /* iterate over heap elements */

  var max_code = -1;
  /* largest code with non zero frequency */

  var node;
  /* new node being created */

  /* Construct the initial heap, with least frequent element in
   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
   * heap[0] is not used.
   */

  s.heap_len = 0;
  s.heap_max = HEAP_SIZE;

  for (n = 0; n < elems; n++) {
    if (tree[n * 2]
    /*.Freq*/
    !== 0) {
      s.heap[++s.heap_len] = max_code = n;
      s.depth[n] = 0;
    } else {
      tree[n * 2 + 1]
      /*.Len*/
      = 0;
    }
  }
  /* The pkzip format requires that at least one distance code exists,
   * and that at least one bit should be sent even if there is only one
   * possible code. So to avoid special checks later on we force at least
   * two codes of non zero frequency.
   */


  while (s.heap_len < 2) {
    node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
    tree[node * 2]
    /*.Freq*/
    = 1;
    s.depth[node] = 0;
    s.opt_len--;

    if (has_stree) {
      s.static_len -= stree[node * 2 + 1]
      /*.Len*/
      ;
    }
    /* node is 0 or 1 so it does not have extra bits */

  }

  desc.max_code = max_code;
  /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
   * establish sub-heaps of increasing lengths:
   */

  for (n = s.heap_len >> 1
  /*int /2*/
  ; n >= 1; n--) {
    pqdownheap(s, tree, n);
  }
  /* Construct the Huffman tree by repeatedly combining the least two
   * frequent nodes.
   */


  node = elems;
  /* next internal node of the tree */

  do {
    //pqremove(s, tree, n);  /* n = node of least frequency */

    /*** pqremove ***/
    n = s.heap[1
    /*SMALLEST*/
    ];
    s.heap[1
    /*SMALLEST*/
    ] = s.heap[s.heap_len--];
    pqdownheap(s, tree, 1
    /*SMALLEST*/
    );
    /***/

    m = s.heap[1
    /*SMALLEST*/
    ];
    /* m = node of next least frequency */

    s.heap[--s.heap_max] = n;
    /* keep the nodes sorted by frequency */

    s.heap[--s.heap_max] = m;
    /* Create a new node father of n and m */

    tree[node * 2]
    /*.Freq*/
    = tree[n * 2]
    /*.Freq*/
    + tree[m * 2]
    /*.Freq*/
    ;
    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
    tree[n * 2 + 1]
    /*.Dad*/
    = tree[m * 2 + 1]
    /*.Dad*/
    = node;
    /* and insert the new node in the heap */

    s.heap[1
    /*SMALLEST*/
    ] = node++;
    pqdownheap(s, tree, 1
    /*SMALLEST*/
    );
  } while (s.heap_len >= 2);

  s.heap[--s.heap_max] = s.heap[1
  /*SMALLEST*/
  ];
  /* At this point, the fields freq and dad are set. We can now
   * generate the bit lengths.
   */

  gen_bitlen(s, desc);
  /* The field len is now set, we can generate the bit codes */

  gen_codes(tree, max_code, s.bl_count);
}
/* ===========================================================================
 * Scan a literal or distance tree to determine the frequencies of the codes
 * in the bit length tree.
 */


function scan_tree(s, tree, max_code) //    deflate_state *s;
//    ct_data *tree;   /* the tree to be scanned */
//    int max_code;    /* and its largest code of non zero frequency */
{
  var n;
  /* iterates over all tree elements */

  var prevlen = -1;
  /* last emitted length */

  var curlen;
  /* length of current code */

  var nextlen = tree[0 * 2 + 1]
  /*.Len*/
  ;
  /* length of next code */

  var count = 0;
  /* repeat count of the current code */

  var max_count = 7;
  /* max repeat count */

  var min_count = 4;
  /* min repeat count */

  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }

  tree[(max_code + 1) * 2 + 1]
  /*.Len*/
  = 0xffff;
  /* guard */

  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1]
    /*.Len*/
    ;

    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      s.bl_tree[curlen * 2]
      /*.Freq*/
      += count;
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        s.bl_tree[curlen * 2] /*.Freq*/++;
      }

      s.bl_tree[REP_3_6 * 2] /*.Freq*/++;
    } else if (count <= 10) {
      s.bl_tree[REPZ_3_10 * 2] /*.Freq*/++;
    } else {
      s.bl_tree[REPZ_11_138 * 2] /*.Freq*/++;
    }

    count = 0;
    prevlen = curlen;

    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
}
/* ===========================================================================
 * Send a literal or distance tree in compressed form, using the codes in
 * bl_tree.
 */


function send_tree(s, tree, max_code) //    deflate_state *s;
//    ct_data *tree; /* the tree to be scanned */
//    int max_code;       /* and its largest code of non zero frequency */
{
  var n;
  /* iterates over all tree elements */

  var prevlen = -1;
  /* last emitted length */

  var curlen;
  /* length of current code */

  var nextlen = tree[0 * 2 + 1]
  /*.Len*/
  ;
  /* length of next code */

  var count = 0;
  /* repeat count of the current code */

  var max_count = 7;
  /* max repeat count */

  var min_count = 4;
  /* min repeat count */

  /* tree[max_code+1].Len = -1; */

  /* guard already set */

  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }

  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1]
    /*.Len*/
    ;

    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      do {
        send_code(s, curlen, s.bl_tree);
      } while (--count !== 0);
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        send_code(s, curlen, s.bl_tree);
        count--;
      } //Assert(count >= 3 && count <= 6, " 3_6?");


      send_code(s, REP_3_6, s.bl_tree);
      send_bits(s, count - 3, 2);
    } else if (count <= 10) {
      send_code(s, REPZ_3_10, s.bl_tree);
      send_bits(s, count - 3, 3);
    } else {
      send_code(s, REPZ_11_138, s.bl_tree);
      send_bits(s, count - 11, 7);
    }

    count = 0;
    prevlen = curlen;

    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
}
/* ===========================================================================
 * Construct the Huffman tree for the bit lengths and return the index in
 * bl_order of the last bit length code to send.
 */


function build_bl_tree(s) {
  var max_blindex;
  /* index of last bit length code of non zero freq */

  /* Determine the bit length frequencies for literal and distance trees */

  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
  /* Build the bit length tree: */

  build_tree(s, s.bl_desc);
  /* opt_len now includes the length of the tree representations, except
   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
   */

  /* Determine the number of bit length codes to send. The pkzip format
   * requires that at least 4 bit length codes be sent. (appnote.txt says
   * 3 but the actual value used is 4.)
   */

  for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
    if (s.bl_tree[bl_order[max_blindex] * 2 + 1]
    /*.Len*/
    !== 0) {
      break;
    }
  }
  /* Update opt_len to include the bit length tree and counts */


  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4; //Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
  //        s->opt_len, s->static_len));

  return max_blindex;
}
/* ===========================================================================
 * Send the header for a block using dynamic Huffman trees: the counts, the
 * lengths of the bit length codes, the literal tree and the distance tree.
 * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
 */


function send_all_trees(s, lcodes, dcodes, blcodes) //    deflate_state *s;
//    int lcodes, dcodes, blcodes; /* number of codes for each tree */
{
  var rank;
  /* index in bl_order */
  //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
  //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
  //        "too many codes");
  //Tracev((stderr, "\nbl counts: "));

  send_bits(s, lcodes - 257, 5);
  /* not +255 as stated in appnote.txt */

  send_bits(s, dcodes - 1, 5);
  send_bits(s, blcodes - 4, 4);
  /* not -3 as stated in appnote.txt */

  for (rank = 0; rank < blcodes; rank++) {
    //Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
    send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1]
    /*.Len*/
    , 3);
  } //Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));


  send_tree(s, s.dyn_ltree, lcodes - 1);
  /* literal tree */
  //Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));

  send_tree(s, s.dyn_dtree, dcodes - 1);
  /* distance tree */
  //Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
}
/* ===========================================================================
 * Check if the data type is TEXT or BINARY, using the following algorithm:
 * - TEXT if the two conditions below are satisfied:
 *    a) There are no non-portable control characters belonging to the
 *       "black list" (0..6, 14..25, 28..31).
 *    b) There is at least one printable character belonging to the
 *       "white list" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).
 * - BINARY otherwise.
 * - The following partially-portable control characters form a
 *   "gray list" that is ignored in this detection algorithm:
 *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).
 * IN assertion: the fields Freq of dyn_ltree are set.
 */


function detect_data_type(s) {
  /* black_mask is the bit mask of black-listed bytes
   * set bits 0..6, 14..25, and 28..31
   * 0xf3ffc07f = binary 11110011111111111100000001111111
   */
  var black_mask = 0xf3ffc07f;
  var n;
  /* Check for non-textual ("black-listed") bytes. */

  for (n = 0; n <= 31; n++, black_mask >>>= 1) {
    if (black_mask & 1 && s.dyn_ltree[n * 2]
    /*.Freq*/
    !== 0) {
      return Z_BINARY;
    }
  }
  /* Check for textual ("white-listed") bytes. */


  if (s.dyn_ltree[9 * 2]
  /*.Freq*/
  !== 0 || s.dyn_ltree[10 * 2]
  /*.Freq*/
  !== 0 || s.dyn_ltree[13 * 2]
  /*.Freq*/
  !== 0) {
    return Z_TEXT;
  }

  for (n = 32; n < LITERALS; n++) {
    if (s.dyn_ltree[n * 2]
    /*.Freq*/
    !== 0) {
      return Z_TEXT;
    }
  }
  /* There are no "black-listed" or "white-listed" bytes:
   * this stream either is empty or has tolerated ("gray-listed") bytes only.
   */


  return Z_BINARY;
}

var static_init_done = false;
/* ===========================================================================
 * Initialize the tree data structures for a new zlib stream.
 */

function _tr_init(s) {
  if (!static_init_done) {
    tr_static_init();
    static_init_done = true;
  }

  s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
  s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
  s.bi_buf = 0;
  s.bi_valid = 0;
  /* Initialize the first block of the first file: */

  init_block(s);
}
/* ===========================================================================
 * Send a stored block
 */


function _tr_stored_block(s, buf, stored_len, last) //DeflateState *s;
//charf *buf;       /* input block */
//ulg stored_len;   /* length of input block */
//int last;         /* one if this is the last block for a file */
{
  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
  /* send block type */

  copy_block(s, buf, stored_len, true);
  /* with header */
}
/* ===========================================================================
 * Send one empty static block to give enough lookahead for inflate.
 * This takes 10 bits, of which 7 may remain in the bit buffer.
 */


function _tr_align(s) {
  send_bits(s, STATIC_TREES << 1, 3);
  send_code(s, END_BLOCK, static_ltree);
  bi_flush(s);
}
/* ===========================================================================
 * Determine the best encoding for the current block: dynamic trees, static
 * trees or store, and output the encoded block to the zip file.
 */


function _tr_flush_block(s, buf, stored_len, last) //DeflateState *s;
//charf *buf;       /* input block, or NULL if too old */
//ulg stored_len;   /* length of input block */
//int last;         /* one if this is the last block for a file */
{
  var opt_lenb, static_lenb;
  /* opt_len and static_len in bytes */

  var max_blindex = 0;
  /* index of last bit length code of non zero freq */

  /* Build the Huffman trees unless a stored block is forced */

  if (s.level > 0) {
    /* Check if the file is binary or text */
    if (s.strm.data_type === Z_UNKNOWN) {
      s.strm.data_type = detect_data_type(s);
    }
    /* Construct the literal and distance trees */


    build_tree(s, s.l_desc); // Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
    //        s->static_len));

    build_tree(s, s.d_desc); // Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
    //        s->static_len));

    /* At this point, opt_len and static_len are the total bit lengths of
     * the compressed block data, excluding the tree representations.
     */

    /* Build the bit length tree for the above two trees, and get the index
     * in bl_order of the last bit length code to send.
     */

    max_blindex = build_bl_tree(s);
    /* Determine the best encoding. Compute the block lengths in bytes. */

    opt_lenb = s.opt_len + 3 + 7 >>> 3;
    static_lenb = s.static_len + 3 + 7 >>> 3; // Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
    //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
    //        s->last_lit));

    if (static_lenb <= opt_lenb) {
      opt_lenb = static_lenb;
    }
  } else {
    // Assert(buf != (char*)0, "lost buf");
    opt_lenb = static_lenb = stored_len + 5;
    /* force a stored block */
  }

  if (stored_len + 4 <= opt_lenb && buf !== -1) {
    /* 4: two words for the lengths */

    /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
     * Otherwise we can't have processed more than WSIZE input bytes since
     * the last block flush, because compression would have been
     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
     * transform a block into a stored block.
     */
    _tr_stored_block(s, buf, stored_len, last);
  } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {
    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
    compress_block(s, static_ltree, static_dtree);
  } else {
    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
    compress_block(s, s.dyn_ltree, s.dyn_dtree);
  } // Assert (s->compressed_len == s->bits_sent, "bad compressed size");

  /* The above check is made mod 2^32, for files larger than 512 MB
   * and uLong implemented on 32 bits.
   */


  init_block(s);

  if (last) {
    bi_windup(s);
  } // Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len>>3,
  //       s->compressed_len-7*last));

}
/* ===========================================================================
 * Save the match info and tally the frequency counts. Return true if
 * the current block must be flushed.
 */


function _tr_tally(s, dist, lc) //    deflate_state *s;
//    unsigned dist;  /* distance of matched string */
//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */
{
  //var out_length, in_length, dcode;
  s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 0xff;
  s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;
  s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;
  s.last_lit++;

  if (dist === 0) {
    /* lc is the unmatched char */
    s.dyn_ltree[lc * 2] /*.Freq*/++;
  } else {
    s.matches++;
    /* Here, lc is the match length - MIN_MATCH */

    dist--;
    /* dist = match distance - 1 */
    //Assert((ush)dist < (ush)MAX_DIST(s) &&
    //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
    //       (ush)d_code(dist) < (ush)D_CODES,  "_tr_tally: bad match");

    s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2] /*.Freq*/++;
    s.dyn_dtree[d_code(dist) * 2] /*.Freq*/++;
  } // (!) This block is disabled in zlib defaults,
  // don't enable it for binary compatibility
  //#ifdef TRUNCATE_BLOCK
  //  /* Try to guess if it is profitable to stop the current block here */
  //  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {
  //    /* Compute an upper bound for the compressed length */
  //    out_length = s.last_lit*8;
  //    in_length = s.strstart - s.block_start;
  //
  //    for (dcode = 0; dcode < D_CODES; dcode++) {
  //      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);
  //    }
  //    out_length >>>= 3;
  //    //Tracev((stderr,"\nlast_lit %u, in %ld, out ~%ld(%ld%%) ",
  //    //       s->last_lit, in_length, out_length,
  //    //       100L - out_length*100L/in_length));
  //    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {
  //      return true;
  //    }
  //  }
  //#endif


  return s.last_lit === s.lit_bufsize - 1;
  /* We avoid equality with lit_bufsize because of wraparound at 64K
   * on 16 bit machines and because stored blocks are restricted to
   * 64K-1 bytes.
   */
}

exports._tr_init = _tr_init;
exports._tr_stored_block = _tr_stored_block;
exports._tr_flush_block = _tr_flush_block;
exports._tr_tally = _tr_tally;
exports._tr_align = _tr_align;

/***/ }),

/***/ "./node_modules/pako/lib/zlib/zstream.js":
/*!***********************************************!*\
  !*** ./node_modules/pako/lib/zlib/zstream.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function ZStream() {
  /* next input byte */
  this.input = null; // JS specific, because we have no pointers

  this.next_in = 0;
  /* number of bytes available at input */

  this.avail_in = 0;
  /* total number of input bytes read so far */

  this.total_in = 0;
  /* next output byte should be put there */

  this.output = null; // JS specific, because we have no pointers

  this.next_out = 0;
  /* remaining free space at output */

  this.avail_out = 0;
  /* total number of bytes output so far */

  this.total_out = 0;
  /* last error message, NULL if no error */

  this.msg = ''
  /*Z_NULL*/
  ;
  /* not visible by applications */

  this.state = null;
  /* best guess about the data type: binary or text */

  this.data_type = 2
  /*Z_UNKNOWN*/
  ;
  /* adler32 value of the uncompressed data */

  this.adler = 0;
}

module.exports = ZStream;

/***/ }),

/***/ "./node_modules/process-nextick-args/index.js":
/*!****************************************************!*\
  !*** ./node_modules/process-nextick-args/index.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

if (!process.version || process.version.indexOf('v0.') === 0 || process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
  module.exports = {
    nextTick: nextTick
  };
} else {
  module.exports = process;
}

function nextTick(fn, arg1, arg2, arg3) {
  if (typeof fn !== 'function') {
    throw new TypeError('"callback" argument must be a function');
  }

  var len = arguments.length;
  var args, i;

  switch (len) {
    case 0:
    case 1:
      return process.nextTick(fn);

    case 2:
      return process.nextTick(function afterTickOne() {
        fn.call(null, arg1);
      });

    case 3:
      return process.nextTick(function afterTickTwo() {
        fn.call(null, arg1, arg2);
      });

    case 4:
      return process.nextTick(function afterTickThree() {
        fn.call(null, arg1, arg2, arg3);
      });

    default:
      args = new Array(len - 1);
      i = 0;

      while (i < args.length) {
        args[i++] = arguments[i];
      }

      return process.nextTick(function afterTick() {
        fn.apply(null, args);
      });
  }
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {}; // cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
  throw new Error('setTimeout has not been defined');
}

function defaultClearTimeout() {
  throw new Error('clearTimeout has not been defined');
}

(function () {
  try {
    if (typeof setTimeout === 'function') {
      cachedSetTimeout = setTimeout;
    } else {
      cachedSetTimeout = defaultSetTimout;
    }
  } catch (e) {
    cachedSetTimeout = defaultSetTimout;
  }

  try {
    if (typeof clearTimeout === 'function') {
      cachedClearTimeout = clearTimeout;
    } else {
      cachedClearTimeout = defaultClearTimeout;
    }
  } catch (e) {
    cachedClearTimeout = defaultClearTimeout;
  }
})();

function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    //normal enviroments in sane situations
    return setTimeout(fun, 0);
  } // if setTimeout wasn't available but was latter defined


  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedSetTimeout(fun, 0);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}

function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    //normal enviroments in sane situations
    return clearTimeout(marker);
  } // if clearTimeout wasn't available but was latter defined


  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedClearTimeout(marker);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
      return cachedClearTimeout.call(null, marker);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
      // Some versions of I.E. have different rules for clearTimeout vs setTimeout
      return cachedClearTimeout.call(this, marker);
    }
  }
}

var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }

  draining = false;

  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }

  if (queue.length) {
    drainQueue();
  }
}

function drainQueue() {
  if (draining) {
    return;
  }

  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;

  while (len) {
    currentQueue = queue;
    queue = [];

    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }

    queueIndex = -1;
    len = queue.length;
  }

  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}

process.nextTick = function (fun) {
  var args = new Array(arguments.length - 1);

  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }

  queue.push(new Item(fun, args));

  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
}; // v8 likes predictible objects


function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}

Item.prototype.run = function () {
  this.fun.apply(null, this.array);
};

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues

process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) {
  return [];
};

process.binding = function (name) {
  throw new Error('process.binding is not supported');
};

process.cwd = function () {
  return '/';
};

process.chdir = function (dir) {
  throw new Error('process.chdir is not supported');
};

process.umask = function () {
  return 0;
};

/***/ }),

/***/ "./node_modules/readable-stream/duplex-browser.js":
/*!********************************************************!*\
  !*** ./node_modules/readable-stream/duplex-browser.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./lib/_stream_duplex.js */ "./node_modules/readable-stream/lib/_stream_duplex.js");

/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_duplex.js":
/*!************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_duplex.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

/*<replacement>*/

var pna = __webpack_require__(/*! process-nextick-args */ "./node_modules/process-nextick-args/index.js");
/*</replacement>*/

/*<replacement>*/


var objectKeys = Object.keys || function (obj) {
  var keys = [];

  for (var key in obj) {
    keys.push(key);
  }

  return keys;
};
/*</replacement>*/


module.exports = Duplex;
/*<replacement>*/

var util = __webpack_require__(/*! core-util-is */ "./node_modules/core-util-is/lib/util.js");

util.inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
/*</replacement>*/

var Readable = __webpack_require__(/*! ./_stream_readable */ "./node_modules/readable-stream/lib/_stream_readable.js");

var Writable = __webpack_require__(/*! ./_stream_writable */ "./node_modules/readable-stream/lib/_stream_writable.js");

util.inherits(Duplex, Readable);
{
  // avoid scope creep, the keys array can then be collected
  var keys = objectKeys(Writable.prototype);

  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);
  Readable.call(this, options);
  Writable.call(this, options);
  if (options && options.readable === false) this.readable = false;
  if (options && options.writable === false) this.writable = false;
  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;
  this.once('end', onend);
}

Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
}); // the no-half-open enforcer

function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended) return; // no more data can be written.
  // But allow more writes to happen in this tick.

  pna.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  get: function get() {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }

    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});

Duplex.prototype._destroy = function (err, cb) {
  this.push(null);
  this.end();
  pna.nextTick(cb, err);
};

/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_passthrough.js":
/*!*****************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_passthrough.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.


module.exports = PassThrough;

var Transform = __webpack_require__(/*! ./_stream_transform */ "./node_modules/readable-stream/lib/_stream_transform.js");
/*<replacement>*/


var util = __webpack_require__(/*! core-util-is */ "./node_modules/core-util-is/lib/util.js");

util.inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);
  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};

/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_readable.js":
/*!**************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_readable.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global, process) {// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

/*<replacement>*/

var pna = __webpack_require__(/*! process-nextick-args */ "./node_modules/process-nextick-args/index.js");
/*</replacement>*/


module.exports = Readable;
/*<replacement>*/

var isArray = __webpack_require__(/*! isarray */ "./node_modules/isarray/index.js");
/*</replacement>*/

/*<replacement>*/


var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;
/*<replacement>*/

var EE = __webpack_require__(/*! events */ "./node_modules/events/events.js").EventEmitter;

var EElistenerCount = function EElistenerCount(emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/


var Stream = __webpack_require__(/*! ./internal/streams/stream */ "./node_modules/readable-stream/lib/internal/streams/stream-browser.js");
/*</replacement>*/

/*<replacement>*/


var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer;

var OurUint8Array = global.Uint8Array || function () {};

function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}

function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
/*</replacement>*/

/*<replacement>*/


var util = __webpack_require__(/*! core-util-is */ "./node_modules/core-util-is/lib/util.js");

util.inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
/*</replacement>*/

/*<replacement>*/

var debugUtil = __webpack_require__(/*! util */ 0);

var debug = void 0;

if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function debug() {};
}
/*</replacement>*/


var BufferList = __webpack_require__(/*! ./internal/streams/BufferList */ "./node_modules/readable-stream/lib/internal/streams/BufferList.js");

var destroyImpl = __webpack_require__(/*! ./internal/streams/destroy */ "./node_modules/readable-stream/lib/internal/streams/destroy.js");

var StringDecoder;
util.inherits(Readable, Stream);
var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn); // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.

  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function ReadableState(options, stream) {
  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ "./node_modules/readable-stream/lib/_stream_duplex.js");
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.

  var isDuplex = stream instanceof Duplex; // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away

  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode; // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"

  var hwm = options.highWaterMark;
  var readableHwm = options.readableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm; // cast to ints.

  this.highWaterMark = Math.floor(this.highWaterMark); // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()

  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false; // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.

  this.sync = true; // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.

  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false; // has it been destroyed

  this.destroyed = false; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // the number of writers that are awaiting a drain event in .pipe()s

  this.awaitDrain = 0; // if true, a maybeReadMore has been scheduled

  this.readingMore = false;
  this.decoder = null;
  this.encoding = null;

  if (options.encoding) {
    if (!StringDecoder) StringDecoder = __webpack_require__(/*! string_decoder/ */ "./node_modules/node-libs-browser/node_modules/string_decoder/lib/string_decoder.js").StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ "./node_modules/readable-stream/lib/_stream_duplex.js");
  if (!(this instanceof Readable)) return new Readable(options);
  this._readableState = new ReadableState(options, this); // legacy

  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  get: function get() {
    if (this._readableState === undefined) {
      return false;
    }

    return this._readableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._readableState.destroyed = value;
  }
});
Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;

Readable.prototype._destroy = function (err, cb) {
  this.push(null);
  cb(err);
}; // Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.


Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;

      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }

      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
}; // Unshift should *always* be something directly out of read()


Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  var state = stream._readableState;

  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);

    if (er) {
      stream.emit('error', er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        stream.emit('error', new Error('stream.push() after EOF'));
      } else {
        state.reading = false;

        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
    }
  }

  return needMoreData(state);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    stream.emit('data', chunk);
    stream.read(0);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);
    if (state.needReadable) emitReadable(stream);
  }

  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;

  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }

  return er;
} // if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.


function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
}; // backwards compatibility.


Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = __webpack_require__(/*! string_decoder/ */ "./node_modules/node-libs-browser/node_modules/string_decoder/lib/string_decoder.js").StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
}; // Don't raise the hwm > 8MB


var MAX_HWM = 0x800000;

function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }

  return n;
} // This function is designed to be inlinable, so please take care when making
// changes to the function body.


function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;

  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  } // If we're asking for more than the current hwm, then raise the hwm.


  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n; // Don't have enough

  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }

  return state.length;
} // you can override either this method, or the async _read(n) below.


Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;
  if (n !== 0) state.emittedReadable = false; // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.

  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state); // if we've ended, and we're now clear, then finish it up.

  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  } // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.
  // if we need a readable event, then we need to do some reading.


  var doRead = state.needReadable;
  debug('need readable', doRead); // if we currently have less than the highWaterMark, then also read some

  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  } // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.


  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true; // if the length is currently zero, then we *need* a readable event.

    if (state.length === 0) state.needReadable = true; // call internal read method

    this._read(state.highWaterMark);

    state.sync = false; // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.

    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  } else {
    state.length -= n;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true; // If we tried to read() past the EOF, then emit end on the next tick.

    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);
  return ret;
};

function onEofChunk(stream, state) {
  if (state.ended) return;

  if (state.decoder) {
    var chunk = state.decoder.end();

    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }

  state.ended = true; // emit 'readable' now to make sure it gets picked up.

  emitReadable(stream);
} // Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.


function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;

  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
} // at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.


function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    pna.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;

  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length) // didn't get any data, stop spinning.
      break;else len = state.length;
  }

  state.readingMore = false;
} // abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.


Readable.prototype._read = function (n) {
  this.emit('error', new Error('_read() is not implemented'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;

    case 1:
      state.pipes = [state.pipes, dest];
      break;

    default:
      state.pipes.push(dest);
      break;
  }

  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) pna.nextTick(endFn);else src.once('end', endFn);
  dest.on('unpipe', onunpipe);

  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');

    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  } // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.


  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);
  var cleanedUp = false;

  function cleanup() {
    debug('cleanup'); // cleanup event handlers once the pipe is broken

    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);
    cleanedUp = true; // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.

    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  } // If the user pushes more data while we're writing to dest then we'll end up
  // in ondata again. However, we only want to increase awaitDrain once because
  // dest will only emit one 'drain' event for the multiple writes.
  // => Introduce a guard on increasing awaitDrain.


  var increasedAwaitDrain = false;
  src.on('data', ondata);

  function ondata(chunk) {
    debug('ondata');
    increasedAwaitDrain = false;
    var ret = dest.write(chunk);

    if (false === ret && !increasedAwaitDrain) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', src._readableState.awaitDrain);
        src._readableState.awaitDrain++;
        increasedAwaitDrain = true;
      }

      src.pause();
    }
  } // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.


  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
  } // Make sure our error handler is attached before userland ones.


  prependListener(dest, 'error', onerror); // Both close and finish should trigger unpipe, but only once.

  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }

  dest.once('close', onclose);

  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }

  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  } // tell the dest that it's being piped to


  dest.emit('pipe', src); // start the flow if it hasn't been started already.

  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function () {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;

    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = {
    hasUnpiped: false
  }; // if we're not piping anywhere, then do nothing.

  if (state.pipesCount === 0) return this; // just one destination.  most common case.

  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;
    if (!dest) dest = state.pipes; // got a match.

    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  } // slow case. multiple pipe destinations.


  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, unpipeInfo);
    }

    return this;
  } // try to find the right one.


  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;
  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];
  dest.emit('unpipe', this, unpipeInfo);
  return this;
}; // set up data events if they are asked for
// Ensure readable listeners eventually get something


Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  if (ev === 'data') {
    // Start flowing on next tick if stream isn't explicitly paused
    if (this._readableState.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    var state = this._readableState;

    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.emittedReadable = false;

      if (!state.reading) {
        pna.nextTick(nReadingNextTick, this);
      } else if (state.length) {
        emitReadable(this);
      }
    }
  }

  return res;
};

Readable.prototype.addListener = Readable.prototype.on;

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
} // pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.


Readable.prototype.resume = function () {
  var state = this._readableState;

  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    resume(this, state);
  }

  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    pna.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  if (!state.reading) {
    debug('resume read 0');
    stream.read(0);
  }

  state.resumeScheduled = false;
  state.awaitDrain = 0;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);

  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }

  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);

  while (state.flowing && stream.read() !== null) {}
} // wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.


Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;
  stream.on('end', function () {
    debug('wrapped end');

    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }

    _this.push(null);
  });
  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk); // don't skip over falsy values in objectMode

    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = _this.push(chunk);

    if (!ret) {
      paused = true;
      stream.pause();
    }
  }); // proxy all the other methods.
  // important when wrapping filters and duplexes.

  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function (method) {
        return function () {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  } // proxy certain important events.


  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  } // when we try to consume some more bytes, simply unpause the
  // underlying stream.


  this._read = function (n) {
    debug('wrapped _read', n);

    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.highWaterMark;
  }
}); // exposed for testing purposes only.

Readable._fromList = fromList; // Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.

function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;
  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = fromListPartial(n, state.buffer, state.decoder);
  }
  return ret;
} // Extracts only enough buffered data to satisfy the amount requested.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.


function fromListPartial(n, list, hasStrings) {
  var ret;

  if (n < list.head.data.length) {
    // slice is the same for buffers and strings
    ret = list.head.data.slice(0, n);
    list.head.data = list.head.data.slice(n);
  } else if (n === list.head.data.length) {
    // first chunk is a perfect match
    ret = list.shift();
  } else {
    // result spans more than one buffer
    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
  }

  return ret;
} // Copies a specified amount of characters from the list of buffered data
// chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.


function copyFromBufferString(n, list) {
  var p = list.head;
  var c = 1;
  var ret = p.data;
  n -= ret.length;

  while (p = p.next) {
    var str = p.data;
    var nb = n > str.length ? str.length : n;
    if (nb === str.length) ret += str;else ret += str.slice(0, n);
    n -= nb;

    if (n === 0) {
      if (nb === str.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = str.slice(nb);
      }

      break;
    }

    ++c;
  }

  list.length -= c;
  return ret;
} // Copies a specified amount of bytes from the list of buffered data chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.


function copyFromBuffer(n, list) {
  var ret = Buffer.allocUnsafe(n);
  var p = list.head;
  var c = 1;
  p.data.copy(ret);
  n -= p.data.length;

  while (p = p.next) {
    var buf = p.data;
    var nb = n > buf.length ? buf.length : n;
    buf.copy(ret, ret.length - n, 0, nb);
    n -= nb;

    if (n === 0) {
      if (nb === buf.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = buf.slice(nb);
      }

      break;
    }

    ++c;
  }

  list.length -= c;
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState; // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.

  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    pna.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
  }
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }

  return -1;
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_transform.js":
/*!***************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_transform.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.


module.exports = Transform;

var Duplex = __webpack_require__(/*! ./_stream_duplex */ "./node_modules/readable-stream/lib/_stream_duplex.js");
/*<replacement>*/


var util = __webpack_require__(/*! core-util-is */ "./node_modules/core-util-is/lib/util.js");

util.inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
/*</replacement>*/

util.inherits(Transform, Duplex);

function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;
  var cb = ts.writecb;

  if (!cb) {
    return this.emit('error', new Error('write callback called multiple times'));
  }

  ts.writechunk = null;
  ts.writecb = null;
  if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);
  cb(er);
  var rs = this._readableState;
  rs.reading = false;

  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);
  Duplex.call(this, options);
  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  }; // start out asking for a readable event once data is transformed.

  this._readableState.needReadable = true; // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.

  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;
    if (typeof options.flush === 'function') this._flush = options.flush;
  } // When the writable side finishes, then flush out anything remaining.


  this.on('prefinish', prefinish);
}

function prefinish() {
  var _this = this;

  if (typeof this._flush === 'function') {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
}; // This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.


Transform.prototype._transform = function (chunk, encoding, cb) {
  throw new Error('_transform() is not implemented');
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;

  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
}; // Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.


Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;

    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  var _this2 = this;

  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);

    _this2.emit('close');
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);
  if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data); // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided

  if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');
  if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');
  return stream.push(null);
}

/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_writable.js":
/*!**************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_writable.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process, setImmediate, global) {// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.

/*<replacement>*/

var pna = __webpack_require__(/*! process-nextick-args */ "./node_modules/process-nextick-args/index.js");
/*</replacement>*/


module.exports = Writable;
/* <replacement> */

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
} // It seems a linked list but it is not
// there will be only 2 of these for each stream


function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;

  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/


var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
/*</replacement>*/

/*<replacement>*/

var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;
/*<replacement>*/

var util = __webpack_require__(/*! core-util-is */ "./node_modules/core-util-is/lib/util.js");

util.inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
/*</replacement>*/

/*<replacement>*/

var internalUtil = {
  deprecate: __webpack_require__(/*! util-deprecate */ "./node_modules/util-deprecate/browser.js")
};
/*</replacement>*/

/*<replacement>*/

var Stream = __webpack_require__(/*! ./internal/streams/stream */ "./node_modules/readable-stream/lib/internal/streams/stream-browser.js");
/*</replacement>*/

/*<replacement>*/


var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer;

var OurUint8Array = global.Uint8Array || function () {};

function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}

function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
/*</replacement>*/


var destroyImpl = __webpack_require__(/*! ./internal/streams/destroy */ "./node_modules/readable-stream/lib/internal/streams/destroy.js");

util.inherits(Writable, Stream);

function nop() {}

function WritableState(options, stream) {
  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ "./node_modules/readable-stream/lib/_stream_duplex.js");
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.

  var isDuplex = stream instanceof Duplex; // object stream flag to indicate whether or not this stream
  // contains buffers or objects.

  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode; // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()

  var hwm = options.highWaterMark;
  var writableHwm = options.writableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;else this.highWaterMark = defaultHwm; // cast to ints.

  this.highWaterMark = Math.floor(this.highWaterMark); // if _final has been called

  this.finalCalled = false; // drain event flag.

  this.needDrain = false; // at the start of calling end()

  this.ending = false; // when end() has been called, and returned

  this.ended = false; // when 'finish' is emitted

  this.finished = false; // has it been destroyed

  this.destroyed = false; // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.

  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.

  this.length = 0; // a flag to see when we're in the middle of a write.

  this.writing = false; // when true all writes will be buffered until .uncork() call

  this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.

  this.sync = true; // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.

  this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)

  this.onwrite = function (er) {
    onwrite(stream, er);
  }; // the callback that the user supplies to write(chunk,encoding,cb)


  this.writecb = null; // the amount that is being written when _write is called.

  this.writelen = 0;
  this.bufferedRequest = null;
  this.lastBufferedRequest = null; // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted

  this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams

  this.prefinished = false; // True if the error was already emitted and should not be thrown again

  this.errorEmitted = false; // count buffered requests

  this.bufferedRequestCount = 0; // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two

  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];

  while (current) {
    out.push(current);
    current = current.next;
  }

  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function () {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})(); // Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.


var realHasInstance;

if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function value(object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;
      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function realHasInstance(object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ "./node_modules/readable-stream/lib/_stream_duplex.js"); // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.
  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.

  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
    return new Writable(options);
  }

  this._writableState = new WritableState(options, this); // legacy.

  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;
    if (typeof options.writev === 'function') this._writev = options.writev;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
} // Otherwise people can pipe Writable streams, which is just wrong.


Writable.prototype.pipe = function () {
  this.emit('error', new Error('Cannot pipe, not readable'));
};

function writeAfterEnd(stream, cb) {
  var er = new Error('write after end'); // TODO: defer error events consistently everywhere, not just the cb

  stream.emit('error', er);
  pna.nextTick(cb, er);
} // Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.


function validChunk(stream, state, chunk, cb) {
  var valid = true;
  var er = false;

  if (chunk === null) {
    er = new TypeError('May not write null values to stream');
  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }

  if (er) {
    stream.emit('error', er);
    pna.nextTick(cb, er);
    valid = false;
  }

  return valid;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  var isBuf = !state.objectMode && _isUint8Array(chunk);

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
  if (typeof cb !== 'function') cb = nop;
  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }
  return ret;
};

Writable.prototype.cork = function () {
  var state = this._writableState;
  state.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;
    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }

  return chunk;
}

Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
}); // if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.

function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);

    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }

  var len = state.objectMode ? 1 : chunk.length;
  state.length += len;
  var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.

  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };

    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }

    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    pna.nextTick(cb, er); // this can emit finish, and it will always happen
    // after error

    pna.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er); // this can emit finish, but finish must
    // always follow error

    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;
  onwriteStateUpdate(state);
  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state);

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      /*<replacement>*/
      asyncWrite(afterWrite, stream, state, finished, cb);
      /*</replacement>*/
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
} // Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.


function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
} // if there's something in the buffer waiting, then process it


function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;
    var count = 0;
    var allBuffers = true;

    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }

    buffer.allBuffers = allBuffers;
    doWrite(stream, state, true, state.length, buffer, '', holder.finish); // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite

    state.pendingcb++;
    state.lastBufferedRequest = null;

    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }

    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;
      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--; // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.

      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new Error('_write() is not implemented'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding); // .end() fully uncorks

  if (state.corked) {
    state.corked = 1;
    this.uncork();
  } // ignore unnecessary end() calls.


  if (!state.ending && !state.finished) endWritable(this, state, cb);
};

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}

function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;

    if (err) {
      stream.emit('error', err);
    }

    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}

function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function') {
      state.pendingcb++;
      state.finalCalled = true;
      pna.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);

  if (need) {
    prefinish(stream, state);

    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');
    }
  }

  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);

  if (cb) {
    if (state.finished) pna.nextTick(cb);else stream.once('finish', cb);
  }

  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;

  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  }

  if (state.corkedRequestsFree) {
    state.corkedRequestsFree.next = corkReq;
  } else {
    state.corkedRequestsFree = corkReq;
  }
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  get: function get() {
    if (this._writableState === undefined) {
      return false;
    }

    return this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._writableState.destroyed = value;
  }
});
Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;

Writable.prototype._destroy = function (err, cb) {
  this.end();
  cb(err);
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../process/browser.js */ "./node_modules/process/browser.js"), __webpack_require__(/*! ./../../timers-browserify/main.js */ "./node_modules/timers-browserify/main.js").setImmediate, __webpack_require__(/*! ./../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/readable-stream/lib/internal/streams/BufferList.js":
/*!*************************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/streams/BufferList.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer;

var util = __webpack_require__(/*! util */ 1);

function copyBuffer(src, target, offset) {
  src.copy(target, offset);
}

module.exports = function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  BufferList.prototype.push = function push(v) {
    var entry = {
      data: v,
      next: null
    };
    if (this.length > 0) this.tail.next = entry;else this.head = entry;
    this.tail = entry;
    ++this.length;
  };

  BufferList.prototype.unshift = function unshift(v) {
    var entry = {
      data: v,
      next: this.head
    };
    if (this.length === 0) this.tail = entry;
    this.head = entry;
    ++this.length;
  };

  BufferList.prototype.shift = function shift() {
    if (this.length === 0) return;
    var ret = this.head.data;
    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
    --this.length;
    return ret;
  };

  BufferList.prototype.clear = function clear() {
    this.head = this.tail = null;
    this.length = 0;
  };

  BufferList.prototype.join = function join(s) {
    if (this.length === 0) return '';
    var p = this.head;
    var ret = '' + p.data;

    while (p = p.next) {
      ret += s + p.data;
    }

    return ret;
  };

  BufferList.prototype.concat = function concat(n) {
    if (this.length === 0) return Buffer.alloc(0);
    if (this.length === 1) return this.head.data;
    var ret = Buffer.allocUnsafe(n >>> 0);
    var p = this.head;
    var i = 0;

    while (p) {
      copyBuffer(p.data, ret, i);
      i += p.data.length;
      p = p.next;
    }

    return ret;
  };

  return BufferList;
}();

if (util && util.inspect && util.inspect.custom) {
  module.exports.prototype[util.inspect.custom] = function () {
    var obj = util.inspect({
      length: this.length
    });
    return this.constructor.name + ' ' + obj;
  };
}

/***/ }),

/***/ "./node_modules/readable-stream/lib/internal/streams/destroy.js":
/*!**********************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/streams/destroy.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*<replacement>*/

var pna = __webpack_require__(/*! process-nextick-args */ "./node_modules/process-nextick-args/index.js");
/*</replacement>*/
// undocumented cb() API, needed for core, not for public API


function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
      pna.nextTick(emitErrorNT, this, err);
    }

    return this;
  } // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks


  if (this._readableState) {
    this._readableState.destroyed = true;
  } // if this is a duplex stream mark the writable part as destroyed as well


  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      pna.nextTick(emitErrorNT, _this, err);

      if (_this._writableState) {
        _this._writableState.errorEmitted = true;
      }
    } else if (cb) {
      cb(err);
    }
  });

  return this;
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy
};

/***/ }),

/***/ "./node_modules/readable-stream/lib/internal/streams/stream-browser.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/streams/stream-browser.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! events */ "./node_modules/events/events.js").EventEmitter;

/***/ }),

/***/ "./node_modules/readable-stream/passthrough.js":
/*!*****************************************************!*\
  !*** ./node_modules/readable-stream/passthrough.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./readable */ "./node_modules/readable-stream/readable-browser.js").PassThrough;

/***/ }),

/***/ "./node_modules/readable-stream/readable-browser.js":
/*!**********************************************************!*\
  !*** ./node_modules/readable-stream/readable-browser.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ./lib/_stream_readable.js */ "./node_modules/readable-stream/lib/_stream_readable.js");
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = __webpack_require__(/*! ./lib/_stream_writable.js */ "./node_modules/readable-stream/lib/_stream_writable.js");
exports.Duplex = __webpack_require__(/*! ./lib/_stream_duplex.js */ "./node_modules/readable-stream/lib/_stream_duplex.js");
exports.Transform = __webpack_require__(/*! ./lib/_stream_transform.js */ "./node_modules/readable-stream/lib/_stream_transform.js");
exports.PassThrough = __webpack_require__(/*! ./lib/_stream_passthrough.js */ "./node_modules/readable-stream/lib/_stream_passthrough.js");

/***/ }),

/***/ "./node_modules/readable-stream/transform.js":
/*!***************************************************!*\
  !*** ./node_modules/readable-stream/transform.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./readable */ "./node_modules/readable-stream/readable-browser.js").Transform;

/***/ }),

/***/ "./node_modules/readable-stream/writable-browser.js":
/*!**********************************************************!*\
  !*** ./node_modules/readable-stream/writable-browser.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./lib/_stream_writable.js */ "./node_modules/readable-stream/lib/_stream_writable.js");

/***/ }),

/***/ "./node_modules/safe-buffer/index.js":
/*!*******************************************!*\
  !*** ./node_modules/safe-buffer/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* eslint-disable node/no-deprecated-api */
var buffer = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js");

var Buffer = buffer.Buffer; // alternative to using Object.keys for old browsers

function copyProps(src, dst) {
  for (var key in src) {
    dst[key] = src[key];
  }
}

if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer;
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports);
  exports.Buffer = SafeBuffer;
}

function SafeBuffer(arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length);
} // Copy static methods from Buffer


copyProps(Buffer, SafeBuffer);

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number');
  }

  return Buffer(arg, encodingOrOffset, length);
};

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number');
  }

  var buf = Buffer(size);

  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding);
    } else {
      buf.fill(fill);
    }
  } else {
    buf.fill(0);
  }

  return buf;
};

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number');
  }

  return Buffer(size);
};

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number');
  }

  return buffer.SlowBuffer(size);
};

/***/ }),

/***/ "./node_modules/setimmediate/setImmediate.js":
/*!***************************************************!*\
  !*** ./node_modules/setimmediate/setImmediate.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {
  "use strict";

  if (global.setImmediate) {
    return;
  }

  var nextHandle = 1; // Spec says greater than zero

  var tasksByHandle = {};
  var currentlyRunningATask = false;
  var doc = global.document;
  var registerImmediate;

  function setImmediate(callback) {
    // Callback can either be a function or a string
    if (typeof callback !== "function") {
      callback = new Function("" + callback);
    } // Copy function arguments


    var args = new Array(arguments.length - 1);

    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i + 1];
    } // Store and register the task


    var task = {
      callback: callback,
      args: args
    };
    tasksByHandle[nextHandle] = task;
    registerImmediate(nextHandle);
    return nextHandle++;
  }

  function clearImmediate(handle) {
    delete tasksByHandle[handle];
  }

  function run(task) {
    var callback = task.callback;
    var args = task.args;

    switch (args.length) {
      case 0:
        callback();
        break;

      case 1:
        callback(args[0]);
        break;

      case 2:
        callback(args[0], args[1]);
        break;

      case 3:
        callback(args[0], args[1], args[2]);
        break;

      default:
        callback.apply(undefined, args);
        break;
    }
  }

  function runIfPresent(handle) {
    // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
    // So if we're currently running a task, we'll need to delay this invocation.
    if (currentlyRunningATask) {
      // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
      // "too much recursion" error.
      setTimeout(runIfPresent, 0, handle);
    } else {
      var task = tasksByHandle[handle];

      if (task) {
        currentlyRunningATask = true;

        try {
          run(task);
        } finally {
          clearImmediate(handle);
          currentlyRunningATask = false;
        }
      }
    }
  }

  function installNextTickImplementation() {
    registerImmediate = function registerImmediate(handle) {
      process.nextTick(function () {
        runIfPresent(handle);
      });
    };
  }

  function canUsePostMessage() {
    // The test against `importScripts` prevents this implementation from being installed inside a web worker,
    // where `global.postMessage` means something completely different and can't be used for this purpose.
    if (global.postMessage && !global.importScripts) {
      var postMessageIsAsynchronous = true;
      var oldOnMessage = global.onmessage;

      global.onmessage = function () {
        postMessageIsAsynchronous = false;
      };

      global.postMessage("", "*");
      global.onmessage = oldOnMessage;
      return postMessageIsAsynchronous;
    }
  }

  function installPostMessageImplementation() {
    // Installs an event handler on `global` for the `message` event: see
    // * https://developer.mozilla.org/en/DOM/window.postMessage
    // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages
    var messagePrefix = "setImmediate$" + Math.random() + "$";

    var onGlobalMessage = function onGlobalMessage(event) {
      if (event.source === global && typeof event.data === "string" && event.data.indexOf(messagePrefix) === 0) {
        runIfPresent(+event.data.slice(messagePrefix.length));
      }
    };

    if (global.addEventListener) {
      global.addEventListener("message", onGlobalMessage, false);
    } else {
      global.attachEvent("onmessage", onGlobalMessage);
    }

    registerImmediate = function registerImmediate(handle) {
      global.postMessage(messagePrefix + handle, "*");
    };
  }

  function installMessageChannelImplementation() {
    var channel = new MessageChannel();

    channel.port1.onmessage = function (event) {
      var handle = event.data;
      runIfPresent(handle);
    };

    registerImmediate = function registerImmediate(handle) {
      channel.port2.postMessage(handle);
    };
  }

  function installReadyStateChangeImplementation() {
    var html = doc.documentElement;

    registerImmediate = function registerImmediate(handle) {
      // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
      // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
      var script = doc.createElement("script");

      script.onreadystatechange = function () {
        runIfPresent(handle);
        script.onreadystatechange = null;
        html.removeChild(script);
        script = null;
      };

      html.appendChild(script);
    };
  }

  function installSetTimeoutImplementation() {
    registerImmediate = function registerImmediate(handle) {
      setTimeout(runIfPresent, 0, handle);
    };
  } // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.


  var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
  attachTo = attachTo && attachTo.setTimeout ? attachTo : global; // Don't get fooled by e.g. browserify environments.

  if ({}.toString.call(global.process) === "[object process]") {
    // For Node.js before 0.9
    installNextTickImplementation();
  } else if (canUsePostMessage()) {
    // For non-IE10 modern browsers
    installPostMessageImplementation();
  } else if (global.MessageChannel) {
    // For web workers, where supported
    installMessageChannelImplementation();
  } else if (doc && "onreadystatechange" in doc.createElement("script")) {
    // For IE 6–8
    installReadyStateChangeImplementation();
  } else {
    // For older browsers
    installSetTimeoutImplementation();
  }

  attachTo.setImmediate = setImmediate;
  attachTo.clearImmediate = clearImmediate;
})(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/stream-browserify/index.js":
/*!*************************************************!*\
  !*** ./node_modules/stream-browserify/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
module.exports = Stream;

var EE = __webpack_require__(/*! events */ "./node_modules/events/events.js").EventEmitter;

var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");

inherits(Stream, EE);
Stream.Readable = __webpack_require__(/*! readable-stream/readable.js */ "./node_modules/readable-stream/readable-browser.js");
Stream.Writable = __webpack_require__(/*! readable-stream/writable.js */ "./node_modules/readable-stream/writable-browser.js");
Stream.Duplex = __webpack_require__(/*! readable-stream/duplex.js */ "./node_modules/readable-stream/duplex-browser.js");
Stream.Transform = __webpack_require__(/*! readable-stream/transform.js */ "./node_modules/readable-stream/transform.js");
Stream.PassThrough = __webpack_require__(/*! readable-stream/passthrough.js */ "./node_modules/readable-stream/passthrough.js"); // Backwards-compat with node 0.4.x

Stream.Stream = Stream; // old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function (dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain); // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.

  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;

  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;
    dest.end();
  }

  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;
    if (typeof dest.destroy === 'function') dest.destroy();
  } // don't leave dangling pipes when there are errors.


  function onerror(er) {
    cleanup();

    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror); // remove all the event listeners that were added.

  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);
    source.removeListener('end', onend);
    source.removeListener('close', onclose);
    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);
    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);
    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);
  dest.on('close', cleanup);
  dest.emit('pipe', source); // Allow for unix-like usage: A.pipe(B).pipe(C)

  return dest;
};

/***/ }),

/***/ "./node_modules/style-loader/lib/addStyles.js":
/*!****************************************************!*\
  !*** ./node_modules/style-loader/lib/addStyles.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

var stylesInDom = {};

var	memoize = function (fn) {
	var memo;

	return function () {
		if (typeof memo === "undefined") memo = fn.apply(this, arguments);
		return memo;
	};
};

var isOldIE = memoize(function () {
	// Test for IE <= 9 as proposed by Browserhacks
	// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
	// Tests for existence of standard globals is to allow style-loader
	// to operate correctly into non-standard environments
	// @see https://github.com/webpack-contrib/style-loader/issues/177
	return window && document && document.all && !window.atob;
});

var getTarget = function (target, parent) {
  if (parent){
    return parent.querySelector(target);
  }
  return document.querySelector(target);
};

var getElement = (function (fn) {
	var memo = {};

	return function(target, parent) {
                // If passing function in options, then use it for resolve "head" element.
                // Useful for Shadow Root style i.e
                // {
                //   insertInto: function () { return document.querySelector("#foo").shadowRoot }
                // }
                if (typeof target === 'function') {
                        return target();
                }
                if (typeof memo[target] === "undefined") {
			var styleTarget = getTarget.call(this, target, parent);
			// Special case to return head of iframe instead of iframe itself
			if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
				try {
					// This will throw an exception if access to iframe is blocked
					// due to cross-origin restrictions
					styleTarget = styleTarget.contentDocument.head;
				} catch(e) {
					styleTarget = null;
				}
			}
			memo[target] = styleTarget;
		}
		return memo[target]
	};
})();

var singleton = null;
var	singletonCounter = 0;
var	stylesInsertedAtTop = [];

var	fixUrls = __webpack_require__(/*! ./urls */ "./node_modules/style-loader/lib/urls.js");

module.exports = function(list, options) {
	if (typeof DEBUG !== "undefined" && DEBUG) {
		if (typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
	}

	options = options || {};

	options.attrs = typeof options.attrs === "object" ? options.attrs : {};

	// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
	// tags it will allow on a page
	if (!options.singleton && typeof options.singleton !== "boolean") options.singleton = isOldIE();

	// By default, add <style> tags to the <head> element
        if (!options.insertInto) options.insertInto = "head";

	// By default, add <style> tags to the bottom of the target
	if (!options.insertAt) options.insertAt = "bottom";

	var styles = listToStyles(list, options);

	addStylesToDom(styles, options);

	return function update (newList) {
		var mayRemove = [];

		for (var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];

			domStyle.refs--;
			mayRemove.push(domStyle);
		}

		if(newList) {
			var newStyles = listToStyles(newList, options);
			addStylesToDom(newStyles, options);
		}

		for (var i = 0; i < mayRemove.length; i++) {
			var domStyle = mayRemove[i];

			if(domStyle.refs === 0) {
				for (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();

				delete stylesInDom[domStyle.id];
			}
		}
	};
};

function addStylesToDom (styles, options) {
	for (var i = 0; i < styles.length; i++) {
		var item = styles[i];
		var domStyle = stylesInDom[item.id];

		if(domStyle) {
			domStyle.refs++;

			for(var j = 0; j < domStyle.parts.length; j++) {
				domStyle.parts[j](item.parts[j]);
			}

			for(; j < item.parts.length; j++) {
				domStyle.parts.push(addStyle(item.parts[j], options));
			}
		} else {
			var parts = [];

			for(var j = 0; j < item.parts.length; j++) {
				parts.push(addStyle(item.parts[j], options));
			}

			stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
		}
	}
}

function listToStyles (list, options) {
	var styles = [];
	var newStyles = {};

	for (var i = 0; i < list.length; i++) {
		var item = list[i];
		var id = options.base ? item[0] + options.base : item[0];
		var css = item[1];
		var media = item[2];
		var sourceMap = item[3];
		var part = {css: css, media: media, sourceMap: sourceMap};

		if(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});
		else newStyles[id].parts.push(part);
	}

	return styles;
}

function insertStyleElement (options, style) {
	var target = getElement(options.insertInto)

	if (!target) {
		throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");
	}

	var lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];

	if (options.insertAt === "top") {
		if (!lastStyleElementInsertedAtTop) {
			target.insertBefore(style, target.firstChild);
		} else if (lastStyleElementInsertedAtTop.nextSibling) {
			target.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);
		} else {
			target.appendChild(style);
		}
		stylesInsertedAtTop.push(style);
	} else if (options.insertAt === "bottom") {
		target.appendChild(style);
	} else if (typeof options.insertAt === "object" && options.insertAt.before) {
		var nextSibling = getElement(options.insertAt.before, target);
		target.insertBefore(style, nextSibling);
	} else {
		throw new Error("[Style Loader]\n\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\n Must be 'top', 'bottom', or Object.\n (https://github.com/webpack-contrib/style-loader#insertat)\n");
	}
}

function removeStyleElement (style) {
	if (style.parentNode === null) return false;
	style.parentNode.removeChild(style);

	var idx = stylesInsertedAtTop.indexOf(style);
	if(idx >= 0) {
		stylesInsertedAtTop.splice(idx, 1);
	}
}

function createStyleElement (options) {
	var style = document.createElement("style");

	if(options.attrs.type === undefined) {
		options.attrs.type = "text/css";
	}

	if(options.attrs.nonce === undefined) {
		var nonce = getNonce();
		if (nonce) {
			options.attrs.nonce = nonce;
		}
	}

	addAttrs(style, options.attrs);
	insertStyleElement(options, style);

	return style;
}

function createLinkElement (options) {
	var link = document.createElement("link");

	if(options.attrs.type === undefined) {
		options.attrs.type = "text/css";
	}
	options.attrs.rel = "stylesheet";

	addAttrs(link, options.attrs);
	insertStyleElement(options, link);

	return link;
}

function addAttrs (el, attrs) {
	Object.keys(attrs).forEach(function (key) {
		el.setAttribute(key, attrs[key]);
	});
}

function getNonce() {
	if (false) {}

	return __webpack_require__.nc;
}

function addStyle (obj, options) {
	var style, update, remove, result;

	// If a transform function was defined, run it on the css
	if (options.transform && obj.css) {
	    result = options.transform(obj.css);

	    if (result) {
	    	// If transform returns a value, use that instead of the original css.
	    	// This allows running runtime transformations on the css.
	    	obj.css = result;
	    } else {
	    	// If the transform function returns a falsy value, don't add this css.
	    	// This allows conditional loading of css
	    	return function() {
	    		// noop
	    	};
	    }
	}

	if (options.singleton) {
		var styleIndex = singletonCounter++;

		style = singleton || (singleton = createStyleElement(options));

		update = applyToSingletonTag.bind(null, style, styleIndex, false);
		remove = applyToSingletonTag.bind(null, style, styleIndex, true);

	} else if (
		obj.sourceMap &&
		typeof URL === "function" &&
		typeof URL.createObjectURL === "function" &&
		typeof URL.revokeObjectURL === "function" &&
		typeof Blob === "function" &&
		typeof btoa === "function"
	) {
		style = createLinkElement(options);
		update = updateLink.bind(null, style, options);
		remove = function () {
			removeStyleElement(style);

			if(style.href) URL.revokeObjectURL(style.href);
		};
	} else {
		style = createStyleElement(options);
		update = applyToTag.bind(null, style);
		remove = function () {
			removeStyleElement(style);
		};
	}

	update(obj);

	return function updateStyle (newObj) {
		if (newObj) {
			if (
				newObj.css === obj.css &&
				newObj.media === obj.media &&
				newObj.sourceMap === obj.sourceMap
			) {
				return;
			}

			update(obj = newObj);
		} else {
			remove();
		}
	};
}

var replaceText = (function () {
	var textStore = [];

	return function (index, replacement) {
		textStore[index] = replacement;

		return textStore.filter(Boolean).join('\n');
	};
})();

function applyToSingletonTag (style, index, remove, obj) {
	var css = remove ? "" : obj.css;

	if (style.styleSheet) {
		style.styleSheet.cssText = replaceText(index, css);
	} else {
		var cssNode = document.createTextNode(css);
		var childNodes = style.childNodes;

		if (childNodes[index]) style.removeChild(childNodes[index]);

		if (childNodes.length) {
			style.insertBefore(cssNode, childNodes[index]);
		} else {
			style.appendChild(cssNode);
		}
	}
}

function applyToTag (style, obj) {
	var css = obj.css;
	var media = obj.media;

	if(media) {
		style.setAttribute("media", media)
	}

	if(style.styleSheet) {
		style.styleSheet.cssText = css;
	} else {
		while(style.firstChild) {
			style.removeChild(style.firstChild);
		}

		style.appendChild(document.createTextNode(css));
	}
}

function updateLink (link, options, obj) {
	var css = obj.css;
	var sourceMap = obj.sourceMap;

	/*
		If convertToAbsoluteUrls isn't defined, but sourcemaps are enabled
		and there is no publicPath defined then lets turn convertToAbsoluteUrls
		on by default.  Otherwise default to the convertToAbsoluteUrls option
		directly
	*/
	var autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;

	if (options.convertToAbsoluteUrls || autoFixUrls) {
		css = fixUrls(css);
	}

	if (sourceMap) {
		// http://stackoverflow.com/a/26603875
		css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
	}

	var blob = new Blob([css], { type: "text/css" });

	var oldSrc = link.href;

	link.href = URL.createObjectURL(blob);

	if(oldSrc) URL.revokeObjectURL(oldSrc);
}


/***/ }),

/***/ "./node_modules/style-loader/lib/urls.js":
/*!***********************************************!*\
  !*** ./node_modules/style-loader/lib/urls.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * When source maps are enabled, `style-loader` uses a link element with a data-uri to
 * embed the css on the page. This breaks all relative urls because now they are relative to a
 * bundle instead of the current page.
 *
 * One solution is to only use full urls, but that may be impossible.
 *
 * Instead, this function "fixes" the relative urls to be absolute according to the current page location.
 *
 * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.
 *
 */
module.exports = function (css) {
  // get current location
  var location = typeof window !== "undefined" && window.location;

  if (!location) {
    throw new Error("fixUrls requires window.location");
  } // blank or null?


  if (!css || typeof css !== "string") {
    return css;
  }

  var baseUrl = location.protocol + "//" + location.host;
  var currentDir = baseUrl + location.pathname.replace(/\/[^\/]*$/, "/"); // convert each url(...)

  /*
  This regular expression is just a way to recursively match brackets within
  a string.
  	 /url\s*\(  = Match on the word "url" with any whitespace after it and then a parens
     (  = Start a capturing group
       (?:  = Start a non-capturing group
           [^)(]  = Match anything that isn't a parentheses
           |  = OR
           \(  = Match a start parentheses
               (?:  = Start another non-capturing groups
                   [^)(]+  = Match anything that isn't a parentheses
                   |  = OR
                   \(  = Match a start parentheses
                       [^)(]*  = Match anything that isn't a parentheses
                   \)  = Match a end parentheses
               )  = End Group
               *\) = Match anything and then a close parens
           )  = Close non-capturing group
           *  = Match anything
        )  = Close capturing group
   \)  = Match a close parens
  	 /gi  = Get all matches, not the first.  Be case insensitive.
   */

  var fixedCss = css.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi, function (fullMatch, origUrl) {
    // strip quotes (if they exist)
    var unquotedOrigUrl = origUrl.trim().replace(/^"(.*)"$/, function (o, $1) {
      return $1;
    }).replace(/^'(.*)'$/, function (o, $1) {
      return $1;
    }); // already a full url? no change

    if (/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/|\s*$)/i.test(unquotedOrigUrl)) {
      return fullMatch;
    } // convert the url to a full url


    var newUrl;

    if (unquotedOrigUrl.indexOf("//") === 0) {
      //TODO: should we add protocol?
      newUrl = unquotedOrigUrl;
    } else if (unquotedOrigUrl.indexOf("/") === 0) {
      // path should be relative to the base url
      newUrl = baseUrl + unquotedOrigUrl; // already starts with '/'
    } else {
      // path should be relative to current directory
      newUrl = currentDir + unquotedOrigUrl.replace(/^\.\//, ""); // Strip leading './'
    } // send back the fixed url(...)


    return "url(" + JSON.stringify(newUrl) + ")";
  }); // send back the fixed css

  return fixedCss;
};

/***/ }),

/***/ "./node_modules/timers-browserify/main.js":
/*!************************************************!*\
  !*** ./node_modules/timers-browserify/main.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var scope = typeof global !== "undefined" && global || typeof self !== "undefined" && self || window;
var apply = Function.prototype.apply; // DOM APIs, for completeness

exports.setTimeout = function () {
  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);
};

exports.setInterval = function () {
  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);
};

exports.clearTimeout = exports.clearInterval = function (timeout) {
  if (timeout) {
    timeout.close();
  }
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}

Timeout.prototype.unref = Timeout.prototype.ref = function () {};

Timeout.prototype.close = function () {
  this._clearFn.call(scope, this._id);
}; // Does not start the time, just sets up the members needed.


exports.enroll = function (item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function (item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function (item) {
  clearTimeout(item._idleTimeoutId);
  var msecs = item._idleTimeout;

  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout) item._onTimeout();
    }, msecs);
  }
}; // setimmediate attaches itself to the global object


__webpack_require__(/*! setimmediate */ "./node_modules/setimmediate/setImmediate.js"); // On some exotic environments, it's not clear which object `setimmediate` was
// able to install onto.  Search each possibility in the same order as the
// `setimmediate` library.


exports.setImmediate = typeof self !== "undefined" && self.setImmediate || typeof global !== "undefined" && global.setImmediate || this && this.setImmediate;
exports.clearImmediate = typeof self !== "undefined" && self.clearImmediate || typeof global !== "undefined" && global.clearImmediate || this && this.clearImmediate;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/util-deprecate/browser.js":
/*!************************************************!*\
  !*** ./node_modules/util-deprecate/browser.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/**
 * Module exports.
 */
module.exports = deprecate;
/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate(fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;

  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }

      warned = true;
    }

    return fn.apply(this, arguments);
  }

  return deprecated;
}
/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */


function config(name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }

  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var g; // This works in non-strict mode

g = function () {
  return this;
}();

try {
  // This works if eval is allowed (see CSP)
  g = g || Function("return this")() || (1, eval)("this");
} catch (e) {
  // This works if the window reference is available
  if ((typeof window === "undefined" ? "undefined" : _typeof(window)) === "object") g = window;
} // g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}


module.exports = g;

/***/ }),

/***/ "./node_modules/webpack/buildin/harmony-module.js":
/*!*******************************************!*\
  !*** (webpack)/buildin/harmony-module.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (originalModule) {
  if (!originalModule.webpackPolyfill) {
    var module = Object.create(originalModule); // module.parent = undefined by default

    if (!module.children) module.children = [];
    Object.defineProperty(module, "loaded", {
      enumerable: true,
      get: function get() {
        return module.l;
      }
    });
    Object.defineProperty(module, "id", {
      enumerable: true,
      get: function get() {
        return module.i;
      }
    });
    Object.defineProperty(module, "exports", {
      enumerable: true
    });
    module.webpackPolyfill = 1;
  }

  return module;
};

/***/ }),

/***/ "./src/automaton.json":
/*!****************************!*\
  !*** ./src/automaton.json ***!
  \****************************/
/*! exports provided: v, length, resolution, params, guiSettings, default */
/***/ (function(module) {

module.exports = {"v":"2.0.1","length":3,"resolution":1000,"params":{"jpeg-blockSize":{"nodes":[{"time":0,"value":0.2,"out":{"time":0,"value":0}},{"time":3,"value":0.2,"in":{"time":0,"value":0}}],"fxs":[]},"jpeg-quantizeF":{"nodes":[{"time":0,"value":0.2,"out":{"time":0,"value":0}},{"time":0.6000000000000001,"value":0,"in":{"time":-0.5,"value":0},"out":{"time":0,"value":0}},{"time":0.9,"value":0,"in":{"time":0,"value":0},"out":{"time":0,"value":0}},{"time":0.9,"value":0.2,"in":{"time":0,"value":0},"out":{"time":0,"value":0}},{"time":1.4000000000000001,"value":0,"in":{"time":-0.43050193050193064,"value":0},"out":{"time":0,"value":0}},{"time":1.4000000000000001,"value":0.1,"in":{"time":0,"value":0},"out":{"time":0,"value":0}},{"time":1.8,"value":0,"in":{"time":-0.3320463320463318,"value":0},"out":{"time":0.8764478764478767,"value":0}},{"time":1.8,"value":0.2,"in":{"time":0,"value":0},"out":{"time":0,"value":0}},{"time":2.1602316602316605,"value":0,"in":{"time":-0.3146718146718146,"value":0},"out":{"time":0.5,"value":0}},{"time":3,"value":0.4,"in":{"time":-0.12934362934362964,"value":-0.25096930478463264}}],"fxs":[{"time":0,"length":3,"row":0,"def":"lofi","params":{"rate":30,"relative":false,"reso":0,"round":false}}]},"camera-rotY":{"nodes":[{"time":0,"value":0,"out":{"time":0,"value":0}},{"time":1.4000000000000001,"value":0.2,"in":{"time":0,"value":0},"out":{"time":0,"value":0}},{"time":1.4000000000000001,"value":0.6000000000000001,"in":{"time":0,"value":0},"out":{"time":0,"value":0}},{"time":1.8,"value":0.30000000000000004,"in":{"time":0,"value":0},"out":{"time":0,"value":0}},{"time":1.8,"value":0.5,"in":{"time":0,"value":0},"out":{"time":0.5,"value":0}},{"time":3,"value":2.3000000000000003,"in":{"time":0,"value":0}}],"fxs":[{"time":0,"length":3,"row":0,"def":"noise","params":{"recursion":2,"freq":1,"reso":4,"seed":1,"amp":0.05}}]},"camera-rotX":{"nodes":[{"time":0,"value":0.5,"out":{"time":0,"value":0}},{"time":0.9,"value":0.5,"in":{"time":0,"value":0},"out":{"time":0,"value":0}},{"time":0.9,"value":0,"in":{"time":0,"value":0},"out":{"time":0,"value":0}},{"time":1.4000000000000001,"value":0,"in":{"time":0,"value":0},"out":{"time":0,"value":0}},{"time":1.4000000000000001,"value":-0.2,"in":{"time":0,"value":0},"out":{"time":0,"value":0}},{"time":1.8,"value":-0.2,"in":{"time":0,"value":0},"out":{"time":0,"value":0}},{"time":1.8,"value":0.4,"in":{"time":0,"value":0},"out":{"time":0.7200772200772203,"value":0}},{"time":3,"value":-0.2,"in":{"time":0,"value":0}}],"fxs":[{"time":0,"length":3,"row":0,"def":"noise","params":{"recursion":2,"freq":1,"reso":4,"seed":1,"amp":0.05}}]},"particles-genRate":{"nodes":[{"time":0,"value":1,"out":{"time":0,"value":0}},{"time":3,"value":1,"in":{"time":0,"value":0}}],"fxs":[]},"particles-colorVar":{"nodes":[{"time":0,"value":0.2,"out":{"time":0,"value":0}},{"time":3,"value":0.2,"in":{"time":0,"value":0}}],"fxs":[]},"particles-colorOffset":{"nodes":[{"time":0,"value":0,"out":{"time":0,"value":0}},{"time":3,"value":0,"in":{"time":0,"value":0}}],"fxs":[]},"post-barrelAmp":{"nodes":[{"time":0,"value":0.1,"out":{"time":0,"value":0}},{"time":3,"value":0.1,"in":{"time":0,"value":0}}],"fxs":[]},"post-barrelOffset":{"nodes":[{"time":0,"value":0,"out":{"time":0,"value":0}},{"time":3,"value":0,"in":{"time":0,"value":0}}],"fxs":[]},"particles-noisePhase":{"nodes":[{"time":0,"value":0,"out":{"time":0,"value":0}},{"time":3,"value":0,"in":{"time":0,"value":0}}],"fxs":[{"time":0,"length":3,"row":0,"def":"sine","params":{"amp":2.74,"freq":1,"phase":0}}]},"camera-Radius":{"nodes":[{"time":0,"value":6.6000000000000005,"out":{"time":0.11196911196911197,"value":0}},{"time":0.5,"value":6,"in":{"time":-0.3204633204633204,"value":0},"out":{"time":0,"value":0}},{"time":0.9,"value":6,"in":{"time":0,"value":0},"out":{"time":0,"value":0}},{"time":0.9,"value":4,"in":{"time":0,"value":0},"out":{"time":0,"value":0}},{"time":1.4,"value":4,"in":{"time":0,"value":0},"out":{"time":0,"value":0}},{"time":1.4,"value":6,"in":{"time":0,"value":0},"out":{"time":0,"value":0}},{"time":1.8,"value":6,"in":{"time":0,"value":0},"out":{"time":0,"value":0}},{"time":1.8,"value":5,"in":{"time":0,"value":0},"out":{"time":0.9343629343629343,"value":0}},{"time":3,"value":7,"in":{"time":0,"value":0}}],"fxs":[]},"box-phase":{"nodes":[{"time":0,"value":1,"out":{"time":0,"value":0}},{"time":3,"value":1,"in":{"time":0,"value":0}}],"fxs":[]}},"guiSettings":{"snapActive":true,"snapTime":0.1,"snapValue":0.1}};

/***/ }),

/***/ "./src/config.json":
/*!*************************!*\
  !*** ./src/config.json ***!
  \*************************/
/*! exports provided: resolution, shadowReso, default */
/***/ (function(module) {

module.exports = {"resolution":[640,640],"shadowReso":512};

/***/ }),

/***/ "./src/geoms/cube.js":
/*!***************************!*\
  !*** ./src/geoms/cube.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

var genCube = function genCube(_props) {
  var props = Object.assign({
    size: 1.0
  }, _props);
  var pos = [];
  var nor = [];
  var ind = [];
  var S = props.size;

  var _loop = function _loop(i) {
    var p = [[-S, -S, S], [S, -S, S], [-S, S, S], [S, S, S]];
    var n = [[0, 0, 1], [0, 0, 1], [0, 0, 1], [0, 0, 1]];
    var id = [0, 1, 3, 0, 3, 2].map(function (v) {
      return v + i * 4;
    });

    if (i !== 0) {
      var func = function func(v) {
        if (i < 4) {
          var t = i * Math.PI / 2.0;
          var x = v[0];
          var z = v[2];
          v[0] = Math.cos(t) * x - Math.sin(t) * z;
          v[2] = Math.sin(t) * x + Math.cos(t) * z;
        } else {
          var _t = (i - 0.5) * Math.PI;

          var y = v[1];
          var _z = v[2];
          v[1] = Math.cos(_t) * y - Math.sin(_t) * _z;
          v[2] = Math.sin(_t) * y + Math.cos(_t) * _z;
        }
      };

      p.map(func);
      n.map(func);
    }

    p.map(function (v) {
      return pos.push.apply(pos, _toConsumableArray(v));
    });
    n.map(function (v) {
      return nor.push.apply(nor, _toConsumableArray(v));
    });
    ind.push.apply(ind, _toConsumableArray(id));
  };

  for (var i = 0; i < 6; i++) {
    _loop(i);
  }

  return {
    position: pos,
    normal: nor,
    index: ind
  };
};

module.exports = genCube;

/***/ }),

/***/ "./src/geoms/octahedron.js":
/*!*********************************!*\
  !*** ./src/geoms/octahedron.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var genOctahedron = function genOctahedron(_props) {
  var props = Object.assign({
    div: 1.0
  }, _props);
  var div = parseInt(Math.max(0, props.div));
  var pos = [];
  var nor = [];
  var ind = [];

  for (var ii = 0; ii < 2; ii++) {
    for (var iq = 0; iq < 4; iq++) {
      for (var iy = 0; iy < div + 1; iy++) {
        for (var ix = 0; ix < iy + 1; ix++) {
          var lat0 = (ii * 2.0 + iy / (div + 1)) * Math.PI / 2.0;
          var lat1 = (ii * 2.0 + (iy + 1) / (div + 1)) * Math.PI / 2.0;
          var lon0 = (ii * 2.0 - 1.0) * ((ix - 1) / Math.max(1, iy) + iq) * Math.PI / 2.0;
          var lon1 = (ii * 2.0 - 1.0) * (ix / (iy + 1) + iq) * Math.PI / 2.0;
          var lon2 = (ii * 2.0 - 1.0) * (ix / Math.max(1, iy) + iq) * Math.PI / 2.0;
          var lon3 = (ii * 2.0 - 1.0) * ((ix + 1) / (iy + 1) + iq) * Math.PI / 2.0;

          if (ix !== 0) {
            ind.push(pos.length / 3, pos.length / 3 + 1, pos.length / 3 + 2);
            var x1 = Math.sin(lat0) * Math.cos(lon0);
            var y1 = Math.cos(lat0);
            var z1 = Math.sin(lat0) * Math.sin(lon0);
            var x2 = Math.sin(lat1) * Math.cos(lon1);
            var y2 = Math.cos(lat1);
            var z2 = Math.sin(lat1) * Math.sin(lon1);
            var x3 = Math.sin(lat0) * Math.cos(lon2);
            var y3 = Math.cos(lat0);
            var z3 = Math.sin(lat0) * Math.sin(lon2);
            pos.push(x1, y1, z1, x2, y2, z2, x3, y3, z3);
            {
              var x = x1 + x2 + x3;
              var y = y1 + y2 + y3;
              var z = z1 + z2 + z3;
              var l = Math.sqrt(x * x + y * y + z * z);

              for (var i = 0; i < 3; i++) {
                nor.push(x / l, y / l, z / l);
              }
            }
          }

          {
            ind.push(pos.length / 3, pos.length / 3 + 1, pos.length / 3 + 2);

            var _x = Math.sin(lat0) * Math.cos(lon2);

            var _y = Math.cos(lat0);

            var _z = Math.sin(lat0) * Math.sin(lon2);

            var _x2 = Math.sin(lat1) * Math.cos(lon1);

            var _y2 = Math.cos(lat1);

            var _z2 = Math.sin(lat1) * Math.sin(lon1);

            var _x3 = Math.sin(lat1) * Math.cos(lon3);

            var _y3 = Math.cos(lat1);

            var _z3 = Math.sin(lat1) * Math.sin(lon3);

            pos.push(_x, _y, _z, _x2, _y2, _z2, _x3, _y3, _z3);
            {
              var _x4 = _x + _x2 + _x3;

              var _y4 = _y + _y2 + _y3;

              var _z4 = _z + _z2 + _z3;

              var _l = Math.sqrt(_x4 * _x4 + _y4 * _y4 + _z4 * _z4);

              for (var _i = 0; _i < 3; _i++) {
                nor.push(_x4 / _l, _y4 / _l, _z4 / _l);
              }
            }
          }
        }
      }
    }
  }

  return {
    position: pos,
    normal: nor,
    index: ind
  };
};

module.exports = genOctahedron;

/***/ }),

/***/ "./src/images/diversity.png":
/*!**********************************!*\
  !*** ./src/images/diversity.png ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABAAAAAQACAIAAADwf7zUAAABG2lUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4KPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iWE1QIENvcmUgNS41LjAiPgogPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4KICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIi8+CiA8L3JkZjpSREY+CjwveDp4bXBtZXRhPgo8P3hwYWNrZXQgZW5kPSJyIj8+Gkqr6gAAAYFpQ0NQc1JHQiBJRUM2MTk2Ni0yLjEAACiRdZHPK0RRFMc/M4PxY0SRFItJWA0xamJjMRNDYTFGGWxmnvmh5sfrvZk02SrbKUps/FrwF7BV1koRKVlYWRMbpuc8o0Yy53bu+dzvved077lgDSaVlF41AKl0Vgv4vc750ILT/kQdHbQBNWFFV6dnx4NUtPdbLGa87jNrVT73rzUsR3UFLLXCo4qqZYUnhKdWs6rJW8KtSiK8LHwi7NLkgsI3ph4p8bPJ8RJ/mqwFAz6wNgs747848ouVhJYSlpfTnUrmlJ/7mC9xRNNzsxK7xDvRCeDHi5NJxvDhYZARmT304aZfVlTIH/jOnyEjuYrMKnk0VoiTIItL1JxUj0qMiR6VkSRv9v9vX/XYkLtU3eGF6kfDeO0B+yYUC4bxcWAYxUOwPcB5upyf2YfhN9ELZa17D5rW4fSirEW24WwD2u/VsBb+lmzi1lgMXo6hMQQtV1C/WOrZzz5HdxBck6+6hJ1d6JXzTUtfGHFnwuy9Uw0AAAAJcEhZcwAACxMAAAsTAQCanBgAACAASURBVHic7N15mFxVnT/gTwhJQwMhEAghhgAhghiGAUEYiTDiAI7KCDq4jaMsghAQRH+C4CCI+yiogKBsggvILosgq2CUVdahO/vSSchCQmfpbN2dTtfvj6LK7q7qpLOB0fd96nm4ufecc8+9VQnne+9ZEgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD+LvV6sysA8OYblAxLtk4WJZOSuW92fVhHNcnwZHCSZFYyKWl5k2sEAMDfhv2TR5OVSaH0aUseSPZ6syvG2qlJzk9e7fCFFpLZyVfe7IoBALz5LkvmdW4n9fCzNLk/Gfhm13/dfSxp6uYaG5MPvtnVY03VJvd2/7u9Pal5s2u4Hg1M7k+WrtVf4XnJZW92/YE3kS5A8A/qo8kt61bCr5Om5O3JputWTluyLFmWLEmWJkuSJUlT0pQsTOYn9Unjup2iqj2SPyfbJUnmHHVU42c+UzN0aMu0aTtcffV2DzyQZGbyL8krG+DUbCCXJZ9PkrT37z/uvPN6v/OdSdqfeupt3/52r6amJN9Lzn1Ta7geXZcct24lfDS5bb1UBdjYCADgH9S3kv9Jkow///xC795rlHfInXdu+cILS5ItN0TNKrQlDcn4pC4Zndy3noq9OflYkmT8BRfsdt55m276eiDT2to6/atfHX7xxUmuSU5aT6djQ9sreTapSVqHDp3z4IND99ijfGjqyy8PPeyw3nPnLk32ShrevEquRy8neyVL9t33laOPXqOMvVau3OMb30jy7eS8DVM34G+cAAD+QV2U/L8kyYrW1j59+qxR3hnHHbfTL35R3F6yzz7NO+ywLjXZZPny2jlzNps2LS09Gqg5LXkkuSl5aF3OmsxLtksWHXRQzSOPbLbZZh0PLVm8eJODDqqtq5uW7LJuZ+EN853S0/36W28dccwxXY7W/+IXI447Lsn/JN95o6u2QUxKdktmHHvsTtdfv0YZV6xY0adv3yQXJ1/eIFUD/tat46t74B/dtLPPHvHJT657OYVCYdnSpcuXLGlesqR16dIVixevXLKkvamp14IFm9fVDXrssdq6umLKnZMTkhOSF5PvJ79Zq9PtVer8M/v9739b59Z/ki232mrS+943vK5up2SgSYE2EnuWNga++92VR/sfckhx4+1vVH0A/mYJAIBO2traptfXrzrNFgsWlLe3u/HGSc8/396374pdd91k1113OuCALbfaai3O26tXry223HKLLbvtVdQ4d+5r48fn4Yd3+eUvaxoakuyT3JicmnwzeXANT7d1aWPlNttUTbBiwIAkmyT9BAAbiXIYV1vtF1jeWftG1WdDKyRJ+i5YMOWll1adcuiIEeUebgDAP66LSvOBtLa2FjpYMH9+DycSWVxtZ9N++41/4onCmlixYsXc2bMXLViwcuXKnqRvaW4eN3p0w4knlk/aknxrDS+/X9KcFJKGz3626llmffjDhWThBrn3bBBXln4Pk198sfILnfDkk8WjP1qTMvdI3pccngzbULVeew/0eM6fBfPnd7wVra2txf0XvdmXAAC8odYxAGhKPpc8nSxNWpP2jkdramY1NHTX1p89ffqEp56qu/XW+osumnLqqY3veU97v37FjO21tYv32Wf2UUeNO//8sY88sripadWRwKRnn511zDHl895XWviph54t1XbCU091KXnso48Wyxy9oW4/698nS7+EGZ/8ZJdgsq2trRjRFZIP9bjAWzr8qtuT727Auq+ND3Y/ia0AAACoYrUBwEvJD7r5nJuM6FzaoOSjSV2pzLrLL6/aZK+/776eT1Xe3q/f9GOPHXP//e3t7d3FAO3t7S/fcsvK/v2LWcasyZjdz5ZOtHz48Pr77is2GVeuXFl3110tQ4cWkpWlaYLYKNQkz5e+0ymjRr326qvFH8m82bOnnnRScf8TPS7t9Iof5PJkwAas/toYkZzb/d/TlwQAAEBH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+fKqJZdvyIRzzlkxaFChfANLn+mf/vTkF14opxz3xz8W98/sEBEVPVTKUnmuJYsXF2pqCsnDPaj20aVyxj/+eDn7/IMPLu78bje5BpRyTf785zueevny5a1DhhSSiRVZjihlqfvZz6rc88suKx49uJszXlHKPm3cuC55W5qbl+25Z+WdXLFiRf3ddxf/eEYPbsWY0k9u5pQplTV87dVX22trC+tv4trflqq6YP78jidqbW0t7n8j58gCAN58GyIAOKxUZsMJJ1RtmJYDgPKnKZmYjE4eTV5KpieLK9qs044/fvr48VULLBQKYx58sG3gwGLKv6zJ7JANq4xViq3MtZuFvSaZmhSStgEDFnZuexUKhRUrVjTtt1/x2getYckPl+7J2G98o7sbUrZ0yZIJTz9df889L193Xd1dd016/vnXXn21Y4JFCxYs2XvvQtKefKbiXNOTQtJeW1u18EX771+sSf/V1bkyACgUCtPGjm0bMKC4/75kz4pcl5VyvXzVVZ2+7vvvL+6vXG/5i+UA4K67Kiv88i23FI+eXJGx6Jvle/vYY1WyX3ddx9/kov33X9DY2NbWVoxkWqtdQqUzy7fivPOqnOKqq4pHz+9BUT0hAAAAOlkvAUCxk8kXkws6tDYKycu33FK11Vj/+99XPpPu7tM6ZMjEL32pY6uxi9nTp487//zio+hCcmcPGqO1ybHJ/yZPlc7yyic+UbXwuUccUUzwePK/yafWcJ3d75cbo9df36XksY8+Wjy0FiNuRyRzSyWPeeih7u5MD0380peKRZXXLRucnJx8PXm03HYcObJq3imjRhUTNCe3J99M3ttNnasGAIVCoe7228vf3YLkpuRryceS4zv8llb27z9j4sRyliVLlhRjp7YOD/L3S76SXNnhlzPhqacqKzz2scfKCa5Ozq54U/T+0tH673+/6iXX33PP1JNOmnLaafX33LNo4cJCoVB/773l315P1CRTimFVv36vzpzZsfC2trbF++5bSBateVjYHQEAANDJugcAZycrqjXcZ37sY02LFlVtQrW3t89/7bWp9fVjHn647vrrx37zm9OOP37RgQcWamoKNTXL99hj7vvf33DiifXf//6Ep55qaW6uWkihUJjV0DD+q18t9pcoPsC+pAeXfFDySkVtX7755qqn6PLEt5BMSUb0+PYOTZYUHxUfcEBbW1vH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AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACv4imIAAACC0lEQVQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAm+j9i9cycZ+CysQAAAABJRU5ErkJggg=="

/***/ }),

/***/ "./src/libs/canvas-saver.js":
/*!**********************************!*\
  !*** ./src/libs/canvas-saver.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var JSZip = __webpack_require__(/*! jszip */ "./node_modules/jszip/lib/index.js");

var CanvasSaver =
/*#__PURE__*/
function () {
  function CanvasSaver(canvas) {
    _classCallCheck(this, CanvasSaver);

    this.canvas = canvas;
    this.queueSave = false;
    this.zip = new JSZip();
    this.anchor = document.createElement('a');
    this.frameCount = 0;
    this.inProgress = 0;
  }

  _createClass(CanvasSaver, [{
    key: "capture",
    value: function capture() {
      var _this = this;

      if (this.queueSave) {
        console.error('You already queued save command! Further captures are ignored.');
        return;
      }

      var filename = ('0000' + this.frameCount).slice(-5) + '.png';
      this.frameCount++;
      this.inProgress++;
      this.canvas.toBlob(function (blob) {
        _this.zip.file(filename, blob);

        _this.inProgress--;

        _this.__done();
      });
    }
  }, {
    key: "save",
    value: function save() {
      this.queueSave = true;

      this.__done();
    }
  }, {
    key: "__done",
    value: function __done() {
      var _this2 = this;

      if (this.queueSave && this.inProgress === 0) {
        this.zip.generateAsync({
          type: 'blob'
        }).then(function (blob) {
          _this2.anchor.href = window.URL.createObjectURL(blob);
          _this2.anchor.download = 'canvasSaver-' + Date.now();

          _this2.anchor.click();

          _this2.frameCount = 0;
          _this2.queueSave = false;
        });
      }
    }
  }]);

  return CanvasSaver;
}();

module.exports = CanvasSaver;

/***/ }),

/***/ "./src/libs/glcat-path-gui.js":
/*!************************************!*\
  !*** ./src/libs/glcat-path-gui.js ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _glcat_path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./glcat-path */ "./src/libs/glcat-path.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }



var requiredFields = function requiredFields(object, nanithefuck, fields) {
  fields.map(function (field) {
    if (typeof object[field] === 'undefined') {
      throw 'GLCat-Path: ' + field + ' is required for ' + nanithefuck;
    }
  });
};

var PathGUI =
/*#__PURE__*/
function (_Path) {
  _inherits(PathGUI, _Path);

  function PathGUI(glCat, params) {
    var _this;

    _classCallCheck(this, PathGUI);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(PathGUI).call(this, glCat, params));

    var it = _assertThisInitialized(_assertThisInitialized(_this));

    requiredFields(params, 'params', ['canvas', 'el']);
    it.gui = {
      parent: it.params.el
    };
    it.gui.info = document.createElement('span');
    it.gui.parent.appendChild(it.gui.info);
    it.gui.range = document.createElement('input');
    it.gui.range.type = 'range';
    it.gui.range.min = 0;
    it.gui.range.max = 0;
    it.gui.range.step = 1;
    it.gui.parent.appendChild(it.gui.range);
    it.dateList = new Array(30).fill(0);
    it.dateListIndex = 0;
    it.totalFrames = 0;
    it.fps = 0;
    it.currentIndex = 0;
    it.viewName = '';
    it.viewIndex = 0;
    var gl = glCat.gl;
    var vboQuad = glCat.createVertexbuffer(new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]));
    it.add({
      __PathGuiReturn: {
        width: it.params.canvas.width,
        height: it.params.canvas.height,
        vert: 'attribute vec2 p;void main(){gl_Position=vec4(p,0,1);}',
        frag: 'precision highp float;uniform vec2 r;uniform sampler2D s;void main(){gl_FragColor=texture2D(s,gl_FragCoord.xy/r);}',
        blend: [gl.ONE, gl.ONE],
        clear: [0.0, 0.0, 0.0, 1.0],
        func: function func(_p, params) {
          gl.viewport(0, 0, it.params.canvas.width, it.params.canvas.height);
          glCat.uniform2fv('r', [it.params.canvas.width, it.params.canvas.height]);
          glCat.attribute('p', vboQuad, 2);
          glCat.uniformTexture('s', params.input, 0);
          gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        }
      }
    });
    return _this;
  }

  _createClass(PathGUI, [{
    key: "begin",
    value: function begin() {
      var it = this;
      it.currentIndex = 0;
    }
  }, {
    key: "end",
    value: function end() {
      var it = this;
      it.gui.range.max = Math.max(it.gui.range.max, it.currentIndex);
      it.currentIndex = 0;
      var now = +new Date() * 1E-3;
      it.dateList[it.dateListIndex] = now;
      it.dateListIndex = (it.dateListIndex + 1) % it.dateList.length;
      it.fps = ((it.dateList.length - 1) / (now - it.dateList[it.dateListIndex])).toFixed(1);
      it.totalFrames++;
      it.gui.info.innerText = 'Path: ' + it.viewName + ' (' + it.viewIndex + ')\n' + it.fps + ' FPS\n' + it.totalFrames + ' frames\n';
    }
  }, {
    key: "render",
    value: function render(name, params) {
      var it = this;
      it.currentIndex++;
      var view = parseInt(it.gui.range.value);

      if (it.currentIndex <= view || view === 0) {
        it.viewName = view === 0 ? '*Full*' : name;
        it.viewIndex = it.currentIndex;

        _get(_getPrototypeOf(PathGUI.prototype), "render", this).call(this, name, params);

        if (it.currentIndex === view) {
          var t = params && params.target ? params.target : it.paths[name].framebuffer;

          if (t && t.framebuffer) {
            var i = t.textures ? t.textures[0] : t.texture;

            if (it.params.stretch) {
              _get(_getPrototypeOf(PathGUI.prototype), "render", this).call(this, '__PathGuiReturn', {
                target: PathGUI.nullFb,
                input: i,
                width: it.params.canvas.width,
                height: it.params.canvas.height
              });
            } else {
              it.params.canvas.width = (params ? params.width : 0) || it.paths[name].width || it.params.width;
              it.params.canvas.height = (params ? params.height : 0) || it.paths[name].height || it.params.height;

              _get(_getPrototypeOf(PathGUI.prototype), "render", this).call(this, '__PathGuiReturn', {
                target: PathGUI.nullFb,
                input: i
              });
            }
          }
        }
      }
    }
  }]);

  return PathGUI;
}(_glcat_path__WEBPACK_IMPORTED_MODULE_0__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (PathGUI);

/***/ }),

/***/ "./src/libs/glcat-path.js":
/*!********************************!*\
  !*** ./src/libs/glcat-path.js ***!
  \********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var requiredFields = function requiredFields(object, nanithefuck, fields) {
  fields.map(function (field) {
    if (typeof object[field] === 'undefined') {
      throw 'GLCat-Path: ' + field + ' is required for ' + nanithefuck;
    }
  });
};

var Path =
/*#__PURE__*/
function () {
  function Path(glCat, params) {
    _classCallCheck(this, Path);

    var it = this;
    it.glCat = glCat;
    it.gl = glCat.gl;
    it.paths = {};

    it.globalFunc = function () {};

    it.params = params || {};
  }

  _createClass(Path, [{
    key: "add",
    value: function add(paths) {
      var it = this;

      for (var name in paths) {
        var path = paths[name];
        requiredFields(path, 'path object', ['vert', 'frag']);
        it.paths[name] = path;

        if (typeof path.depthTest === 'undefined') {
          path.depthTest = true;
        }

        if (typeof path.depthWrite === 'undefined') {
          path.depthWrite = true;
        }

        if (typeof path.blend === 'undefined') {
          path.blend = [it.gl.SRC_ALPHA, it.gl.ONE_MINUS_SRC_ALPHA];
        }

        if (typeof path.cull === 'undefined') {
          path.cull = true;
        }

        if (path.framebuffer) {
          if (path.drawbuffers) {
            path.framebuffer = it.glCat.createDrawBuffers(path.width, path.height, path.drawbuffers);
          } else if (path.float) {
            path.framebuffer = it.glCat.createFloatFramebuffer(path.width, path.height);
          } else {
            path.framebuffer = it.glCat.createFramebuffer(path.width, path.height);
          }
        }

        path.program = it.glCat.createProgram(path.vert, path.frag);
      }
    }
  }, {
    key: "render",
    value: function render(name, params) {
      var _it$gl;

      var it = this;
      var path = it.paths[name];

      if (!path) {
        throw 'GLCat-Path: The path called ' + name + ' is not defined!';
      }

      if (!params) {
        params = {};
      }

      params.framebuffer = typeof params.target !== 'undefined' ? params.target.framebuffer : path.framebuffer ? path.framebuffer.framebuffer : null;
      var width = params.width || path.width;
      var height = params.height || path.height;

      if (!width || !height) {
        throw 'GLCat-Path: width or height is invalid';
      }

      it.gl.viewport(0, 0, width, height);
      it.glCat.useProgram(path.program);
      path.cull ? it.gl.enable(it.gl.CULL_FACE) : it.gl.disable(it.gl.CULL_FACE);
      it.gl.bindFramebuffer(it.gl.FRAMEBUFFER, params.framebuffer);

      if (it.params.drawbuffers) {
        it.glCat.drawBuffers(path.drawbuffers ? path.drawbuffers : params.framebuffer === null ? [it.gl.BACK] : [it.gl.COLOR_ATTACHMENT0]);
      }

      (_it$gl = it.gl).blendFunc.apply(_it$gl, _toConsumableArray(path.blend));

      if (path.clear) {
        var _it$glCat;

        (_it$glCat = it.glCat).clear.apply(_it$glCat, _toConsumableArray(path.clear));
      }

      path.depthTest ? it.gl.enable(it.gl.DEPTH_TEST) : it.gl.disable(it.gl.DEPTH_TEST);
      path.depthWrite ? it.gl.depthMask(true) : it.gl.depthMask(false);
      it.glCat.uniform2fv('resolution', [width, height]);
      it.globalFunc(path, params);

      if (path.func) {
        path.func(path, params);
      }
    }
  }, {
    key: "replaceProgram",
    value: function replaceProgram(name, vert, frag) {
      var path = this.paths[name];

      if (!path) {
        throw 'GLCat-Path: The path called ' + name + ' is not defined!';
      }

      try {
        var prevProgram = path.program;
        var newProgram = this.glCat.createProgram(vert, frag);

        if (newProgram) {
          path.program = newProgram;
          this.gl.deleteProgram(prevProgram.program);
          this.gl.deleteShader(prevProgram.vert);
          this.gl.deleteShader(prevProgram.frag);
        }
      } catch (e) {
        console.error(e);
      }
    }
  }, {
    key: "resize",
    value: function resize(name, width, height) {
      var it = this;
      var path = it.paths[name];
      path.width = width;
      path.height = height;

      if (path.framebuffer) {
        if (it.params.drawbuffers && path.drawbuffers) {
          path.framebuffer = it.glCat.createDrawBuffers(path.width, path.height, path.drawbuffers);
        } else if (path.float) {
          it.glCat.resizeFloatFramebuffer(path.framebuffer, path.width, path.height);
        } else {
          it.glCat.resizeFramebuffer(path.framebuffer, path.width, path.height);
        }
      }

      if (typeof path.onresize === 'function') {
        path.onresize(path, width, height);
      }
    }
  }, {
    key: "setGlobalFunc",
    value: function setGlobalFunc(func) {
      this.globalFunc = func;
    }
  }, {
    key: "fb",
    value: function fb(name) {
      if (!this.paths[name]) {
        throw 'glcat-path.fb: path called ' + name + ' is not defined';
      }

      if (!this.paths[name].framebuffer) {
        throw 'glcat-path.fb: there is no framebuffer for the path ' + name;
      }

      return this.paths[name].framebuffer;
    }
  }]);

  return Path;
}();

Path.nullFb = {
  framebuffer: null
};
/* harmony default export */ __webpack_exports__["default"] = (Path);

/***/ }),

/***/ "./src/libs/glcat.js":
/*!***************************!*\
  !*** ./src/libs/glcat.js ***!
  \***************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * @typedef {Object} GLCatProgram
 * @property {WebGLProgram} program
 * @property {Object<string,GLint|WebGLUniformLocation>} locations
 */

/**
 * @typedef {Object} GLCatFramebuffer
 * @property {WebGLFramebuffer} framebuffer
 * @property {WebGLRenderbuffer} depth
 * @property {WebGLTexture} texture
 */

/**
 * @typedef {Object} GLCatDrawBuffers
 * @property {WebGLFramebuffer} framebuffer
 * @property {WebGLRenderbuffer} depth
 * @property {WebGLTexture[]} textures
 */

/**
 * @typedef {ImageBitmap|ImageData|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} Pixelable
 */

/**
 * WebGL wrapper with lots of respect to the original API, starring FMS_Cat.
 */
var GLCat =
/*#__PURE__*/
function () {
  /**
   * Create a new GLCat instance.
   * @param {WebGLRenderingContext} _gl Original WebGL context
   */
  function GLCat(_gl) {
    _classCallCheck(this, GLCat);

    this.gl = _gl;
    var gl = this.gl;
    gl.enable(gl.DEPTH_TEST);
    gl.depthFunc(gl.LEQUAL);
    gl.enable(gl.BLEND);
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
    /**
     * Contain extensions.  
     * Keys are extension name, and values are extension object.
     * @type {Object<string,WebGLExtension>}
     * @protected
     */

    this.__extensions = {};
    /**
     * Currently using program.
     * @type {WebGLProgram}
     * @protected
     */

    this.__currentProgram = null;
  }
  /**
   * Get a new or existing extension object.
   * @param {string} _name Name of the extension
   * @param {boolean} [_throw=false] If this is true, exception will be throwed when it is failed to get extension
   * @returns {WebGLExtension} Extension object
   */


  _createClass(GLCat, [{
    key: "getExtension",
    value: function getExtension(_name, _throw) {
      var _this = this;

      var gl = this.gl;

      if (_typeof(_name) === 'object' && _name.isArray()) {
        return _name.every(function (name) {
          return _this.getExtension(name, _throw);
        });
      } else if (typeof _name === 'string') {
        if (this.__extensions[_name]) {
          return this.__extensions[_name];
        } else {
          this.__extensions[_name] = gl.getExtension(_name);

          if (this.__extensions[_name]) {
            return this.__extensions[_name];
          } else {
            if (_throw) {
              throw new Error('The extension "' + _name + '" is not supported');
            }

            return null;
          }
        }
      } else {
        throw new Error('GLCat.getExtension: _name must be string or array');
      }
    }
    /**
     * Create a new GLCat program object.
     * @param {string} _vert GLSL source of the vertex shader
     * @param {string} _frag GLSL source of the fragment shader
     * @param {Function} [_onError] Will be called if compile/link error is occurred
     * @returns {GLCatProgram} Created program
     */

  }, {
    key: "createProgram",
    value: function createProgram(_vert, _frag, _onError) {
      var gl = this.gl;
      var error;

      if (typeof _onError === 'function') {
        error = _onError;
      } else {
        error = function error(_str) {
          throw new Error(_str);
        };
      }

      var vert = gl.createShader(gl.VERTEX_SHADER);
      gl.shaderSource(vert, _vert);
      gl.compileShader(vert);

      if (!gl.getShaderParameter(vert, gl.COMPILE_STATUS)) {
        error(gl.getShaderInfoLog(vert));
        gl.deleteShader(vert);
        return null;
      }

      var frag = gl.createShader(gl.FRAGMENT_SHADER);
      gl.shaderSource(frag, _frag);
      gl.compileShader(frag);

      if (!gl.getShaderParameter(frag, gl.COMPILE_STATUS)) {
        error(gl.getShaderInfoLog(frag));
        gl.deleteShader(vert);
        gl.deleteShader(frag);
        return null;
      }

      var program = gl.createProgram();
      gl.attachShader(program, vert);
      gl.attachShader(program, frag);
      gl.linkProgram(program);

      if (gl.getProgramParameter(program, gl.LINK_STATUS)) {
        return {
          vert: vert,
          frag: frag,
          program: program,
          locations: {}
        };
      } else {
        error(gl.getProgramInfoLog(program));
        gl.deleteShader(vert);
        gl.deleteShader(frag);
        gl.deleteProgram(program);
        return null;
      }
    }
    /**
     * Specity a program to use.
     * @param {GLCatProgram} _program Program you want to use
     * @returns {void} void
     */

  }, {
    key: "useProgram",
    value: function useProgram(_program) {
      var gl = this.gl;
      gl.useProgram(_program.program);
      this.__currentProgram = _program;
    }
    /**
     * Create a new vertex buffer.
     * @param {ArrayBuffer|ArrayBufferView} _source Source of the data
     * @returns {WebGLBuffer} Generated vertex buffer
     */

  }, {
    key: "createVertexbuffer",
    value: function createVertexbuffer(_source) {
      var gl = this.gl;
      var buffer = gl.createBuffer();

      if (_source) {
        this.setVertexbuffer(buffer, _source);
      }

      return buffer;
    }
    /**
     * Set new data into a vertex buffer.
     * @param {WebGLBuffer} _target Target vertex buffer
     * @param {ArrayBuffer|ArrayBufferView} _source Source of the data
     * @param {GLenum} [_usage=gl.STATIC_DRAW] Usage of the buffer
     * @returns {void} void
     */

  }, {
    key: "setVertexbuffer",
    value: function setVertexbuffer(_target, _source, _usage) {
      var gl = this.gl;
      var usage = _usage || gl.STATIC_DRAW;
      gl.bindBuffer(gl.ARRAY_BUFFER, _target);
      gl.bufferData(gl.ARRAY_BUFFER, _source, usage);
      gl.bindBuffer(gl.ARRAY_BUFFER, null);
    }
    /**
     * Create a new index buffer.
     * @param {ArrayBuffer|ArrayBufferView} _source Source of the data
     * @returns {WebGLBuffer} Generated index buffer
     */

  }, {
    key: "createIndexbuffer",
    value: function createIndexbuffer(_source) {
      var gl = this.gl;
      var buffer = gl.createBuffer();

      if (_source) {
        this.setIndexbuffer(buffer, _source);
      }

      return buffer;
    }
    /**
     * Set new data into a index buffer.
     * @param {WebGLBuffer} _target Target index buffer
     * @param {ArrayBuffer|ArrayBufferView} _source Source of the data
     * @param {GLenum} [_usage=gl.STATIC_DRAW] Usage of the buffer
     * @returns {void} void
     */

  }, {
    key: "setIndexbuffer",
    value: function setIndexbuffer(_target, _source, _usage) {
      var gl = this.gl;
      var usage = _usage || gl.STATIC_DRAW;
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, _target);
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, _source, usage);
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
    }
    /**
     * Get location for given attribute variable name for current program.
     * @param {string} _name Name of the attribute variable
     * @returns {GLint} Location of the attribute variable
     */

  }, {
    key: "getAttribLocation",
    value: function getAttribLocation(_name) {
      var gl = this.gl;
      var location;

      if (this.__currentProgram.locations[_name]) {
        location = this.__currentProgram.locations[_name];
      } else {
        location = gl.getAttribLocation(this.__currentProgram.program, _name);
        this.__currentProgram.locations[_name] = location;
      }

      return location;
    }
    /**
     * Attach an vertex buffer as attribute variable to the current program.
     * @param {string} _name Name of the attribute variable
     * @param {WebGLBuffer} _buffer Vertex buffer
     * @param {GLint} _size Number of components per vertex. Must be 1, 2, 3 or 4
     * @param {GLenum} [_type=gl.FLOAT] Data type of each component
     * @param {GLsizei} [_stride=0] Stride in bytes
     * @param {GLintptr} [_offset=0] Offset in bytes
     * @returns {void} void
     */

  }, {
    key: "attribute",
    value: function attribute(_name, _buffer, _size, _type, _stride, _offset) {
      var gl = this.gl;
      var location = this.getAttribLocation(_name);

      if (location === -1) {
        return;
      }

      gl.bindBuffer(gl.ARRAY_BUFFER, _buffer);
      gl.enableVertexAttribArray(location);
      gl.vertexAttribPointer(location, _size, _type || gl.FLOAT, false, _stride || 0, _offset || 0);
      var ext = this.getExtension('ANGLE_instanced_arrays');

      if (ext) {
        ext.vertexAttribDivisorANGLE(location, 0);
      }

      gl.bindBuffer(gl.ARRAY_BUFFER, null);
    }
    /**
     * Attach an vertex buffer as attribute variable to the current program.  
     * Can set divisor at 4th argument for use of instancing.
     * @param {string} _name Name of the attribute variable
     * @param {WebGLBuffer} _buffer Vertex buffer
     * @param {GLint} _size Number of components per vertex. Must be 1, 2, 3 or 4
     * @param {GLuint} _div Divisor of the attribute
     * @param {GLenum} [_type=gl.FLOAT] Data type of each component
     * @param {GLsizei} [_stride=0] Stride in bytes
     * @param {GLintptr} [_offset=0] Offset in bytes
     * @returns {void} void
     */

  }, {
    key: "attributeDivisor",
    value: function attributeDivisor(_name, _buffer, _size, _div, _type, _stride, _offset) {
      var gl = this.gl;
      this.getExtension('ANGLE_instanced_arrays', true);
      var location = this.getAttribLocation(_name);

      if (location === -1) {
        return;
      }

      gl.bindBuffer(gl.ARRAY_BUFFER, _buffer);
      gl.enableVertexAttribArray(location);
      gl.vertexAttribPointer(location, _size, _type || gl.FLOAT, false, _stride || 0, _offset || 0);
      var ext = this.getExtension('ANGLE_instanced_arrays');

      if (ext) {
        ext.vertexAttribDivisorANGLE(location, _div);
      }

      gl.bindBuffer(gl.ARRAY_BUFFER, null);
    }
    /**
     * Get location for given uniform variable name for current program.
     * @param {string} _name Name of the uniform variable
     * @returns {WebGLUniformLocation} Location of the uniform variable
     */

  }, {
    key: "getUniformLocation",
    value: function getUniformLocation(_name) {
      var gl = this.gl;
      var location;

      if (typeof this.__currentProgram.locations[_name] !== 'undefined') {
        location = this.__currentProgram.locations[_name];
      } else {
        location = gl.getUniformLocation(this.__currentProgram.program, _name);
        this.__currentProgram.locations[_name] = location;
      }

      return location;
    }
    /**
     * Attach an uniform variable.  
     * Finally, laziness won.
     * @param {string} _type Type of the uniform variable
     * @param {string} _name Name of the uniform variable
     * @param {number} _value Value
     * @returns {void} void
     */

  }, {
    key: "uniform",
    value: function uniform(_type, _name, _value) {
      var gl = this.gl;
      var location = this.getUniformLocation(_name);

      gl['uniform' + _type](location, _value);
    }
    /**
     * Attach an `int` type uniform variable.
     * @param {string} _name Name of the uniform variable
     * @param {number} _value `int` value
     * @returns {void} void
     */

  }, {
    key: "uniform1i",
    value: function uniform1i(_name, _value) {
      var gl = this.gl;
      var location = this.getUniformLocation(_name);
      gl.uniform1i(location, _value);
    }
    /**
     * Attach a `float` type uniform variable.
     * @param {string} _name Name of the uniform variable
     * @param {number} _value `float` value
     * @returns {void} void
     */

  }, {
    key: "uniform1f",
    value: function uniform1f(_name, _value) {
      var gl = this.gl;
      var location = this.getUniformLocation(_name);
      gl.uniform1f(location, _value);
    }
    /**
     * Attach an array of `vec2` type uniform variable.
     * @param {string} _name Name of the uniform variable
     * @param {Float32Array|number[]} _value Array of `vec2` value
     * @returns {void} void
     */

  }, {
    key: "uniform2fv",
    value: function uniform2fv(_name, _value) {
      var gl = this.gl;
      var location = this.getUniformLocation(_name);
      gl.uniform2fv(location, _value);
    }
    /**
     * Attach an array of `vec3` type uniform variable.
     * @param {string} _name Name of the uniform variable
     * @param {Float32Array|number[]} _value Array of `vec3` value
     * @returns {void} void
     */

  }, {
    key: "uniform3fv",
    value: function uniform3fv(_name, _value) {
      var gl = this.gl;
      var location = this.getUniformLocation(_name);
      gl.uniform3fv(location, _value);
    }
    /**
     * Attach an array of `vec4` type uniform variable.
     * @param {string} _name Name of the uniform variable
     * @param {Float32Array|number[]} _value Array of `vec4` value
     * @returns {void} void
     */

  }, {
    key: "uniform4fv",
    value: function uniform4fv(_name, _value) {
      var gl = this.gl;
      var location = this.getUniformLocation(_name);
      gl.uniform4fv(location, _value);
    }
    /**
     * Attach an array of `mat4` type uniform variable.
     * @param {string} _name Name of the uniform variable
     * @param {Float32Array|number[]} _value Array of `mat4` value
     * @param {GLboolean} [_transpose=false] Specify whether to transpose the matrix
     * @returns {void} void
     */

  }, {
    key: "uniformMatrix4fv",
    value: function uniformMatrix4fv(_name, _value, _transpose) {
      var gl = this.gl;
      var location = this.getUniformLocation(_name);
      gl.uniformMatrix4fv(location, _transpose || false, _value);
    }
    /**
     * Attach a `sampler2D` type uniform texture.
     * @param {string} _name Name of the uniform texture
     * @param {WebGLTexture} _texture Texture object
     * @param {number} _number Specify a texture unit, in integer
     * @returns {void} void
     */

  }, {
    key: "uniformTexture",
    value: function uniformTexture(_name, _texture, _number) {
      var gl = this.gl;
      var location = this.getUniformLocation(_name);
      gl.activeTexture(gl.TEXTURE0 + _number);
      gl.bindTexture(gl.TEXTURE_2D, _texture);
      gl.uniform1i(location, _number);
    }
    /**
     * Attach a `samplerCube` type uniform texture.
     * @param {string} _name Name of the uniform texture
     * @param {WebGLTexture} _texture Texture object
     * @param {number} _number Specify a texture unit, in integer
     * @returns {void} void
     */

  }, {
    key: "uniformCubemap",
    value: function uniformCubemap(_name, _texture, _number) {
      var gl = this.gl;
      var location = this.getUniformLocation(_name);
      gl.activeTexture(gl.TEXTURE0 + _number);
      gl.bindTexture(gl.TEXTURE_CUBE_MAP, _texture);
      gl.uniform1i(location, _number);
    }
    /**
     * Create a texture object.
     * @returns {WebGLTexture} Texture object
     */

  }, {
    key: "createTexture",
    value: function createTexture() {
      var gl = this.gl;
      var texture = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, texture);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.bindTexture(gl.TEXTURE_2D, null);
      return texture;
    }
    /**
     * Specify how to filter the texture.
     * @param {WebGLTexture} _texture Texture object
     * @param {GLenum} _filter Texture filter
     * @returns {void} void
     */

  }, {
    key: "textureFilter",
    value: function textureFilter(_texture, _filter) {
      var gl = this.gl;
      gl.bindTexture(gl.TEXTURE_2D, _texture);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, _filter);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, _filter);
      gl.bindTexture(gl.TEXTURE_2D, null);
    }
    /**
     * Specify how to wrap the texture.
     * @param {WebGLTexture} _texture Texture object
     * @param {GLenum} _filter Wrapping function for the texture
     * @returns {void} void
     */

  }, {
    key: "textureWrap",
    value: function textureWrap(_texture, _wrap) {
      var gl = this.gl;
      gl.bindTexture(gl.TEXTURE_2D, _texture);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, _wrap);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, _wrap);
      gl.bindTexture(gl.TEXTURE_2D, null);
    }
    /**
     * Set new data into a texture object.  
     * This function uses image data. If you want to source `Uint8Array`, use `GLCat.setTextureFromArray()` instead.
     * @param {WebGLTexture} _texture Texture object
     * @param {Pixelable} _source Source image of the pixel data
     * @returns {void} void
     */

  }, {
    key: "setTexture",
    value: function setTexture(_texture, _source) {
      var gl = this.gl;
      gl.bindTexture(gl.TEXTURE_2D, _texture);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, _source);
      gl.bindTexture(gl.TEXTURE_2D, null);
    }
    /**
     * Set new data into a texture object.  
     * This function uses `Uint8Array`. If you want to source image data, use `GLCat.setTexture()` instead.  
     * Or you want to use float texture? Try this: `GLCat.setTextureFromFloatArray()`
     * @param {WebGLTexture} _texture Texture object
     * @param {GLsizei} _width Width of the texture
     * @param {GLsizei} _height Height of the texture
     * @param {Uint8Array} _source Source buffer of the pixel data
     * @returns {void} void
     */

  }, {
    key: "setTextureFromArray",
    value: function setTextureFromArray(_texture, _width, _height, _source) {
      var gl = this.gl;
      gl.bindTexture(gl.TEXTURE_2D, _texture);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, _width, _height, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array(_source));
      gl.bindTexture(gl.TEXTURE_2D, null);
    }
    /**
     * Set new data into a texture object.  
     * This function uses `Float32Array`.  
     * If you can't grab `OES_texture_float` extension here, you will die at this point.
     * @param {WebGLTexture} _texture Texture object
     * @param {GLsizei} _width Width of the texture
     * @param {GLsizei} _height Height of the texture
     * @param {Float32Array} _source Source buffer of the pixel data
     * @returns {void} void
     */

  }, {
    key: "setTextureFromFloatArray",
    value: function setTextureFromFloatArray(_texture, _width, _height, _source) {
      var gl = this.gl;
      this.getExtension('OES_texture_float', true);
      gl.bindTexture(gl.TEXTURE_2D, _texture);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, _width, _height, 0, gl.RGBA, gl.FLOAT, new Float32Array(_source));

      if (!this.getExtension('OES_texture_float_linear')) {
        this.textureFilter(_texture, gl.NEAREST);
      }

      gl.bindTexture(gl.TEXTURE_2D, null);
    }
    /**
     * Copy pixels from current framebuffer to given texture.
     * @param {WebGLTexture} _texture Target texture object
     * @param {GLsizei} _width Width of the texture
     * @param {GLsizei} _height Height of the texture
     * @returns {void} void
     */

  }, {
    key: "copyTexture",
    value: function copyTexture(_texture, _width, _height) {
      var gl = this.gl;
      gl.bindTexture(gl.TEXTURE_2D, _texture);
      gl.copyTexImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 0, 0, _width, _height, 0);
      gl.bindTexture(gl.TEXTURE_2D, null);
    }
    /**
     * Create a cubemap texture object.
     * @param {Pixelable[]} _arrayOfImage Array of iamges. Order: `X+`, `X-`, `Y+`, `Y-`, `Z+`, `Z-`
     * @returns {WebGLTexture} Texture object
     */

  }, {
    key: "createCubemap",
    value: function createCubemap(_arrayOfImage) {
      var gl = this.gl;
      var texture = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_CUBE_MAP, texture);

      for (var i = 0; i < 6; i++) {
        gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, _arrayOfImage[i]);
      }

      gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.bindTexture(gl.TEXTURE_CUBE_MAP, null);
      return texture;
    }
    /**
     * Create a framebuffer object.
     * @param {GLsizei} _width Width of the framebuffer
     * @param {GLsizei} _height Height of the framebuffer
     * @returns {GLCatFramebuffer} Framebuffer object
     */

  }, {
    key: "createFramebuffer",
    value: function createFramebuffer(_width, _height) {
      var gl = this.gl;
      var framebuffer = {};
      framebuffer.framebuffer = gl.createFramebuffer();
      gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer.framebuffer);
      framebuffer.depth = gl.createRenderbuffer();
      gl.bindRenderbuffer(gl.RENDERBUFFER, framebuffer.depth);
      gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, _width, _height);
      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, framebuffer.depth);
      framebuffer.texture = this.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, framebuffer.texture);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, _width, _height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
      gl.bindTexture(gl.TEXTURE_2D, null);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, framebuffer.texture, 0);
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      return framebuffer;
    }
    /**
     * Resize a framebuffer object.
     * @param {GLCatFramebuffer} Framebuffer object
     * @param {GLsizei} _width Width of the framebuffer
     * @param {GLsizei} _height Height of the framebuffer
     * @returns {void} void
     */

  }, {
    key: "resizeFramebuffer",
    value: function resizeFramebuffer(_framebuffer, _width, _height) {
      var it = this;
      var gl = it.gl;
      gl.bindFramebuffer(gl.FRAMEBUFFER, _framebuffer.framebuffer);
      gl.bindRenderbuffer(gl.RENDERBUFFER, _framebuffer.depth);
      gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, _width, _height);
      gl.bindRenderbuffer(gl.RENDERBUFFER, null);
      gl.bindTexture(gl.TEXTURE_2D, _framebuffer.texture);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, _width, _height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
      gl.bindTexture(gl.TEXTURE_2D, null);
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    }
    /**
     * Create a framebuffer object, but Float32 one.
     * @param {GLsizei} _width Width of the framebuffer
     * @param {GLsizei} _height Height of the framebuffer
     * @returns {GLCatFramebuffer} Framebuffer object
     */

  }, {
    key: "createFloatFramebuffer",
    value: function createFloatFramebuffer(_width, _height) {
      var it = this;
      var gl = it.gl;
      it.getExtension('OES_texture_float', true);
      var framebuffer = {};
      framebuffer.framebuffer = gl.createFramebuffer();
      gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer.framebuffer);
      framebuffer.depth = gl.createRenderbuffer();
      gl.bindRenderbuffer(gl.RENDERBUFFER, framebuffer.depth);
      gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, _width, _height);
      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, framebuffer.depth);
      framebuffer.texture = it.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, framebuffer.texture);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, _width, _height, 0, gl.RGBA, gl.FLOAT, null);

      if (!it.getExtension('OES_texture_float_linear')) {
        it.textureFilter(framebuffer.texture, gl.NEAREST);
      }

      gl.bindTexture(gl.TEXTURE_2D, null);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, framebuffer.texture, 0);
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      return framebuffer;
    }
    /**
     * Resize a float framebuffer object.
     * @param {GLCatFramebuffer} Framebuffer object
     * @param {GLsizei} _width Width of the framebuffer
     * @param {GLsizei} _height Height of the framebuffer
     * @returns {void} void
     */

  }, {
    key: "resizeFloatFramebuffer",
    value: function resizeFloatFramebuffer(_framebuffer, _width, _height) {
      var it = this;
      var gl = it.gl;
      gl.bindFramebuffer(gl.FRAMEBUFFER, _framebuffer.framebuffer);
      gl.bindRenderbuffer(gl.RENDERBUFFER, _framebuffer.depth);
      gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, _width, _height);
      gl.bindRenderbuffer(gl.RENDERBUFFER, null);
      gl.bindTexture(gl.TEXTURE_2D, _framebuffer.texture);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, _width, _height, 0, gl.RGBA, gl.FLOAT, null);
      gl.bindTexture(gl.TEXTURE_2D, null);
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    }
    /**
     * Create a draw buffers object.  
     * If you can't grab `WEBGL_draw_buffers` extension, you will die instantly.  
     * Format of its textures will be Float32.
     * @param {GLsizei} _width Width of the draw buffers
     * @param {GLsizei} _height Height of the draw buffers
     * @param {number} Specify how many textures it has
     * @returns {GLCatDrawBuffers} Draw buffers object
     */

  }, {
    key: "createDrawBuffers",
    value: function createDrawBuffers(_width, _height, _numDrawBuffers) {
      var it = this;
      var gl = it.gl;
      it.getExtension('OES_texture_float', true);
      var ext = it.getExtension('WEBGL_draw_buffers', true);

      if (ext.MAX_DRAW_BUFFERS_WEBGL < _numDrawBuffers) {
        throw 'createDrawBuffers: MAX_DRAW_BUFFERS_WEBGL is ' + ext.MAX_DRAW_BUFFERS_WEBGL;
      }

      var drawbuffers = {};
      drawbuffers.framebuffer = gl.createFramebuffer();
      gl.bindFramebuffer(gl.FRAMEBUFFER, drawbuffers.framebuffer);
      drawbuffers.depth = gl.createRenderbuffer();
      gl.bindRenderbuffer(gl.RENDERBUFFER, drawbuffers.depth);
      gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, _width, _height);
      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, drawbuffers.depth);
      drawbuffers.textures = [];

      for (var i = 0; i < _numDrawBuffers; i++) {
        drawbuffers.textures[i] = it.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, drawbuffers.textures[i]);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, _width, _height, 0, gl.RGBA, gl.FLOAT, null);

        if (!it.getExtension('OES_texture_float_linear')) {
          it.textureFilter(drawbuffers.textures[i], gl.NEAREST);
        }

        gl.bindTexture(gl.TEXTURE_2D, null);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, ext.COLOR_ATTACHMENT0_WEBGL + i, gl.TEXTURE_2D, drawbuffers.textures[i], 0);
      }

      var status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);

      if (status !== gl.FRAMEBUFFER_COMPLETE) {
        throw 'createDrawBuffers: gl.checkFramebufferStatus( gl.FRAMEBUFFER ) returns ' + status;
      }

      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      return drawbuffers;
    }
    /**
     * Resize a draw buffers object.
     * @param {GLCatDrawBuffers} Draw buffers object
     * @param {GLsizei} _width Width of the draw buffers
     * @param {GLsizei} _height Height of the draw buffers
     * @returns {void} void
     */

  }, {
    key: "resizeDrawBuffers",
    value: function resizeDrawBuffers(_framebuffer, _width, _height) {
      var it = this;
      var gl = it.gl;
      gl.bindFramebuffer(gl.FRAMEBUFFER, _framebuffer.framebuffer);
      gl.bindRenderbuffer(gl.RENDERBUFFER, _framebuffer.depth);
      gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, _width, _height);
      gl.bindRenderbuffer(gl.RENDERBUFFER, null);

      for (var i = 0; i < _framebuffer.textures.length; i++) {
        gl.bindTexture(gl.TEXTURE_2D, _framebuffer.textures[i]);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, _width, _height, 0, gl.RGBA, gl.FLOAT, null);
        gl.bindTexture(gl.TEXTURE_2D, null);
      }

      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    }
    /**
     * Call this before you are going to use draw buffers.
     * @param {number} Specify how many draw buffers you are going to use
     * @returns {void} void
     */

  }, {
    key: "drawBuffers",
    value: function drawBuffers(_numDrawBuffers) {
      var it = this;
      var gl = it.gl;
      var ext = it.getExtension('WEBGL_draw_buffers', true);
      var array = [];

      if (typeof _numDrawBuffers === 'number') {
        for (var i = 0; i < _numDrawBuffers; i++) {
          array.push(ext.COLOR_ATTACHMENT0_WEBGL + i);
        }
      } else {
        array = array.concat(_numDrawBuffers);
      }

      ext.drawBuffersWEBGL(array);
    }
    /**
     * Clear current framebuffer.
     * @param {GLclampf} [_r=0.0] Red amount of clearing color
     * @param {GLclampf} [_g=0.0] Green amount of clearing color
     * @param {GLclampf} [_b=0.0] Blue amount of clearing color
     * @param {GLclampf} [_a=1.0] Alpha amount of clearing color
     * @param {GLclampf} [_depth=1.0] Clearing depth
     * @returns {void} void
     */

  }, {
    key: "clear",
    value: function clear(_r, _g, _b, _a, _depth) {
      var it = this;
      var gl = it.gl;
      var r = _r || 0.0;
      var g = _g || 0.0;
      var b = _b || 0.0;
      var a = typeof _a === 'number' ? _a : 1.0;
      var depth = typeof _depth === 'number' ? _depth : 1.0;
      gl.clearColor(r, g, b, a);
      gl.clearDepth(depth);
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    }
  }]);

  return GLCat;
}();

/* harmony default export */ __webpack_exports__["default"] = (GLCat);

/***/ }),

/***/ "./src/libs/mathcat.js":
/*!*****************************!*\
  !*** ./src/libs/mathcat.js ***!
  \*****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// にゃーん
var MathCat = {};
/**
 * Add two vecs.
 * @param {number[]} a vecN
 * @param {number[]} b vecN
 * @returns {number[]} vecN, `a + b`
 * @static
 */

MathCat.vecAdd = function (a, b) {
  return a.map(function (e, i) {
    return e + b[i];
  });
};
/**
 * Substract a vec from an another vec.
 * @param {number[]} a vecN
 * @param {number[]} b vecN
 * @returns {number[]} vecN, `a - b`
 * @static
 */


MathCat.vecSub = function (a, b) {
  return a.map(function (e, i) {
    return e - b[i];
  });
};
/**
 * Multiply two vecs.
 * @param {number[]} a vecN
 * @param {number[]} b vecN
 * @returns {number[]} vecN, `a * b`
 * @static
 */


MathCat.vecMul = function (a, b) {
  return a.map(function (e, i) {
    return e - b[i];
  });
};
/**
 * Return a cross of two vec3s.
 * @param {number[]} a vec3
 * @param {number[]} b vec3
 * @returns {number[]} vec3, cross product of `a` and `b`
 * @static
 */


MathCat.vec3Cross = function (a, b) {
  return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];
};
/**
 * Scale a vec by scalar.
 * @param {number} s scalar
 * @param {number[]} v vecN
 * @returns {number[]} vecN, `s * v`
 * @static
 */


MathCat.vecScale = function (s, v) {
  return v.map(function (e) {
    return e * s;
  });
};
/**
 * Dot two vectors.
 * @param {number[]} a vecN
 * @param {number[]} b vecN
 * @returns {number[]} vecN, Dot of `a` and `b`
 * @static
 */


MathCat.vecDot = function (a, b) {
  return a.reduce(function (p, e, i) {
    return p + e * b[i];
  }, 0.0);
};
/**
 * Return length of a vec.
 * @param {number[]} v vecN
 * @returns {number} scalar, length of `v`
 * @static
 */


MathCat.vecLength = function (v) {
  return Math.sqrt(v.reduce(function (p, c) {
    return p + c * c;
  }, 0.0));
};
/**
 * Normalize a vec.
 * @param {number[]} v vecN
 * @returns {number[]} vec, normalized `v`
 * @static
 */


MathCat.vecNormalize = function (v) {
  return MathCat.vecScale(1.0 / MathCat.vecLength(v), v);
};
/**
 * Multiply two quats.
 * @param {number[]} q quat
 * @param {number[]} r quat
 * @returns {number[]} quat, product of `a` and `b`
 * @static
 */


MathCat.quatMul = function (q, r) {
  return [q[3] * r[0] + q[0] * r[3] + q[1] * r[2] - q[2] * r[1], q[3] * r[1] - q[0] * r[2] + q[1] * r[3] + q[2] * r[0], q[3] * r[2] + q[0] * r[1] - q[1] * r[0] + q[2] * r[3], q[3] * r[3] - q[0] * r[0] - q[1] * r[1] - q[2] * r[2]];
};
/**
 * Inverse a quat.
 * @param {number[]} q quat
 * @returns {number[]} quat, `-q`
 * @static
 */


MathCat.quatInv = function (q) {
  return [-q[0], -q[1], -q[2], q[3]];
};
/**
 * Rotate a vec3 using one quat.
 * @param {number[]} v vec3
 * @param {number[]} q quat
 * @returns {number[]} vec3, rotated vector
 * @static
 */


MathCat.rotateVecByQuat = function (v, q) {
  var p = [v[0], v[1], v[2], 0.0];
  var r = MathCat.quatInv(q);
  var res = MathCat.quatMul(MathCat.quatMul(q, p), r);
  return [res[0], res[1], res[2]];
};
/**
 * Convert quat into mat4.
 * @param {number[]} q quat
 * @returns {number[]} mat4, rotation matrix made from quat
 * @static
 */


MathCat.quatToMat4 = function (q) {
  var x = MathCat.rotateVecByQuat([1.0, 0.0, 0.0], q);
  var y = MathCat.rotateVecByQuat([0.0, 1.0, 0.0], q);
  var z = MathCat.rotateVecByQuat([0.0, 0.0, 1.0], q);
  return [x[0], y[0], z[0], 0.0, x[1], y[1], z[1], 0.0, x[2], y[2], z[2], 0.0, 0.0, 0.0, 0.0, 1.0];
};
/**
 * Generate quat from angle and axis.
 * @param {number} angle scalar, Rotation angle in radian
 * @param {number[]} axis vec3, Rotation axis
 * @returns {number[]} quat, Generated quaternion
 * @static
 */


MathCat.quatAngleAxis = function (angle, axis) {
  var ha = angle / 2.0;
  var sha = Math.sin(ha);
  return [axis[0] * sha, axis[1] * sha, axis[2] * sha, Math.cos(ha)];
};
/**
 * Apply two mat4s.
 * @param {number[]} a mat4
 * @param {number[]} b mat4
 * @returns {number[]} mat4, Applied matrix
 * @static
 */


MathCat.mat4Apply = function (a, b) {
  return [a[0] * b[0] + a[4] * b[1] + a[8] * b[2] + a[12] * b[3], a[1] * b[0] + a[5] * b[1] + a[9] * b[2] + a[13] * b[3], a[2] * b[0] + a[6] * b[1] + a[10] * b[2] + a[14] * b[3], a[3] * b[0] + a[7] * b[1] + a[11] * b[2] + a[15] * b[3], a[0] * b[4] + a[4] * b[5] + a[8] * b[6] + a[12] * b[7], a[1] * b[4] + a[5] * b[5] + a[9] * b[6] + a[13] * b[7], a[2] * b[4] + a[6] * b[5] + a[10] * b[6] + a[14] * b[7], a[3] * b[4] + a[7] * b[5] + a[11] * b[6] + a[15] * b[7], a[0] * b[8] + a[4] * b[9] + a[8] * b[10] + a[12] * b[11], a[1] * b[8] + a[5] * b[9] + a[9] * b[10] + a[13] * b[11], a[2] * b[8] + a[6] * b[9] + a[10] * b[10] + a[14] * b[11], a[3] * b[8] + a[7] * b[9] + a[11] * b[10] + a[15] * b[11], a[0] * b[12] + a[4] * b[13] + a[8] * b[14] + a[12] * b[15], a[1] * b[12] + a[5] * b[13] + a[9] * b[14] + a[13] * b[15], a[2] * b[12] + a[6] * b[13] + a[10] * b[14] + a[14] * b[15], a[3] * b[12] + a[7] * b[13] + a[11] * b[14] + a[15] * b[15]];
};
/**
 * Invert a mat4.
 * @param {number[]} m mat4
 * @returns {number[]} mat4, Inverted matrix
 * @static
 */


MathCat.mat4Inverse = function (m) {
  var a00 = m[0],
      a01 = m[1],
      a02 = m[2],
      a03 = m[3],
      a10 = m[4],
      a11 = m[5],
      a12 = m[6],
      a13 = m[7],
      a20 = m[8],
      a21 = m[9],
      a22 = m[10],
      a23 = m[11],
      a30 = m[12],
      a31 = m[13],
      a32 = m[14],
      a33 = m[15],
      b00 = a00 * a11 - a01 * a10,
      b01 = a00 * a12 - a02 * a10,
      b02 = a00 * a13 - a03 * a10,
      b03 = a01 * a12 - a02 * a11,
      b04 = a01 * a13 - a03 * a11,
      b05 = a02 * a13 - a03 * a12,
      b06 = a20 * a31 - a21 * a30,
      b07 = a20 * a32 - a22 * a30,
      b08 = a20 * a33 - a23 * a30,
      b09 = a21 * a32 - a22 * a31,
      b10 = a21 * a33 - a23 * a31,
      b11 = a22 * a33 - a23 * a32;
  return MathCat.vecScale(1.0 / b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06, [a11 * b11 - a12 * b10 + a13 * b09, a02 * b10 - a01 * b11 - a03 * b09, a31 * b05 - a32 * b04 + a33 * b03, a22 * b04 - a21 * b05 - a23 * b03, a12 * b08 - a10 * b11 - a13 * b07, a00 * b11 - a02 * b08 + a03 * b07, a32 * b02 - a30 * b05 - a33 * b01, a20 * b05 - a22 * b02 + a23 * b01, a10 * b10 - a11 * b08 + a13 * b06, a01 * b08 - a00 * b10 - a03 * b06, a30 * b04 - a31 * b02 + a33 * b00, a21 * b02 - a20 * b04 - a23 * b00, a11 * b07 - a10 * b09 - a12 * b06, a00 * b09 - a01 * b07 + a02 * b06, a31 * b01 - a30 * b03 - a32 * b00, a20 * b03 - a21 * b01 + a22 * b00]);
};
/**
 * Apply a mat4 to a vec4.
 * @param {number[]} m mat4
 * @param {number[]} v vec4
 * @returns {number[]} vec4, Applied vector
 * @static
 */


MathCat.mat4ApplyToVec4 = function (m, v) {
  return [m[0] * v[0] + m[4] * v[1] + m[8] * v[2] + m[12] * v[3], m[1] * v[0] + m[5] * v[1] + m[9] * v[2] + m[13] * v[3], m[2] * v[0] + m[6] * v[1] + m[10] * v[2] + m[14] * v[3], m[3] * v[0] + m[7] * v[1] + m[11] * v[2] + m[15] * v[3]];
};
/**
 * Transpose a mat4.
 * @param {number[]} m mat4
 * @returns {number[]} mat4, Transposed matrix
 * @static
 */


MathCat.mat4Transpose = function (m) {
  return [m[0], m[4], m[8], m[12], m[1], m[5], m[9], m[13], m[2], m[6], m[10], m[14], m[3], m[7], m[11], m[15]];
};
/**
 * Generate an indentity mat4.
 * @returns {number[]} mat4, Identity matrix
 * @static
 */


MathCat.mat4Identity = function () {
  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
};
/**
 * Generate a 3d translate matrix.
 * @param {number[]} v vec3, Translation
 * @returns {number[]} mat4, Generated matrix
 * @static
 */


MathCat.mat4Translate = function (v) {
  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, v[0], v[1], v[2], 1];
};
/**
 * Generate a 3d scale matrix.  
 * See also: {@link MathCat#mat4ScaleXYZ}
 * @param {number[]} v vec3, Scaling
 * @returns {number[]} mat4, Generated matrix
 * @static
 */


MathCat.mat4Scale = function (v) {
  return [v[0], 0, 0, 0, 0, v[1], 0, 0, 0, 0, v[2], 0, 0, 0, 0, 1];
};
/**
 * Generate a 3d scale matrix.  
 * See also: {@link MathCat#mat4Scale}
 * @param {number[]} s scalar, Scaling
 * @returns {number[]} mat4, Generated matrix
 * @static
 */


MathCat.mat4ScaleXYZ = function (s) {
  return [s, 0, 0, 0, 0, s, 0, 0, 0, 0, s, 0, 0, 0, 0, 1];
};
/**
 * Generate a 3d rotation matrix.  
 * 2d rotation around x axis.
 * @param {number[]} t scalar, Rotation angle in radians
 * @returns {number[]} mat4, Generated matrix
 * @static
 */


MathCat.mat4RotateX = function (t) {
  return [1, 0, 0, 0, 0, Math.cos(t), -Math.sin(t), 0, 0, Math.sin(t), Math.cos(t), 0, 0, 0, 0, 1];
};
/**
 * Generate a 3d rotation matrix.  
 * 2d rotation around y axis.
 * @param {number[]} t scalar, Rotation angle in radians
 * @returns {number[]} mat4, Generated matrix
 * @static
 */


MathCat.mat4RotateY = function (t) {
  return [Math.cos(t), 0, Math.sin(t), 0, 0, 1, 0, 0, -Math.sin(t), 0, Math.cos(t), 0, 0, 0, 0, 1];
};
/**
 * Generate a 3d rotation matrix.  
 * 2d rotation around z axis.
 * @param {number[]} t scalar, Rotation angle in radians
 * @returns {number[]} mat4, Generated matrix
 * @static
 */


MathCat.mat4RotateZ = function (t) {
  return [Math.cos(t), -Math.sin(t), 0, 0, Math.sin(t), Math.cos(t), 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
};
/**
 * Generate a "LookAt" view matrix.
 * @param {number[]} pos vec3, Position
 * @param {number[]} tar vec3, Target
 * @param {number[]} [air=[ 0.0, 1.0, 0.0 ]] vec3, Up vector
 * @param {number} [rot=0.0] scalar, Roll. yeahhhh I think such lookAt generator should have roll parameter
 * @returns {number[]} mat4, Generated matrix
 * @static
 */


MathCat.mat4LookAt = function (pos, tar, air, rot) {
  var dir = MathCat.vecNormalize(MathCat.vecSub(tar, pos));
  var sid = MathCat.vecNormalize(MathCat.vec3Cross(dir, air || [0.0, 1.0, 0.0]));
  var top = MathCat.vec3Cross(sid, dir);
  sid = MathCat.vecAdd(MathCat.vecScale(Math.cos(rot || 0.0), sid), MathCat.vecScale(Math.sin(rot || 0.0), top));
  top = MathCat.vec3Cross(sid, dir);
  return [sid[0], top[0], dir[0], 0.0, sid[1], top[1], dir[1], 0.0, sid[2], top[2], dir[2], 0.0, -sid[0] * pos[0] - sid[1] * pos[1] - sid[2] * pos[2], -top[0] * pos[0] - top[1] * pos[1] - top[2] * pos[2], -dir[0] * pos[0] - dir[1] * pos[1] - dir[2] * pos[2], 1.0];
};
/**
 * Generate a "Perspective" projection matrix.  
 * It won't include aspect!
 * @param {number} fov scalar
 * @param {number} near scalar
 * @param {number} far scalar
 * @returns {number[]} mat4, Generated matrix
 * @static
 */


MathCat.mat4Perspective = function (fov, near, far) {
  var p = 1.0 / Math.tan(fov * Math.PI / 360.0);
  var d = far - near;
  return [p, 0.0, 0.0, 0.0, 0.0, p, 0.0, 0.0, 0.0, 0.0, (far + near) / d, 1.0, 0.0, 0.0, -2 * far * near / d, 0.0];
};

/* harmony default export */ __webpack_exports__["default"] = (MathCat);

/***/ }),

/***/ "./src/libs/ultracat.js":
/*!******************************!*\
  !*** ./src/libs/ultracat.js ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

// お前、ナンデモアリかよ！
var UltraCat = {};
UltraCat.triangleStripQuad = [-1, -1, 1, -1, -1, 1, 1, 1];
UltraCat.triangleStripQuad3 = [-1, -1, 0, 1, -1, 0, -1, 1, 0, 1, 1, 0];
UltraCat.triangleStripQuadNor = [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1];
UltraCat.triangleStripQuadUV = [0, 0, 1, 0, 0, 1, 1, 1]; // destructive

UltraCat.shuffleArrayD = function (array, dice) {
  var f = dice ? dice : function () {
    return Math.random();
  };

  for (var i = 0; i < array.length - 1; i++) {
    var ir = i + Math.floor(f() * (array.length - i));
    var temp = array[ir];
    array[ir] = array[i];
    array[i] = temp;
  }

  return array;
};

UltraCat.triIndexToLineIndex = function (array) {
  var ret = [];

  for (var i = 0; i < array.length / 3; i++) {
    var head = i * 3;
    ret.push(array[head], array[head + 1], array[head + 1], array[head + 2], array[head + 2], array[head]);
  }

  return ret;
};

UltraCat.matrix2d = function (w, h) {
  var arr = [];

  for (var iy = 0; iy < h; iy++) {
    for (var ix = 0; ix < w; ix++) {
      arr.push(ix, iy);
    }
  }

  return arr;
};

UltraCat.lerp = function (a, b, x) {
  return a + (b - a) * x;
};

UltraCat.clamp = function (x, l, h) {
  return Math.min(Math.max(x, l), h);
};

UltraCat.saturate = function (x) {
  return Math.min(Math.max(x, 0.0), 1.0);
};

UltraCat.linearstep = function (a, b, x) {
  return UltraCat.saturate((x - a) / (b - a));
};

UltraCat.smoothstep = function (a, b, x) {
  var t = UltraCat.linearstep(a, b, x);
  return t * t * (3.0 - 2.0 * t);
};

UltraCat.ExpSmooth =
/*#__PURE__*/
function () {
  function _class(factor) {
    _classCallCheck(this, _class);

    this.factor = factor;
    this.value = 0.0;
  }

  _createClass(_class, [{
    key: "update",
    value: function update(value, dt) {
      this.value = UltraCat.lerp(value, this.value, Math.exp(-this.factor * dt));
      return this.value;
    }
  }]);

  return _class;
}();

/* harmony default export */ __webpack_exports__["default"] = (UltraCat);

/***/ }),

/***/ "./src/libs/xorshift.js":
/*!******************************!*\
  !*** ./src/libs/xorshift.js ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var Xorshift =
/*#__PURE__*/
function () {
  function Xorshift(_seed) {
    _classCallCheck(this, Xorshift);

    this.set(_seed);
  }

  _createClass(Xorshift, [{
    key: "gen",
    value: function gen(_seed) {
      if (_seed) {
        this.set(_seed);
      }

      this.seed = this.seed ^ this.seed << 13;
      this.seed = this.seed ^ this.seed >>> 17;
      this.seed = this.seed ^ this.seed << 5;
      return this.seed / Math.pow(2, 32) + 0.5;
    }
  }, {
    key: "set",
    value: function set(_seed) {
      this.seed = _seed || this.seed || 1;
    }
  }]);

  return Xorshift;
}();

/* harmony default export */ __webpack_exports__["default"] = (Xorshift);

/***/ }),

/***/ "./src/main.js":
/*!*********************!*\
  !*** ./src/main.js ***!
  \*********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _styles_main_scss__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./styles/main.scss */ "./src/styles/main.scss");
/* harmony import */ var _styles_main_scss__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_styles_main_scss__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _libs_glcat_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./libs/glcat.js */ "./src/libs/glcat.js");
/* harmony import */ var _libs_glcat_path_gui__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./libs/glcat-path-gui */ "./src/libs/glcat-path-gui.js");
/* harmony import */ var _libs_mathcat_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./libs/mathcat.js */ "./src/libs/mathcat.js");
/* harmony import */ var _libs_ultracat_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./libs/ultracat.js */ "./src/libs/ultracat.js");
/* harmony import */ var _fms_cat_automaton__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @fms-cat/automaton */ "./node_modules/@fms-cat/automaton/dist/automaton.js");
/* harmony import */ var _fms_cat_automaton__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_fms_cat_automaton__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _libs_canvas_saver__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./libs/canvas-saver */ "./src/libs/canvas-saver.js");
/* harmony import */ var _libs_canvas_saver__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_libs_canvas_saver__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _config_json__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./config.json */ "./src/config.json");
var _config_json__WEBPACK_IMPORTED_MODULE_7___namespace = /*#__PURE__*/__webpack_require__.t(/*! ./config.json */ "./src/config.json", 1);
 // == import various modules / stuff ===========================================







 // == we are stull struggling by this ==========================================

var $ = document.querySelector.bind(document); // == hi canvas ================================================================

var canvas = $('#canvas');
var width = canvas.width = _config_json__WEBPACK_IMPORTED_MODULE_7__.resolution[0];
var height = canvas.height = _config_json__WEBPACK_IMPORTED_MODULE_7__.resolution[1];
var saver = new _libs_canvas_saver__WEBPACK_IMPORTED_MODULE_6___default.a(canvas);
var gl = canvas.getContext('webgl');
gl.lineWidth(1); // e

var glCat = new _libs_glcat_js__WEBPACK_IMPORTED_MODULE_1__["default"](gl);
glCat.getExtension('OES_texture_float', true);
glCat.getExtension('OES_texture_float_linear', true);
glCat.getExtension('EXT_frag_depth', true);
glCat.getExtension('ANGLE_instanced_arrays', true);
var glCatPath = new _libs_glcat_path_gui__WEBPACK_IMPORTED_MODULE_2__["default"](glCat, {
  el: $('#divPath'),
  canvas: canvas,
  stretch: true,
  drawbuffers: true
}); // oh hi

var vboQuad = glCat.createVertexbuffer(new Float32Array(_libs_ultracat_js__WEBPACK_IMPORTED_MODULE_4__["default"].triangleStripQuad)); // == hello automaton ==========================================================

var totalFrame = 0;
var isInitialFrame = true;
var automaton = new _fms_cat_automaton__WEBPACK_IMPORTED_MODULE_5___default.a({
  loop: true,
  fps: 120,
  gui: $('#divAutomaton'),
  data: __webpack_require__(/*! ./automaton.json */ "./src/automaton.json")
});
var auto = automaton.auto;

if (false) {} // == lights, camera, action! ==================================================


var cameraPos = [0.0, 0.0, 0.0];
var cameraTar = [0.0, 0.0, 0.0];
var cameraRoll = 0.0; // protip: considering roll of cam is cool idea

var perspFov = 70.0;
var perspNear = 0.01;
var perspFar = 100.0;
var lightPos = [5.0, 5.0, 10.0]; // this is pretty random

var shadowReso = _config_json__WEBPACK_IMPORTED_MODULE_7__.shadowReso; // texture size for shadow buffer

var matP = _libs_mathcat_js__WEBPACK_IMPORTED_MODULE_3__["default"].mat4Perspective(perspFov, perspNear, perspFar);
var matV = _libs_mathcat_js__WEBPACK_IMPORTED_MODULE_3__["default"].mat4LookAt(cameraPos, cameraTar, [0.0, 1.0, 0.0], cameraRoll);
var matPL = _libs_mathcat_js__WEBPACK_IMPORTED_MODULE_3__["default"].mat4Perspective(perspFov, perspNear, perspFar);
var matVL = _libs_mathcat_js__WEBPACK_IMPORTED_MODULE_3__["default"].mat4LookAt(lightPos, cameraTar, [0.0, 1.0, 0.0], 0.0);

var updateMatrices = function updateMatrices(camOffset) {
  cameraPos = [0.0, 0.0, auto('camera-Radius')];
  cameraPos = _libs_mathcat_js__WEBPACK_IMPORTED_MODULE_3__["default"].rotateVecByQuat(cameraPos, _libs_mathcat_js__WEBPACK_IMPORTED_MODULE_3__["default"].quatAngleAxis(auto('camera-rotX', {
    smooth: 10.0
  }) - 0.5, [1.0, 0.0, 0.0]));
  cameraPos = _libs_mathcat_js__WEBPACK_IMPORTED_MODULE_3__["default"].rotateVecByQuat(cameraPos, _libs_mathcat_js__WEBPACK_IMPORTED_MODULE_3__["default"].quatAngleAxis(auto('camera-rotY', {
    smooth: 10.0
  }) - 0.5, [0.0, 1.0, 0.0]));

  if (camOffset) {
    cameraPos = _libs_mathcat_js__WEBPACK_IMPORTED_MODULE_3__["default"].vecAdd(cameraPos, camOffset);
  }

  matP = _libs_mathcat_js__WEBPACK_IMPORTED_MODULE_3__["default"].mat4Perspective(perspFov, perspNear, perspFar);
  matV = _libs_mathcat_js__WEBPACK_IMPORTED_MODULE_3__["default"].mat4LookAt(cameraPos, cameraTar, [0.0, 1.0, 0.0], cameraRoll);
  matPL = _libs_mathcat_js__WEBPACK_IMPORTED_MODULE_3__["default"].mat4Perspective(perspFov, perspNear, perspFar);
  matVL = _libs_mathcat_js__WEBPACK_IMPORTED_MODULE_3__["default"].mat4LookAt(lightPos, cameraTar, [0.0, 1.0, 0.0], 0.0);
};

updateMatrices(); // == mouse listener, why tho ==================================================

var mouseX = 0.0;
var mouseY = 0.0;
canvas.addEventListener('mousemove', function (event) {
  mouseX = event.offsetX;
  mouseY = event.offsetY;
}); // == global uniform variables =================================================

glCatPath.setGlobalFunc(function () {
  glCat.uniform1i('isInitialFrame', isInitialFrame);
  glCat.uniform1f('time', automaton.time);
  glCat.uniform1f('deltaTime', automaton.deltaTime);
  glCat.uniform1f('totalFrame', totalFrame);
  glCat.uniform3fv('cameraPos', cameraPos);
  glCat.uniform3fv('cameraTar', cameraTar);
  glCat.uniform1f('cameraRoll', cameraRoll);
  glCat.uniform1f('perspFov', perspFov);
  glCat.uniform1f('perspNear', perspNear);
  glCat.uniform1f('perspFar', perspFar);
  glCat.uniform3fv('lightPos', lightPos);
  glCat.uniformMatrix4fv('matP', matP);
  glCat.uniformMatrix4fv('matV', matV);
  glCat.uniformMatrix4fv('matPL', matPL);
  glCat.uniformMatrix4fv('matVL', matVL);
  glCat.uniform2fv('mouse', [mouseX, mouseY]);
  glCat.uniform4fv('bgColor', [0.0, 0.0, 0.0, 1.0]);
}); // == glcat-path setup =========================================================

glCatPath.add({
  return: {
    width: width,
    height: height,
    vert: __webpack_require__(/*! ./shaders/quad.vert */ "./src/shaders/quad.vert"),
    frag: __webpack_require__(/*! ./shaders/return.frag */ "./src/shaders/return.frag"),
    blend: [gl.ONE, gl.ZERO],
    clear: [0.0, 0.0, 0.0, 1.0],
    func: function func(path, params) {
      glCat.attribute('p', vboQuad, 2);
      glCat.uniformTexture('sampler0', params.input, 0);
      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    }
  },
  inspector: {
    width: width,
    height: height,
    vert: __webpack_require__(/*! ./shaders/quad.vert */ "./src/shaders/quad.vert"),
    frag: __webpack_require__(/*! ./shaders/inspector.frag */ "./src/shaders/inspector.frag"),
    blend: [gl.ONE, gl.ZERO],
    clear: [0.0, 0.0, 0.0, 1.0],
    func: function func(path, params) {
      glCat.attribute('p', vboQuad, 2);
      glCat.uniform3fv('circleColor', [1.0, 1.0, 1.0]);
      glCat.uniformTexture('sampler0', params.input, 0);
      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    }
  },
  target: {
    width: width,
    height: height,
    vert: __webpack_require__(/*! ./shaders/quad.vert */ "./src/shaders/quad.vert"),
    frag: __webpack_require__(/*! ./shaders/bg.frag */ "./src/shaders/bg.frag"),
    blend: [gl.ONE, gl.ZERO],
    clear: [0.0, 0.0, 0.0, 1.0],
    framebuffer: true,
    float: true,
    drawbuffers: 2,
    depthWrite: false,
    func: function func() {
      glCat.attribute('p', vboQuad, 2);
      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    }
  },
  shadow: {
    width: shadowReso,
    height: shadowReso,
    vert: __webpack_require__(/*! ./shaders/quad.vert */ "./src/shaders/quad.vert"),
    frag: __webpack_require__(/*! ./shaders/bg.frag */ "./src/shaders/bg.frag"),
    blend: [gl.ONE, gl.ZERO],
    clear: [perspFar, 0.0, 0.0, 1.0],
    framebuffer: true,
    float: true,
    func: function func() {// glCat.attribute( 'p', vboQuad, 2 );
      // gl.drawArrays( gl.TRIANGLE_STRIP, 0, 4 );
    }
  }
}); // == setup paths ==============================================================

var context = {
  glCatPath: glCatPath,
  automaton: automaton,
  width: width,
  height: height
};

__webpack_require__(/*! ./paths/bloom */ "./src/paths/bloom.js").default(context);

__webpack_require__(/*! ./paths/box */ "./src/paths/box.js").default(context);

__webpack_require__(/*! ./paths/jpeg */ "./src/paths/jpeg.js").default(context);

__webpack_require__(/*! ./paths/overlay */ "./src/paths/overlay.js").default(context);

__webpack_require__(/*! ./paths/particles */ "./src/paths/particles.js").default(context);

__webpack_require__(/*! ./paths/postfx */ "./src/paths/postfx.js").default(context); // == loop here ================================================================


var update = function update() {
  if (!$('#active').checked) {
    setTimeout(update, 100);
    return;
  } // == update some bunch of shit ==============================================


  automaton.update();
  updateMatrices(); // == let's render this ======================================================

  glCatPath.begin(); // == compute stuff ==========================================================

  glCatPath.render('particlesComputeReturn');
  glCatPath.render('particlesMotionRead');
  glCatPath.render('particlesEnforce');
  glCatPath.render('particlesDivergence');
  glCatPath.render('particlesPressure');
  glCatPath.render('particlesMotionWrite');
  glCatPath.render('particlesCompute'); // == shadow =================================================================

  glCatPath.render('shadow');
  glCatPath.render('particlesRender', {
    target: glCatPath.fb('shadow'),
    isShadow: true,
    width: shadowReso,
    height: shadowReso
  }); // == foreground =============================================================

  glCatPath.render('target');
  glCatPath.render('particlesRender', {
    target: glCatPath.fb('target'),
    textureShadow: glCatPath.fb('shadow').texture,
    width: width,
    height: height
  });
  glCatPath.render('box', {
    target: glCatPath.fb('target'),
    width: width,
    height: height
  });
  glCatPath.render('overlay', {
    target: glCatPath.fb('target'),
    width: width,
    height: height
  }); // == post ===================================================================

  glCatPath.render('preBloom', {
    input: glCatPath.fb('target').textures[0],
    bias: [-0.9, -0.9, -0.9],
    factor: [1.0, 1.0, 1.0]
  });
  glCatPath.render('bloom');
  glCatPath.render('postBloom', {
    dry: glCatPath.fb('target').textures[0]
  });
  glCatPath.render('jpegCosine', {
    input: glCatPath.fb('postBloom').texture
  });
  glCatPath.render('jpegRender');
  glCatPath.render('post', {
    input: glCatPath.fb('jpegRender').texture
  });
  glCatPath.render('return', {
    target: _libs_glcat_path_gui__WEBPACK_IMPORTED_MODULE_2__["default"].nullFb,
    input: glCatPath.fb('post').texture
  }); // glCatPath.render( 'inspector', {
  //   target: GLCatPath.nullFb,
  //   input: glCatPath.fb( 'particlesMotionWrite' ).texture
  // } );
  // == end ====================================================================

  glCatPath.end(); // == save ===================================================================

  if ($('#save').checked) {
    saver.capture();

    if (automaton.fps * automaton.length * 1.1 < saver.frameCount) {
      $('#save').checked = false;
      saver.save();
    }
  } // == finalize the loop ======================================================


  isInitialFrame = false;
  totalFrame++;
  requestAnimationFrame(update);
};

update(); // == keyboard is good =========================================================

window.addEventListener('keydown', function (event) {
  if (event.which === 27) {
    // panic button
    $('#active').checked = false;
  }

  if (event.which === 32) {
    // play / pause
    automaton.isPlaying ? automaton.pause() : automaton.play();
  }
});

/***/ }),

/***/ "./src/paths/bloom.js":
/*!****************************!*\
  !*** ./src/paths/bloom.js ***!
  \****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _libs_ultracat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../libs/ultracat */ "./src/libs/ultracat.js");
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

 // ------

/* harmony default export */ __webpack_exports__["default"] = (function (context) {
  var glCatPath = context.glCatPath;
  var glCat = glCatPath.glCat;
  var gl = glCat.gl;
  var width = context.width;
  var height = context.height; // ------

  var vboQuad = glCat.createVertexbuffer(new Float32Array(_libs_ultracat__WEBPACK_IMPORTED_MODULE_0__["default"].triangleStripQuad)); // ------

  glCatPath.add({
    preBloom: {
      width: width / 4,
      height: height / 4,
      vert: __webpack_require__(/*! ../shaders/quad.vert */ "./src/shaders/quad.vert"),
      frag: __webpack_require__(/*! ../shaders/bloom-pre.frag */ "./src/shaders/bloom-pre.frag"),
      blend: [gl.ONE, gl.ONE],
      clear: [0.0, 0.0, 0.0, 0.0],
      framebuffer: true,
      float: true,
      func: function func(path, params) {
        glCat.attribute('p', vboQuad, 2);
        glCat.uniform3fv('bias', params.bias);
        glCat.uniform3fv('factor', params.factor);
        glCat.uniformTexture('sampler0', params.input, 0);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
      }
    },
    bloom: {
      width: width / 4,
      height: height / 4,
      vert: __webpack_require__(/*! ../shaders/quad.vert */ "./src/shaders/quad.vert"),
      frag: __webpack_require__(/*! ../shaders/gauss.frag */ "./src/shaders/gauss.frag"),
      blend: [gl.ONE, gl.ONE],
      clear: [0.0, 0.0, 0.0, 0.0],
      framebuffer: true,
      float: true,
      tempFb: glCat.createFramebuffer(width / 4, height / 4),
      func: function func(path, params) {
        glCat.attribute('p', vboQuad, 2);

        for (var i = 0; i < 3; i++) {
          var gaussVar = [3.0, 10.0, 30.0][i];
          glCat.uniform1f('var', gaussVar);
          gl.bindFramebuffer(gl.FRAMEBUFFER, path.tempFb.framebuffer);
          glCat.clear.apply(glCat, _toConsumableArray(path.clear));
          glCat.uniform1i('isVert', false);
          glCat.uniformTexture('sampler0', i === 0 ? glCatPath.fb('preBloom').texture : path.framebuffer.texture, 0);
          gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
          gl.bindFramebuffer(gl.FRAMEBUFFER, params.framebuffer);
          glCat.uniform1i('isVert', true);
          glCat.uniformTexture('sampler0', path.tempFb.texture, 0);
          gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        }
      }
    },
    postBloom: {
      width: width,
      height: height,
      vert: __webpack_require__(/*! ../shaders/quad.vert */ "./src/shaders/quad.vert"),
      frag: __webpack_require__(/*! ../shaders/bloom-post.frag */ "./src/shaders/bloom-post.frag"),
      blend: [gl.ONE, gl.ZERO],
      clear: [0.0, 0.0, 0.0, 0.0],
      framebuffer: true,
      float: true,
      func: function func(path, params) {
        glCat.attribute('p', vboQuad, 2);
        glCat.uniformTexture('samplerDry', params.dry, 0);
        glCat.uniformTexture('samplerWet', glCatPath.fb('bloom').texture, 1);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
      }
    }
  });
});

/***/ }),

/***/ "./src/paths/box.js":
/*!**************************!*\
  !*** ./src/paths/box.js ***!
  \**************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var _libs_mathcat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../libs/mathcat */ "./src/libs/mathcat.js");
/* harmony import */ var _libs_ultracat__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../libs/ultracat */ "./src/libs/ultracat.js");
/* harmony import */ var _geoms_cube__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../geoms/cube */ "./src/geoms/cube.js");
/* harmony import */ var _geoms_cube__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_geoms_cube__WEBPACK_IMPORTED_MODULE_2__);


 // ------

/* harmony default export */ __webpack_exports__["default"] = (function (context) {
  // == hi context =============================================================
  var glCatPath = context.glCatPath;
  var glCat = glCatPath.glCat;
  var gl = glCat.gl;
  var auto = context.automaton.auto; // == hi vbo =================================================================

  var box = _geoms_cube__WEBPACK_IMPORTED_MODULE_2___default()();
  var vboBoxPos = glCat.createVertexbuffer(new Float32Array([-1.0, -1.0, -1.0, 1.0, -1.0, -1.0, 1.0, -1.0, -1.0, 1.0, 1.0, -1.0, 1.0, 1.0, -1.0, -1.0, 1.0, -1.0, -1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, 1.0, 1.0, -1.0, 1.0, 1.0, -1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, -1.0, 1.0, 1.0, -1.0, 1.0, 1.0, -1.0, -1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0, 1.0, 1.0, -1.0, -1.0, 1.0, -1.0, 1.0, 1.0, 1.0, -1.0, 1.0, 1.0, 1.0, -1.0, 1.0, -1.0, -1.0, 1.0, 1.0])); // == path definition begin ==================================================

  glCatPath.add({
    box: {
      vert: __webpack_require__(/*! ../shaders/box.vert */ "./src/shaders/box.vert"),
      frag: __webpack_require__(/*! ../shaders/box.frag */ "./src/shaders/box.frag"),
      blend: [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA],
      func: function func(path, params) {
        glCat.attribute('pos', vboBoxPos, 3);
        var matM = _libs_mathcat__WEBPACK_IMPORTED_MODULE_0__["default"].mat4Identity();
        matM = _libs_mathcat__WEBPACK_IMPORTED_MODULE_0__["default"].mat4Apply(_libs_mathcat__WEBPACK_IMPORTED_MODULE_0__["default"].mat4Scale([2.1, 2.1 * auto('box-phase'), 2.1]), matM);
        matM = _libs_mathcat__WEBPACK_IMPORTED_MODULE_0__["default"].mat4Apply(_libs_mathcat__WEBPACK_IMPORTED_MODULE_0__["default"].mat4Translate([0.0, -2.1 + 2.1 * auto('box-phase'), 0.0]), matM);
        glCat.uniformMatrix4fv('matM', matM);
        gl.drawArrays(gl.LINES, 0, 24);
      }
    }
  });
  module.hot.accept(['../shaders/box.vert', '../shaders/box.frag'], function () {
    glCatPath.replaceProgram('box', __webpack_require__(/*! ../shaders/box.vert */ "./src/shaders/box.vert"), __webpack_require__(/*! ../shaders/box.frag */ "./src/shaders/box.frag"));
  });
});
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./src/paths/jpeg.js":
/*!***************************!*\
  !*** ./src/paths/jpeg.js ***!
  \***************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _libs_ultracat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../libs/ultracat */ "./src/libs/ultracat.js");
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

 // ------

/* harmony default export */ __webpack_exports__["default"] = (function (context) {
  var glCatPath = context.glCatPath;
  var glCat = glCatPath.glCat;
  var gl = glCat.gl;
  var width = context.width;
  var height = context.height;
  var auto = context.automaton.auto; // ------

  var vboQuad = glCat.createVertexbuffer(new Float32Array(_libs_ultracat__WEBPACK_IMPORTED_MODULE_0__["default"].triangleStripQuad)); // ------

  glCatPath.add({
    jpegCosine: {
      width: width,
      height: height,
      vert: __webpack_require__(/*! ../shaders/quad.vert */ "./src/shaders/quad.vert"),
      frag: __webpack_require__(/*! ../shaders/jpeg-cosine.frag */ "./src/shaders/jpeg-cosine.frag"),
      blend: [gl.ONE, gl.ONE],
      clear: [0.0, 0.0, 0.0, 0.0],
      framebuffer: true,
      float: true,
      tempFb: glCat.createFloatFramebuffer(width, height),
      func: function func(path, params) {
        glCat.attribute('p', vboQuad, 2);
        glCat.uniform1i('blockSize', parseInt(8.0 + 120.0 * auto('jpeg-blockSize')));
        glCat.uniform1f('quantize', 0.0);
        glCat.uniform1f('quantizeF', Math.pow(auto('jpeg-quantizeF'), 2.0));
        glCat.uniform1f('highFreqMultiplier', 0.0);
        gl.bindFramebuffer(gl.FRAMEBUFFER, path.tempFb.framebuffer);
        glCat.clear.apply(glCat, _toConsumableArray(path.clear));
        glCat.uniform1i('isVert', false);
        glCat.uniformTexture('sampler0', params.input, 0);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        gl.bindFramebuffer(gl.FRAMEBUFFER, params.framebuffer);
        glCat.uniform1i('isVert', true);
        glCat.uniformTexture('sampler0', path.tempFb.texture, 0);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
      }
    },
    jpegRender: {
      width: width,
      height: height,
      vert: __webpack_require__(/*! ../shaders/quad.vert */ "./src/shaders/quad.vert"),
      frag: __webpack_require__(/*! ../shaders/jpeg-render.frag */ "./src/shaders/jpeg-render.frag"),
      blend: [gl.ONE, gl.ONE],
      clear: [0.0, 0.0, 0.0, 0.0],
      framebuffer: true,
      float: true,
      tempFb: glCat.createFloatFramebuffer(width, height),
      func: function func(path, params) {
        glCat.attribute('p', vboQuad, 2);
        glCat.uniform1i('blockSize', parseInt(8.0 + 120.0 * auto('jpeg-blockSize')));
        gl.bindFramebuffer(gl.FRAMEBUFFER, path.tempFb.framebuffer);
        glCat.clear.apply(glCat, _toConsumableArray(path.clear));
        glCat.uniform1i('isVert', false);
        glCat.uniformTexture('sampler0', glCatPath.fb('jpegCosine').texture, 0);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        gl.bindFramebuffer(gl.FRAMEBUFFER, params.framebuffer);
        glCat.uniform1i('isVert', true);
        glCat.uniformTexture('sampler0', path.tempFb.texture, 0);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
      }
    }
  });
});

/***/ }),

/***/ "./src/paths/overlay.js":
/*!******************************!*\
  !*** ./src/paths/overlay.js ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var _libs_ultracat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../libs/ultracat */ "./src/libs/ultracat.js");
 // ------

/* harmony default export */ __webpack_exports__["default"] = (function (context) {
  // == hi context =============================================================
  var glCatPath = context.glCatPath;
  var glCat = glCatPath.glCat;
  var gl = glCat.gl;
  var width = context.width;
  var height = context.height;
  var auto = context.automaton.auto; // == hi vbo =================================================================

  var vboQuad = glCat.createVertexbuffer(new Float32Array(_libs_ultracat__WEBPACK_IMPORTED_MODULE_0__["default"].triangleStripQuad)); // == hi texture =============================================================

  var textureDiversity = glCat.createTexture();
  {
    var image = new Image();

    image.onload = function () {
      glCat.setTexture(textureDiversity, image);
    };

    image.src = __webpack_require__(/*! ../images/diversity.png */ "./src/images/diversity.png");
  } // == path definition begin ==================================================

  glCatPath.add({
    overlay: {
      vert: __webpack_require__(/*! ../shaders/quad.vert */ "./src/shaders/quad.vert"),
      frag: __webpack_require__(/*! ../shaders/overlay.frag */ "./src/shaders/overlay.frag"),
      blend: [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA],
      func: function func(path, params) {
        glCat.attribute('p', vboQuad, 2);
        glCat.uniformTexture('sampler0', textureDiversity, 0);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
      }
    }
  });
  module.hot.accept(['../shaders/quad.vert', '../shaders/overlay.frag'], function () {
    glCatPath.replaceProgram('overlay', __webpack_require__(/*! ../shaders/quad.vert */ "./src/shaders/quad.vert"), __webpack_require__(/*! ../shaders/overlay.frag */ "./src/shaders/overlay.frag"));
  });
});
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./src/paths/particles.js":
/*!********************************!*\
  !*** ./src/paths/particles.js ***!
  \********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _libs_xorshift__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../libs/xorshift */ "./src/libs/xorshift.js");
/* harmony import */ var _libs_ultracat__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../libs/ultracat */ "./src/libs/ultracat.js");
// == load some modules ========================================================

 // == roll the dice ============================================================

var seed = 15882356;
var xorshift = new _libs_xorshift__WEBPACK_IMPORTED_MODULE_0__["default"](seed); // == very basic constants =====================================================

var ppp = 2;
var nParticleSqrt = 512;
var nParticle = nParticleSqrt * nParticleSqrt;
var jacobiIter = 50;
var motionFieldVoxelUnit = 0.2;
var motionFieldResolutionXY = 256;
var motionFieldResolution = [motionFieldResolutionXY * 8, motionFieldResolutionXY * 8];
/* harmony default export */ __webpack_exports__["default"] = (function (context) {
  // == prepare context ========================================================
  var glCatPath = context.glCatPath;
  var glCat = glCatPath.glCat;
  var gl = glCat.gl;
  var auto = context.automaton.auto; // == prepare vbos ===========================================================

  var vboQuad = glCat.createVertexbuffer(new Float32Array(_libs_ultracat__WEBPACK_IMPORTED_MODULE_1__["default"].triangleStripQuad));
  var vboComputeUV = glCat.createVertexbuffer(new Float32Array(_libs_ultracat__WEBPACK_IMPORTED_MODULE_1__["default"].matrix2d(nParticleSqrt, nParticleSqrt).map(function (v, i) {
    return i % 2 === 0 ? (v * ppp + 0.5) / nParticleSqrt / ppp : (v + 0.5) / nParticleSqrt;
  })));

  var oct = __webpack_require__(/*! ../geoms/octahedron */ "./src/geoms/octahedron.js")({
    div: 1.0
  });

  var vboOctPos = glCat.createVertexbuffer(new Float32Array(oct.position));
  var vboOctNor = glCat.createVertexbuffer(new Float32Array(oct.normal));
  var iboOct = glCat.createIndexbuffer(new Uint16Array(oct.index)); // == prepare random texture =================================================

  var textureRandomSize = 32;

  var textureRandomUpdate = function textureRandomUpdate(_tex) {
    glCat.setTextureFromArray(_tex, textureRandomSize, textureRandomSize, function () {
      var len = textureRandomSize * textureRandomSize * 4;
      var ret = new Uint8Array(len);

      for (var i = 0; i < len; i++) {
        ret[i] = Math.floor(xorshift.gen() * 256.0);
      }

      return ret;
    }());
  };

  var textureRandomStatic = glCat.createTexture();
  glCat.textureWrap(textureRandomStatic, gl.REPEAT);
  textureRandomUpdate(textureRandomStatic);
  var textureRandom = glCat.createTexture();
  glCat.textureWrap(textureRandom, gl.REPEAT); // == Toby Fox - Dummy! ======================================================

  var textureDummy = glCat.createTexture();
  glCat.setTextureFromArray(textureDummy, 1, 1, new Uint8Array([0, 0, 0, 0])); // == let's create paths =====================================================

  glCatPath.add({
    // == framebuffer sucks ====================================================
    particlesComputeReturn: {
      width: nParticleSqrt * ppp,
      height: nParticleSqrt,
      vert: __webpack_require__(/*! ../shaders/quad.vert */ "./src/shaders/quad.vert"),
      frag: __webpack_require__(/*! ../shaders/return.frag */ "./src/shaders/return.frag"),
      blend: [gl.ONE, gl.ZERO],
      clear: [0.0, 0.0, 0.0, 0.0],
      framebuffer: true,
      float: true,
      func: function func(path, params) {
        if (context.automaton.time === 0.0) {
          xorshift.set(seed);
        }

        glCat.attribute('p', vboQuad, 2);
        glCat.uniformTexture('sampler0', glCatPath.fb('particlesCompute').texture, 0);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
      }
    },
    // == generate motion field by particles ===================================
    particlesMotionRead: {
      width: motionFieldResolution[0],
      height: motionFieldResolution[1],
      vert: __webpack_require__(/*! ../shaders/particles-motion-read.vert */ "./src/shaders/particles-motion-read.vert"),
      frag: __webpack_require__(/*! ../shaders/particles-motion-read.frag */ "./src/shaders/particles-motion-read.frag"),
      blend: [gl.ONE, gl.ONE],
      clear: [0.0, 0.0, 0.0, 0.0],
      framebuffer: true,
      float: true,
      func: function func(path, params) {
        glCat.attribute('computeUV', vboComputeUV, 2);
        glCat.uniform2fv('resolutionPcompute', [nParticleSqrt * ppp, nParticleSqrt]);
        glCat.uniform2fv('resolutionMotion', motionFieldResolution);
        glCat.uniform2fv('planeResolution', [motionFieldResolutionXY, motionFieldResolutionXY]);
        glCat.uniform1f('voxelUnit', motionFieldVoxelUnit);
        glCat.uniformTexture('samplerPcompute', glCatPath.fb('particlesComputeReturn').texture, 0);
        gl.drawArrays(gl.POINTS, 0, nParticle);
      }
    },
    // == enforce ==============================================================
    particlesEnforce: {
      width: motionFieldResolution[0],
      height: motionFieldResolution[1],
      vert: __webpack_require__(/*! ../shaders/quad.vert */ "./src/shaders/quad.vert"),
      frag: __webpack_require__(/*! ../shaders/particles-enforce.frag */ "./src/shaders/particles-enforce.frag"),
      blend: [gl.ONE, gl.ZERO],
      clear: [0.0, 0.0, 0.0, 0.0],
      framebuffer: true,
      float: true,
      func: function func(path, params) {
        glCat.attribute('p', vboQuad, 2);
        glCat.uniform2fv('resolutionMotion', motionFieldResolution);
        glCat.uniform2fv('planeResolution', [motionFieldResolutionXY, motionFieldResolutionXY]);
        glCat.uniform1f('voxelUnit', motionFieldVoxelUnit);
        glCat.uniformTexture('samplerMotion', glCatPath.fb('particlesMotionRead').texture, 0);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
      }
    },
    // == generate divergence field by motion field ============================
    particlesDivergence: {
      width: motionFieldResolution[0],
      height: motionFieldResolution[1],
      vert: __webpack_require__(/*! ../shaders/quad.vert */ "./src/shaders/quad.vert"),
      frag: __webpack_require__(/*! ../shaders/particles-divergence.frag */ "./src/shaders/particles-divergence.frag"),
      blend: [gl.ONE, gl.ZERO],
      clear: [0.0, 0.0, 0.0, 0.0],
      framebuffer: true,
      float: true,
      func: function func(path, params) {
        glCat.attribute('p', vboQuad, 2);
        glCat.uniform2fv('resolutionMotion', motionFieldResolution);
        glCat.uniform2fv('planeResolution', [motionFieldResolutionXY, motionFieldResolutionXY]);
        glCat.uniform1f('voxelUnit', motionFieldVoxelUnit);
        glCat.uniformTexture('samplerMotion', glCatPath.fb('particlesEnforce').texture, 0);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
      }
    },
    // == let's calculate pressure =============================================
    particlesPressure: {
      width: motionFieldResolution[0],
      height: motionFieldResolution[1],
      vert: __webpack_require__(/*! ../shaders/quad.vert */ "./src/shaders/quad.vert"),
      frag: __webpack_require__(/*! ../shaders/particles-pressure.frag */ "./src/shaders/particles-pressure.frag"),
      blend: [gl.ONE, gl.ZERO],
      clear: [0.0, 0.0, 0.0, 0.0],
      framebuffer: true,
      float: true,
      tempFb: [glCat.createFramebuffer.apply(glCat, motionFieldResolution), glCat.createFramebuffer.apply(glCat, motionFieldResolution)],
      func: function func(path, params) {
        glCat.attribute('p', vboQuad, 2);
        glCat.uniform2fv('resolutionMotion', motionFieldResolution);
        glCat.uniform2fv('planeResolution', [motionFieldResolutionXY, motionFieldResolutionXY]);
        glCat.uniform1f('voxelUnit', motionFieldVoxelUnit);

        for (var i = 0; i < jacobiIter; i++) {
          gl.bindFramebuffer(gl.FRAMEBUFFER, i === jacobiIter - 1 ? params.framebuffer : path.tempFb[i % 2].framebuffer);
          glCat.uniformTexture('samplerDivergence', glCatPath.fb('particlesDivergence').texture, 0);
          glCat.uniformTexture('samplerPressure', path.tempFb[(i + 1) % 2].texture, 1);
          gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        }
      }
    },
    // == write back the velocity ==============================================
    particlesMotionWrite: {
      width: motionFieldResolution[0],
      height: motionFieldResolution[1],
      vert: __webpack_require__(/*! ../shaders/quad.vert */ "./src/shaders/quad.vert"),
      frag: __webpack_require__(/*! ../shaders/particles-motion-write.frag */ "./src/shaders/particles-motion-write.frag"),
      blend: [gl.ONE, gl.ZERO],
      clear: [0.0, 0.0, 0.0, 0.0],
      framebuffer: true,
      float: true,
      func: function func(path, params) {
        glCat.attribute('p', vboQuad, 2);
        glCat.uniform2fv('resolutionMotion', motionFieldResolution);
        glCat.uniform2fv('planeResolution', [motionFieldResolutionXY, motionFieldResolutionXY]);
        glCat.uniform1f('voxelUnit', motionFieldVoxelUnit);
        glCat.uniformTexture('samplerMotion', glCatPath.fb('particlesMotionRead').texture, 0);
        glCat.uniformTexture('samplerPressure', glCatPath.fb('particlesPressure').texture, 1);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
      }
    },
    // == compute particles =======================================================
    particlesCompute: {
      width: nParticleSqrt * ppp,
      height: nParticleSqrt,
      vert: __webpack_require__(/*! ../shaders/quad.vert */ "./src/shaders/quad.vert"),
      frag: __webpack_require__(/*! ../shaders/particles-compute.frag */ "./src/shaders/particles-compute.frag"),
      blend: [gl.ONE, gl.ZERO],
      clear: [0.0, 0.0, 0.0, 0.0],
      framebuffer: true,
      float: true,
      func: function func(path, params) {
        textureRandomUpdate(textureRandom);
        glCat.attribute('p', vboQuad, 2);
        glCat.uniform1f('nParticle', nParticle);
        glCat.uniform1f('nParticleSqrt', nParticleSqrt);
        glCat.uniform1f('ppp', ppp);
        glCat.uniform1i('isInitFrame', context.automaton.time === 0.0 ? true : false);
        glCat.uniform2fv('resolutionMotion', motionFieldResolution);
        glCat.uniform2fv('planeResolution', [motionFieldResolutionXY, motionFieldResolutionXY]);
        glCat.uniform1f('voxelUnit', motionFieldVoxelUnit);
        glCat.uniformTexture('samplerPcompute', glCatPath.fb('particlesComputeReturn').texture, 0);
        glCat.uniformTexture('samplerRandom', textureRandom, 1);
        glCat.uniformTexture('samplerRandomStatic', textureRandomStatic, 2);
        glCat.uniformTexture('samplerMotionWrite', glCatPath.fb('particlesMotionWrite').texture, 3);
        glCat.uniform1f('noisePhase', auto('particles-noisePhase'));
        glCat.uniform1f('genRate', auto('particles-genRate'));
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
      }
    },
    // == render particles =====================================================
    particlesRender: {
      vert: __webpack_require__(/*! ../shaders/particles-render.vert */ "./src/shaders/particles-render.vert"),
      frag: __webpack_require__(/*! ../shaders/particles-render.frag */ "./src/shaders/particles-render.frag"),
      blend: [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA],
      drawbuffers: 2,
      func: function func(path, params) {
        glCat.attributeDivisor('computeUV', vboComputeUV, 2, 1);
        glCat.attribute('geomPos', vboOctPos, 3);
        glCat.attribute('geomNor', vboOctNor, 3);
        glCat.uniform1f('nParticle', nParticle);
        glCat.uniform1f('nParticleSqrt', nParticleSqrt);
        glCat.uniform1f('ppp', ppp);
        glCat.uniform2fv('resolutionPcompute', [nParticleSqrt * ppp, nParticleSqrt]);
        glCat.uniform1i('isShadow', params.isShadow ? 1 : 0);
        glCat.uniform1f('colorVar', auto('particles-colorVar'));
        glCat.uniform1f('colorOffset', auto('particles-colorOffset'));
        glCat.uniformTexture('samplerPcompute', glCatPath.fb('particlesCompute').texture, 0);
        glCat.uniformTexture('samplerRandom', textureRandom, 1);
        glCat.uniformTexture('samplerRandomStatic', textureRandomStatic, 2);
        glCat.uniformTexture('samplerShadow', params.textureShadow || textureDummy, 3);
        var ext = glCat.getExtension('ANGLE_instanced_arrays');
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, iboOct);
        ext.drawElementsInstancedANGLE(gl.TRIANGLES, oct.index.length, gl.UNSIGNED_SHORT, 0, nParticle);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
      }
    }
  });

  if (false) {}
});

/***/ }),

/***/ "./src/paths/postfx.js":
/*!*****************************!*\
  !*** ./src/paths/postfx.js ***!
  \*****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _libs_ultracat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../libs/ultracat */ "./src/libs/ultracat.js");
 // ------

/* harmony default export */ __webpack_exports__["default"] = (function (context) {
  var glCatPath = context.glCatPath;
  var glCat = glCatPath.glCat;
  var gl = glCat.gl;
  var width = context.width;
  var height = context.height;
  var auto = context.automaton.auto; // ------

  var vboQuad = glCat.createVertexbuffer(new Float32Array(_libs_ultracat__WEBPACK_IMPORTED_MODULE_0__["default"].triangleStripQuad)); // ------

  glCatPath.add({
    post: {
      width: width,
      height: height,
      vert: __webpack_require__(/*! ../shaders/quad.vert */ "./src/shaders/quad.vert"),
      frag: __webpack_require__(/*! ../shaders/post.frag */ "./src/shaders/post.frag"),
      blend: [gl.ONE, gl.ZERO],
      clear: [0.0, 0.0, 0.0, 0.0],
      framebuffer: true,
      float: true,
      func: function func(path, params) {
        glCat.attribute('p', vboQuad, 2);
        glCat.uniform1f('barrelAmp', auto('post-barrelAmp'));
        glCat.uniform1f('barrelOffset', auto('post-barrelOffset'));
        glCat.uniformTexture('sampler0', params.input, 0);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
      }
    },
    fxaa: {
      width: width,
      height: height,
      vert: __webpack_require__(/*! ../shaders/quad.vert */ "./src/shaders/quad.vert"),
      frag: __webpack_require__(/*! ../shaders/fxaa.frag */ "./src/shaders/fxaa.frag"),
      blend: [gl.ONE, gl.ZERO],
      clear: [0.0, 0.0, 0.0, 0.0],
      framebuffer: true,
      float: true,
      func: function func(path, params) {
        glCat.attribute('p', vboQuad, 2);
        glCat.uniformTexture('sampler0', params.input, 0);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
      }
    }
  });
});

/***/ }),

/***/ "./src/shaders/bg.frag":
/*!*****************************!*\
  !*** ./src/shaders/bg.frag ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "#extension GL_EXT_draw_buffers : require\nprecision highp float;\n#define GLSLIFY 1\n\nuniform vec4 bgColor;\nuniform float perspFar;\n\n// ------\n\nvoid main() {\n  gl_FragData[ 0 ] = bgColor;\n  gl_FragData[ 1 ] = vec4( perspFar, 0.0, 0.0, 1.0 );\n}"

/***/ }),

/***/ "./src/shaders/bloom-post.frag":
/*!*************************************!*\
  !*** ./src/shaders/bloom-post.frag ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "#define saturate(i) clamp(i,0.,1.)\n\nprecision highp float;\n#define GLSLIFY 1\n\nuniform vec2 resolution;\nuniform sampler2D samplerDry;\nuniform sampler2D samplerWet;\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / resolution;\n  vec3 dry = texture2D( samplerDry, uv ).xyz;\n  vec3 wet = texture2D( samplerWet, uv ).xyz;\n  gl_FragColor = vec4( max( vec3( 0.0 ), saturate( dry + wet ) ), 1.0 );\n}\n"

/***/ }),

/***/ "./src/shaders/bloom-pre.frag":
/*!************************************!*\
  !*** ./src/shaders/bloom-pre.frag ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "precision highp float;\n#define GLSLIFY 1\n\nuniform vec2 resolution;\nuniform vec3 bias;\nuniform vec3 factor;\nuniform sampler2D sampler0;\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / resolution;\n  vec2 deltaTexel = 0.25 / resolution;\n  vec2 uvOrigin = ( floor( gl_FragCoord.xy ) + deltaTexel * 0.5 ) / resolution;\n\n  vec3 sum = vec3( 0.0 );\n  for ( int iy = 0; iy < 4; iy ++ ) {\n    for ( int ix = 0; ix < 4; ix ++ ) {\n      vec2 uv = uvOrigin + vec2( ix, iy ) * deltaTexel;\n      sum += texture2D( sampler0, uv ).xyz / 16.0;\n    }\n  }\n\n  gl_FragColor = vec4(\n    max( vec3( 0.0 ), ( sum + bias ) * factor ),\n    1.0\n  );\n}\n"

/***/ }),

/***/ "./src/shaders/box.frag":
/*!******************************!*\
  !*** ./src/shaders/box.frag ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "precision highp float;\n#define GLSLIFY 1\n\nvoid main() {\n  gl_FragColor = vec4( vec3( 0.5 ), 1.0 );\n}"

/***/ }),

/***/ "./src/shaders/box.vert":
/*!******************************!*\
  !*** ./src/shaders/box.vert ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "#define GLSLIFY 1\n#define HUGE 9E16\n#define PI 3.14159265\n#define V vec3(0.,1.,-1.)\n#define saturate(i) clamp(i,0.,1.)\n#define lofi(i,m) (floor((i)/(m))*(m))\n\n// ------\n\nattribute vec3 pos;\n\nuniform vec2 resolution;\nuniform vec3 color;\n\nvarying vec3 vPos;\n\nuniform bool isShadow;\n\nuniform mat4 matP;\nuniform mat4 matV;\nuniform mat4 matPL;\nuniform mat4 matVL;\nuniform mat4 matM;\n\n// ------\n\nvoid main() {\n  vec4 pos = matM * vec4( pos, 1.0 );\n  vPos = pos.xyz;\n\n  vec4 outPos;\n  if ( isShadow ) {\n    outPos = matPL * matVL * pos;\n  } else {\n    outPos = matP * matV * pos;\n    outPos.x /= resolution.x / resolution.y;\n  }\n  gl_Position = outPos;\n}"

/***/ }),

/***/ "./src/shaders/fxaa.frag":
/*!*******************************!*\
  !*** ./src/shaders/fxaa.frag ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "#define PI 3.14159265\n#define V vec3(0.,1.,-1.)\n\n#define FXAA_REDUCE_MIN (1.0 / 128.0)\n#define FXAA_REDUCE_MUL (1.0 / 8.0)\n#define FXAA_SPAN_MAX 16.0\n\n// ------\n\nprecision highp float;\n#define GLSLIFY 1\n\nuniform vec2 resolution;\n\nuniform sampler2D texture;\n\n// ------\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / resolution;\n\n  #define T(v) texture2D( texture, (v) / resolution ).xyz\n  vec3 rgb11 = T( gl_FragCoord.xy );\n  vec3 rgb00 = T( gl_FragCoord.xy + V.zz );\n  vec3 rgb02 = T( gl_FragCoord.xy + V.zy );\n  vec3 rgb20 = T( gl_FragCoord.xy + V.yz );\n  vec3 rgb22 = T( gl_FragCoord.xy + V.yy );\n  #undef T\n\n  vec3 luma = vec3( 0.299, 0.587, 0.114 );\n  #define L(c) dot( c, luma )\n  float luma11 = L( rgb11 );\n  float luma00 = L( rgb00 );\n  float luma02 = L( rgb02 );\n  float luma20 = L( rgb20 );\n  float luma22 = L( rgb22 );\n  #undef L\n\n  float lumaMin = min( luma00, min( min( luma00, luma02 ), min( luma20, luma22 ) ) );\n  float lumaMax = max( luma00, max( max( luma00, luma02 ), max( luma20, luma22 ) ) );\n\n  vec2 dir = vec2(\n    -( ( luma00 + luma20 ) - ( luma02 + luma22 ) ),\n    ( ( luma00 + luma02 ) - ( luma20 + luma22 ) )\n  );\n\n  float dirReduce = max(\n    ( luma00 + luma02 + luma20 + luma22 ) * 0.25 * FXAA_REDUCE_MUL,\n    FXAA_REDUCE_MIN\n  );\n  float rcpDirMin = 1.0 / ( min( abs( dir.x ), abs( dir.y ) ) + dirReduce );\n  dir = min(\n    vec2( FXAA_SPAN_MAX ),\n    max(\n      vec2( -FXAA_SPAN_MAX ),\n      dir * rcpDirMin\n    )\n  ) / resolution;\n\n  vec3 rgbA = 0.5 * (\n    texture2D( texture, uv + dir * ( 1.0 / 3.0 - 0.5 ) ).xyz +\n    texture2D( texture, uv + dir * ( 2.0 / 3.0 - 0.5 ) ).xyz\n  );\n  vec3 rgbB = rgbA * 0.5 + 0.25 * (\n    texture2D( texture, uv - dir * 0.5 ).xyz +\n    texture2D( texture, uv + dir * 0.5 ).xyz\n  );\n\n  float lumaB = dot( rgbB, luma );\n  gl_FragColor = (\n    ( ( lumaB < lumaMin ) || ( lumaMax < lumaB ) ) ?\n    vec4( rgbA, 1.0 ) :\n    vec4( rgbB, 1.0 )\n  );\n}"

/***/ }),

/***/ "./src/shaders/gauss.frag":
/*!********************************!*\
  !*** ./src/shaders/gauss.frag ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "#define saturate(i) clamp(i,0.,1.)\n#define PI 3.14159265\n#define SAMPLES 20\n#define MUL_THR 0.01\n\n// ------\n\nprecision highp float;\n#define GLSLIFY 1\n\nuniform vec2 resolution;\nuniform bool isVert;\nuniform sampler2D sampler0;\n\nuniform float var;\n\nfloat gaussian( float _x, float _v ) {\n  return 1.0 / sqrt( 2.0 * PI * _v ) * exp( - _x * _x / 2.0 / _v );\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / resolution;\n\n  if ( var <= 0.0 ) {\n    gl_FragColor = texture2D( sampler0, uv );\n    return;\n  }\n\n  vec2 bv = ( isVert ? vec2( 0.0, 1.0 ) : vec2( 1.0, 0.0 ) ) / resolution;\n\n  vec3 sum = vec3( 0.0 );\n  for ( int i = 0; i <= SAMPLES; i ++ ) {\n    float mul = gaussian( abs( float( i ) ), var );\n    if ( mul < MUL_THR ) { break; }\n    for ( int j = -1; j < 2; j += 2 ) {\n      vec2 v = saturate( uv + bv * float( i * j ) );\n      vec3 tex = texture2D( sampler0, v ).xyz;\n      sum += tex * mul;\n      if ( i == 0 ) { break; }\n    }\n  }\n\n  gl_FragColor = vec4( sum, 1.0 );\n}\n"

/***/ }),

/***/ "./src/shaders/inspector.frag":
/*!************************************!*\
  !*** ./src/shaders/inspector.frag ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "#define RADIUS 40.0\n\nprecision highp float;\n#define GLSLIFY 1\n\nuniform vec2 resolution;\nuniform vec2 mouse;\nuniform vec3 circleColor;\nuniform sampler2D sampler0;\n\nbool print( in vec2 _coord, float _in ) {\n  vec2 coord = _coord;\n\n  // vertical restriction\n  if ( coord.y <= 0.0 || 5.0 <= coord.y ) { return false; }\n  \n  // dot\n  if ( 0.0 < coord.x && coord.x < 2.0 ) {\n    return coord.x < 1.0 && coord.y < 1.0;\n  }\n\n  // padded by dot\n  if ( 2.0 < coord.x ) { coord.x -= 2.0; }\n  \n  // determine digit\n  float ci = floor( coord.x / 5.0 ) + 1.0;\n\n  // too low / too high\n  if ( 4.0 < ci ) { return false; }\n  if ( ci < -4.0 ) { return false; }\n\n  // x of char\n  float cfx = floor( mod( coord.x, 5.0 ) );\n\n  // width is 4\n  if ( 4.0 == cfx ) { return false; }\n\n  // y of char\n  float cfy = floor( coord.y );\n\n  // bit of char\n  float cf = cfx + 4.0 * cfy;\n\n  // determine char  \n  float num = 0.0;\n  if ( 0.0 < ci ) {\n    float n = abs( _in );\n    for ( int i = 0; i < 6; i ++ ) {\n      if ( ci < float( i ) ) { break; }\n      \n      num = mod( floor( n ), 10.0 );\n      n -= num;\n      n *= 10.0;\n    }\n  } else {\n    float n = abs( _in );\n    for ( int i = 0; i < 6; i ++ ) {\n      if ( -ci < float( i ) ) { break; }\n      \n      if ( ci != 0.0 && n < 1.0 ) {\n        // minus\n        return float( i ) == -ci && _in < 0.0 && cfy == 2.0 && 0.0 < cfx;\n      }\n      num = mod( floor( n ), 10.0 );\n      n -= num;\n      n /= 10.0;\n    }\n  }\n\n  bool a;\n  a = 1.0 == mod( floor( (\n    num == 0.0 ? 432534.0 :\n    num == 1.0 ? 410692.0 :\n    num == 2.0 ? 493087.0 :\n    num == 3.0 ? 493191.0 :\n    num == 4.0 ? 630408.0 :\n    num == 5.0 ? 989063.0 :\n    num == 6.0 ? 399254.0 :\n    num == 7.0 ? 1016898.0 :\n    num == 8.0 ? 431766.0 :\n    433798.0\n  ) / pow( 2.0, cf ) ), 2.0 );\n  \n  return a ? true : false;\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / resolution;\n\n  vec2 m = floor( vec2( 0.0, resolution.y ) + vec2( 1.0, -1.0 ) * mouse );\n  vec2 center = floor( m + vec2( 1.0, 0.7 ) * RADIUS );\n  float circle = length( gl_FragCoord.xy - center ) - RADIUS;\n\n  vec4 col = texture2D( sampler0, uv );\n  vec4 mcol = texture2D( sampler0, ( m + 0.5 ) / resolution );\n  vec4 bcol = vec4( circleColor, 1.0 );\n\n  col = mix(\n    col,\n    mix(\n      bcol,\n      mcol,\n      smoothstep( 1.0, 0.0, circle + 5.0 )\n    ),\n    smoothstep( 1.0, 0.0, circle )\n  );\n\n  if ( circle < 0.0 ) {\n    col = print( gl_FragCoord.xy - center - vec2( 0.0, 8.0 ), mcol.x ) ? bcol : col;\n    col = print( gl_FragCoord.xy - center - vec2( 0.0, 0.0 ), mcol.y ) ? bcol : col;\n    col = print( gl_FragCoord.xy - center - vec2( 0.0, -8.0 ), mcol.z ) ? bcol : col;\n    col = print( gl_FragCoord.xy - center - vec2( 0.0, -16.0 ), mcol.w ) ? bcol : col;\n  }\n\n  gl_FragColor = col;\n}"

/***/ }),

/***/ "./src/shaders/jpeg-cosine.frag":
/*!**************************************!*\
  !*** ./src/shaders/jpeg-cosine.frag ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "#define lofi(i,j) floor((i)/(j)+.5)*(j)\n#define PI 3.14159265\n\n// ------\n\nprecision highp float;\n#define GLSLIFY 1\n\nuniform vec2 resolution;\n\nuniform bool isVert;\nuniform int blockSize;\nuniform sampler2D sampler0;\n\nuniform float highFreqMultiplier;\nuniform float quantize;\nuniform float quantizeF;\n\n// ------\n\nvec3 rgb2yuv( vec3 rgb ) {\n  return vec3(\n    0.299 * rgb.x + 0.587 * rgb.y + 0.114 * rgb.z,\n    -0.148736 * rgb.x - 0.331264 * rgb.y + 0.5 * rgb.z,\n    0.5 * rgb.x - 0.418688 * rgb.y - 0.081312 * rgb.z\n  );\n}\n\nvec3 rgb2hsv( vec3 rgb ) {\n  float hi = max( rgb.x, max( rgb.y, rgb.z ) );\n  float lo = min( rgb.x, min( rgb.y, rgb.z ) );\n  float d = hi - lo;\n  return vec3(\n    (\n      d == 0.0 ? 0.0 :\n      lo == rgb.z ? ( rgb.y - rgb.x ) / d + 1.0 :\n      lo == rgb.x ? ( rgb.z - rgb.y ) / d + 3.0 :\n                    ( rgb.x - rgb.z ) / d + 5.0\n    ) / 6.0, // h\n    d, // s\n    hi // v\n  );\n}\n\nvoid main() {\n  vec2 bv = ( isVert ? vec2( 0.0, 1.0 ) : vec2( 1.0, 0.0 ) );\n  vec2 block = bv * float( blockSize - 1 ) + vec2( 1.0 );\n  vec2 blockOrigin = 0.5 + floor( gl_FragCoord.xy / block ) * block;\n  int bs = int( min( float( blockSize ), dot( bv, resolution - blockOrigin + 0.5 ) ) );\n\n  float freq = floor( mod( dot( bv, gl_FragCoord.xy ), float( blockSize ) ) ) / float( bs ) * PI;\n  float factor = ( freq == 0.0 ? 1.0 : 2.0 ) / float( bs );\n\n  vec4 sum = vec4( 0.0 );\n  for ( int i = 0; i < 1024; i ++ ) {\n    if ( bs <= i ) { break; }\n\n    vec2 delta = float( i ) * bv;\n    float wave = cos( ( float( i ) + 0.5 ) * freq );\n\n    vec2 uv = ( blockOrigin + delta ) / resolution;\n    vec4 val = texture2D( sampler0, uv );\n    if ( !isVert ) { val.xyz = rgb2yuv( val.xyz ); }\n    sum += wave * factor * val;\n  }\n\n  if ( isVert ) {\n    float len = length( floor( mod( gl_FragCoord.xy, float( blockSize ) ) ) );\n\n    float q = quantize + quantizeF * len;\n    sum.x = 0.0 < q ? lofi( sum.x, q ) : sum.x;\n    sum.y = 0.0 < q ? lofi( sum.y, q ) : sum.y;\n    sum.z = 0.0 < q ? lofi( sum.z, q ) : sum.z;\n    sum.a = 0.0 < q ? lofi( sum.a, q ) : sum.a;\n\n    sum *= 1.0 + len * highFreqMultiplier;\n  }\n\n  gl_FragColor = sum;\n}"

/***/ }),

/***/ "./src/shaders/jpeg-render.frag":
/*!**************************************!*\
  !*** ./src/shaders/jpeg-render.frag ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "#define saturate(i) clamp(i,0.,1.)\n#define lofi(i,j) floor((i)/(j)+.5)*(j)\n#define PI 3.14159265\n\nprecision highp float;\n#define GLSLIFY 1\n\nuniform vec2 resolution;\n\nuniform bool isVert;\nuniform int blockSize;\nuniform sampler2D sampler0;\n\n// ------\n\nbool validuv( vec2 v ) { return 0.0 < v.x && v.x < 1.0 && 0.0 < v.y && v.y < 1.0; }\n\nvec3 yuv2rgb( vec3 yuv ) {\n  return vec3(\n    yuv.x + 1.402 * yuv.z,\n    yuv.x - 0.344136 * yuv.y - 0.714136 * yuv.z,\n    yuv.x + 1.772 * yuv.y\n  );\n}\n\nvec3 hsv2rgb( vec3 hsv ) {\n  float h = 6.0 * hsv.x;\n  float c = hsv.y;\n  float x = c * ( 1.0 - abs( mod( h, 2.0 ) - 1.0 ) );\n  return saturate( hsv.z - c + (\n    h < 1.0 ? vec3( c, x, 0.0 ) :\n    h < 2.0 ? vec3( x, c, 0.0 ) :\n    h < 3.0 ? vec3( 0.0, c, x ) :\n    h < 4.0 ? vec3( 0.0, x, c ) :\n    h < 5.0 ? vec3( x, 0.0, c ) :\n              vec3( c, 0.0, x )\n  ) );\n}\n\nvoid main() {\n  vec2 bv = ( isVert ? vec2( 0.0, 1.0 ) : vec2( 1.0, 0.0 ) );\n  vec2 block = bv * float( blockSize - 1 ) + vec2( 1.0 );\n  vec2 blockOrigin = 0.5 + floor( gl_FragCoord.xy / block ) * block;\n  int bs = int( min( float( blockSize ), dot( bv, resolution - blockOrigin + 0.5 ) ) );\n\n  float delta = mod( dot( bv, gl_FragCoord.xy ), float( blockSize ) );\n  \n  vec4 sum = vec4( 0.0 );\n  for ( int i = 0; i < 1024; i ++ ) {\n    if ( bs <= i ) { break; }\n\n    float fdelta = float( i );\n    vec4 val = texture2D( sampler0, ( blockOrigin + bv * fdelta ) / resolution );\n\n    float wave = cos( delta * fdelta / float( bs ) * PI );\n    sum += wave * val;\n  }\n\n  if ( isVert ) {\n    sum.xyz = yuv2rgb( sum.xyz );\n  }\n\n  gl_FragColor = sum;\n}"

/***/ }),

/***/ "./src/shaders/overlay.frag":
/*!**********************************!*\
  !*** ./src/shaders/overlay.frag ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "#define PI 3.14159265\n#define TAU 6.28318531\n#define lofi(i,m) (floor((i)/(m))*(m))\n\nprecision highp float;\n#define GLSLIFY 1\n\nuniform float time;\nuniform vec2 resolution;\nuniform sampler2D sampler0;\n\nfloat fractSin( float i ) {\n  return fract( sin( i ) * 1846.42 );\n}\n\nvoid main() {\n  vec2 uv = vec2( 0.0, 1.0 ) + vec2( 1.0, -1.0 ) * gl_FragCoord.xy / resolution;\n\n  float deform = 1.0 - 2.0 * fractSin( sin( lofi( time * TAU + 40.0 * ( uv.x + uv.y ), 1.0 ) ) );\n  deform = 0.005 * sign( deform ) * pow( abs( deform ), 10.0 );\n\n  vec3 col = vec3(\n    texture2D( sampler0, uv + deform ).y,\n    texture2D( sampler0, uv + 2.0 * deform ).y,\n    texture2D( sampler0, uv + 3.0 * deform ).y\n  );\n  float border = max(\n    texture2D( sampler0, uv + deform ).x,\n    max(\n      texture2D( sampler0, uv + 2.0 * deform ).x,\n      texture2D( sampler0, uv + 3.0 * deform ).x\n    )\n  );\n\n  gl_FragColor = vec4( col, col + 0.5 * border );\n}"

/***/ }),

/***/ "./src/shaders/particles-compute.frag":
/*!********************************************!*\
  !*** ./src/shaders/particles-compute.frag ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "#define PARTICLE_LIFE_LENGTH 3.0\n\n#define HUGE 9E16\n#define PI 3.14159265\n#define TAU 6.283185307\n#define V vec3(0.,1.,-1.)\n#define saturate(i) clamp(i,0.,1.)\n#define lofi(i,m) (floor((i)/(m))*(m))\n#define lofir(i,m) (floor((i)/(m)+.5)*(m))\n\n// ------\n\nprecision highp float;\n#define GLSLIFY 1\n\nuniform float time;\n\nuniform float nParticleSqrt;\nuniform float nParticle;\nuniform float ppp;\n\nuniform float totalFrame;\nuniform bool init;\nuniform float deltaTime;\nuniform vec2 resolution;\n\nuniform bool isInitFrame;\n\nuniform vec2 resolutionMotion;\nuniform vec2 planeResolution;\nuniform float voxelUnit;\n\nuniform sampler2D samplerPcompute;\nuniform sampler2D samplerMotionWrite;\nuniform sampler2D samplerRandom;\n\nuniform float noisePhase;\nuniform float velScale;\nuniform float genRate;\n\n// ------\n\nvec2 vInvert( vec2 _uv ) {\n  return vec2( 0.0, 1.0 ) + vec2( 1.0, -1.0 ) * _uv;\n}\n\n// ------\n\nmat2 rotate2D( float _t ) {\n  return mat2( cos( _t ), sin( _t ), -sin( _t ), cos( _t ) );\n}\n\nfloat fractSin( float i ) {\n  return fract( sin( i ) * 1846.42 );\n}\n\nvec4 sampleRandom( vec2 _uv ) {\n  return texture2D( samplerRandom, _uv );\n}\n\nfloat GPURnd(inout vec4 n)\n{\n\t// Based on the post http://gpgpu.org/forums/viewtopic.php?t=2591&sid=17051481b9f78fb49fba5b98a5e0f1f3\n\t// (The page no longer exists as of March 17th, 2015. Please let me know if you see why this code works.)\n\tconst vec4 q = vec4(   1225.0,    1585.0,    2457.0,    2098.0);\n\tconst vec4 r = vec4(   1112.0,     367.0,      92.0,     265.0);\n\tconst vec4 a = vec4(   3423.0,    2646.0,    1707.0,    1999.0);\n\tconst vec4 m = vec4(4194287.0, 4194277.0, 4194191.0, 4194167.0);\n\n\tvec4 beta = floor(n / q);\n\tvec4 p = a * (n - beta * q) - beta * r;\n\tbeta = (sign(-p) + vec4(1.0)) * vec4(0.5) * m;\n\tn = (p + beta);\n\n\treturn fract(dot(n / m, vec4(1.0, -1.0, 1.0, -1.0)));\n}\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0; }\n\nfloat mod289(float x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0; }\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nfloat permute(float x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat taylorInvSqrt(float r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec4 grad4(float j, vec4 ip)\n  {\n  const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n  vec4 p,s;\n\n  p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n  p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n  s = vec4(lessThan(p, vec4(0.0)));\n  p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www;\n\n  return p;\n  }\n\n// (sqrt(5) - 1)/4 = F4, used once below\n#define F4 0.309016994374947451\n\nfloat snoise(vec4 v)\n  {\n  const vec4  C = vec4( 0.138196601125011,  // (5 - sqrt(5))/20  G4\n                        0.276393202250021,  // 2 * G4\n                        0.414589803375032,  // 3 * G4\n                       -0.447213595499958); // -1 + 4 * G4\n\n// First corner\n  vec4 i  = floor(v + dot(v, vec4(F4)) );\n  vec4 x0 = v -   i + dot(i, C.xxxx);\n\n// Other corners\n\n// Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)\n  vec4 i0;\n  vec3 isX = step( x0.yzw, x0.xxx );\n  vec3 isYZ = step( x0.zww, x0.yyz );\n//  i0.x = dot( isX, vec3( 1.0 ) );\n  i0.x = isX.x + isX.y + isX.z;\n  i0.yzw = 1.0 - isX;\n//  i0.y += dot( isYZ.xy, vec2( 1.0 ) );\n  i0.y += isYZ.x + isYZ.y;\n  i0.zw += 1.0 - isYZ.xy;\n  i0.z += isYZ.z;\n  i0.w += 1.0 - isYZ.z;\n\n  // i0 now contains the unique values 0,1,2,3 in each channel\n  vec4 i3 = clamp( i0, 0.0, 1.0 );\n  vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );\n  vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );\n\n  //  x0 = x0 - 0.0 + 0.0 * C.xxxx\n  //  x1 = x0 - i1  + 1.0 * C.xxxx\n  //  x2 = x0 - i2  + 2.0 * C.xxxx\n  //  x3 = x0 - i3  + 3.0 * C.xxxx\n  //  x4 = x0 - 1.0 + 4.0 * C.xxxx\n  vec4 x1 = x0 - i1 + C.xxxx;\n  vec4 x2 = x0 - i2 + C.yyyy;\n  vec4 x3 = x0 - i3 + C.zzzz;\n  vec4 x4 = x0 + C.wwww;\n\n// Permutations\n  i = mod289(i);\n  float j0 = permute( permute( permute( permute(i.w) + i.z) + i.y) + i.x);\n  vec4 j1 = permute( permute( permute( permute (\n             i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))\n           + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))\n           + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))\n           + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));\n\n// Gradients: 7x7x6 points over a cube, mapped onto a 4-cross polytope\n// 7*7*6 = 294, which is close to the ring size 17*17 = 289.\n  vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;\n\n  vec4 p0 = grad4(j0,   ip);\n  vec4 p1 = grad4(j1.x, ip);\n  vec4 p2 = grad4(j1.y, ip);\n  vec4 p3 = grad4(j1.z, ip);\n  vec4 p4 = grad4(j1.w, ip);\n\n// Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n  p4 *= taylorInvSqrt(dot(p4,p4));\n\n// Mix contributions from the five corners\n  vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);\n  vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)            ), 0.0);\n  m0 = m0 * m0;\n  m1 = m1 * m1;\n  return 49.0 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))\n               + dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;\n\n  }\n\nvec3 randomSphere( inout vec4 seed ) {\n  vec3 v;\n  for ( int i = 0; i < 10; i ++ ) {\n    v = vec3(\n      GPURnd( seed ),\n      GPURnd( seed ),\n      GPURnd( seed )\n    ) * 2.0 - 1.0;\n    if ( length( v ) < 1.0 ) { break; }\n  }\n  return v;\n}\n\nvec2 randomCircle( inout vec4 seed ) {\n  vec2 v;\n  for ( int i = 0; i < 10; i ++ ) {\n    v = vec2(\n      GPURnd( seed ),\n      GPURnd( seed )\n    ) * 2.0 - 1.0;\n    if ( length( v ) < 1.0 ) { break; }\n  }\n  return v;\n}\n\nvec3 randomBox( inout vec4 seed ) {\n  vec3 v;\n  v = vec3(\n    GPURnd( seed ),\n    GPURnd( seed ),\n    GPURnd( seed )\n  ) * 2.0 - 1.0;\n  return v;\n}\n\n// == deal with motion field ===================================================\nvec2 motionCoord( vec3 _v ) {\n  vec3 v = floor( _v / voxelUnit ) + 0.5;\n  vec2 planeSize = planeResolution / resolutionMotion;\n\n  // == where are the plane origin? ============================================\n  float zRange = floor( 1.0 / planeSize.x ) * floor( 1.0 / planeSize.y ) / 2.0;\n  if ( v.z < -zRange || zRange < v.z ) {\n    return vec2( 0.0, 0.0 );\n  }\n  float planeIndex = floor( v.z + zRange );\n  vec2 planeOrigin = vec2( fract( planeIndex * planeSize.x ), floor( planeIndex * planeSize.x ) * planeSize.y );\n\n  // == place a dot on the plane ===============================================\n  vec2 xyRange = planeResolution / 2.0;\n  if ( v.x < -xyRange.x || xyRange.x < v.x || v.y < -xyRange.y || xyRange.y < v.y ) {\n    return vec2( 0.0, 0.0 );\n  }\n  return planeOrigin + ( v.xy + xyRange ) / planeResolution * planeSize;\n}\n\n// ------\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / resolution;\n  vec2 puv = vec2( ( floor( gl_FragCoord.x / ppp ) * ppp + 0.5 ) / resolution.x, uv.y );\n  float mode = mod( gl_FragCoord.x, ppp );\n  vec2 dpix = vec2( 1.0 ) / resolution;\n\n  float dt = deltaTime;\n\n  // == prepare some vars ======================================================\n  vec4 seed = texture2D( samplerRandom, puv );\n  GPURnd( seed );\n\n  vec4 pos = texture2D( samplerPcompute, puv );\n  vec4 vel = texture2D( samplerPcompute, puv + dpix * vec2( 1.0, 0.0 ) );\n\n  float timing = mix( 0.0, PARTICLE_LIFE_LENGTH, floor( puv.y * nParticleSqrt ) / nParticleSqrt );\n  timing += lofi( time, PARTICLE_LIFE_LENGTH );\n\n  if ( time - deltaTime + PARTICLE_LIFE_LENGTH < timing ) {\n    timing -= PARTICLE_LIFE_LENGTH;\n  }\n\n  // == initialize particles ===================================================\n  if ( isInitFrame ) {\n    pos.w = 0.0;\n  }\n\n  // == generate particles =====================================================\n  if (\n    time - deltaTime < timing && timing <= time &&\n    GPURnd( seed ) < genRate\n  ) {\n    dt = time - timing;\n\n    pos.xyz = 0.3 * randomSphere( seed );\n    pos.y += 1.0;\n\n    vel.xyz = 2.0 * randomSphere( seed );\n    vel.y = 4.0;\n    vel.w = 0.0;\n\n    pos.w = 1.0; // life\n  } else {\n    // == update particles =======================================================\n    {\n      vec3 motion = texture2D( samplerMotionWrite, motionCoord( pos.xyz ) ).xyz;\n      vec3 tmp = pos.xyz + dt * 0.5 * ( vel.xyz + motion );\n      motion = texture2D( samplerMotionWrite, motionCoord( tmp ) ).xyz;\n      vel.xyz += motion;\n    }\n\n    for ( int i = 0; i < 3; i ++ ) {\n      if ( 2.0 < abs( pos[ i ] ) ) {\n        float s = sign( pos[ i ] );\n        if ( i == 1 && s == 1.0 ) { continue; }\n        pos[ i ] = s * 2.0;\n        vel[ i ] *= 0.0;\n      }\n    }\n\n    vel.zx -= dt * 10.0 * vec2( -1.0, 1.0 ) * normalize( pos.xz );\n    vel.xyz += dt * 2.0 * vec3(\n      -snoise( vec4( 0.8 * pos.xyz, 1.485 + noisePhase ) ),\n      snoise( vec4( 0.8 * pos.xyz, 3.485 + noisePhase ) ),\n      -snoise( vec4( 0.8 * pos.xyz, 5.485 + noisePhase ) )\n    );\n    vel.y -= dt * 20.8;\n\n    pos.xyz += vel.xyz * dt;\n    pos.xyz += 0.01 * dt * ( vec3(\n      GPURnd( seed ),\n      GPURnd( seed ),\n      GPURnd( seed )\n    ) - 0.5 );\n    pos.w -= dt / PARTICLE_LIFE_LENGTH;\n  }\n\n  gl_FragColor = (\n    mode < 1.0 ? pos :\n    vel\n  );\n}"

/***/ }),

/***/ "./src/shaders/particles-divergence.frag":
/*!***********************************************!*\
  !*** ./src/shaders/particles-divergence.frag ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "precision highp float;\n#define GLSLIFY 1\n\n// == variables ================================================================\nuniform vec2 resolutionMotion;\nuniform vec2 planeResolution;\nuniform float voxelUnit;\n\nuniform sampler2D samplerMotion;\n\n// == deal with motion field ===================================================\nvec2 motionCoord( vec3 _v ) {\n  vec3 v = floor( _v / voxelUnit ) + 0.5;\n  vec2 planeSize = planeResolution / resolutionMotion;\n\n  // == where are the plane origin? ============================================\n  float zRange = floor( 1.0 / planeSize.x ) * floor( 1.0 / planeSize.y ) / 2.0;\n  if ( v.z < -zRange || zRange < v.z ) {\n    return vec2( 0.0, 0.0 );\n  }\n  float planeIndex = floor( v.z + zRange );\n  vec2 planeOrigin = vec2( fract( planeIndex * planeSize.x ), floor( planeIndex * planeSize.x ) * planeSize.y );\n\n  // == place a dot on the plane ===============================================\n  vec2 xyRange = planeResolution / 2.0;\n  if ( v.x < -xyRange.x || xyRange.x < v.x || v.y < -xyRange.y || xyRange.y < v.y ) {\n    return vec2( 0.0, 0.0 );\n  }\n  return planeOrigin + ( v.xy + xyRange ) / planeResolution * planeSize;\n}\n\nvec3 motionCoordInv( vec2 _coord ) {\n  vec2 planeSize = planeResolution / resolutionMotion;\n  vec3 ret = vec3( 0.0 );\n\n  // == x and y ================================================================\n  ret.xy = ( ( fract( _coord / planeSize ) - 0.5 ) * planeResolution ) * voxelUnit;\n\n  // == z ======================================================================\n  float zRange = floor( 1.0 / planeSize.x ) * floor( 1.0 / planeSize.y ) / 2.0;\n  vec2 planePlace = floor( _coord / planeSize );\n  ret.z = ( planePlace.x + floor( planePlace.y / planeSize.x ) - zRange + 0.5 ) * voxelUnit;\n\n  return ret;\n}\n\n// == main =====================================================================\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / resolutionMotion;\n  vec3 v = motionCoordInv( uv );\n\n  vec2 d = vec2( 0.0, voxelUnit );\n\n  vec4 center = texture2D( samplerMotion, uv );\n  float xm = texture2D( samplerMotion, motionCoord( v - d.yxx ) ).x;\n  float xp = texture2D( samplerMotion, motionCoord( v + d.yxx ) ).x;\n  float ym = texture2D( samplerMotion, motionCoord( v - d.xyx ) ).y;\n  float yp = texture2D( samplerMotion, motionCoord( v + d.xyx ) ).y;\n  float zm = texture2D( samplerMotion, motionCoord( v - d.xxy ) ).z;\n  float zp = texture2D( samplerMotion, motionCoord( v + d.xxy ) ).z;\n\n  float divergence = xp - xm + yp - ym + zp - zm;\n  divergence -= exp( ( center.w / 1000.0 - 20.0 ) );\n\n  gl_FragColor = vec4( divergence, 0.0, 0.0, center.w );\n}"

/***/ }),

/***/ "./src/shaders/particles-enforce.frag":
/*!********************************************!*\
  !*** ./src/shaders/particles-enforce.frag ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "precision highp float;\n#define GLSLIFY 1\n\n// == variables ================================================================\nuniform vec2 resolutionMotion;\nuniform vec2 planeResolution;\nuniform float voxelUnit;\n\nuniform float deltaTime;\nuniform sampler2D samplerMotion;\n\n// == deal with motion field ===================================================\nvec2 motionCoord( vec3 _v ) {\n  vec3 v = floor( _v / voxelUnit ) + 0.5;\n  vec2 planeSize = planeResolution / resolutionMotion;\n\n  // == where are the plane origin? ============================================\n  float zRange = floor( 1.0 / planeSize.x ) * floor( 1.0 / planeSize.y ) / 2.0;\n  if ( v.z < -zRange || zRange < v.z ) {\n    return vec2( 0.0, 0.0 );\n  }\n  float planeIndex = floor( v.z + zRange );\n  vec2 planeOrigin = vec2( fract( planeIndex * planeSize.x ), floor( planeIndex * planeSize.x ) * planeSize.y );\n\n  // == place a dot on the plane ===============================================\n  vec2 xyRange = planeResolution / 2.0;\n  if ( v.x < -xyRange.x || xyRange.x < v.x || v.y < -xyRange.y || xyRange.y < v.y ) {\n    return vec2( 0.0, 0.0 );\n  }\n  return planeOrigin + ( v.xy + xyRange ) / planeResolution * planeSize;\n}\n\nvec3 motionCoordInv( vec2 _coord ) {\n  vec2 planeSize = planeResolution / resolutionMotion;\n  vec3 ret = vec3( 0.0 );\n\n  // == x and y ================================================================\n  ret.xy = ( ( fract( _coord / planeSize ) - 0.5 ) * planeResolution ) * voxelUnit;\n\n  // == z ======================================================================\n  float zRange = floor( 1.0 / planeSize.x ) * floor( 1.0 / planeSize.y ) / 2.0;\n  vec2 planePlace = floor( _coord / planeSize );\n  ret.z = ( planePlace.x + floor( planePlace.y / planeSize.x ) - zRange + 0.5 ) * voxelUnit;\n\n  return ret;\n}\n\n// == um =======================================================================\nvec3 extractVelocity( vec4 tex ) {\n  return tex.w == 0.0 ? vec3( 0.0 ) : tex.xyz / tex.w;\n}\n\n// == main =====================================================================\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / resolutionMotion;\n  vec3 v = motionCoordInv( uv );\n\n  vec4 tex = texture2D( samplerMotion, uv );\n  vec3 vel = vec3( 0.0 );\n  for ( int iz = -1; iz <= 1; iz ++ ) {\n    for ( int iy = -1; iy <= 1; iy ++ ) {\n      for ( int ix = -1; ix <= 1; ix ++ ) {\n        vec4 tex = texture2D( samplerMotion, motionCoord( v + vec3( ix, iy, iz ) * voxelUnit ) );\n        vel += extractVelocity( tex ) / 27.0;\n      }\n    }\n  }\n\n  if ( 2.0 < abs( v.x ) ) { vel.x = 0.0; }\n  if ( 2.0 < abs( v.z ) ) { vel.z = 0.0; }\n  if ( v.y < -2.0 ) { vel.y = 0.0; }\n\n  gl_FragColor = vec4( vel, tex.w );\n}"

/***/ }),

/***/ "./src/shaders/particles-motion-read.frag":
/*!************************************************!*\
  !*** ./src/shaders/particles-motion-read.frag ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "precision highp float;\n#define GLSLIFY 1\n\n// == variables ================================================================\nvarying vec3 vCol;\nvarying float vValid;\n\nvoid main() {\n  // == if it is invalid then just discard =====================================\n  if ( vValid == 0.0 ) { discard; }\n\n  // == just shot a dot ========================================================\n  gl_FragColor = vec4( vCol, 1.0 );\n}"

/***/ }),

/***/ "./src/shaders/particles-motion-read.vert":
/*!************************************************!*\
  !*** ./src/shaders/particles-motion-read.vert ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "#define GLSLIFY 1\n#define HUGE 9E16\n#define PI 3.141592654\n#define TAU 6.283185307\n#define V vec3(0.,1.,-1.)\n#define saturate(i) clamp(i,0.,1.)\n#define lofi(i,m) (floor((i)/(m))*(m))\n#define lofir(i,m) (floor((i+0.5)/(m))*(m))\n\n// == variables ================================================================\nattribute vec2 computeUV;\n\nvarying vec3 vCol;\nvarying float vValid;\n\nuniform vec2 resolutionPcompute;\n\nuniform vec2 resolutionMotion;\nuniform vec2 planeResolution;\nuniform float voxelUnit;\n\nuniform sampler2D samplerPcompute;\n\n// == deal with motion field ===================================================\nvec2 motionCoord( vec3 _v ) {\n  vec3 v = floor( _v / voxelUnit ) + 0.5;\n  vec2 planeSize = planeResolution / resolutionMotion;\n\n  // == where are the plane origin? ============================================\n  float zRange = floor( 1.0 / planeSize.x ) * floor( 1.0 / planeSize.y ) / 2.0;\n  if ( v.z < -zRange || zRange < v.z ) {\n    return vec2( 0.0, 0.0 );\n  }\n  float planeIndex = floor( v.z + zRange );\n  vec2 planeOrigin = vec2( fract( planeIndex * planeSize.x ), floor( planeIndex * planeSize.x ) * planeSize.y );\n\n  // == place a dot on the plane ===============================================\n  vec2 xyRange = planeResolution / 2.0;\n  if ( v.x < -xyRange.x || xyRange.x < v.x || v.y < -xyRange.y || xyRange.y < v.y ) {\n    return vec2( 0.0, 0.0 );\n  }\n  return planeOrigin + ( v.xy + xyRange ) / planeResolution * planeSize;\n}\n\n// == main =====================================================================\nvoid main() {\n  // == fetch compute texture ==================================================\n  vec2 puv = computeUV;\n  vec2 dppix = vec2( 1.0 ) / resolutionPcompute;\n\n  vec4 pos = texture2D( samplerPcompute, puv );\n  vec4 vel = texture2D( samplerPcompute, puv + dppix * vec2( 1.0, 0.0 ) );\n\n  // == place a dot ============================================================\n  vec2 coord = motionCoord( pos.xyz );\n  vValid = coord != vec2( 0.0, 0.0 ) ? 1.0 : 0.0; // out of compute cells\n  vValid = 0.0 < pos.w ? 1.0 : 0.0; // life is depleted\n  gl_Position = vec4( coord * 2.0 - 1.0, 0.0, 1.0 );\n  gl_PointSize = 1.0;\n\n  // == set a color ============================================================\n  vCol = vel.xyz;\n}"

/***/ }),

/***/ "./src/shaders/particles-motion-write.frag":
/*!*************************************************!*\
  !*** ./src/shaders/particles-motion-write.frag ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "precision highp float;\n#define GLSLIFY 1\n\n// == variables ================================================================\nuniform vec2 resolutionMotion;\nuniform vec2 planeResolution;\nuniform float voxelUnit;\n\nuniform sampler2D samplerMotion;\nuniform sampler2D samplerPressure;\n\n// == deal with motion field ===================================================\nvec2 motionCoord( vec3 _v ) {\n  vec3 v = floor( _v / voxelUnit ) + 0.5;\n  vec2 planeSize = planeResolution / resolutionMotion;\n\n  // == where are the plane origin? ============================================\n  float zRange = floor( 1.0 / planeSize.x ) * floor( 1.0 / planeSize.y ) / 2.0;\n  if ( v.z < -zRange || zRange < v.z ) {\n    return vec2( 0.0, 0.0 );\n  }\n  float planeIndex = floor( v.z + zRange );\n  vec2 planeOrigin = vec2( fract( planeIndex * planeSize.x ), floor( planeIndex * planeSize.x ) * planeSize.y );\n\n  // == place a dot on the plane ===============================================\n  vec2 xyRange = planeResolution / 2.0;\n  if ( v.x < -xyRange.x || xyRange.x < v.x || v.y < -xyRange.y || xyRange.y < v.y ) {\n    return vec2( 0.0, 0.0 );\n  }\n  return planeOrigin + ( v.xy + xyRange ) / planeResolution * planeSize;\n}\n\nvec3 motionCoordInv( vec2 _coord ) {\n  vec2 planeSize = planeResolution / resolutionMotion;\n  vec3 ret = vec3( 0.0 );\n\n  // == x and y ================================================================\n  ret.xy = ( ( fract( _coord / planeSize ) - 0.5 ) * planeResolution ) * voxelUnit;\n\n  // == z ======================================================================\n  float zRange = floor( 1.0 / planeSize.x ) * floor( 1.0 / planeSize.y ) / 2.0;\n  vec2 planePlace = floor( _coord / planeSize );\n  ret.z = ( planePlace.x + floor( planePlace.y / planeSize.x ) - zRange + 0.5 ) * voxelUnit;\n\n  return ret;\n}\n\n// == um =======================================================================\nvec3 extractVelocity( vec4 tex ) {\n  return tex.w == 0.0 ? vec3( 0.0 ) : tex.xyz / tex.w;\n}\n\n// == main =====================================================================\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / resolutionMotion;\n  vec3 v = motionCoordInv( uv );\n\n  vec2 d = vec2( 0.0, voxelUnit );\n\n  float xm = texture2D( samplerPressure, motionCoord( v - d.yxx ) ).x;\n  float xp = texture2D( samplerPressure, motionCoord( v + d.yxx ) ).x;\n  float ym = texture2D( samplerPressure, motionCoord( v - d.xyx ) ).x;\n  float yp = texture2D( samplerPressure, motionCoord( v + d.xyx ) ).x;\n  float zm = texture2D( samplerPressure, motionCoord( v - d.xxy ) ).x;\n  float zp = texture2D( samplerPressure, motionCoord( v + d.xxy ) ).x;\n\n  vec3 oldVel = extractVelocity( texture2D( samplerMotion, uv ) );\n  vec3 newVel = oldVel - vec3( xp - xm, yp - ym, zp - zm );\n\n  gl_FragColor = vec4( newVel - oldVel, 1.0 );\n}"

/***/ }),

/***/ "./src/shaders/particles-pressure.frag":
/*!*********************************************!*\
  !*** ./src/shaders/particles-pressure.frag ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "precision highp float;\n#define GLSLIFY 1\n\n// == variables ================================================================\nuniform vec2 resolutionMotion;\nuniform vec2 planeResolution;\nuniform float voxelUnit;\n\nuniform sampler2D samplerDivergence;\nuniform sampler2D samplerPressure;\n\n// == deal with motion field ===================================================\nvec2 motionCoord( vec3 _v ) {\n  vec3 v = floor( _v / voxelUnit ) + 0.5;\n  vec2 planeSize = planeResolution / resolutionMotion;\n\n  // == where are the plane origin? ============================================\n  float zRange = floor( 1.0 / planeSize.x ) * floor( 1.0 / planeSize.y ) / 2.0;\n  if ( v.z < -zRange || zRange < v.z ) {\n    return vec2( 0.0, 0.0 );\n  }\n  float planeIndex = floor( v.z + zRange );\n  vec2 planeOrigin = vec2( fract( planeIndex * planeSize.x ), floor( planeIndex * planeSize.x ) * planeSize.y );\n\n  // == place a dot on the plane ===============================================\n  vec2 xyRange = planeResolution / 2.0;\n  if ( v.x < -xyRange.x || xyRange.x < v.x || v.y < -xyRange.y || xyRange.y < v.y ) {\n    return vec2( 0.0, 0.0 );\n  }\n  return planeOrigin + ( v.xy + xyRange ) / planeResolution * planeSize;\n}\n\nvec3 motionCoordInv( vec2 _coord ) {\n  vec2 planeSize = planeResolution / resolutionMotion;\n  vec3 ret = vec3( 0.0 );\n\n  // == x and y ================================================================\n  ret.xy = ( ( fract( _coord / planeSize ) - 0.5 ) * planeResolution ) * voxelUnit;\n\n  // == z ======================================================================\n  float zRange = floor( 1.0 / planeSize.x ) * floor( 1.0 / planeSize.y ) / 2.0;\n  vec2 planePlace = floor( _coord / planeSize );\n  ret.z = ( planePlace.x + floor( planePlace.y / planeSize.x ) - zRange + 0.5 ) * voxelUnit;\n\n  return ret;\n}\n\n// == main =====================================================================\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / resolutionMotion;\n  vec3 v = motionCoordInv( uv );\n\n  vec2 d = vec2( 0.0, voxelUnit );\n\n  vec4 divergence = texture2D( samplerDivergence, uv );\n  if ( divergence.w == 0.0 ) { discard; } // this is an air\n\n  float xm = texture2D( samplerPressure, motionCoord( v - d.yxx ) ).x;\n  float xp = texture2D( samplerPressure, motionCoord( v + d.yxx ) ).x;\n  float ym = texture2D( samplerPressure, motionCoord( v - d.xyx ) ).x;\n  float yp = texture2D( samplerPressure, motionCoord( v + d.xyx ) ).x;\n  float zm = texture2D( samplerPressure, motionCoord( v - d.xxy ) ).x;\n  float zp = texture2D( samplerPressure, motionCoord( v + d.xxy ) ).x;\n\n  float pressure = ( xm + xp + ym + yp + zm + zp - divergence.x ) / 6.0;\n\n  gl_FragColor = vec4( pressure, 0.0, 0.0, 1.0 );\n}"

/***/ }),

/***/ "./src/shaders/particles-render.frag":
/*!*******************************************!*\
  !*** ./src/shaders/particles-render.frag ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "#define PI 3.14159265\n#define TAU 6.28318531\n#define saturate(i) clamp(i,0.,1.)\n\n// ------\n\n#extension GL_EXT_draw_buffers : require\nprecision highp float;\n#define GLSLIFY 1\n\nvarying vec3 vPos;\nvarying vec3 vNor;\nvarying vec3 vCol;\nvarying float vLife;\n\nuniform mat4 matPL;\nuniform mat4 matVL;\n\nuniform vec3 cameraPos;\nuniform float perspFar;\nuniform vec3 lightPos;\n\nuniform bool isShadow;\n\nuniform sampler2D samplerShadow;\n\n// == nande ====================================================================\nvec3 rgb2yuv( vec3 rgb ) {\n  return vec3(\n    0.299 * rgb.x + 0.587 * rgb.y + 0.114 * rgb.z,\n    -0.148736 * rgb.x - 0.331264 * rgb.y + 0.5 * rgb.z,\n    0.5 * rgb.x - 0.418688 * rgb.y - 0.081312 * rgb.z\n  );\n}\n\nvec3 hsv2rgb( vec3 hsv ) {\n  float h = 6.0 * hsv.x;\n  float c = hsv.y;\n  float x = c * ( 1.0 - abs( mod( h, 2.0 ) - 1.0 ) );\n  return saturate( hsv.z - c + (\n    h < 1.0 ? vec3( c, x, 0.0 ) :\n    h < 2.0 ? vec3( x, c, 0.0 ) :\n    h < 3.0 ? vec3( 0.0, c, x ) :\n    h < 4.0 ? vec3( 0.0, x, c ) :\n    h < 5.0 ? vec3( x, 0.0, c ) :\n              vec3( c, 0.0, x )\n  ) );\n}\n\n// == rotate ===================================================================\nmat2 rotate2D( float _t ) {\n  return mat2( cos( _t ), sin( _t ), -sin( _t ), cos( _t ) );\n}\n\n// == uh =======================================================================\nfloat shadow( float d ) {\n  vec4 pl = matPL * matVL * vec4( vPos, 1.0 );\n  vec2 uv = pl.xy / pl.w * 0.5 + 0.5;\n\n  float dc = length( vPos - lightPos );\n  float ret = 0.0;\n  for ( int iy = -1; iy <= 1; iy ++ ) {\n    for ( int ix = -1; ix <= 1; ix ++ ) {\n      vec2 uv = uv + vec2( float( ix ), float ( iy ) ) * 4E-4;\n      float proj = texture2D( samplerShadow, uv ).x;\n      float bias = 0.1 + ( 1.0 - d ) * 0.3;\n\n      float dif = smoothstep( bias * 2.0, bias, ( dc - proj ) );\n      ret += dif / 9.0;\n    }\n  }\n  return ret;\n}\n\n// == main procedure ===========================================================\nvoid main() {\n  if ( vLife <= 0.0 ) { discard; }\n\n  if ( isShadow ) {\n    float depth = length( vPos - lightPos );\n    gl_FragData[ 0 ] = vec4( depth, 0.0, 0.0, 1.0 );\n    return;\n  }\n\n  vec3 lightDir = normalize( vPos - lightPos );\n  vec3 rayDir = normalize( vPos - cameraPos );\n  float d = dot( -vNor, lightDir );\n  float dif = mix( 1.0, d, 0.5 );\n  vec3 col = dif * vCol;\n\n  float shadowFactor = shadow( d );\n  col *= mix( 0.2, 1.0, shadowFactor );\n  col = max( vec3( 0.0 ), col );\n\n  gl_FragData[ 0 ] = vec4( hsv2rgb( rgb2yuv( col ) ), 1.0 );\n  gl_FragData[ 1 ] = vec4( length( cameraPos - vPos ), 0.0, 0.0, 1.0 );\n}"

/***/ }),

/***/ "./src/shaders/particles-render.vert":
/*!*******************************************!*\
  !*** ./src/shaders/particles-render.vert ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "#define GLSLIFY 1\n#define HUGE 9E16\n#define PI 3.141592654\n#define TAU 6.283185307\n#define V vec3(0.,1.,-1.)\n#define saturate(i) clamp(i,0.,1.)\n#define lofi(i,m) (floor((i)/(m))*(m))\n#define lofir(i,m) (floor((i+0.5)/(m))*(m))\n\n// ------\n\nattribute vec2 computeUV;\nattribute vec3 geomPos;\nattribute vec3 geomNor;\n\nvarying vec3 vPos;\nvarying vec3 vNor;\nvarying vec3 vCol;\nvarying float vLife;\n\nuniform vec2 resolution;\nuniform vec2 resolutionPcompute;\n\nuniform mat4 matP;\nuniform mat4 matV;\nuniform mat4 matVL;\nuniform mat4 matPL;\n\nuniform bool isShadow;\n\nuniform float colorVar;\nuniform float colorOffset;\n\nuniform sampler2D samplerPcompute;\nuniform sampler2D samplerRandomStatic;\n\n// ------\n\nvec3 catColor( float _p ) {\n  return 0.5 + 0.5 * vec3(\n    cos( _p ),\n    cos( _p + PI / 3.0 * 4.0 ),\n    cos( _p + PI / 3.0 * 2.0 )\n  );\n}\n\nvec4 random( vec2 _uv ) {\n  return texture2D( samplerRandomStatic, _uv );\n}\n\nmat2 rotate2D( float _t ) {\n  return mat2( cos( _t ), sin( _t ), -sin( _t ), cos( _t ) );\n}\n\n// ------\n\nvec3 rotateGeometry( vec3 _p, vec3 _v ) {\n  vec3 v = _v;\n  v.yz = rotate2D( 4.0 * _p.x ) * v.yz;\n  v.zx = rotate2D( 4.0 * _p.y ) * v.zx;\n  v.xy = rotate2D( 4.0 * _p.z ) * v.xy;\n  return v;\n}\n\nvoid main() {\n  // == fetch compute texture ==================================================\n  vec2 puv = computeUV;\n  vec2 dppix = vec2( 1.0 ) / resolutionPcompute;\n\n  vec4 pos = texture2D( samplerPcompute, puv );\n  vec4 vel = texture2D( samplerPcompute, puv + dppix * vec2( 1.0, 0.0 ) );\n\n  // == ???????? ===============================================================\n  vec4 dice = random( puv.yy * 182.92 );\n\n  // == assign varying variables ===============================================\n  vLife = pos.w;\n\n  // vCol = (\n  //   dice.y < 0.8\n  //   ? pow( catColor( TAU * ( ( dice.x * 2.0 - 1.0 ) * colorVar + colorOffset ) ), vec3( 2.0 ) )\n  //   : vec3( 0.4 )\n  // );\n  // vCol = abs( vel.xyz );\n  vCol = 2.0 * exp( 2.3 * ( vLife - 1.0 ) ) * catColor( 6.9 + 2.0 * ( 1.0 - vLife ) );\n\n  // == geometry ===============================================================\n  float size = ( 0.01 + 0.1 * pow( dice.w, 2.0 ) ) * pow( sin( PI * vLife ), 0.25 );\n\n  vNor = rotateGeometry( pos.xyz, geomNor );\n  pos.xyz += size * rotateGeometry( pos.xyz, geomPos );\n\n  // == finalize ===============================================================\n  vPos = pos.xyz;\n\n  vec4 outPos;\n  if ( isShadow ) {\n    outPos = matPL * matVL * vec4( pos.xyz, 1.0 );\n  } else {\n    outPos = matP * matV * vec4( pos.xyz, 1.0 );\n    outPos.x /= resolution.x / resolution.y;\n  }\n  gl_Position = outPos;\n  // gl_PointSize = resolution.y * size / outPos.z;\n}"

/***/ }),

/***/ "./src/shaders/post.frag":
/*!*******************************!*\
  !*** ./src/shaders/post.frag ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "#define BARREL_ITER 10\n\n#define HUGE 9E16\n#define PI 3.14159265\n#define V vec3(0.,1.,-1.)\n#define saturate(i) clamp(i,0.,1.)\n#define lofi(i,m) (floor((i)/(m))*(m))\n\n// ------\n\nprecision highp float;\n#define GLSLIFY 1\n\nuniform float time;\nuniform vec2 resolution;\n\nuniform float barrelAmp;\nuniform float barrelOffset;\nuniform float qualityShit6;\n\nuniform sampler2D sampler0;\n\n// ------\n\nvec3 barrel( float amp, vec2 uv ) {\n\tfloat corn = length( vec2( 0.5 ) );\n\tfloat a = min( 3.0 * sqrt( amp ), corn * PI );\n\tfloat zoom = corn / ( tan( corn * a ) + corn );\n\tvec2 p = saturate(\n    ( uv + normalize( uv - 0.5 ) * tan( length( uv - 0.5 ) * a ) ) * zoom +\n    0.5 * ( 1.0 - zoom )\n  );\n\treturn texture2D( sampler0, vec2( p.x, p.y ) ).xyz;\n}\n\n// ------\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / resolution;\n  vec2 p = ( gl_FragCoord.xy * 2.0 - resolution ) / resolution.y;\n  float vig = 1.0 - length( p ) * 0.2;\n\n  vec3 tex = vec3( 0.0 );\n\n  for ( int i = 0; i < BARREL_ITER; i ++ ) {\n    float fi = ( float( i ) + 0.5 ) / float( BARREL_ITER );\n    vec3 a = saturate( vec3(\n      1.0 - 3.0 * abs( 1.0 / 6.0 - fi ),\n      1.0 - 3.0 * abs( 1.0 / 2.0 - fi ),\n      1.0 - 3.0 * abs( 5.0 / 6.0 - fi )\n    ) ) / float( BARREL_ITER ) * 4.0;\n    tex += a * barrel( barrelOffset + barrelAmp * fi, uv );\n  }\n\n  tex = mix( vec3( 0.0 ), tex, vig );\n\n  vec3 col = pow( saturate( tex.xyz ), vec3( 1.0 / 2.2 ) );\n  col = vec3(\n    smoothstep( -0.10, 1.10, col.x ),\n    smoothstep(  0.00, 1.00, col.y ),\n    smoothstep( -0.30, 1.30, col.z )\n  );\n  col = mix( col, 1.0 - col, qualityShit6 );\n\n  gl_FragColor = vec4( col, 1.0 );\n}"

/***/ }),

/***/ "./src/shaders/quad.vert":
/*!*******************************!*\
  !*** ./src/shaders/quad.vert ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "#define GLSLIFY 1\nattribute vec2 p;\n\nvoid main() {\n  gl_Position = vec4( p, 0.0, 1.0 );\n}"

/***/ }),

/***/ "./src/shaders/return.frag":
/*!*********************************!*\
  !*** ./src/shaders/return.frag ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "precision highp float;\n#define GLSLIFY 1\n\nuniform vec2 resolution;\nuniform sampler2D sampler0;\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / resolution;\n  gl_FragColor = texture2D( sampler0, uv );\n}"

/***/ }),

/***/ "./src/styles/main.scss":
/*!******************************!*\
  !*** ./src/styles/main.scss ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(/*! !../../node_modules/css-loader!../../node_modules/sass-loader/lib/loader.js!./main.scss */ "./node_modules/css-loader/index.js!./node_modules/sass-loader/lib/loader.js!./src/styles/main.scss");

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(/*! ../../node_modules/style-loader/lib/addStyles.js */ "./node_modules/style-loader/lib/addStyles.js")(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),

/***/ 0:
/*!**********************!*\
  !*** util (ignored) ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 1:
/*!**********************!*\
  !*** util (ignored) ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2hlbHBlcnMvdG9Db25zdW1hYmxlQXJyYXkuanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vYXJyYXkvZnJvbS5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9tYXRoL2xvZzEwLmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL21hdGgvc2lnbi5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hLWZ1bmN0aW9uLmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FuLW9iamVjdC5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hcnJheS1pbmNsdWRlcy5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jbGFzc29mLmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NvZi5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jb3JlLmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NyZWF0ZS1wcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jdHguanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZGVmaW5lZC5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kZXNjcmlwdG9ycy5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kb20tY3JlYXRlLmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2VudW0tYnVnLWtleXMuanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZXhwb3J0LmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2ZhaWxzLmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2dsb2JhbC5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19oYXMuanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faGlkZS5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19odG1sLmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2llOC1kb20tZGVmaW5lLmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2lvYmplY3QuanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXMtYXJyYXktaXRlci5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pcy1vYmplY3QuanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlci1jYWxsLmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItY3JlYXRlLmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItZGVmaW5lLmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItZGV0ZWN0LmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXJhdG9ycy5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19saWJyYXJ5LmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX21hdGgtc2lnbi5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtY3JlYXRlLmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1kcC5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZHBzLmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1ncG8uanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWtleXMtaW50ZXJuYWwuanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWtleXMuanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fcHJvcGVydHktZGVzYy5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19yZWRlZmluZS5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zZXQtdG8tc3RyaW5nLXRhZy5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zaGFyZWQta2V5LmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NoYXJlZC5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zdHJpbmctYXQuanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8tYWJzb2x1dGUtaW5kZXguanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8taW50ZWdlci5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1pb2JqZWN0LmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWxlbmd0aC5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1vYmplY3QuanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8tcHJpbWl0aXZlLmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3VpZC5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL193a3MuanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QuanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYuYXJyYXkuZnJvbS5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5tYXRoLmxvZzEwLmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm1hdGguc2lnbi5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy90aW1lcnMtYnJvd3NlcmlmeS9tYWluLmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvdnVlLWhvdC1yZWxvYWQtYXBpL2Rpc3QvaW5kZXguanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy92dWUvZGlzdC92dWUucnVudGltZS5jb21tb24uanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy92dWVpZnkvbGliL2luc2VydC1jc3MuanMiLCJ3ZWJwYWNrOi8vL3NyYy9hc3MuanMiLCJ3ZWJwYWNrOi8vL3NyYy9jbG9jay1mcmFtZS5qcyIsIndlYnBhY2s6Ly8vc3JjL2Nsb2NrLXJlYWx0aW1lLmpzIiwid2VicGFjazovLy9zcmMvY2xvY2suanMiLCJ3ZWJwYWNrOi8vL3NyYy9jb21wYXQuanMiLCJ3ZWJwYWNrOi8vL3NyYy9jdWJpYy1iZXppZXIuanMiLCJ3ZWJwYWNrOi8vL3NyYy9meC1kZWZpbml0aW9ucy5qcyIsIndlYnBhY2s6Ly8vc3JjL2Z4cy9hZGQuanMiLCJ3ZWJwYWNrOi8vL3NyYy9meHMvY2RzLmpzIiwid2VicGFjazovLy9zcmMvZnhzL2NsYW1wLmpzIiwid2VicGFjazovLy9zcmMvZnhzL2V4cC5qcyIsIndlYnBhY2s6Ly8vc3JjL2Z4cy9ncmF2aXR5LmpzIiwid2VicGFjazovLy9zcmMvZnhzL2xvZmkuanMiLCJ3ZWJwYWNrOi8vL3NyYy9meHMvbW9kdWxlcy94b3JzaGlmdC5qcyIsIndlYnBhY2s6Ly8vc3JjL2Z4cy9ub2lzZS5qcyIsIndlYnBhY2s6Ly8vc3JjL2Z4cy9wb3cuanMiLCJ3ZWJwYWNrOi8vL3NyYy9meHMvc2luZS5qcyIsIndlYnBhY2s6Ly8vc3JjL2dlbi1pZC5qcyIsIndlYnBhY2s6Ly8vc3JjL2hhcy1vdmVyd3JhcC5qcyIsIndlYnBhY2s6Ly8vc3JjL2ltYWdlcy9hYm91dC1jbG9zZS5zdmciLCJ3ZWJwYWNrOi8vL3NyYy9qc29uLWNvcHkuanMiLCJ3ZWJwYWNrOi8vL3NyYy9tYWluLWd1aS5qcyIsIndlYnBhY2s6Ly8vc3JjL21haW4uanMiLCJ3ZWJwYWNrOi8vL3NyYy9wYXJhbS1ndWkuanMiLCJ3ZWJwYWNrOi8vL3NyYy9wYXJhbS5qcyIsIndlYnBhY2s6Ly8vc3JjL3Z1ZS9hYm91dC52dWUiLCJ3ZWJwYWNrOi8vL3NyYy92dWUvY29udGV4dC1tZW51LnZ1ZSIsIndlYnBhY2s6Ly8vc3JjL3Z1ZS9oZWFkZXIudnVlIiwid2VicGFjazovLy9zcmMvdnVlL21haW4udnVlIiwid2VicGFjazovLy9zcmMvdnVlL3BhcmFtbGlzdC52dWUiLCJ3ZWJwYWNrOi8vL3NyYy92dWUvcHJvcGJveC52dWUiLCJ3ZWJwYWNrOi8vL3NyYy92dWUvcHJvcG1lbnUudnVlIiwid2VicGFjazovLy9zcmMvdnVlL3Njcm9sbGFibGUudnVlIiwid2VicGFjazovLy9zcmMvdnVlL3N0YWxrZXIudnVlIiwid2VicGFjazovLy9zcmMvdnVlL3RpbWVsaW5lLWZ4bWVudS52dWUiLCJ3ZWJwYWNrOi8vL3NyYy92dWUvdGltZWxpbmUudnVlIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9iYXNlNjQtanMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS11dGlsLWlzL2xpYi91dGlsLmpzIiwid2VicGFjazovLy8uL3NyYy9zdHlsZXMvbWFpbi5zY3NzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZXZlbnRzL2V2ZW50cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW1tZWRpYXRlL2xpYi9icm93c2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbmhlcml0cy9pbmhlcml0c19icm93c2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pc2FycmF5L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qc3ppcC9saWIvYmFzZTY0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qc3ppcC9saWIvY29tcHJlc3NlZE9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL2NvbXByZXNzaW9ucy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL2NyYzMyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qc3ppcC9saWIvZGVmYXVsdHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzemlwL2xpYi9leHRlcm5hbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL2ZsYXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qc3ppcC9saWIvZ2VuZXJhdGUvWmlwRmlsZVdvcmtlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL2dlbmVyYXRlL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qc3ppcC9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzemlwL2xpYi9sb2FkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qc3ppcC9saWIvbm9kZWpzL05vZGVqc1N0cmVhbUlucHV0QWRhcHRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL25vZGVqcy9Ob2RlanNTdHJlYW1PdXRwdXRBZGFwdGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qc3ppcC9saWIvbm9kZWpzVXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzemlwL2xpYi9vYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzemlwL2xpYi9yZWFkYWJsZS1zdHJlYW0tYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL3JlYWRlci9BcnJheVJlYWRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL3JlYWRlci9EYXRhUmVhZGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qc3ppcC9saWIvcmVhZGVyL05vZGVCdWZmZXJSZWFkZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzemlwL2xpYi9yZWFkZXIvU3RyaW5nUmVhZGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qc3ppcC9saWIvcmVhZGVyL1VpbnQ4QXJyYXlSZWFkZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzemlwL2xpYi9yZWFkZXIvcmVhZGVyRm9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qc3ppcC9saWIvc2lnbmF0dXJlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qc3ppcC9saWIvc3RyZWFtL0NvbnZlcnRXb3JrZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzemlwL2xpYi9zdHJlYW0vQ3JjMzJQcm9iZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL3N0cmVhbS9EYXRhTGVuZ3RoUHJvYmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzemlwL2xpYi9zdHJlYW0vRGF0YVdvcmtlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL3N0cmVhbS9HZW5lcmljV29ya2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qc3ppcC9saWIvc3RyZWFtL1N0cmVhbUhlbHBlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL3N1cHBvcnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzemlwL2xpYi91dGY4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qc3ppcC9saWIvdXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzemlwL2xpYi96aXBFbnRyaWVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qc3ppcC9saWIvemlwRW50cnkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzemlwL2xpYi96aXBPYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzemlwL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vc2V0LWltbWVkaWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanN6aXAvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hLWZ1bmN0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qc3ppcC9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FuLW9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanN6aXAvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jb2YuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzemlwL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY29yZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanN6aXAvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jdHguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzemlwL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZGVzY3JpcHRvcnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzemlwL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZG9tLWNyZWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanN6aXAvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19leHBvcnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzemlwL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZmFpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzemlwL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZ2xvYmFsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qc3ppcC9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2hpZGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzemlwL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faHRtbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanN6aXAvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pZTgtZG9tLWRlZmluZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanN6aXAvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pbnZva2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzemlwL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXMtb2JqZWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qc3ppcC9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1kcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanN6aXAvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19wcm9wZXJ0eS1kZXNjLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qc3ppcC9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3Rhc2suanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzemlwL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8tcHJpbWl0aXZlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qc3ppcC9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvd2ViLmltbWVkaWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbGllL2xpYi9icm93c2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ub2RlLWxpYnMtYnJvd3Nlci9ub2RlX21vZHVsZXMvc3RyaW5nX2RlY29kZXIvbGliL3N0cmluZ19kZWNvZGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wYWtvL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wYWtvL2xpYi9kZWZsYXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wYWtvL2xpYi9pbmZsYXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wYWtvL2xpYi91dGlscy9jb21tb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Bha28vbGliL3V0aWxzL3N0cmluZ3MuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvYWRsZXIzMi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9jb25zdGFudHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvY3JjMzIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvZGVmbGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9nemhlYWRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9pbmZmYXN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2luZmxhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvaW5mdHJlZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvbWVzc2FnZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvdHJlZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvenN0cmVhbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy1uZXh0aWNrLWFyZ3MvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2R1cGxleC1icm93c2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fZHVwbGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fcGFzc3Rocm91Z2guanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9yZWFkYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvQnVmZmVyTGlzdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2Rlc3Ryb3kuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9zdHJlYW0tYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3Bhc3N0aHJvdWdoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vcmVhZGFibGUtYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3RyYW5zZm9ybS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3dyaXRhYmxlLWJyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NhZmUtYnVmZmVyL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zZXRpbW1lZGlhdGUvc2V0SW1tZWRpYXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zdHJlYW0tYnJvd3NlcmlmeS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvdXJscy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdGltZXJzLWJyb3dzZXJpZnkvbWFpbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdXRpbC1kZXByZWNhdGUvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9oYXJtb255LW1vZHVsZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvZ2VvbXMvY3ViZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvZ2VvbXMvb2N0YWhlZHJvbi5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvaW1hZ2VzL2RpdmVyc2l0eS5wbmciLCJ3ZWJwYWNrOi8vLy4vc3JjL2xpYnMvY2FudmFzLXNhdmVyLmpzIiwid2VicGFjazovLy8uL3NyYy9saWJzL2dsY2F0LXBhdGgtZ3VpLmpzIiwid2VicGFjazovLy8uL3NyYy9saWJzL2dsY2F0LXBhdGguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2xpYnMvZ2xjYXQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2xpYnMvbWF0aGNhdC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbGlicy91bHRyYWNhdC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbGlicy94b3JzaGlmdC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbWFpbi5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvcGF0aHMvYmxvb20uanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3BhdGhzL2JveC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvcGF0aHMvanBlZy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvcGF0aHMvb3ZlcmxheS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvcGF0aHMvcGFydGljbGVzLmpzIiwid2VicGFjazovLy8uL3NyYy9wYXRocy9wb3N0ZnguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NoYWRlcnMvYmcuZnJhZyIsIndlYnBhY2s6Ly8vLi9zcmMvc2hhZGVycy9ibG9vbS1wb3N0LmZyYWciLCJ3ZWJwYWNrOi8vLy4vc3JjL3NoYWRlcnMvYmxvb20tcHJlLmZyYWciLCJ3ZWJwYWNrOi8vLy4vc3JjL3NoYWRlcnMvYm94LmZyYWciLCJ3ZWJwYWNrOi8vLy4vc3JjL3NoYWRlcnMvYm94LnZlcnQiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NoYWRlcnMvZnhhYS5mcmFnIiwid2VicGFjazovLy8uL3NyYy9zaGFkZXJzL2dhdXNzLmZyYWciLCJ3ZWJwYWNrOi8vLy4vc3JjL3NoYWRlcnMvaW5zcGVjdG9yLmZyYWciLCJ3ZWJwYWNrOi8vLy4vc3JjL3NoYWRlcnMvanBlZy1jb3NpbmUuZnJhZyIsIndlYnBhY2s6Ly8vLi9zcmMvc2hhZGVycy9qcGVnLXJlbmRlci5mcmFnIiwid2VicGFjazovLy8uL3NyYy9zaGFkZXJzL292ZXJsYXkuZnJhZyIsIndlYnBhY2s6Ly8vLi9zcmMvc2hhZGVycy9wYXJ0aWNsZXMtY29tcHV0ZS5mcmFnIiwid2VicGFjazovLy8uL3NyYy9zaGFkZXJzL3BhcnRpY2xlcy1kaXZlcmdlbmNlLmZyYWciLCJ3ZWJwYWNrOi8vLy4vc3JjL3NoYWRlcnMvcGFydGljbGVzLWVuZm9yY2UuZnJhZyIsIndlYnBhY2s6Ly8vLi9zcmMvc2hhZGVycy9wYXJ0aWNsZXMtbW90aW9uLXJlYWQuZnJhZyIsIndlYnBhY2s6Ly8vLi9zcmMvc2hhZGVycy9wYXJ0aWNsZXMtbW90aW9uLXJlYWQudmVydCIsIndlYnBhY2s6Ly8vLi9zcmMvc2hhZGVycy9wYXJ0aWNsZXMtbW90aW9uLXdyaXRlLmZyYWciLCJ3ZWJwYWNrOi8vLy4vc3JjL3NoYWRlcnMvcGFydGljbGVzLXByZXNzdXJlLmZyYWciLCJ3ZWJwYWNrOi8vLy4vc3JjL3NoYWRlcnMvcGFydGljbGVzLXJlbmRlci5mcmFnIiwid2VicGFjazovLy8uL3NyYy9zaGFkZXJzL3BhcnRpY2xlcy1yZW5kZXIudmVydCIsIndlYnBhY2s6Ly8vLi9zcmMvc2hhZGVycy9wb3N0LmZyYWciLCJ3ZWJwYWNrOi8vLy4vc3JjL3NoYWRlcnMvcXVhZC52ZXJ0Iiwid2VicGFjazovLy8uL3NyYy9zaGFkZXJzL3JldHVybi5mcmFnIiwid2VicGFjazovLy8uL3NyYy9zdHlsZXMvbWFpbi5zY3NzPzMyZDMiLCJ3ZWJwYWNrOi8vL3V0aWwgKGlnbm9yZWQpIiwid2VicGFjazovLy91dGlsIChpZ25vcmVkKT8xZmQ0Il0sIm5hbWVzIjpbImV4cG9ydHMiLCJieXRlTGVuZ3RoIiwidG9CeXRlQXJyYXkiLCJmcm9tQnl0ZUFycmF5IiwibG9va3VwIiwicmV2TG9va3VwIiwiQXJyIiwiVWludDhBcnJheSIsIkFycmF5IiwiY29kZSIsImkiLCJsZW4iLCJsZW5ndGgiLCJjaGFyQ29kZUF0IiwiZ2V0TGVucyIsImI2NCIsIkVycm9yIiwidmFsaWRMZW4iLCJpbmRleE9mIiwicGxhY2VIb2xkZXJzTGVuIiwibGVucyIsIl9ieXRlTGVuZ3RoIiwidG1wIiwiYXJyIiwiY3VyQnl0ZSIsInRyaXBsZXRUb0Jhc2U2NCIsIm51bSIsImVuY29kZUNodW5rIiwidWludDgiLCJzdGFydCIsImVuZCIsIm91dHB1dCIsInB1c2giLCJqb2luIiwiZXh0cmFCeXRlcyIsInBhcnRzIiwibWF4Q2h1bmtMZW5ndGgiLCJsZW4yIiwiYmFzZTY0IiwicmVxdWlyZSIsImllZWU3NTQiLCJpc0FycmF5IiwiQnVmZmVyIiwiU2xvd0J1ZmZlciIsIklOU1BFQ1RfTUFYX0JZVEVTIiwiVFlQRURfQVJSQVlfU1VQUE9SVCIsImdsb2JhbCIsInVuZGVmaW5lZCIsInR5cGVkQXJyYXlTdXBwb3J0Iiwia01heExlbmd0aCIsIl9fcHJvdG9fXyIsInByb3RvdHlwZSIsImZvbyIsInN1YmFycmF5IiwiZSIsImNyZWF0ZUJ1ZmZlciIsInRoYXQiLCJSYW5nZUVycm9yIiwiYXJnIiwiZW5jb2RpbmdPck9mZnNldCIsImFsbG9jVW5zYWZlIiwiZnJvbSIsInBvb2xTaXplIiwiX2F1Z21lbnQiLCJ2YWx1ZSIsIlR5cGVFcnJvciIsIkFycmF5QnVmZmVyIiwiZnJvbUFycmF5QnVmZmVyIiwiZnJvbVN0cmluZyIsImZyb21PYmplY3QiLCJTeW1ib2wiLCJzcGVjaWVzIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJjb25maWd1cmFibGUiLCJhc3NlcnRTaXplIiwic2l6ZSIsImFsbG9jIiwiZmlsbCIsImVuY29kaW5nIiwiY2hlY2tlZCIsImFsbG9jVW5zYWZlU2xvdyIsInN0cmluZyIsImlzRW5jb2RpbmciLCJhY3R1YWwiLCJ3cml0ZSIsInNsaWNlIiwiZnJvbUFycmF5TGlrZSIsImFycmF5IiwiYnl0ZU9mZnNldCIsIm9iaiIsImlzQnVmZmVyIiwiY29weSIsImJ1ZmZlciIsImlzbmFuIiwidHlwZSIsImRhdGEiLCJ0b1N0cmluZyIsImIiLCJfaXNCdWZmZXIiLCJjb21wYXJlIiwiYSIsIngiLCJ5IiwiTWF0aCIsIm1pbiIsIlN0cmluZyIsInRvTG93ZXJDYXNlIiwiY29uY2F0IiwibGlzdCIsInBvcyIsImJ1ZiIsImlzVmlldyIsImxvd2VyZWRDYXNlIiwidXRmOFRvQnl0ZXMiLCJiYXNlNjRUb0J5dGVzIiwic2xvd1RvU3RyaW5nIiwiaGV4U2xpY2UiLCJ1dGY4U2xpY2UiLCJhc2NpaVNsaWNlIiwibGF0aW4xU2xpY2UiLCJiYXNlNjRTbGljZSIsInV0ZjE2bGVTbGljZSIsInN3YXAiLCJuIiwibSIsInN3YXAxNiIsInN3YXAzMiIsInN3YXA2NCIsImFyZ3VtZW50cyIsImFwcGx5IiwiZXF1YWxzIiwiaW5zcGVjdCIsInN0ciIsIm1heCIsIm1hdGNoIiwidGFyZ2V0IiwidGhpc1N0YXJ0IiwidGhpc0VuZCIsInRoaXNDb3B5IiwidGFyZ2V0Q29weSIsImJpZGlyZWN0aW9uYWxJbmRleE9mIiwidmFsIiwiZGlyIiwiaXNOYU4iLCJhcnJheUluZGV4T2YiLCJjYWxsIiwibGFzdEluZGV4T2YiLCJpbmRleFNpemUiLCJhcnJMZW5ndGgiLCJ2YWxMZW5ndGgiLCJyZWFkIiwicmVhZFVJbnQxNkJFIiwiZm91bmRJbmRleCIsImZvdW5kIiwiaiIsImluY2x1ZGVzIiwiaGV4V3JpdGUiLCJvZmZzZXQiLCJOdW1iZXIiLCJyZW1haW5pbmciLCJzdHJMZW4iLCJwYXJzZWQiLCJwYXJzZUludCIsInN1YnN0ciIsInV0ZjhXcml0ZSIsImJsaXRCdWZmZXIiLCJhc2NpaVdyaXRlIiwiYXNjaWlUb0J5dGVzIiwibGF0aW4xV3JpdGUiLCJiYXNlNjRXcml0ZSIsInVjczJXcml0ZSIsInV0ZjE2bGVUb0J5dGVzIiwiaXNGaW5pdGUiLCJ0b0pTT04iLCJfYXJyIiwicmVzIiwiZmlyc3RCeXRlIiwiY29kZVBvaW50IiwiYnl0ZXNQZXJTZXF1ZW5jZSIsInNlY29uZEJ5dGUiLCJ0aGlyZEJ5dGUiLCJmb3VydGhCeXRlIiwidGVtcENvZGVQb2ludCIsImRlY29kZUNvZGVQb2ludHNBcnJheSIsIk1BWF9BUkdVTUVOVFNfTEVOR1RIIiwiY29kZVBvaW50cyIsImZyb21DaGFyQ29kZSIsInJldCIsIm91dCIsInRvSGV4IiwiYnl0ZXMiLCJuZXdCdWYiLCJzbGljZUxlbiIsImNoZWNrT2Zmc2V0IiwiZXh0IiwicmVhZFVJbnRMRSIsIm5vQXNzZXJ0IiwibXVsIiwicmVhZFVJbnRCRSIsInJlYWRVSW50OCIsInJlYWRVSW50MTZMRSIsInJlYWRVSW50MzJMRSIsInJlYWRVSW50MzJCRSIsInJlYWRJbnRMRSIsInBvdyIsInJlYWRJbnRCRSIsInJlYWRJbnQ4IiwicmVhZEludDE2TEUiLCJyZWFkSW50MTZCRSIsInJlYWRJbnQzMkxFIiwicmVhZEludDMyQkUiLCJyZWFkRmxvYXRMRSIsInJlYWRGbG9hdEJFIiwicmVhZERvdWJsZUxFIiwicmVhZERvdWJsZUJFIiwiY2hlY2tJbnQiLCJ3cml0ZVVJbnRMRSIsIm1heEJ5dGVzIiwid3JpdGVVSW50QkUiLCJ3cml0ZVVJbnQ4IiwiZmxvb3IiLCJvYmplY3RXcml0ZVVJbnQxNiIsImxpdHRsZUVuZGlhbiIsIndyaXRlVUludDE2TEUiLCJ3cml0ZVVJbnQxNkJFIiwib2JqZWN0V3JpdGVVSW50MzIiLCJ3cml0ZVVJbnQzMkxFIiwid3JpdGVVSW50MzJCRSIsIndyaXRlSW50TEUiLCJsaW1pdCIsInN1YiIsIndyaXRlSW50QkUiLCJ3cml0ZUludDgiLCJ3cml0ZUludDE2TEUiLCJ3cml0ZUludDE2QkUiLCJ3cml0ZUludDMyTEUiLCJ3cml0ZUludDMyQkUiLCJjaGVja0lFRUU3NTQiLCJ3cml0ZUZsb2F0Iiwid3JpdGVGbG9hdExFIiwid3JpdGVGbG9hdEJFIiwid3JpdGVEb3VibGUiLCJ3cml0ZURvdWJsZUxFIiwid3JpdGVEb3VibGVCRSIsInRhcmdldFN0YXJ0Iiwic2V0IiwiSU5WQUxJRF9CQVNFNjRfUkUiLCJiYXNlNjRjbGVhbiIsInN0cmluZ3RyaW0iLCJyZXBsYWNlIiwidHJpbSIsInVuaXRzIiwiSW5maW5pdHkiLCJsZWFkU3Vycm9nYXRlIiwiYnl0ZUFycmF5IiwiYyIsImhpIiwibG8iLCJzcmMiLCJkc3QiLCJvYmplY3RUb1N0cmluZyIsImlzQm9vbGVhbiIsImlzTnVsbCIsImlzTnVsbE9yVW5kZWZpbmVkIiwiaXNOdW1iZXIiLCJpc1N0cmluZyIsImlzU3ltYm9sIiwiaXNVbmRlZmluZWQiLCJpc1JlZ0V4cCIsInJlIiwiaXNPYmplY3QiLCJpc0RhdGUiLCJkIiwiaXNFcnJvciIsImlzRnVuY3Rpb24iLCJpc1ByaW1pdGl2ZSIsIm8iLCJtb2R1bGUiLCJ1c2VTb3VyY2VNYXAiLCJtYXAiLCJpdGVtIiwiY29udGVudCIsImNzc1dpdGhNYXBwaW5nVG9TdHJpbmciLCJtb2R1bGVzIiwibWVkaWFRdWVyeSIsImFscmVhZHlJbXBvcnRlZE1vZHVsZXMiLCJpZCIsImNzc01hcHBpbmciLCJidG9hIiwic291cmNlTWFwcGluZyIsInRvQ29tbWVudCIsInNvdXJjZVVSTHMiLCJzb3VyY2VzIiwic291cmNlIiwic291cmNlUm9vdCIsInNvdXJjZU1hcCIsInVuZXNjYXBlIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwiSlNPTiIsInN0cmluZ2lmeSIsIkV2ZW50RW1pdHRlciIsIl9ldmVudHMiLCJfbWF4TGlzdGVuZXJzIiwiZGVmYXVsdE1heExpc3RlbmVycyIsInNldE1heExpc3RlbmVycyIsImVtaXQiLCJlciIsImhhbmRsZXIiLCJhcmdzIiwibGlzdGVuZXJzIiwiZXJyb3IiLCJlcnIiLCJjb250ZXh0IiwiYWRkTGlzdGVuZXIiLCJsaXN0ZW5lciIsIm5ld0xpc3RlbmVyIiwid2FybmVkIiwiY29uc29sZSIsInRyYWNlIiwib24iLCJvbmNlIiwiZmlyZWQiLCJnIiwicmVtb3ZlTGlzdGVuZXIiLCJwb3NpdGlvbiIsInNwbGljZSIsInJlbW92ZUFsbExpc3RlbmVycyIsImtleSIsImxpc3RlbmVyQ291bnQiLCJldmxpc3RlbmVyIiwiZW1pdHRlciIsImlzTEUiLCJtTGVuIiwibkJ5dGVzIiwiZUxlbiIsImVNYXgiLCJlQmlhcyIsIm5CaXRzIiwicyIsIk5hTiIsInJ0IiwiYWJzIiwibG9nIiwiTE4yIiwiTXV0YXRpb24iLCJNdXRhdGlvbk9ic2VydmVyIiwiV2ViS2l0TXV0YXRpb25PYnNlcnZlciIsInNjaGVkdWxlRHJhaW4iLCJjYWxsZWQiLCJvYnNlcnZlciIsIm5leHRUaWNrIiwiZWxlbWVudCIsImRvY3VtZW50IiwiY3JlYXRlVGV4dE5vZGUiLCJvYnNlcnZlIiwiY2hhcmFjdGVyRGF0YSIsInNldEltbWVkaWF0ZSIsIk1lc3NhZ2VDaGFubmVsIiwiY2hhbm5lbCIsInBvcnQxIiwib25tZXNzYWdlIiwicG9ydDIiLCJwb3N0TWVzc2FnZSIsImNyZWF0ZUVsZW1lbnQiLCJzY3JpcHRFbCIsIm9ucmVhZHlzdGF0ZWNoYW5nZSIsInBhcmVudE5vZGUiLCJyZW1vdmVDaGlsZCIsImRvY3VtZW50RWxlbWVudCIsImFwcGVuZENoaWxkIiwic2V0VGltZW91dCIsImRyYWluaW5nIiwicXVldWUiLCJvbGRRdWV1ZSIsImltbWVkaWF0ZSIsInRhc2siLCJjcmVhdGUiLCJpbmhlcml0cyIsImN0b3IiLCJzdXBlckN0b3IiLCJzdXBlcl8iLCJjb25zdHJ1Y3RvciIsImVudW1lcmFibGUiLCJ3cml0YWJsZSIsIlRlbXBDdG9yIiwidXRpbHMiLCJzdXBwb3J0IiwiX2tleVN0ciIsImVuY29kZSIsImlucHV0IiwiY2hyMSIsImNocjIiLCJjaHIzIiwiZW5jMSIsImVuYzIiLCJlbmMzIiwiZW5jNCIsInJlbWFpbmluZ0J5dGVzIiwiZ2V0VHlwZU9mIiwiY2hhckF0IiwiZGVjb2RlIiwicmVzdWx0SW5kZXgiLCJkYXRhVXJsUHJlZml4IiwidG90YWxMZW5ndGgiLCJ1aW50OGFycmF5IiwiZXh0ZXJuYWwiLCJEYXRhV29ya2VyIiwiRGF0YUxlbmd0aFByb2JlIiwiQ3JjMzJQcm9iZSIsIkNvbXByZXNzZWRPYmplY3QiLCJjb21wcmVzc2VkU2l6ZSIsInVuY29tcHJlc3NlZFNpemUiLCJjcmMzMiIsImNvbXByZXNzaW9uIiwiY29tcHJlc3NlZENvbnRlbnQiLCJnZXRDb250ZW50V29ya2VyIiwid29ya2VyIiwiUHJvbWlzZSIsInJlc29sdmUiLCJwaXBlIiwidW5jb21wcmVzc1dvcmtlciIsInN0cmVhbUluZm8iLCJnZXRDb21wcmVzc2VkV29ya2VyIiwid2l0aFN0cmVhbUluZm8iLCJjcmVhdGVXb3JrZXJGcm9tIiwidW5jb21wcmVzc2VkV29ya2VyIiwiY29tcHJlc3Npb25PcHRpb25zIiwiY29tcHJlc3NXb3JrZXIiLCJHZW5lcmljV29ya2VyIiwiU1RPUkUiLCJtYWdpYyIsIkRFRkxBVEUiLCJtYWtlVGFibGUiLCJ0YWJsZSIsImsiLCJjcmNUYWJsZSIsImNyYyIsInQiLCJjcmMzMnN0ciIsImNyYzMyd3JhcHBlciIsImJpbmFyeSIsImNyZWF0ZUZvbGRlcnMiLCJkYXRlIiwiY29tbWVudCIsInVuaXhQZXJtaXNzaW9ucyIsImRvc1Blcm1pc3Npb25zIiwiRVM2UHJvbWlzZSIsIlVTRV9UWVBFREFSUkFZIiwiVWludDE2QXJyYXkiLCJVaW50MzJBcnJheSIsInBha28iLCJBUlJBWV9UWVBFIiwiRmxhdGVXb3JrZXIiLCJhY3Rpb24iLCJvcHRpb25zIiwiX3Bha28iLCJfcGFrb0FjdGlvbiIsIl9wYWtvT3B0aW9ucyIsIm1ldGEiLCJwcm9jZXNzQ2h1bmsiLCJjaHVuayIsIl9jcmVhdGVQYWtvIiwidHJhbnNmb3JtVG8iLCJmbHVzaCIsImNsZWFuVXAiLCJyYXciLCJsZXZlbCIsInNlbGYiLCJvbkRhdGEiLCJ1dGY4Iiwic2lnbmF0dXJlIiwiZGVjVG9IZXgiLCJkZWMiLCJoZXgiLCJnZW5lcmF0ZVVuaXhFeHRlcm5hbEZpbGVBdHRyIiwiaXNEaXIiLCJyZXN1bHQiLCJnZW5lcmF0ZURvc0V4dGVybmFsRmlsZUF0dHIiLCJnZW5lcmF0ZVppcFBhcnRzIiwic3RyZWFtZWRDb250ZW50Iiwic3RyZWFtaW5nRW5kZWQiLCJwbGF0Zm9ybSIsImVuY29kZUZpbGVOYW1lIiwiZmlsZSIsInVzZUN1c3RvbUVuY29kaW5nIiwidXRmOGVuY29kZSIsImVuY29kZWRGaWxlTmFtZSIsIm5hbWUiLCJ1dGZFbmNvZGVkRmlsZU5hbWUiLCJlbmNvZGVkQ29tbWVudCIsInV0ZkVuY29kZWRDb21tZW50IiwidXNlVVRGOEZvckZpbGVOYW1lIiwidXNlVVRGOEZvckNvbW1lbnQiLCJkb3NUaW1lIiwiZG9zRGF0ZSIsImV4dHJhRmllbGRzIiwidW5pY29kZVBhdGhFeHRyYUZpZWxkIiwidW5pY29kZUNvbW1lbnRFeHRyYUZpZWxkIiwiZGF0YUluZm8iLCJiaXRmbGFnIiwiZXh0RmlsZUF0dHIiLCJ2ZXJzaW9uTWFkZUJ5IiwiZ2V0VVRDSG91cnMiLCJnZXRVVENNaW51dGVzIiwiZ2V0VVRDU2Vjb25kcyIsImdldFVUQ0Z1bGxZZWFyIiwiZ2V0VVRDTW9udGgiLCJnZXRVVENEYXRlIiwiaGVhZGVyIiwiZmlsZVJlY29yZCIsIkxPQ0FMX0ZJTEVfSEVBREVSIiwiZGlyUmVjb3JkIiwiQ0VOVFJBTF9GSUxFX0hFQURFUiIsImdlbmVyYXRlQ2VudHJhbERpcmVjdG9yeUVuZCIsImVudHJpZXNDb3VudCIsImNlbnRyYWxEaXJMZW5ndGgiLCJsb2NhbERpckxlbmd0aCIsImRpckVuZCIsIkNFTlRSQUxfRElSRUNUT1JZX0VORCIsImdlbmVyYXRlRGF0YURlc2NyaXB0b3JzIiwiZGVzY3JpcHRvciIsIkRBVEFfREVTQ1JJUFRPUiIsIlppcEZpbGVXb3JrZXIiLCJzdHJlYW1GaWxlcyIsImJ5dGVzV3JpdHRlbiIsInppcENvbW1lbnQiLCJ6aXBQbGF0Zm9ybSIsImFjY3VtdWxhdGUiLCJjb250ZW50QnVmZmVyIiwiZGlyUmVjb3JkcyIsImN1cnJlbnRTb3VyY2VPZmZzZXQiLCJjdXJyZW50RmlsZSIsIl9zb3VyY2VzIiwiY3VycmVudEZpbGVQZXJjZW50IiwicGVyY2VudCIsInJlbWFpbmluZ0ZpbGVzIiwib3BlbmVkU291cmNlIiwicmVjb3JkIiwiY2xvc2VkU291cmNlIiwic2hpZnQiLCJwcmVwYXJlTmV4dFNvdXJjZSIsInByZXZpb3VzIiwiaXNQYXVzZWQiLCJwYXVzZSIsInJlc3VtZSIsInJlZ2lzdGVyUHJldmlvdXMiLCJnZW5lcmF0ZWRFcnJvciIsImxvY2siLCJjb21wcmVzc2lvbnMiLCJnZXRDb21wcmVzc2lvbiIsImZpbGVDb21wcmVzc2lvbiIsInppcENvbXByZXNzaW9uIiwiY29tcHJlc3Npb25OYW1lIiwiZ2VuZXJhdGVXb3JrZXIiLCJ6aXAiLCJ6aXBGaWxlV29ya2VyIiwiZm9yRWFjaCIsInJlbGF0aXZlUGF0aCIsIl9jb21wcmVzc1dvcmtlciIsIkpTWmlwIiwiZmlsZXMiLCJyb290IiwiY2xvbmUiLCJuZXdPYmoiLCJsb2FkQXN5bmMiLCJkZWZhdWx0cyIsInZlcnNpb24iLCJaaXBFbnRyaWVzIiwibm9kZWpzVXRpbHMiLCJjaGVja0VudHJ5Q1JDMzIiLCJ6aXBFbnRyeSIsInJlamVjdCIsImRlY29tcHJlc3NlZCIsImV4dGVuZCIsImNoZWNrQ1JDMzIiLCJvcHRpbWl6ZWRCaW5hcnlTdHJpbmciLCJkZWNvZGVGaWxlTmFtZSIsInV0ZjhkZWNvZGUiLCJpc05vZGUiLCJpc1N0cmVhbSIsInByZXBhcmVDb250ZW50IiwidGhlbiIsInppcEVudHJpZXMiLCJsb2FkIiwicHJvbWlzZXMiLCJhbGwiLCJhZGRGaWxlcyIsInJlc3VsdHMiLCJmaWxlTmFtZVN0ciIsImZpbGVDb21tZW50U3RyIiwiTm9kZWpzU3RyZWFtSW5wdXRBZGFwdGVyIiwiZmlsZW5hbWUiLCJzdHJlYW0iLCJfdXBzdHJlYW1FbmRlZCIsIl9iaW5kU3RyZWFtIiwiX3N0cmVhbSIsIlJlYWRhYmxlIiwiTm9kZWpzU3RyZWFtT3V0cHV0QWRhcHRlciIsImhlbHBlciIsInVwZGF0ZUNiIiwiX2hlbHBlciIsIl9yZWFkIiwibmV3QnVmZmVyRnJvbSIsImFsbG9jQnVmZmVyIiwiU3RyZWFtSGVscGVyIiwiWmlwT2JqZWN0IiwiZ2VuZXJhdGUiLCJmaWxlQWRkIiwib3JpZ2luYWxPcHRpb25zIiwiZGF0YVR5cGUiLCJwYXJlbnQiLCJEYXRlIiwidG9VcHBlckNhc2UiLCJmb3JjZVRyYWlsaW5nU2xhc2giLCJwYXJlbnRGb2xkZXIiLCJmb2xkZXJBZGQiLCJpc1VuaWNvZGVTdHJpbmciLCJpc0NvbXByZXNzZWRFbXB0eSIsInppcE9iamVjdENvbnRlbnQiLCJvYmplY3QiLCJwYXRoIiwic3Vic3RyaW5nIiwibGFzdFNsYXNoIiwiY2IiLCJoYXNPd25Qcm9wZXJ0eSIsImZpbHRlciIsInNlYXJjaCIsImVudHJ5IiwicmVnZXhwIiwidGVzdCIsImZvbGRlciIsIm5ld0ZvbGRlciIsInJlbW92ZSIsImtpZHMiLCJnZW5lcmF0ZUludGVybmFsU3RyZWFtIiwib3B0cyIsIm1pbWVUeXBlIiwiY2hlY2tTdXBwb3J0IiwiZ2VuZXJhdGVBc3luYyIsIm9uVXBkYXRlIiwiZ2VuZXJhdGVOb2RlU3RyZWFtIiwidG9Ob2RlanNTdHJlYW0iLCJEYXRhUmVhZGVyIiwiQXJyYXlSZWFkZXIiLCJieXRlQXQiLCJ6ZXJvIiwibGFzdEluZGV4T2ZTaWduYXR1cmUiLCJzaWciLCJzaWcwIiwic2lnMSIsInNpZzIiLCJzaWczIiwicmVhZEFuZENoZWNrU2lnbmF0dXJlIiwicmVhZERhdGEiLCJpbmRleCIsImNoZWNrSW5kZXgiLCJuZXdJbmRleCIsInNldEluZGV4Iiwic2tpcCIsInJlYWRJbnQiLCJyZWFkU3RyaW5nIiwicmVhZERhdGUiLCJkb3N0aW1lIiwiVVRDIiwiVWludDhBcnJheVJlYWRlciIsIk5vZGVCdWZmZXJSZWFkZXIiLCJTdHJpbmdSZWFkZXIiLCJaSVA2NF9DRU5UUkFMX0RJUkVDVE9SWV9MT0NBVE9SIiwiWklQNjRfQ0VOVFJBTF9ESVJFQ1RPUllfRU5EIiwiQ29udmVydFdvcmtlciIsImRlc3RUeXBlIiwicHJvcE5hbWUiLCJERUZBVUxUX0JMT0NLX1NJWkUiLCJkYXRhUCIsImRhdGFJc1JlYWR5IiwiX3RpY2tTY2hlZHVsZWQiLCJfdGlja0FuZFJlcGVhdCIsImRlbGF5IiwiaXNGaW5pc2hlZCIsIl90aWNrIiwibmV4dEluZGV4IiwiZXh0cmFTdHJlYW1JbmZvIiwiaXNMb2NrZWQiLCJfbGlzdGVuZXJzIiwibmV4dCIsIm1lcmdlU3RyZWFtSW5mbyIsIndpdGhFcnJvciIsIm1lIiwibm9kZXN0cmVhbSIsInRyYW5zZm9ybVppcE91dHB1dCIsIm5ld0Jsb2IiLCJkYXRhQXJyYXkiLCJ1cGRhdGVDYWxsYmFjayIsImNodW5rVHlwZSIsIl9pbnRlcm5hbFR5cGUiLCJyZXN1bHRUeXBlIiwiX291dHB1dFR5cGUiLCJfbWltZVR5cGUiLCJvdXRwdXRUeXBlIiwiaW50ZXJuYWxUeXBlIiwiX3dvcmtlciIsImV2dCIsImZuIiwib2JqZWN0TW9kZSIsImFycmF5YnVmZmVyIiwibm9kZWJ1ZmZlciIsImJsb2IiLCJCbG9iIiwiQnVpbGRlciIsIkJsb2JCdWlsZGVyIiwiV2ViS2l0QmxvYkJ1aWxkZXIiLCJNb3pCbG9iQnVpbGRlciIsIk1TQmxvYkJ1aWxkZXIiLCJidWlsZGVyIiwiYXBwZW5kIiwiZ2V0QmxvYiIsIl91dGY4bGVuIiwic3RyaW5nMmJ1ZiIsImMyIiwibV9wb3MiLCJzdHJfbGVuIiwiYnVmX2xlbiIsInV0Zjhib3JkZXIiLCJidWYyc3RyaW5nIiwiY19sZW4iLCJ1dGYxNmJ1ZiIsImFwcGx5RnJvbUNoYXJDb2RlIiwiVXRmOERlY29kZVdvcmtlciIsImxlZnRPdmVyIiwicHJldmlvdXNEYXRhIiwibmV4dEJvdW5kYXJ5IiwidXNhYmxlRGF0YSIsIlV0ZjhFbmNvZGVXb3JrZXIiLCJzdHJpbmcyYmluYXJ5Iiwic3RyaW5nVG9BcnJheUxpa2UiLCJwYXJ0IiwiaWRlbnRpdHkiLCJhcnJheVRvU3RyaW5nSGVscGVyIiwic3RyaW5naWZ5QnlDaHVuayIsInN0cmluZ2lmeUJ5Q2hhciIsInJlc3VsdFN0ciIsImFwcGx5Q2FuQmVVc2VkIiwiYXJyYXlMaWtlVG9TdHJpbmciLCJjYW5Vc2VBcHBseSIsImFycmF5TGlrZVRvQXJyYXlMaWtlIiwiYXJyYXlGcm9tIiwiYXJyYXlUbyIsInRyYW5zZm9ybSIsImlucHV0VHlwZSIsInN1cHBvcnRlZCIsIk1BWF9WQUxVRV8xNkJJVFMiLCJNQVhfVkFMVUVfMzJCSVRTIiwicHJldHR5IiwiY2FsbGJhY2siLCJPYmoiLCJhdHRyIiwiaW5wdXREYXRhIiwiaXNCaW5hcnkiLCJpc09wdGltaXplZEJpbmFyeVN0cmluZyIsImlzQmFzZTY0IiwicHJvbWlzZSIsImlzQmxvYiIsIkZpbGVSZWFkZXIiLCJyZWFkZXIiLCJvbmxvYWQiLCJvbmVycm9yIiwicmVhZEFzQXJyYXlCdWZmZXIiLCJyZWFkZXJGb3IiLCJaaXBFbnRyeSIsImxvYWRPcHRpb25zIiwiY2hlY2tTaWduYXR1cmUiLCJleHBlY3RlZFNpZ25hdHVyZSIsImlzU2lnbmF0dXJlIiwiYXNrZWRJbmRleCIsImN1cnJlbnRJbmRleCIsInJlYWRCbG9ja0VuZE9mQ2VudHJhbCIsImRpc2tOdW1iZXIiLCJkaXNrV2l0aENlbnRyYWxEaXJTdGFydCIsImNlbnRyYWxEaXJSZWNvcmRzT25UaGlzRGlzayIsImNlbnRyYWxEaXJSZWNvcmRzIiwiY2VudHJhbERpclNpemUiLCJjZW50cmFsRGlyT2Zmc2V0IiwiemlwQ29tbWVudExlbmd0aCIsImRlY29kZVBhcmFtVHlwZSIsImRlY29kZUNvbnRlbnQiLCJyZWFkQmxvY2taaXA2NEVuZE9mQ2VudHJhbCIsInppcDY0RW5kT2ZDZW50cmFsU2l6ZSIsInppcDY0RXh0ZW5zaWJsZURhdGEiLCJleHRyYURhdGFTaXplIiwiZXh0cmFGaWVsZElkIiwiZXh0cmFGaWVsZExlbmd0aCIsImV4dHJhRmllbGRWYWx1ZSIsInJlYWRCbG9ja1ppcDY0RW5kT2ZDZW50cmFsTG9jYXRvciIsImRpc2tXaXRoWmlwNjRDZW50cmFsRGlyU3RhcnQiLCJyZWxhdGl2ZU9mZnNldEVuZE9mWmlwNjRDZW50cmFsRGlyIiwiZGlza3NDb3VudCIsInJlYWRMb2NhbEZpbGVzIiwibG9jYWxIZWFkZXJPZmZzZXQiLCJyZWFkTG9jYWxQYXJ0IiwiaGFuZGxlVVRGOCIsInByb2Nlc3NBdHRyaWJ1dGVzIiwicmVhZENlbnRyYWxEaXIiLCJ6aXA2NCIsInJlYWRDZW50cmFsUGFydCIsInJlYWRFbmRPZkNlbnRyYWwiLCJpc0dhcmJhZ2UiLCJlbmRPZkNlbnRyYWxEaXJPZmZzZXQiLCJleHBlY3RlZEVuZE9mQ2VudHJhbERpck9mZnNldCIsInByZXBhcmVSZWFkZXIiLCJjcmMzMmZuIiwiTUFERV9CWV9ET1MiLCJNQURFX0JZX1VOSVgiLCJmaW5kQ29tcHJlc3Npb24iLCJjb21wcmVzc2lvbk1ldGhvZCIsIm1ldGhvZCIsImlzRW5jcnlwdGVkIiwiYml0RmxhZyIsInVzZVVURjgiLCJsb2NhbEV4dHJhRmllbGRzTGVuZ3RoIiwiZmlsZU5hbWVMZW5ndGgiLCJmaWxlTmFtZSIsImV4dHJhRmllbGRzTGVuZ3RoIiwiZmlsZUNvbW1lbnRMZW5ndGgiLCJkaXNrTnVtYmVyU3RhcnQiLCJpbnRlcm5hbEZpbGVBdHRyaWJ1dGVzIiwiZXh0ZXJuYWxGaWxlQXR0cmlidXRlcyIsInJlYWRFeHRyYUZpZWxkcyIsInBhcnNlWklQNjRFeHRyYUZpZWxkIiwiZmlsZUNvbW1lbnQiLCJtYWRlQnkiLCJleHRyYVJlYWRlciIsInVwYXRoIiwiZmluZEV4dHJhRmllbGRVbmljb2RlUGF0aCIsImZpbGVOYW1lQnl0ZUFycmF5IiwidWNvbW1lbnQiLCJmaW5kRXh0cmFGaWVsZFVuaWNvZGVDb21tZW50IiwiY29tbWVudEJ5dGVBcnJheSIsInVwYXRoRmllbGQiLCJ1Y29tbWVudEZpZWxkIiwiX2RhdGEiLCJfZGF0YUJpbmFyeSIsImludGVybmFsU3RyZWFtIiwiYXNrVW5pY29kZVN0cmluZyIsIl9kZWNvbXByZXNzV29ya2VyIiwiYXN5bmMiLCJub2RlU3RyZWFtIiwicmVtb3ZlZE1ldGhvZHMiLCJyZW1vdmVkRm4iLCJpdCIsImNvcmUiLCJfX2UiLCJhRnVuY3Rpb24iLCJnZXQiLCJpcyIsImN0eCIsImhpZGUiLCJQUk9UT1RZUEUiLCIkZXhwb3J0IiwiSVNfRk9SQ0VEIiwiRiIsIklTX0dMT0JBTCIsIkciLCJJU19TVEFUSUMiLCJTIiwiSVNfUFJPVE8iLCJQIiwiSVNfQklORCIsIkIiLCJJU19XUkFQIiwiVyIsImV4cFByb3RvIiwib3duIiwiQyIsIkZ1bmN0aW9uIiwidmlydHVhbCIsIlIiLCJVIiwiZXhlYyIsIndpbmRvdyIsIl9fZyIsImRQIiwiY3JlYXRlRGVzYyIsImYiLCJ1biIsImFuT2JqZWN0IiwiSUU4X0RPTV9ERUZJTkUiLCJ0b1ByaW1pdGl2ZSIsIk8iLCJBdHRyaWJ1dGVzIiwiYml0bWFwIiwiaW52b2tlIiwiaHRtbCIsImNlbCIsInByb2Nlc3MiLCJzZXRUYXNrIiwiY2xlYXJUYXNrIiwiY2xlYXJJbW1lZGlhdGUiLCJjb3VudGVyIiwiT05SRUFEWVNUQVRFQ0hBTkdFIiwiZGVmZXIiLCJwb3J0IiwicnVuIiwiZXZlbnQiLCJhZGRFdmVudExpc3RlbmVyIiwiaW1wb3J0U2NyaXB0cyIsImNsZWFyIiwidmFsdWVPZiIsIiR0YXNrIiwiSU5URVJOQUwiLCJoYW5kbGVycyIsIlJFSkVDVEVEIiwiRlVMRklMTEVEIiwiUEVORElORyIsInJlc29sdmVyIiwic3RhdGUiLCJvdXRjb21lIiwic2FmZWx5UmVzb2x2ZVRoZW5hYmxlIiwib25SZWplY3RlZCIsIm9uRnVsZmlsbGVkIiwidW53cmFwIiwiUXVldWVJdGVtIiwiY2FsbEZ1bGZpbGxlZCIsIm90aGVyQ2FsbEZ1bGZpbGxlZCIsImNhbGxSZWplY3RlZCIsIm90aGVyQ2FsbFJlamVjdGVkIiwiZnVuYyIsInJldHVyblZhbHVlIiwidHJ5Q2F0Y2giLCJnZXRUaGVuIiwic3RhdHVzIiwidGhlbmFibGUiLCJhcHB5VGhlbiIsIm9uRXJyb3IiLCJvblN1Y2Nlc3MiLCJ0cnlUb1Vud3JhcCIsInJlYXNvbiIsIml0ZXJhYmxlIiwidmFsdWVzIiwicmVzb2x2ZWQiLCJhbGxSZXNvbHZlciIsInJlc29sdmVGcm9tQWxsIiwib3V0VmFsdWUiLCJyYWNlIiwicmVzcG9uc2UiLCJfbm9ybWFsaXplRW5jb2RpbmciLCJlbmMiLCJyZXRyaWVkIiwibm9ybWFsaXplRW5jb2RpbmciLCJuZW5jIiwiU3RyaW5nRGVjb2RlciIsIm5iIiwidGV4dCIsInV0ZjE2VGV4dCIsInV0ZjE2RW5kIiwiZmlsbExhc3QiLCJ1dGY4RmlsbExhc3QiLCJiYXNlNjRUZXh0IiwiYmFzZTY0RW5kIiwic2ltcGxlV3JpdGUiLCJzaW1wbGVFbmQiLCJsYXN0TmVlZCIsImxhc3RUb3RhbCIsImxhc3RDaGFyIiwiciIsInV0ZjhFbmQiLCJ1dGY4VGV4dCIsInV0ZjhDaGVja0J5dGUiLCJieXRlIiwidXRmOENoZWNrSW5jb21wbGV0ZSIsInV0ZjhDaGVja0V4dHJhQnl0ZXMiLCJwIiwidG90YWwiLCJhc3NpZ24iLCJkZWZsYXRlIiwiaW5mbGF0ZSIsImNvbnN0YW50cyIsInpsaWJfZGVmbGF0ZSIsInN0cmluZ3MiLCJtc2ciLCJaU3RyZWFtIiwiWl9OT19GTFVTSCIsIlpfRklOSVNIIiwiWl9PSyIsIlpfU1RSRUFNX0VORCIsIlpfU1lOQ19GTFVTSCIsIlpfREVGQVVMVF9DT01QUkVTU0lPTiIsIlpfREVGQVVMVF9TVFJBVEVHWSIsIlpfREVGTEFURUQiLCJEZWZsYXRlIiwiY2h1bmtTaXplIiwid2luZG93Qml0cyIsIm1lbUxldmVsIiwic3RyYXRlZ3kiLCJ0byIsIm9wdCIsImd6aXAiLCJlbmRlZCIsImNodW5rcyIsInN0cm0iLCJhdmFpbF9vdXQiLCJkZWZsYXRlSW5pdDIiLCJkZWZsYXRlU2V0SGVhZGVyIiwiZGljdGlvbmFyeSIsImRpY3QiLCJkZWZsYXRlU2V0RGljdGlvbmFyeSIsIl9kaWN0X3NldCIsIm1vZGUiLCJfbW9kZSIsIm5leHRfaW4iLCJhdmFpbF9pbiIsIkJ1ZjgiLCJuZXh0X291dCIsIm9uRW5kIiwiYnVmMmJpbnN0cmluZyIsInNocmlua0J1ZiIsImRlZmxhdGVFbmQiLCJmbGF0dGVuQ2h1bmtzIiwiZGVmbGF0b3IiLCJkZWZsYXRlUmF3IiwiemxpYl9pbmZsYXRlIiwiR1poZWFkZXIiLCJJbmZsYXRlIiwiaW5mbGF0ZUluaXQyIiwiaW5mbGF0ZUdldEhlYWRlciIsIm5leHRfb3V0X3V0ZjgiLCJ0YWlsIiwidXRmOHN0ciIsImFsbG93QnVmRXJyb3IiLCJiaW5zdHJpbmcyYnVmIiwiWl9ORUVEX0RJQ1QiLCJpbmZsYXRlU2V0RGljdGlvbmFyeSIsIlpfQlVGX0VSUk9SIiwiYXJyYXlTZXQiLCJpbmZsYXRlRW5kIiwiaW5mbGF0b3IiLCJpbmZsYXRlUmF3IiwidW5nemlwIiwiVFlQRURfT0siLCJJbnQzMkFycmF5IiwiX2hhcyIsImZuVHlwZWQiLCJkZXN0Iiwic3JjX29mZnMiLCJkZXN0X29mZnMiLCJsIiwiZm5VbnR5cGVkIiwic2V0VHlwZWQiLCJCdWYxNiIsIkJ1ZjMyIiwiU1RSX0FQUExZX09LIiwiU1RSX0FQUExZX1VJQV9PSyIsIl9fIiwicSIsImFkbGVyMzIiLCJhZGxlciIsInMxIiwiczIiLCJaX1BBUlRJQUxfRkxVU0giLCJaX0ZVTExfRkxVU0giLCJaX0JMT0NLIiwiWl9UUkVFUyIsIlpfRVJSTk8iLCJaX1NUUkVBTV9FUlJPUiIsIlpfREFUQV9FUlJPUiIsIlpfTk9fQ09NUFJFU1NJT04iLCJaX0JFU1RfU1BFRUQiLCJaX0JFU1RfQ09NUFJFU1NJT04iLCJaX0ZJTFRFUkVEIiwiWl9IVUZGTUFOX09OTFkiLCJaX1JMRSIsIlpfRklYRUQiLCJaX0JJTkFSWSIsIlpfVEVYVCIsIlpfVU5LTk9XTiIsInRyZWVzIiwiTUFYX01FTV9MRVZFTCIsIk1BWF9XQklUUyIsIkRFRl9NRU1fTEVWRUwiLCJMRU5HVEhfQ09ERVMiLCJMSVRFUkFMUyIsIkxfQ09ERVMiLCJEX0NPREVTIiwiQkxfQ09ERVMiLCJIRUFQX1NJWkUiLCJNQVhfQklUUyIsIk1JTl9NQVRDSCIsIk1BWF9NQVRDSCIsIk1JTl9MT09LQUhFQUQiLCJQUkVTRVRfRElDVCIsIklOSVRfU1RBVEUiLCJFWFRSQV9TVEFURSIsIk5BTUVfU1RBVEUiLCJDT01NRU5UX1NUQVRFIiwiSENSQ19TVEFURSIsIkJVU1lfU1RBVEUiLCJGSU5JU0hfU1RBVEUiLCJCU19ORUVEX01PUkUiLCJCU19CTE9DS19ET05FIiwiQlNfRklOSVNIX1NUQVJURUQiLCJCU19GSU5JU0hfRE9ORSIsIk9TX0NPREUiLCJlcnJvckNvZGUiLCJyYW5rIiwiZmx1c2hfcGVuZGluZyIsInBlbmRpbmciLCJwZW5kaW5nX2J1ZiIsInBlbmRpbmdfb3V0IiwidG90YWxfb3V0IiwiZmx1c2hfYmxvY2tfb25seSIsImxhc3QiLCJfdHJfZmx1c2hfYmxvY2siLCJibG9ja19zdGFydCIsInN0cnN0YXJ0IiwicHV0X2J5dGUiLCJwdXRTaG9ydE1TQiIsInJlYWRfYnVmIiwid3JhcCIsInRvdGFsX2luIiwibG9uZ2VzdF9tYXRjaCIsImN1cl9tYXRjaCIsImNoYWluX2xlbmd0aCIsIm1heF9jaGFpbl9sZW5ndGgiLCJzY2FuIiwiYmVzdF9sZW4iLCJwcmV2X2xlbmd0aCIsIm5pY2VfbWF0Y2giLCJ3X3NpemUiLCJfd2luIiwid21hc2siLCJ3X21hc2siLCJwcmV2Iiwic3RyZW5kIiwic2Nhbl9lbmQxIiwic2Nhbl9lbmQiLCJnb29kX21hdGNoIiwibG9va2FoZWFkIiwibWF0Y2hfc3RhcnQiLCJmaWxsX3dpbmRvdyIsIl93X3NpemUiLCJtb3JlIiwid2luZG93X3NpemUiLCJoYXNoX3NpemUiLCJoZWFkIiwiaW5zZXJ0IiwiaW5zX2giLCJoYXNoX3NoaWZ0IiwiaGFzaF9tYXNrIiwiZGVmbGF0ZV9zdG9yZWQiLCJtYXhfYmxvY2tfc2l6ZSIsInBlbmRpbmdfYnVmX3NpemUiLCJtYXhfc3RhcnQiLCJkZWZsYXRlX2Zhc3QiLCJoYXNoX2hlYWQiLCJiZmx1c2giLCJtYXRjaF9sZW5ndGgiLCJfdHJfdGFsbHkiLCJtYXhfbGF6eV9tYXRjaCIsImxhc3RfbGl0IiwiZGVmbGF0ZV9zbG93IiwibWF4X2luc2VydCIsInByZXZfbWF0Y2giLCJtYXRjaF9hdmFpbGFibGUiLCJkZWZsYXRlX3JsZSIsImRlZmxhdGVfaHVmZiIsIkNvbmZpZyIsImdvb2RfbGVuZ3RoIiwibWF4X2xhenkiLCJuaWNlX2xlbmd0aCIsIm1heF9jaGFpbiIsImNvbmZpZ3VyYXRpb25fdGFibGUiLCJsbV9pbml0IiwiRGVmbGF0ZVN0YXRlIiwiZ3poZWFkIiwiZ3ppbmRleCIsImxhc3RfZmx1c2giLCJ3X2JpdHMiLCJoYXNoX2JpdHMiLCJkeW5fbHRyZWUiLCJkeW5fZHRyZWUiLCJibF90cmVlIiwibF9kZXNjIiwiZF9kZXNjIiwiYmxfZGVzYyIsImJsX2NvdW50IiwiaGVhcCIsImhlYXBfbGVuIiwiaGVhcF9tYXgiLCJkZXB0aCIsImxfYnVmIiwibGl0X2J1ZnNpemUiLCJkX2J1ZiIsIm9wdF9sZW4iLCJzdGF0aWNfbGVuIiwibWF0Y2hlcyIsImJpX2J1ZiIsImJpX3ZhbGlkIiwiZGVmbGF0ZVJlc2V0S2VlcCIsImRhdGFfdHlwZSIsIl90cl9pbml0IiwiZGVmbGF0ZVJlc2V0IiwiZGVmbGF0ZUluaXQiLCJvbGRfZmx1c2giLCJiZWciLCJoY3JjIiwiZXh0cmEiLCJ0aW1lIiwib3MiLCJsZXZlbF9mbGFncyIsImJzdGF0ZSIsIl90cl9hbGlnbiIsIl90cl9zdG9yZWRfYmxvY2siLCJkaWN0TGVuZ3RoIiwiYXZhaWwiLCJ0bXBEaWN0IiwiZGVmbGF0ZUluZm8iLCJ4ZmxhZ3MiLCJleHRyYV9sZW4iLCJkb25lIiwiQkFEIiwiVFlQRSIsImluZmxhdGVfZmFzdCIsIl9pbiIsIl9vdXQiLCJkbWF4Iiwid3NpemUiLCJ3aGF2ZSIsInduZXh0Iiwic193aW5kb3ciLCJob2xkIiwiYml0cyIsImxjb2RlIiwiZGNvZGUiLCJsbWFzayIsImRtYXNrIiwiaGVyZSIsIm9wIiwiZGlzdCIsImZyb21fc291cmNlIiwibGVuY29kZSIsImRpc3Rjb2RlIiwibGVuYml0cyIsImRpc3RiaXRzIiwidG9wIiwiZG9sZW4iLCJkb2Rpc3QiLCJzYW5lIiwiaW5mbGF0ZV90YWJsZSIsIkNPREVTIiwiTEVOUyIsIkRJU1RTIiwiWl9NRU1fRVJST1IiLCJIRUFEIiwiRkxBR1MiLCJUSU1FIiwiT1MiLCJFWExFTiIsIkVYVFJBIiwiTkFNRSIsIkNPTU1FTlQiLCJIQ1JDIiwiRElDVElEIiwiRElDVCIsIlRZUEVETyIsIlNUT1JFRCIsIkNPUFlfIiwiQ09QWSIsIlRBQkxFIiwiTEVOTEVOUyIsIkNPREVMRU5TIiwiTEVOXyIsIkxFTiIsIkxFTkVYVCIsIkRJU1QiLCJESVNURVhUIiwiTUFUQ0giLCJMSVQiLCJDSEVDSyIsIkxFTkdUSCIsIkRPTkUiLCJNRU0iLCJTWU5DIiwiRU5PVUdIX0xFTlMiLCJFTk9VR0hfRElTVFMiLCJERUZfV0JJVFMiLCJ6c3dhcDMyIiwiSW5mbGF0ZVN0YXRlIiwiaGF2ZWRpY3QiLCJmbGFncyIsImNoZWNrIiwid2JpdHMiLCJuY29kZSIsIm5sZW4iLCJuZGlzdCIsImhhdmUiLCJ3b3JrIiwibGVuZHluIiwiZGlzdGR5biIsImJhY2siLCJ3YXMiLCJpbmZsYXRlUmVzZXRLZWVwIiwiaW5mbGF0ZVJlc2V0IiwiaW5mbGF0ZVJlc2V0MiIsImluZmxhdGVJbml0IiwidmlyZ2luIiwibGVuZml4IiwiZGlzdGZpeCIsImZpeGVkdGFibGVzIiwic3ltIiwidXBkYXRld2luZG93IiwicHV0IiwibGVmdCIsImhlcmVfYml0cyIsImhlcmVfb3AiLCJoZXJlX3ZhbCIsImxhc3RfYml0cyIsImxhc3Rfb3AiLCJsYXN0X3ZhbCIsImhidWYiLCJvcmRlciIsImluZl9sZWF2ZSIsImRpY3RpZCIsImluZmxhdGVJbmZvIiwiTUFYQklUUyIsImxiYXNlIiwibGV4dCIsImRiYXNlIiwiZGV4dCIsImxlbnNfaW5kZXgiLCJjb2RlcyIsInRhYmxlX2luZGV4IiwiY3VyciIsImRyb3AiLCJ1c2VkIiwiaHVmZiIsImluY3IiLCJsb3ciLCJtYXNrIiwiYmFzZSIsImJhc2VfaW5kZXgiLCJjb3VudCIsIm9mZnMiLCJleHRyYV9pbmRleCIsIlNUT1JFRF9CTE9DSyIsIlNUQVRJQ19UUkVFUyIsIkRZTl9UUkVFUyIsIkJ1Zl9zaXplIiwiTUFYX0JMX0JJVFMiLCJFTkRfQkxPQ0siLCJSRVBfM182IiwiUkVQWl8zXzEwIiwiUkVQWl8xMV8xMzgiLCJleHRyYV9sYml0cyIsImV4dHJhX2RiaXRzIiwiZXh0cmFfYmxiaXRzIiwiYmxfb3JkZXIiLCJESVNUX0NPREVfTEVOIiwic3RhdGljX2x0cmVlIiwic3RhdGljX2R0cmVlIiwiX2Rpc3RfY29kZSIsIl9sZW5ndGhfY29kZSIsImJhc2VfbGVuZ3RoIiwiYmFzZV9kaXN0IiwiU3RhdGljVHJlZURlc2MiLCJzdGF0aWNfdHJlZSIsImV4dHJhX2JpdHMiLCJleHRyYV9iYXNlIiwiZWxlbXMiLCJtYXhfbGVuZ3RoIiwiaGFzX3N0cmVlIiwic3RhdGljX2xfZGVzYyIsInN0YXRpY19kX2Rlc2MiLCJzdGF0aWNfYmxfZGVzYyIsIlRyZWVEZXNjIiwiZHluX3RyZWUiLCJzdGF0X2Rlc2MiLCJtYXhfY29kZSIsImRfY29kZSIsInB1dF9zaG9ydCIsInciLCJzZW5kX2JpdHMiLCJzZW5kX2NvZGUiLCJ0cmVlIiwiYmlfcmV2ZXJzZSIsImJpX2ZsdXNoIiwiZ2VuX2JpdGxlbiIsImRlc2MiLCJzdHJlZSIsImgiLCJ4Yml0cyIsIm92ZXJmbG93IiwiZ2VuX2NvZGVzIiwibmV4dF9jb2RlIiwidHJfc3RhdGljX2luaXQiLCJpbml0X2Jsb2NrIiwiYmlfd2luZHVwIiwiY29weV9ibG9jayIsInNtYWxsZXIiLCJfbjIiLCJfbTIiLCJwcWRvd25oZWFwIiwidiIsImNvbXByZXNzX2Jsb2NrIiwibHRyZWUiLCJkdHJlZSIsImxjIiwibHgiLCJidWlsZF90cmVlIiwibm9kZSIsInNjYW5fdHJlZSIsInByZXZsZW4iLCJjdXJsZW4iLCJuZXh0bGVuIiwibWF4X2NvdW50IiwibWluX2NvdW50Iiwic2VuZF90cmVlIiwiYnVpbGRfYmxfdHJlZSIsIm1heF9ibGluZGV4Iiwic2VuZF9hbGxfdHJlZXMiLCJsY29kZXMiLCJkY29kZXMiLCJibGNvZGVzIiwiZGV0ZWN0X2RhdGFfdHlwZSIsImJsYWNrX21hc2siLCJzdGF0aWNfaW5pdF9kb25lIiwic3RvcmVkX2xlbiIsIm9wdF9sZW5iIiwic3RhdGljX2xlbmIiLCJhcmcxIiwiYXJnMiIsImFyZzMiLCJhZnRlclRpY2tPbmUiLCJhZnRlclRpY2tUd28iLCJhZnRlclRpY2tUaHJlZSIsImFmdGVyVGljayIsImNhY2hlZFNldFRpbWVvdXQiLCJjYWNoZWRDbGVhclRpbWVvdXQiLCJkZWZhdWx0U2V0VGltb3V0IiwiZGVmYXVsdENsZWFyVGltZW91dCIsImNsZWFyVGltZW91dCIsInJ1blRpbWVvdXQiLCJmdW4iLCJydW5DbGVhclRpbWVvdXQiLCJtYXJrZXIiLCJjdXJyZW50UXVldWUiLCJxdWV1ZUluZGV4IiwiY2xlYW5VcE5leHRUaWNrIiwiZHJhaW5RdWV1ZSIsInRpbWVvdXQiLCJJdGVtIiwidGl0bGUiLCJicm93c2VyIiwiZW52IiwiYXJndiIsInZlcnNpb25zIiwibm9vcCIsIm9mZiIsInByZXBlbmRMaXN0ZW5lciIsInByZXBlbmRPbmNlTGlzdGVuZXIiLCJiaW5kaW5nIiwiY3dkIiwiY2hkaXIiLCJ1bWFzayIsInBuYSIsIm9iamVjdEtleXMiLCJrZXlzIiwiRHVwbGV4IiwidXRpbCIsIldyaXRhYmxlIiwicmVhZGFibGUiLCJhbGxvd0hhbGZPcGVuIiwib25lbmQiLCJfd3JpdGFibGVTdGF0ZSIsImhpZ2hXYXRlck1hcmsiLCJvbkVuZE5UIiwiX3JlYWRhYmxlU3RhdGUiLCJkZXN0cm95ZWQiLCJfZGVzdHJveSIsIlBhc3NUaHJvdWdoIiwiVHJhbnNmb3JtIiwiX3RyYW5zZm9ybSIsIlJlYWRhYmxlU3RhdGUiLCJFRSIsIkVFbGlzdGVuZXJDb3VudCIsIlN0cmVhbSIsIk91clVpbnQ4QXJyYXkiLCJfdWludDhBcnJheVRvQnVmZmVyIiwiX2lzVWludDhBcnJheSIsImRlYnVnVXRpbCIsImRlYnVnIiwiZGVidWdsb2ciLCJCdWZmZXJMaXN0IiwiZGVzdHJveUltcGwiLCJrUHJveHlFdmVudHMiLCJ1bnNoaWZ0IiwiaXNEdXBsZXgiLCJyZWFkYWJsZU9iamVjdE1vZGUiLCJod20iLCJyZWFkYWJsZUh3bSIsInJlYWRhYmxlSGlnaFdhdGVyTWFyayIsImRlZmF1bHRId20iLCJwaXBlcyIsInBpcGVzQ291bnQiLCJmbG93aW5nIiwiZW5kRW1pdHRlZCIsInJlYWRpbmciLCJzeW5jIiwibmVlZFJlYWRhYmxlIiwiZW1pdHRlZFJlYWRhYmxlIiwicmVhZGFibGVMaXN0ZW5pbmciLCJyZXN1bWVTY2hlZHVsZWQiLCJkZWZhdWx0RW5jb2RpbmciLCJhd2FpdERyYWluIiwicmVhZGluZ01vcmUiLCJkZWNvZGVyIiwiZGVzdHJveSIsIl91bmRlc3Ryb3kiLCJ1bmRlc3Ryb3kiLCJza2lwQ2h1bmtDaGVjayIsInJlYWRhYmxlQWRkQ2h1bmsiLCJhZGRUb0Zyb250Iiwib25Fb2ZDaHVuayIsImNodW5rSW52YWxpZCIsImdldFByb3RvdHlwZU9mIiwiYWRkQ2h1bmsiLCJtYXliZVJlYWRNb3JlIiwibmVlZE1vcmVEYXRhIiwiZW1pdFJlYWRhYmxlIiwic2V0RW5jb2RpbmciLCJNQVhfSFdNIiwiY29tcHV0ZU5ld0hpZ2hXYXRlck1hcmsiLCJob3dNdWNoVG9SZWFkIiwibk9yaWciLCJlbmRSZWFkYWJsZSIsImRvUmVhZCIsImZyb21MaXN0IiwiZW1pdFJlYWRhYmxlXyIsImZsb3ciLCJtYXliZVJlYWRNb3JlXyIsInBpcGVPcHRzIiwiZG9FbmQiLCJzdGRvdXQiLCJzdGRlcnIiLCJlbmRGbiIsInVucGlwZSIsIm9udW5waXBlIiwidW5waXBlSW5mbyIsImhhc1VucGlwZWQiLCJjbGVhbnVwIiwib25kcmFpbiIsInBpcGVPbkRyYWluIiwiY2xlYW5lZFVwIiwib25jbG9zZSIsIm9uZmluaXNoIiwib25kYXRhIiwibmVlZERyYWluIiwiaW5jcmVhc2VkQXdhaXREcmFpbiIsImRlc3RzIiwiZXYiLCJuUmVhZGluZ05leHRUaWNrIiwicmVzdW1lXyIsIl90aGlzIiwicGF1c2VkIiwiYmluZCIsIl9mcm9tTGlzdCIsImZyb21MaXN0UGFydGlhbCIsImhhc1N0cmluZ3MiLCJjb3B5RnJvbUJ1ZmZlclN0cmluZyIsImNvcHlGcm9tQnVmZmVyIiwiZW5kUmVhZGFibGVOVCIsInhzIiwiYWZ0ZXJUcmFuc2Zvcm0iLCJ0cyIsIl90cmFuc2Zvcm1TdGF0ZSIsInRyYW5zZm9ybWluZyIsIndyaXRlY2IiLCJ3cml0ZWNodW5rIiwicnMiLCJuZWVkVHJhbnNmb3JtIiwid3JpdGVlbmNvZGluZyIsIl9mbHVzaCIsInByZWZpbmlzaCIsIl93cml0ZSIsIl90aGlzMiIsImVycjIiLCJXcml0ZVJlcSIsIkNvcmtlZFJlcXVlc3QiLCJmaW5pc2giLCJvbkNvcmtlZEZpbmlzaCIsImFzeW5jV3JpdGUiLCJXcml0YWJsZVN0YXRlIiwiaW50ZXJuYWxVdGlsIiwiZGVwcmVjYXRlIiwibm9wIiwid3JpdGFibGVPYmplY3RNb2RlIiwid3JpdGFibGVId20iLCJ3cml0YWJsZUhpZ2hXYXRlck1hcmsiLCJmaW5hbENhbGxlZCIsImVuZGluZyIsImZpbmlzaGVkIiwibm9EZWNvZGUiLCJkZWNvZGVTdHJpbmdzIiwid3JpdGluZyIsImNvcmtlZCIsImJ1ZmZlclByb2Nlc3NpbmciLCJvbndyaXRlIiwid3JpdGVsZW4iLCJidWZmZXJlZFJlcXVlc3QiLCJsYXN0QnVmZmVyZWRSZXF1ZXN0IiwicGVuZGluZ2NiIiwicHJlZmluaXNoZWQiLCJlcnJvckVtaXR0ZWQiLCJidWZmZXJlZFJlcXVlc3RDb3VudCIsImNvcmtlZFJlcXVlc3RzRnJlZSIsImdldEJ1ZmZlciIsImN1cnJlbnQiLCJfIiwicmVhbEhhc0luc3RhbmNlIiwiaGFzSW5zdGFuY2UiLCJ3cml0ZXYiLCJfd3JpdGV2IiwiZmluYWwiLCJfZmluYWwiLCJ3cml0ZUFmdGVyRW5kIiwidmFsaWRDaHVuayIsInZhbGlkIiwiaXNCdWYiLCJ3cml0ZU9yQnVmZmVyIiwiY29yayIsInVuY29yayIsImNsZWFyQnVmZmVyIiwic2V0RGVmYXVsdEVuY29kaW5nIiwiZGVjb2RlQ2h1bmsiLCJuZXdDaHVuayIsImRvV3JpdGUiLCJvbndyaXRlRXJyb3IiLCJmaW5pc2hNYXliZSIsIm9ud3JpdGVTdGF0ZVVwZGF0ZSIsIm5lZWRGaW5pc2giLCJhZnRlcldyaXRlIiwib253cml0ZURyYWluIiwiaG9sZGVyIiwiYWxsQnVmZmVycyIsImVuZFdyaXRhYmxlIiwiY2FsbEZpbmFsIiwibmVlZCIsImNvcmtSZXEiLCJfY2xhc3NDYWxsQ2hlY2siLCJpbnN0YW5jZSIsIkNvbnN0cnVjdG9yIiwiY29weUJ1ZmZlciIsImN1c3RvbSIsInJlYWRhYmxlRGVzdHJveWVkIiwid3JpdGFibGVEZXN0cm95ZWQiLCJlbWl0RXJyb3JOVCIsImNvcHlQcm9wcyIsIlNhZmVCdWZmZXIiLCJuZXh0SGFuZGxlIiwidGFza3NCeUhhbmRsZSIsImN1cnJlbnRseVJ1bm5pbmdBVGFzayIsImRvYyIsInJlZ2lzdGVySW1tZWRpYXRlIiwiaGFuZGxlIiwicnVuSWZQcmVzZW50IiwiaW5zdGFsbE5leHRUaWNrSW1wbGVtZW50YXRpb24iLCJjYW5Vc2VQb3N0TWVzc2FnZSIsInBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMiLCJvbGRPbk1lc3NhZ2UiLCJpbnN0YWxsUG9zdE1lc3NhZ2VJbXBsZW1lbnRhdGlvbiIsIm1lc3NhZ2VQcmVmaXgiLCJyYW5kb20iLCJvbkdsb2JhbE1lc3NhZ2UiLCJhdHRhY2hFdmVudCIsImluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uIiwiaW5zdGFsbFJlYWR5U3RhdGVDaGFuZ2VJbXBsZW1lbnRhdGlvbiIsInNjcmlwdCIsImluc3RhbGxTZXRUaW1lb3V0SW1wbGVtZW50YXRpb24iLCJhdHRhY2hUbyIsIl9pc1N0ZGlvIiwiZGlkT25FbmQiLCJjc3MiLCJsb2NhdGlvbiIsImJhc2VVcmwiLCJwcm90b2NvbCIsImhvc3QiLCJjdXJyZW50RGlyIiwicGF0aG5hbWUiLCJmaXhlZENzcyIsImZ1bGxNYXRjaCIsIm9yaWdVcmwiLCJ1bnF1b3RlZE9yaWdVcmwiLCIkMSIsIm5ld1VybCIsInNjb3BlIiwiVGltZW91dCIsInNldEludGVydmFsIiwiY2xlYXJJbnRlcnZhbCIsImNsb3NlIiwiY2xlYXJGbiIsIl9pZCIsIl9jbGVhckZuIiwidW5yZWYiLCJyZWYiLCJlbnJvbGwiLCJtc2VjcyIsIl9pZGxlVGltZW91dElkIiwiX2lkbGVUaW1lb3V0IiwidW5lbnJvbGwiLCJfdW5yZWZBY3RpdmUiLCJhY3RpdmUiLCJvblRpbWVvdXQiLCJfb25UaW1lb3V0IiwiY29uZmlnIiwiZGVwcmVjYXRlZCIsIndhcm4iLCJsb2NhbFN0b3JhZ2UiLCJldmFsIiwib3JpZ2luYWxNb2R1bGUiLCJ3ZWJwYWNrUG9seWZpbGwiLCJjaGlsZHJlbiIsImdlbkN1YmUiLCJfcHJvcHMiLCJwcm9wcyIsIm5vciIsImluZCIsIlBJIiwieiIsImNvcyIsInNpbiIsIm5vcm1hbCIsImdlbk9jdGFoZWRyb24iLCJkaXYiLCJpaSIsImlxIiwiaXkiLCJpeCIsImxhdDAiLCJsYXQxIiwibG9uMCIsImxvbjEiLCJsb24yIiwibG9uMyIsIngxIiwieTEiLCJ6MSIsIngyIiwieTIiLCJ6MiIsIngzIiwieTMiLCJ6MyIsInNxcnQiLCJDYW52YXNTYXZlciIsImNhbnZhcyIsInF1ZXVlU2F2ZSIsImFuY2hvciIsImZyYW1lQ291bnQiLCJpblByb2dyZXNzIiwidG9CbG9iIiwiX19kb25lIiwiaHJlZiIsIlVSTCIsImNyZWF0ZU9iamVjdFVSTCIsImRvd25sb2FkIiwibm93IiwiY2xpY2siLCJyZXF1aXJlZEZpZWxkcyIsIm5hbml0aGVmdWNrIiwiZmllbGRzIiwiZmllbGQiLCJQYXRoR1VJIiwiZ2xDYXQiLCJwYXJhbXMiLCJndWkiLCJlbCIsImluZm8iLCJyYW5nZSIsInN0ZXAiLCJkYXRlTGlzdCIsImRhdGVMaXN0SW5kZXgiLCJ0b3RhbEZyYW1lcyIsImZwcyIsInZpZXdOYW1lIiwidmlld0luZGV4IiwiZ2wiLCJ2Ym9RdWFkIiwiY3JlYXRlVmVydGV4YnVmZmVyIiwiRmxvYXQzMkFycmF5IiwiYWRkIiwiX19QYXRoR3VpUmV0dXJuIiwid2lkdGgiLCJoZWlnaHQiLCJ2ZXJ0IiwiZnJhZyIsImJsZW5kIiwiT05FIiwiX3AiLCJ2aWV3cG9ydCIsInVuaWZvcm0yZnYiLCJhdHRyaWJ1dGUiLCJ1bmlmb3JtVGV4dHVyZSIsImRyYXdBcnJheXMiLCJUUklBTkdMRV9TVFJJUCIsInRvRml4ZWQiLCJpbm5lclRleHQiLCJ2aWV3IiwicGF0aHMiLCJmcmFtZWJ1ZmZlciIsInRleHR1cmVzIiwidGV4dHVyZSIsInN0cmV0Y2giLCJudWxsRmIiLCJQYXRoIiwiZ2xvYmFsRnVuYyIsImRlcHRoVGVzdCIsImRlcHRoV3JpdGUiLCJTUkNfQUxQSEEiLCJPTkVfTUlOVVNfU1JDX0FMUEhBIiwiY3VsbCIsImRyYXdidWZmZXJzIiwiY3JlYXRlRHJhd0J1ZmZlcnMiLCJmbG9hdCIsImNyZWF0ZUZsb2F0RnJhbWVidWZmZXIiLCJjcmVhdGVGcmFtZWJ1ZmZlciIsInByb2dyYW0iLCJjcmVhdGVQcm9ncmFtIiwidXNlUHJvZ3JhbSIsImVuYWJsZSIsIkNVTExfRkFDRSIsImRpc2FibGUiLCJiaW5kRnJhbWVidWZmZXIiLCJGUkFNRUJVRkZFUiIsImRyYXdCdWZmZXJzIiwiQkFDSyIsIkNPTE9SX0FUVEFDSE1FTlQwIiwiYmxlbmRGdW5jIiwiREVQVEhfVEVTVCIsImRlcHRoTWFzayIsInByZXZQcm9ncmFtIiwibmV3UHJvZ3JhbSIsImRlbGV0ZVByb2dyYW0iLCJkZWxldGVTaGFkZXIiLCJyZXNpemVGbG9hdEZyYW1lYnVmZmVyIiwicmVzaXplRnJhbWVidWZmZXIiLCJvbnJlc2l6ZSIsIkdMQ2F0IiwiX2dsIiwiZGVwdGhGdW5jIiwiTEVRVUFMIiwiQkxFTkQiLCJfX2V4dGVuc2lvbnMiLCJfX2N1cnJlbnRQcm9ncmFtIiwiX25hbWUiLCJfdGhyb3ciLCJldmVyeSIsImdldEV4dGVuc2lvbiIsIl92ZXJ0IiwiX2ZyYWciLCJfb25FcnJvciIsIl9zdHIiLCJjcmVhdGVTaGFkZXIiLCJWRVJURVhfU0hBREVSIiwic2hhZGVyU291cmNlIiwiY29tcGlsZVNoYWRlciIsImdldFNoYWRlclBhcmFtZXRlciIsIkNPTVBJTEVfU1RBVFVTIiwiZ2V0U2hhZGVySW5mb0xvZyIsIkZSQUdNRU5UX1NIQURFUiIsImF0dGFjaFNoYWRlciIsImxpbmtQcm9ncmFtIiwiZ2V0UHJvZ3JhbVBhcmFtZXRlciIsIkxJTktfU1RBVFVTIiwibG9jYXRpb25zIiwiZ2V0UHJvZ3JhbUluZm9Mb2ciLCJfcHJvZ3JhbSIsIl9zb3VyY2UiLCJzZXRWZXJ0ZXhidWZmZXIiLCJfdGFyZ2V0IiwiX3VzYWdlIiwidXNhZ2UiLCJTVEFUSUNfRFJBVyIsImJpbmRCdWZmZXIiLCJBUlJBWV9CVUZGRVIiLCJidWZmZXJEYXRhIiwic2V0SW5kZXhidWZmZXIiLCJFTEVNRU5UX0FSUkFZX0JVRkZFUiIsImdldEF0dHJpYkxvY2F0aW9uIiwiX2J1ZmZlciIsIl9zaXplIiwiX3R5cGUiLCJfc3RyaWRlIiwiX29mZnNldCIsImVuYWJsZVZlcnRleEF0dHJpYkFycmF5IiwidmVydGV4QXR0cmliUG9pbnRlciIsIkZMT0FUIiwidmVydGV4QXR0cmliRGl2aXNvckFOR0xFIiwiX2RpdiIsImdldFVuaWZvcm1Mb2NhdGlvbiIsIl92YWx1ZSIsInVuaWZvcm0xaSIsInVuaWZvcm0xZiIsInVuaWZvcm0zZnYiLCJ1bmlmb3JtNGZ2IiwiX3RyYW5zcG9zZSIsInVuaWZvcm1NYXRyaXg0ZnYiLCJfdGV4dHVyZSIsIl9udW1iZXIiLCJhY3RpdmVUZXh0dXJlIiwiVEVYVFVSRTAiLCJiaW5kVGV4dHVyZSIsIlRFWFRVUkVfMkQiLCJURVhUVVJFX0NVQkVfTUFQIiwiY3JlYXRlVGV4dHVyZSIsInRleFBhcmFtZXRlcmkiLCJURVhUVVJFX01BR19GSUxURVIiLCJMSU5FQVIiLCJURVhUVVJFX01JTl9GSUxURVIiLCJURVhUVVJFX1dSQVBfUyIsIkNMQU1QX1RPX0VER0UiLCJURVhUVVJFX1dSQVBfVCIsIl9maWx0ZXIiLCJfd3JhcCIsInRleEltYWdlMkQiLCJSR0JBIiwiVU5TSUdORURfQllURSIsIl93aWR0aCIsIl9oZWlnaHQiLCJ0ZXh0dXJlRmlsdGVyIiwiTkVBUkVTVCIsImNvcHlUZXhJbWFnZTJEIiwiX2FycmF5T2ZJbWFnZSIsIlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCIsImNyZWF0ZVJlbmRlcmJ1ZmZlciIsImJpbmRSZW5kZXJidWZmZXIiLCJSRU5ERVJCVUZGRVIiLCJyZW5kZXJidWZmZXJTdG9yYWdlIiwiREVQVEhfQ09NUE9ORU5UMTYiLCJmcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlciIsIkRFUFRIX0FUVEFDSE1FTlQiLCJmcmFtZWJ1ZmZlclRleHR1cmUyRCIsIl9mcmFtZWJ1ZmZlciIsIl9udW1EcmF3QnVmZmVycyIsIk1BWF9EUkFXX0JVRkZFUlNfV0VCR0wiLCJDT0xPUl9BVFRBQ0hNRU5UMF9XRUJHTCIsImNoZWNrRnJhbWVidWZmZXJTdGF0dXMiLCJGUkFNRUJVRkZFUl9DT01QTEVURSIsImRyYXdCdWZmZXJzV0VCR0wiLCJfciIsIl9nIiwiX2IiLCJfYSIsIl9kZXB0aCIsImNsZWFyQ29sb3IiLCJjbGVhckRlcHRoIiwiQ09MT1JfQlVGRkVSX0JJVCIsIkRFUFRIX0JVRkZFUl9CSVQiLCJNYXRoQ2F0IiwidmVjQWRkIiwidmVjU3ViIiwidmVjTXVsIiwidmVjM0Nyb3NzIiwidmVjU2NhbGUiLCJ2ZWNEb3QiLCJyZWR1Y2UiLCJ2ZWNMZW5ndGgiLCJ2ZWNOb3JtYWxpemUiLCJxdWF0TXVsIiwicXVhdEludiIsInJvdGF0ZVZlY0J5UXVhdCIsInF1YXRUb01hdDQiLCJxdWF0QW5nbGVBeGlzIiwiYW5nbGUiLCJheGlzIiwiaGEiLCJzaGEiLCJtYXQ0QXBwbHkiLCJtYXQ0SW52ZXJzZSIsImEwMCIsImEwMSIsImEwMiIsImEwMyIsImExMCIsImExMSIsImExMiIsImExMyIsImEyMCIsImEyMSIsImEyMiIsImEyMyIsImEzMCIsImEzMSIsImEzMiIsImEzMyIsImIwMCIsImIwMSIsImIwMiIsImIwMyIsImIwNCIsImIwNSIsImIwNiIsImIwNyIsImIwOCIsImIwOSIsImIxMCIsImIxMSIsIm1hdDRBcHBseVRvVmVjNCIsIm1hdDRUcmFuc3Bvc2UiLCJtYXQ0SWRlbnRpdHkiLCJtYXQ0VHJhbnNsYXRlIiwibWF0NFNjYWxlIiwibWF0NFNjYWxlWFlaIiwibWF0NFJvdGF0ZVgiLCJtYXQ0Um90YXRlWSIsIm1hdDRSb3RhdGVaIiwibWF0NExvb2tBdCIsInRhciIsImFpciIsInJvdCIsInNpZCIsIm1hdDRQZXJzcGVjdGl2ZSIsImZvdiIsIm5lYXIiLCJmYXIiLCJ0YW4iLCJVbHRyYUNhdCIsInRyaWFuZ2xlU3RyaXBRdWFkIiwidHJpYW5nbGVTdHJpcFF1YWQzIiwidHJpYW5nbGVTdHJpcFF1YWROb3IiLCJ0cmlhbmdsZVN0cmlwUXVhZFVWIiwic2h1ZmZsZUFycmF5RCIsImRpY2UiLCJpciIsInRlbXAiLCJ0cmlJbmRleFRvTGluZUluZGV4IiwibWF0cml4MmQiLCJsZXJwIiwiY2xhbXAiLCJzYXR1cmF0ZSIsImxpbmVhcnN0ZXAiLCJzbW9vdGhzdGVwIiwiRXhwU21vb3RoIiwiZmFjdG9yIiwiZHQiLCJleHAiLCJYb3JzaGlmdCIsIl9zZWVkIiwic2VlZCIsIiQiLCJxdWVyeVNlbGVjdG9yIiwiQ09ORklHIiwicmVzb2x1dGlvbiIsInNhdmVyIiwiZ2V0Q29udGV4dCIsImxpbmVXaWR0aCIsImdsQ2F0UGF0aCIsIkdMQ2F0UGF0aCIsInRvdGFsRnJhbWUiLCJpc0luaXRpYWxGcmFtZSIsImF1dG9tYXRvbiIsIkF1dG9tYXRvbiIsImxvb3AiLCJhdXRvIiwiY2FtZXJhUG9zIiwiY2FtZXJhVGFyIiwiY2FtZXJhUm9sbCIsInBlcnNwRm92IiwicGVyc3BOZWFyIiwicGVyc3BGYXIiLCJsaWdodFBvcyIsInNoYWRvd1Jlc28iLCJtYXRQIiwibWF0ViIsIm1hdFBMIiwibWF0VkwiLCJ1cGRhdGVNYXRyaWNlcyIsImNhbU9mZnNldCIsInNtb290aCIsIm1vdXNlWCIsIm1vdXNlWSIsIm9mZnNldFgiLCJvZmZzZXRZIiwic2V0R2xvYmFsRnVuYyIsImRlbHRhVGltZSIsInJldHVybiIsIlpFUk8iLCJpbnNwZWN0b3IiLCJzaGFkb3ciLCJkZWZhdWx0IiwidXBkYXRlIiwiYmVnaW4iLCJyZW5kZXIiLCJmYiIsImlzU2hhZG93IiwidGV4dHVyZVNoYWRvdyIsImJpYXMiLCJkcnkiLCJjYXB0dXJlIiwic2F2ZSIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsIndoaWNoIiwiaXNQbGF5aW5nIiwicGxheSIsInByZUJsb29tIiwiYmxvb20iLCJ0ZW1wRmIiLCJnYXVzc1ZhciIsInBvc3RCbG9vbSIsImJveCIsInZib0JveFBvcyIsIm1hdE0iLCJMSU5FUyIsImhvdCIsImFjY2VwdCIsInJlcGxhY2VQcm9ncmFtIiwianBlZ0Nvc2luZSIsImpwZWdSZW5kZXIiLCJ0ZXh0dXJlRGl2ZXJzaXR5IiwiaW1hZ2UiLCJJbWFnZSIsInNldFRleHR1cmUiLCJvdmVybGF5IiwieG9yc2hpZnQiLCJwcHAiLCJuUGFydGljbGVTcXJ0IiwiblBhcnRpY2xlIiwiamFjb2JpSXRlciIsIm1vdGlvbkZpZWxkVm94ZWxVbml0IiwibW90aW9uRmllbGRSZXNvbHV0aW9uWFkiLCJtb3Rpb25GaWVsZFJlc29sdXRpb24iLCJ2Ym9Db21wdXRlVVYiLCJvY3QiLCJ2Ym9PY3RQb3MiLCJ2Ym9PY3ROb3IiLCJpYm9PY3QiLCJjcmVhdGVJbmRleGJ1ZmZlciIsInRleHR1cmVSYW5kb21TaXplIiwidGV4dHVyZVJhbmRvbVVwZGF0ZSIsIl90ZXgiLCJzZXRUZXh0dXJlRnJvbUFycmF5IiwiZ2VuIiwidGV4dHVyZVJhbmRvbVN0YXRpYyIsInRleHR1cmVXcmFwIiwiUkVQRUFUIiwidGV4dHVyZVJhbmRvbSIsInRleHR1cmVEdW1teSIsInBhcnRpY2xlc0NvbXB1dGVSZXR1cm4iLCJwYXJ0aWNsZXNNb3Rpb25SZWFkIiwiUE9JTlRTIiwicGFydGljbGVzRW5mb3JjZSIsInBhcnRpY2xlc0RpdmVyZ2VuY2UiLCJwYXJ0aWNsZXNQcmVzc3VyZSIsInBhcnRpY2xlc01vdGlvbldyaXRlIiwicGFydGljbGVzQ29tcHV0ZSIsInBhcnRpY2xlc1JlbmRlciIsImF0dHJpYnV0ZURpdmlzb3IiLCJkcmF3RWxlbWVudHNJbnN0YW5jZWRBTkdMRSIsIlRSSUFOR0xFUyIsIlVOU0lHTkVEX1NIT1JUIiwicG9zdCIsImZ4YWEiXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtEQUEwQyxnQ0FBZ0M7QUFDMUU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnRUFBd0Qsa0JBQWtCO0FBQzFFO0FBQ0EseURBQWlELGNBQWM7QUFDL0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUF5QyxpQ0FBaUM7QUFDMUUsd0hBQWdILG1CQUFtQixFQUFFO0FBQ3JJO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQTJCLDBCQUEwQixFQUFFO0FBQ3ZELHlDQUFpQyxlQUFlO0FBQ2hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhEQUFzRCwrREFBK0Q7O0FBRXJIO0FBQ0E7OztBQUdBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2xGQTtBQUFBLE9BQUMsTUFBRDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0tBQUEsRTs7S0FBQTs7QUFB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QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUZBLE1BRUE7QUFDQTtBQUNBO0FBQ0EsU0FOQSxDQU1BO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUZBLE1BRUE7QUFDQTtBQUNBO0FBQ0EsU0FOQSxDQU1BO0FBQ0E7QUFDQTtBQUNBLE9BbkJBOztBQW9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBSkEsQ0FLQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FIQSxDQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FIQSxDQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBSkEsQ0FLQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FIQSxDQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FIQSxDQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUNBOztBQUNBO0FBQ0E7QUFDQSxTQUZBLE1BRUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFFQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BWEEsQyxDQWFBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0EsT0FGQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCLENBQUE7O0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQUE7QUFBQTs7QUFFQTtBQUNBO0FBQ0EsT0FGQTs7QUFJQTtBQUFBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBLE9BRkE7O0FBR0E7QUFBQTtBQUFBO1UzRHZMQTs7O0E0REFBOztBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDLENBRUE7O0FBRUE7QUFDQTtBQUNBLFNBRkE7O0FBR0E7QUFDQTtBQUNBLFNBRkE7O0FBR0EsK0JBQ0E7QUFBQTtBQUFBLFNBREE7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBLFNBRkEsQyxDQUlBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUhBOztBQUtBO0FBQ0E7QUFDQTtBQUNBLFNBSEE7O0FBS0E7QUFDQTtBQUVBOztBQUNBO0FBQ0E7QUFDQSxtQ0FDQTtBQUNBLGFBSEEsRUFHQSxLQUhBO0FBSUE7QUFDQSxTQVZBLEMsQ0FZQTs7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUZBLE1BRUE7QUFDQTtBQUNBLGVBUEEsQ0FRQTs7O0FBQ0E7QUFDQTtBQUNBLFdBWkE7QUFjQTtBQUNBLFNBckJBO0FBdUJBO0FBQ0E7QUFDQSxTQUZBOzs7OztNNUR6RUE7O0E2REFBLGMsQ0FBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFBQTtBQUFBOztBQUNBO0FBRUE7QUFDQTtBQUNBLGtDQU5BLENBUUE7O0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUNBO0FBQ0EsdUJBQ0EsaUVBQ0EsMENBRkE7QUFJQTtBQUNBO0FBQ0EsT0FyQkE7QUF1QkE7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFBQTtBQUFBOztBQUVBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQSxvQkFEQTtBQUVBLDBCQUZBO0FBR0E7QUFIQTtBQUtBLE9BZEE7QUFnQkE7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0EsT0FGQTtBQUlBOzs7Ozs7OztBQU9BO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBLFdBTkE7QUFPQSxTQVRBLE1BU0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBLFdBTkE7QUFPQTtBQUNBO0FBQ0E7QUFDQSxXQUhBO0FBSUE7QUFDQTtBQUVBOzs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBLG1DQUNBLGtFQURBLEdBRUEsTUFGQTtBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FGQSxDQUVBO0FBQ0E7QUFDQSx5QkFDQSw2RUFEQTtBQUdBO0FBQ0EsU0FUQTtBQVVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBRkE7QUFHQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBRkEsQ0FHQTtBQUNBOztBQUNBO0FBQ0E7QUFDQSxhQVBBLENBUUE7OztBQUNBO0FBQ0E7QUFDQSxhQVhBLENBWUE7OztBQUNBO0FBQ0E7QUFDQSxhQWZBLENBZ0JBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQSxXQXBCQTtBQXFCQSxTQXhCQSxNQXdCQTtBQUNBO0FBQ0E7QUFDQSxtRUFIQSxDQUtBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFGQSxNQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFIQTtBQUlBO0FBQ0E7O0FBQ0Esd0NBakJBLENBa0JBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0EsYUFGQTtBQUdBO0FBQ0E7QUFDQSxPQXBFQTtBQXNFQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQWJBLE1BYUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FGQSxNQUVBO0FBQ0EseUJBQ0EsbUVBREE7QUFHQTtBQUNBLFNBUkE7QUFTQSxPQWpDQTtVN0Q5TUE7OztBOERBQTs7Ozs7QUFLQTtBQUVBOztBQUVBLDRDLENBRUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7QUFHQTtBQUNBLGlCQUNBLDZCQUNBLHlCQURBLElBRUE7QUFDQSxzQ0FIQSxJQUlBLDBCQUxBO0FBT0E7QUFFQTs7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUVBOzs7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7QUFJQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBRUE7Ozs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7QUFHQTtBQUNBLCtCQUNBLEVBREEsR0FFQSw2QkFDQSw0QkFEQSxHQUVBLFdBSkE7QUFLQTtBQUVBOzs7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7QUFJQSx5QkFDQSxHQURBLEVBRUEsZ0JBRkEsRUFHQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBLG9DQUNBO0FBQUE7QUFBQSxXQURBLEdBRUE7QUFBQTtBQUFBLFdBRkE7QUFHQTtBQUVBOzs7OztBQUdBO0FBRUE7Ozs7QUFHQTtBQUVBOzs7O0FBR0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7QUFHQTs7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FIQTtBQUlBO0FBRUE7Ozs7O0FBR0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBLFNBRkE7QUFJQTs7OztBQUdBO0FBQ0E7QUFDQSxTQUZBO0FBSUE7Ozs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxTQUZBO0FBSUE7Ozs7Ozs7O0FBUUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQ0EsUUFDQSx3QkFEQSxHQUVBLGVBSEEsR0FJQSxZ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QTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTs7QUFDQTtBQUNBLDBEQUNBLDBFQUNBLHFEQUZBO0FBSUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7OztBQUdBO0FBQ0Esd0RBQ0Esc0NBREEsR0FFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQSwwREFDQSxtRUFDQSx3QkFGQTtBQUlBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBRUE7Ozs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFFQTs7Ozs7OztBQUtBO0FBRUE7Ozs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxtQkFDQSw2REFDQSxrQ0FGQTtBQUlBOztBQUNBO0FBQ0EsV0FSQTtBQVNBO0FBRUE7Ozs7O0FBR0E7QUFDQTtBQUFBO0FBQUE7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0EsYUFGQSxNQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFFQTs7Ozs7QUFHQSwrQkFDQSxTQURBLEVBRUEsUUFGQSxFQUdBLEVBSEEsRUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBLGFBUEEsQ0FRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBLCtCQUNBLHFFQURBLEVBRUEsd0VBRkE7QUFJQSxhQUxBO0FBTUEsV0FuQkEsTUFtQkE7QUFDQTtBQUNBO0FBQ0Esa0VBQ0EscUJBREEsR0FFQSxRQUZBO0FBR0Esa0VBQ0Esc0JBREEsR0FFQSxTQUZBOztBQUdBO0FBQ0E7QUFDQSxlQUZBLE1BRUE7QUFDQTtBQUNBO0FBQ0EsYUFiQTtBQWNBO0FBQ0E7O0FBRUEsZ0NBQ0EsU0FEQSxFQUVBLFFBRkEsRUFHQSxFQUhBLEVBSUE7QUFDQTtBQUNBO0FBQ0EsNERBQ0EsNENBQ0Es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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBLGlCQUNBLCtEQUNBLFlBREEsR0FDQSx3Q0FEQSxHQUVBLFFBRkEsR0FFQSxnQkFGQSxHQUVBLEdBSEEsRUFJQSxFQUpBO0FBTUE7QUFDQTs7QUFDQTs7QUFDQTtBQUNBO0FBQ0EsbUJBQ0Esc0VBREEsRUFFQSxFQUZBO0FBSUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBLHFEQUZBLENBR0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FQQSxNQU9BO0FBQ0E7QUFDQSxXQUZBLE1BRUE7QUFDQTtBQUNBLFdBRkEsTUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQSx3QkFEQTtBQUVBO0FBRkE7QUFJQTtBQUVBOzs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUVBOzs7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUFBO0FBQUE7QUFDQSxtQkFIQSxDQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUZBLENBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0EsV0FGQSxNQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBQ0E7OztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUyxDQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQSxpQyxDQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBRkE7QUFHQSxTQUpBLE1BSUEsOENBQ0EsNEJBQ0E7QUFDQSwwRUFIQSxHQUlBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQSxXQUZBO0FBR0EsU0FYQSxNQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FGQTtBQUdBLFMsQ0FFQTs7QUFDQTs7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBLG1DQURBLENBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUFBO0FBQUE7QUFDQSxXQVJBO0FBU0EsU0FYQSxNQVdBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBTEE7QUFNQTs7QUFFQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFGQSxDQUVBO0FBQ0E7QUFDQTtBQUNBLGFBTkEsTUFNQTtBQUNBO0FBQ0E7QUFDQSxXQVZBOztBQVdBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBLGFBRkEsTUFFQTtBQUNBO0FBQ0E7QUFDQSxXQXBCQSxDQXFCQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFGQTtBQUdBO0FBQ0E7QUFFQTs7QUFFQTs7O0FBRUE7O0FBRUE7QUFDQSx1Q0FDQSwyQ0FDQSxnRkFEQSxHQUVBLHdFQUZBLEdBR0EsU0FKQSxDQUlBO0FBSkE7O0FBT0E7QUFDQSxpQkFDQSwyRUFDQSxzRUFEQSxHQUVBLCtEQUZBLEdBR0EsNkJBSEEsR0FJQSxnRkFMQSxFQU1BLE1BTkE7QUFRQSxXQVRBOztBQVdBLHlCQUNBLCtDQURBOztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBSEEsTUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVEE7QUFXQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQVJBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBTkE7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFDQSxVQURBLEdBRUEsVUFGQTtBQUdBO0FBQ0EsYUFQQSxNQU9BO0FBQ0E7QUFDQTtBQUNBLFdBWEE7QUFZQTtBQUVBOzs7QUFFQTtBQUVBOzs7Ozs7QUFLQTtBQUNBOztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFBQTtBQUFBO0FBQ0EsV0FIQSxNQUdBO0FBQ0E7QUFDQTs7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUNBLGNBQ0EsUUFDQSxTQURBLElBRUEsWUFGQSxJQUdBLGVBSEEsSUFJQSxrQkFMQSxFQU1BO0FBQ0E7QUFBQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUxBO0FBTUE7QUFDQTtBQUVBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwrQ0FIQSxDQUdBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBREE7QUFFQSx5QkFGQTtBQUdBLDRCQUhBO0FBSUE7QUFKQTtBQU1BLFNBYkE7O0FBZUE7QUFDQTtBQUNBO0FBRUE7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUxBLE1BS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUNBQ0EsRUFEQSxFQUVBLEtBRkEsRUFHQSxHQUhBLEVBSUEsU0FKQSxFQUtBLEVBTEEsRUFNQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQSw0REFDQSxzRUFEQSxFQUVBLEVBRkE7QUFJQSxhQUxBLE1BS0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQSxhQUxBLE1BS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0NBREEsQ0FFQTtBQUNBOztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FIQSxNQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBSkEsTUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUVBOzs7QUFFQSwyQ0FDQSxJQURBLEVBRUEsSUFGQSxFQUdBLEdBSEEsRUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0Esb0JBQ0EsMEJBQ0EsS0FEQSxJQUNBLDZCQUZBLEVBR0E7QUFDQSxzQkFDQSw0REFDQSxnQ0FEQSxHQUNBLGlDQURBLEdBRUEsS0FGQSxHQUVBLEdBRkEsR0FFQSxNQUZBLEdBR0EsZ0VBSEEsR0FJQSxtRUFKQSxHQUtBLHVDQUxBLEdBS0EsTUFMQSxHQUtBLGtCQUxBLEdBS0EsR0FMQSxHQUtBLEtBTkE7QUFRQTtBQUNBOztBQUNBLDBEQUNBLHlDQURBO0FBRUE7QUFDQTs7QUFDQTtBQUNBOztBQUVBLDJCQUNBLEdBREEsRUFFQSxJQUZBLEVBR0EsR0FIQSxFQUlBLE1BSkEsRUFLQSxRQUxBLEVBTUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0EsYUFOQSxNQU1BO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQSxTLENBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0EseUNBQ0EsMkJBREEsR0FFQSwwQkFDQSxnQ0FEQSxHQUVBLFNBSkE7QUFLQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFBQTtBQUFBOztBQUNBO0FBQ0Esa0NBSkEsQ0FLQTs7QUFDQTtBQUNBO0FBQ0EsNkVBREEsQ0FFQTs7QUFDQTtBQUNBO0FBQ0E7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R0FJQSw0QkFKQSxHQUlBLGdCQUpBLEdBSUEsa0JBSkEsR0FJQSxLQUpBLEdBSUEsS0FMQTtBQU9BO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUZBLENBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBLFdBM0JBO0FBNEJBO0FBRUE7O0FBSUE7Ozs7O0FBR0EsOEJBQ0EsUUFEQSxFQUVBLE9BRkEsRUFHQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0Esa0NBRkEsQ0FHQTs7QUFDQTtBQUNBO0FBQ0EsYUFOQSxDQU9BO0FBQ0E7OztBQUNBLDhFQUNBLElBREEsSUFDQSxpQkFEQSxFQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0EsZUFGQSxNQUVBO0FBQ0E7QUFDQTtBQUNBLGFBVkEsTUFVQTtBQUNBO0FBQ0E7QUFDQSxXQTNCQSxDQTRCQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxvQ0FDQSxHQURBLEVBQ0E7QUFDQSxXQUZBLEVBR0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUZBLE1BRUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUVBOzs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esb0NBREEsQ0FHQTs7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQVRBLENBVUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0Esb0NBQ0EsTUFEQSxFQUNBLEtBREEsRUFDQSxTQURBLEVBQ0E7QUFBQTtBQURBLGdCQUVBLHNCQUZBLEVBR0EsbUJBSEEsRUFGQSxDQU9BO0FBQ0E7O0FBQ0E7QUFDQSxhQVZBLE1BVUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0EsZ0RBMUJBLENBMkJBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0EsYUFqQ0EsQ0FrQ0E7OztBQUNBO0FBQ0E7QUFDQSxhQXJDQSxDQXNDQTtBQUNBOztBQUNBLFdBeENBOztBQTBDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBTEE7O0FBT0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQSx3Q0FOQSxDQU9BOztBQUNBOztBQUNBO0FBQ0E7QUFDQSxhQVhBLENBWUE7OztBQUNBO0FBQ0E7QUFDQTs7QUFDQTs7QUFDQTtBQUNBO0FBQ0EsYUFuQkEsQ0FvQkE7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBLGFBeEJBLENBeUJBOzs7QUFDQSxtQ0ExQkEsQ0EyQkE7O0FBQ0EsMENBNUJBLENBNkJBOzs7QUFDQSxzQ0E5QkEsQ0ErQkE7O0FBQ0Esc0JBaENBLENBaUNBOztBQUNBO0FBQ0E7QUFDQSxhQXBDQSxDQXFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0F6Q0E7QUEwQ0E7O0FBRUEsZ0NBQ0EsRUFEQSxFQUVBLEVBRkEsRUFHQSxTQUhBLEVBSUE7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQSxvRkFDQSxjQURBLElBQ0EsRUFEQSxFQUNBO0FBQ0EscUJBQ0Esb0VBQ0EsbUVBREEsR0FFQSx1REFIQSxFQUlBLEVBSkE7QUFNQSxlQVJBLE1BUUE7QUFDQSxxQkFDQSxxRUFEQSxFQUVBLEVBRkE7QUFJQTtBQUNBO0FBQ0E7O0FBQ0E7QUFFQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUNBOztBQUNBO0FBQ0E7QUFFQTs7QUFDQTs7QUFDQTtBQUNBO0FBQ0EsYUFmQTtBQWdCQSxXQWpCQSxNQWlCQTtBQUNBO0FBQ0E7QUFDQSxhQUZBO0FBR0EsV0EvQ0EsQ0FpREE7QUFDQTtBQUNBOzs7QUFDQTtBQUFBO0FBQUE7QUFDQSw0QkFyREEsQ0F1REE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUVBLHNDQUNBLEVBREEsRUFFQSxTQUZBLEVBR0EsU0FIQSxFQUlBLFdBSkEsRUFLQSxjQUxBLEVBTUE7QUFDQTtBQUNBO0FBQ0EsV0FIQSxDQUtBO0FBQ0E7OztBQUNBLCtCQUNBO0FBQ0EscUNBREEsSUFDQTtBQUNBLHNDQUZBLElBRUE7QUFDQSx5Q0FKQSxDQUlBO0FBSkE7QUFPQTtBQUNBLGtDQWZBLENBZUE7O0FBRUE7QUFBQTtBQUNBO0FBQ0E7O0FBQ0EsdURBcEJBLENBc0JBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBLG1EQTFCQSxDQTRCQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0Esa0RBRkEsQ0FFQTs7QUFDQTtBQUNBOztBQUNBLGtDQVRBLENBVUE7O0FBQ0E7QUFDQSxXQXpDQSxDQTJDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBL0NBLENBaURBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUxBLE1BS0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFGQSxDQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFFQTs7O0FBR0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7O0FBR0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBRUE7Ozs7O0FBR0E7QUFDQTtBQUNBLDBCQUZBLENBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUFBO0FBQUEsYUFaQSxDQWNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFKQSxDQUtBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQSxxQkFDQSwyQ0FDQSxlQUNBLDJEQURBLEdBRUEsaUNBSEEsQ0FEQSxFQU1BLFVBTkE7QUFRQTtBQUNBO0FBQ0E7QUFDQSxXQXBDQSxDQXNDQTs7O0FBQ0E7QUFDQTtBQUVBLGdDQTFDQSxDQTRDQTs7QUFDQTtBQUNBLHlDQTlDQSxDQWdEQTs7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7QUFLQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBLGFBRkEsTUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQSxhQVpBLENBYUE7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFFQTtBQUVBOzs7Ozs7QUFLQSx1Q0FDQSxFQURBLEVBRUEsT0FGQSxFQUdBLEVBSEEsRUFJQSxPQUpBLEVBS0EsZUFMQSxFQU1BO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBLGtDQUxBLENBTUE7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUxBLE1BS0E7QUFDQTtBQUNBOztBQUNBO0FBQ0EsNEJBaEJBLENBZ0JBOztBQUNBO0FBQ0EsaUNBbEJBLENBa0JBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQ0Esa0JBREEsR0FFQSxFQUZBLENBdkJBLENBMEJBOztBQUNBO0FBQ0E7QUFDQSxXQUZBLE1BRUE7QUFDQTs7QUFDQTtBQUNBOztBQUNBLDREQUNBLCtDQUNBLG1EQURBLEdBRUEsMkNBSEEsRUFJQSxFQUpBO0FBTUE7QUFDQTs7QUFDQSxtQ0FDQSxTQURBLEdBRUEsVUFGQTtBQUdBLFNBbERBO0FBb0RBOzs7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQSxXQUZBLENBRUE7QUFDQTtBQUNBO0FBQ0EsYUFGQSxNQUVBO0FBQ0E7QUFDQTtBQUNBLFdBUkEsU0FRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0EsU0F0QkE7QUF3QkE7Ozs7O0FBR0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQVRBO0FBV0E7Ozs7O0FBR0E7QUFDQTtBQUVBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBbEJBO0FBb0JBOzs7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBRkEsTUFFQTtBQUNBO0FBQ0EsV0FGQSxNQUVBO0FBQ0E7QUFDQTtBQUNBLFNBVEE7QUFXQTs7Ozs7O0FBSUE7QUFDQTtBQUNBOztBQUNBLGdCQUNBLHdCQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUpBLElBS0EsU0FOQSxFQU9BO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUZBLENBRUE7QUFDQTtBQUNBO0FBQ0EsZUFOQSxNQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQXpCQTtBQTJCQTs7Ozs7O0FBSUE7QUFDQTtBQUNBO0FBQ0EsU0FIQTtBQUtBOzs7OztBQUdBO0FBQ0E7QUFFQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQVBBO0FBU0E7Ozs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBLFNBaEJBO0FBa0JBOzs7QUFFQTtBQUNBLDBCQURBO0FBRUEsNEJBRkE7QUFHQSxtQkFIQTtB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O0FBQ0E7QUFDQSxxQkFGQTtBQUdBO0FBQ0E7QUFDQSxlQXZCQTs7QUF5QkE7QUFBQTtBQUFBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBRUE7O0FBRUE7Ozs7O0FBR0EsOEJBQ0EsS0FEQSxFQUVBLE9BRkEsRUFHQTtBQUNBO0FBQ0EsbUNBRkEsQ0FHQTtBQUNBOztBQUNBO0FBQ0E7QUFDQSxXQVBBLENBUUE7OztBQUNBLDJFQUNBLGlCQURBLEVBRUEsSUFGQSxFQUdBLElBSEEsQ0FHQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBRUE7Ozs7OztBQUlBLDBCQUNBLElBREEsRUFFQSxLQUZBLEVBR0EsR0FIQSxFQUlBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRCQUNBLElBREEsRUFFQSxHQUZBLEVBR0EsTUFIQSxFQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FOQSxNQU1BO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNERBQ0EsK0NBREEsRUFFQSxJQUZBO0FBSUEsYUFMQSxNQUtBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUVBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUVBLHlDQUNBLElBREEsRUFFQSxLQUZBLEVBR0EsUUFIQSxFQUlBLE1BSkEsRUFLQSxJQUxBLEVBTUE7QUFDQSxxQ0FEQSxDQUVBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQSw4Q0FEQSxDQUVBOztBQUNBO0FBQ0EsV0FKQSxNQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBSkEsQ0FLQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFBQTtBQUFBLFlBMUJBLENBNEJBOzs7QUFDQTtBQUNB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QTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBLFdBWEEsTUFXQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVEQUNBLHNCQURBLEVBRUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0EsYUFKQSxDQU1BOzs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQSxhQUZBLE1BRUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQSxXQWhCQTtBQWlCQTtBQUVBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBSEE7QUFJQTtBQUVBOzs7QUFFQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFFQTs7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFGQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQSx1Q0FDQSxhQURBLEVBRUEsYUFGQTtBQUlBLGlDQXhCQSxDQTBCQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQSxhQWxDQSxDQW9DQTs7O0FBQ0E7QUFDQTtBQUNBLGdDQXZDQSxDQXlDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQSxhQUZBLEVBM0NBLENBOENBOztBQUNBO0FBQ0E7QUFDQSxhQWpEQSxDQW1EQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQSx3REF4REEsQ0EwREE7O0FBQ0E7QUFDQTtBQUNBLFdBN0RBO0FBOERBOztBQUVBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBLGtDQUNBLEVBREEsRUFFQSxVQUZBLEVBR0E7QUFDQTtBQUNBO0FBQ0EsZUFGQSxNQUVBO0FBQ0E7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QTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFFQTs7O0FBRUE7QUFDQSwyQ0FEQTtBQUVBO0FBRkE7QUFLQSxnQ0FDQSwrQ0FDQSwyRUFEQSxHQUVBLG9FQUZBLEdBR0Esd0VBSEEsR0FJQSw2RUFKQSxHQUtBLDJEQUxBLEdBTUEsa0RBTkEsR0FPQSx5RUFQQSxHQVFBLGtDQVJBLEdBU0EsdUNBVEEsR0FVQSx5REFYQSxFLENBY0E7QUFDQTs7QUFDQSw0QkFDQSwyRUFDQSwwRUFEQSxHQUVBLGtFQUhBLEVBSUEsSUFKQTs7QUFTQTtBQUNBO0FBQ0EsU0FGQTs7QUFJQTtBQUNBO0FBQ0E7QUFDQSxXQUhBLENBSUE7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBLDhDQUNBLGdEQUNBLHFDQUZBO0FBSUEsV0FOQSxNQU1BO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBRUE7O0FBRUE7Ozs7QUFHQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQSw0REFDQSw0QkFEQTtBQUdBO0FBQ0E7O0FBQ0E7QUFDQSxXQVRBLE1BU0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBRUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0EsV0FKQSxDQUtBOzs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUdBO0FBQ0Esd0NBREE7QUFFQSwwQ0FG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QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQSxnQ0FKQSxDQUlBOztBQUNBO0FBQ0E7QUFBQTtBQUFBOztBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0EsV0FqT0EsQ0FtT0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQSxhQUZBLE1BRUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0EsYUFaQSxDQWFBOzs7QUFDQSw2Q0FDQSxtQkFEQSxJQUVBLHFCQUZBLElBR0EsOEJBSEEsRUFJQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQUE7QUFBQTs7QUFDQTtBQUFBO0FBQUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBSEEsTUFHQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBSkEsTUFJQTtBQUNBO0FBQ0E7QUFDQSxlQVZBLENBV0E7OztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBLGVBRkEsTUFFQTtBQUNBO0FBQ0E7QUFDQSxhQXZCQSxNQXVCQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFUQSxDQVdBO0FBQ0E7QUFDQTs7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFEQURBLENBQ0E7QUFDQSxlQUZBLE1BRUE7QUFDQTtBQUNBLGVBRkEsTUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBSkEsTUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBSkEsTUFJQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUxBLE1BS0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFMQSxNQUtBO0FBQ0E7QUFBQTtBQUFBOztBQUNBLHNEQUNBLDhCQURBLEdBRUEsMERBRkE7O0FBR0E7QUFBQTtBQUNBO0FBQ0EsaUJBRkEsTUFFQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBSkEsTUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUhBLE1BR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBLHVCQUNBLHlFQURBLEVBRUEsYUFGQTtBQUlBLGlCQUxBLE1BS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBRkEsTUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQSxhQWRBLENBZ0JBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSwwQ0FDQSx5QkFEQSxJQUVBLDBCQUZBLEtBR0EsOENBSEEsR0FJQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUNBO0FBQ0E7QUFBQTtBQUFBOztBQUNBO0FBQUE7QUFBQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQSxlQUZBLE1BRUE7QUFDQTtBQUFBO0FBQUE7O0FBQ0E7QUFDQSxlQUhBLE1BR0E7QUFDQTtBQUNBLGVBRkEsTUFFQTtBQUNBO0FBQ0E7QUFDQSxhQVhBLE1BV0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFGQSxNQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQ0FyZUEsQ0FzZUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0Esb0ZBMWVBLENBNGVBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBWEEsQ0FZQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFGQSxNQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFDQSw4QkFEQSxJQUVBLGdCQUZBLEVBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQSxtQkFkQSxNQWNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQSxxQkFWQSxDQVdBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQSxtRUFDQSw4QkFEQSxJQUVBLGdCQUZBLEVBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBL0RBLE1BK0RBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpRUFDQSx1Q0FDQSx3RUFGQTtBQUlBLGFBTEEsTUFLQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBOztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBSkEsTUFJQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBSEEsTUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFIQSxNQUdBO0FBQ0EsMkJBQ0EsK0RBQ0EsOERBREEsR0FFQSwr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O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQWJBOztBQWVBO0FBQ0E7QUFDQTs7QUFFQSxrRUFDQSw0QkFEQSxJQUNBLHNCQURBLEVBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLCtFQWJBLENBZUE7O0FBQ0E7QUFFQSxvRUFsQkEsQ0FvQkE7QUFDQTtBQUNBOztBQUNBLDZEQUNBLGlCQURBLEdBRUEsS0FGQTtBQUlBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2QkFEQTtBQUVBO0FBR0E7O0FBRUE7Ozs7O0FBUEE7O0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0EsYUFGQSxNQUVBO0FBQ0E7QUFDQTtBQUNBLFdBTkEsTUFNQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0EsYUFGQSxNQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQVRBLE1BU0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTs7QUFDQTtBQUNBO0FBQ0EsYUFGQSxNQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBLFdBUEEsTUFPQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUNBREE7QUFFQSw0Q0FGQTtBQUdBLG9EQUhBO0FBSUEsdUNBSkE7QUFLQSw0Q0FMQTtBQU1BO0FBTkE7QUFRQSxTQVRBO0FBV0E7QUFDQTtBQUNBLG9DLENBRUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBLHNEQUNBLDBDQURBLEVBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0EscURBQ0EseUNBREEsRUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFMsQ0FFQTs7O0FBQ0EsOEJBQ0EsK0JBQ0EseUNBREEsR0FFQSxVQUhBO0FBSUE7QUFBQTtBQUFBO0FBQUEsU0FKQTs7QUFNQTtBQUNBO0FBQ0E7QUFDQSxXQUZBO0FBR0E7O0FBRUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBRUEsb0NBQ0EsRUFEQSxFQUVBLFlBRkEsRUFHQSxFQUhBLEVBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUFBO0FBQUE7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUhBOztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBTkE7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUpBLEVBSUEsV0FKQTtBQUtBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBTkEsTUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQU5BLE1BTUE7QUFDQTtBQUNBLGlDQUNBLHVDQUNBLFVBREEsR0FFQSxTQUhBLEdBSUEsSUFKQTtBQUtBLCtCQUNBLHNCQUNBLDBCQURBLEdBRUEseUJBSEEsR0FJQSxDQUpBO0FBS0E7O0FBQ0EsNkJBQ0EsdUJBQ0EscURBRkE7QUFHQTtBQUNBLHNCQURBO0FBRUEsNEJBRkE7QUFHQSxnQ0FIQTtBQUlBO0FBSkE7QUFNQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUZBO0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBRUE7OztBQUVBO0FBQ0EsNkJBREEsQ0FHQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBRUE7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQW5DQSxDQXFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxxREFDQSxXQURBLEdBRUEsVUFGQTtBQUdBLDREQUNBLGlCQURBLEdBRUEsZ0JBRkE7QUFHQSxvREFDQSxhQURBLEdBRUEsWUFGQTtBQUlBLDJDQUNBLDJCQURBLEdBRUEsV0FGQTtBQUdBLHFDQUNBLDZDQURBLEdBRUEsS0FGQTtBQUdBLDBDQUNBLHlCQURBLEdBRUEsVUFGQTtBQUdBLDhDQUNBLGlDQURBLEdBRUEsY0FGQTtBQUlBLCtDQUNBLHFCQUNBLGNBREEsR0FFQSxRQUhBOztBQU1BO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBLGFBTEEsTUFLQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQSxXQWRBOztBQWdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBLGlDQUNBLDZCQURBLElBRUEsd0JBRkEsRUFHQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQSxhQVZBO0FBV0EsV0F2SEEsQ0F5SEE7OztBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFGQSxNQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQVpBO0FBYUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2QkFEQSxDQUdBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFFQTs7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUEsK0NBQ0EscUJBQ0EsY0FEQSxHQUVBLFFBSEE7O0FBTUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0EsYUFMQSxNQUtBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0EsV0FsQkE7O0FBb0JBO0FBQ0E7QUFDQSxXQUZBLE1BRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFKQSxDQUtBOzs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUZBLE1BRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBWkE7QUFhQTs7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFMsQ0FFQTs7O0FBQ0E7QUFDQTtBQUNBLGlCQUNBLHlFQUNBLE1BREEsR0FDQSxtQkFEQSxHQUNBLEdBRkEsRUFHQSxhQUhBO0FBS0EsV0FOQSxNQU1BO0FBQ0EsaUJBQ0EsMERBQ0EsNkNBRkEsRUFHQSxhQUhBO0FBS0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTs7QUFDQTtBQUNBO0FBQ0EsMENBQ0EsNEJBQ0EsYUFEQSxHQUVBLFVBSEE7QUFLQSxXQVBBLE1BT0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQURBO0FBRUEsMEJBRkE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBRkEsTUFFQTtBQUNBO0FBQ0E7QUFDQTtBQVZBLFlBV0EsRUFYQTtBQWFBLCtCQUNBLEtBREEsRUFFQSxLQUZBLEVBR0EsTUFIQSxFQUlBLFFBSkEsRUFLQSxLQUxBLEVBTUEsVUFOQTtBQVNBO0FBRUE7QUFDQTs7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBRUE7Ozs7O0FBS0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FMQTtBQU1BOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBRkE7QUFHQSxlQUpBLE1BSUE7QUFDQTtBQUNBOztBQUNBO0FBQ0EsYUFWQSxNQVVBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBLHdFQUZBLENBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0E1QkE7QUE4QkE7QUFDQTtBQUNBLHNEQURBLENBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0EsOENBQ0E7QUFBQTtBQUFBLGtCQURBLEdBRUEsb0ZBRkE7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBbERBOztBQXFEQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFGQSxFQUVBLENBRkE7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBLDBEQUNBLDhEQUNBLGtEQURBLEdBQ0Esa0RBRkEsRUFHQSxFQUhBO0FBS0E7QUFDQTs7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFMQSxNQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTs7QUFFQTtBQUNBLHNDQUNBLGFBREEsR0FFQSxZQUZBO0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBOzs7QUFDQTtBQUNBLHNGQUNBLDBDQURB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OztBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztNMUZBQTs7Ozs7Ozs7Ozs7O0EyRmlFQSxvRDs7O0FBTUE7QUFDQSxvREFEQTtBQUVBLDRCQUZBO0FBR0E7QUFIQTtBQUNBLFc7O0FBT0E7QUFDQTs7O0FBQ0E7QUFDQTs7OztBQUtBO0FBQ0E7O0FBQ0E7Ozs7QUFLQTs7QUFDQTtBQUNBLGU7OztBQUdBO0FBQ0E7QUFDQTs7QUFDQTs7QUFHQTtBQUNBLGU7OztBQUdBO0FBQ0EsYTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFIQSxNQUdBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsYTtBQUNBO0FBRUE7O0FBR0EsYTtBQUNBO0FBRUE7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBR0E7QUFDQTtBQUNBLGVBRkEsRUFFQSxJQUZBO0FBR0E7OztBQWpGQSxPOzs7Ozs7Ozs7O0FBaEVBO0FBQUE7O0FBQUE7O0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztNM0ZBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QTRGK0RBLGtDO0FBQ0Esb0M7QUFDQSwwQztBQUNBLHdDO0FBQ0Esd0M7QUFDQSw4QztBQUNBOzs7O0FBTUE7QUFDQSxnQ0FEQTtBQUVBLHFDQUZBO0FBR0EsaUNBSEE7QUFJQSwrQkFKQTtBQUtBLHdCQUxBO0FBTUEsc0NBTkE7QUFPQSw2QkFQQTtBQVFBLDZCQVJBO0FBU0E7QUFUQTtBQUNBLFc7O0FBYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhO0FBQ0E7QUFFQTtBQUNBO0FBQ0EsYTtBQUNBO0FBRUE7QUFDQTtBQUNBLGE7QUFDQTtBQUVBO0FBQ0E7QUFDQSxhO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFJQTs7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQSxhO0FBQ0EsVztBQUNBOztBQXRFQSxPOzs7Ozs7Ozs7O0FBOURBO0FBQUE7O0FBQUE7O0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O001RkFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBNkZrQ0E7Ozs7QUFNQTtBQUNBLFc7O0FBSUE7QUFDQTs7O0FBQ0Esc0M7QUFDQSxzQztBQUNBO0FBQ0Esc0NBREE7QUFHQTtBQUNBO0FBQ0E7QUFMQSxtQkFNQTtBQUpBLHNDQUlBO0FBR0E7QUFDQTs7QUFDQTtBQUNBO0FBTkEsaUJBTkE7O0FBRkE7OztBQWRBLE87Ozs7Ozs7Ozs7QUFqQ0E7QUFBQTs7QUFBQTs7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztNN0ZBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QThGbUNBO0FBQ0E7QUFDQTtBQUFBOzs7QUFFQTtBQUNBLFdBTEE7OztBQVFBO0FBQ0EsUzs7Ozs7O0FBZUE7QUFDQSwwQkFEQTtBQUVBO0FBRkE7QUFDQSxXOztBQU1BO0FBQ0E7OztBQUNBO0FBQUE7Ozs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0EsaUJBSEEsRUFHQSxFQUhBO0FBSUE7O0FBQ0E7O0FBR0E7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSxpQixNQUFBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFUQSxNQVNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFBQTs7QUFBQTtBQUNBO0FBQUE7O0FBQUE7O0FBQ0E7QUFDQSxlLEVBQUE7QUFDQTtBQUNBO0FBQUE7O0FBQUE7QUFDQSxlO0FBQ0EsYTtBQUNBO0FBRUE7O0FBQ0E7QUFDQTtBQUFBOzs7QUFFQTtBQUNBO0FBQ0EsYTtBQUNBO0FBRUE7QUFDQSxhO0FBQ0E7QUFFQTtBQUNBO0FBQUE7OztBQUVBO0FBQ0E7QUFDQTs7O0FBdkZBLE87Ozs7Ozs7Ozs7QUEvQ0E7QUFBQTs7QUFBQTs7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O005RkFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBK0ZpUUEsc0M7QUFDQTs7O0FBSUE7QUFDQTtBQUNBLHlCQURBO0FBRUE7QUFGQTtBQURBO0FBQ0EsVzs7QUFRQTtBQUNBO0FBQ0E7QUFDQTs7O0FBSUE7QUFDQTtBQUNBLGE7QUFDQTtBQUVBO0FBQ0EsYTtBQUtBO0FBRUE7QUFDQSxhO0FBS0E7QUFFQTtBQUNBLGE7QUFLQTtBQUVBO0FBQ0E7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBM0VBLE87Ozs7Ozs7Ozs7QUF0UEE7QUFBQTs7QUFBQTs7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztNL0ZBQTs7Ozs7Ozs7Ozs7OztBZ0c2QkE7QUFDQSxvQkFEQTtBQUVBO0FBRkE7QUFDQSxXOztBQU1BO0FBQ0E7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsYTtBQUNBO0FBRUE7QUFDQTs7O0FBSUE7OztBQUNBOztBQUNBO0FBQ0EsYTs7QUFDQTtBQUNBOztBQTVDQSxPOzs7Ozs7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QUFDQSxhO0FBQ0E7QUFFQTs7QUFDQTtBQUNBO0FBQUE7Ozs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsYTtBQUNBO0FBRUE7QUFDQTtBQUNBLGE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGE7QUFDQTtBQVFBO0FBQ0E7Ozs7QUFLQTtBQUFBOztBQUdBO0FBQ0EsYTtBQUNBO0FBVUE7QUFDQTs7QUFHQTtBQUNBOztBQUdBO0FBQ0E7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLGE7QUFDQTtBQVFBOztBQUNBO0FBQ0E7QUFBQTs7O0FBRUE7O0FBR0E7O0FBR0E7QUFFQSxlLEVBQUE7QUFBQTtBQUNBLGU7QUFBQSxhO0FBRUE7QUFPQTs7QUFDQTtBQUNBO0FBQUE7Ozs7QUFFQTtBQUNBO0FBQUE7OztBQUVBO0FBRUEsZSxFQUFBO0FBQUE7QUFDQSxlLEVBQUEsSTs7QUFJQSxhO0FBQ0E7QUFRQTs7QUFDQTtBQUNBO0FBQUE7Ozs7QUFJQTs7O0FBS0E7QUFFQSxlLEVBQUE7QUFBQTtBQUNBLGUsRUFBQSxJO0FBQUEsYTtBQUdBO0FBT0E7O0FBQ0E7QUFDQTtBQUFBOzs7O0FBSUE7QUFHQTtBQUNBLGUsRUFBQTtBQUNBO0FBRUE7QUFDQSxlLEVBQUEsSTtBQUNBLGE7QUFHQTtBQVFBOzs7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFLQTtBQUNBOzs7QUFLQSxlOzs7QUFHQTtBQUNBO0FBQ0E7O0FBR0E7OztBQUdBO0FBQ0EsZTs7O0FBR0E7QUFDQSxhO0FBQ0E7QUFPQTtBQUNBO0FBQUE7OztBQUVBO0FBQ0E7QUFDQTtBQUNBLGE7QUFDQTtBQU9BO0FBQ0E7QUFBQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYTtBQUNBO0FBUUE7Ozs7QUFDQTtBQUNBO0FBQUE7OztBQUVBOztBQUdBO0FBQ0E7O0FBR0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFBQSxpQixNQUFBO0FBQUE7QUFDQTs7Ozs7QUFJQTtBQUNBO0FBRUEsbUJBSEEsRUFHQTtBQUFBO0FBQ0EsbUJBSkE7QUFJQTtBQUVBLGU7QUFDQSxhO0FBQ0E7QUFTQTs7OztBQUNBO0FBQ0E7QUFBQTs7O0FBRUE7O0FBR0E7O0FBR0E7QUFDQTs7QUFHQTtBQUNBOztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxpQixNQUFBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7O0FBR0E7QUFDQTtBQUdBO0FBQ0EsbUJBTEEsRUFLQTtBQUNBO0FBRUE7QUFDQSxtQkFUQTtBQVVBO0FBRUEsZTtBQUNBLGE7QUFDQTtBQU9BO0FBQ0E7QUFDQSxhO0FBQ0E7QUFRQTs7QUFDQTtBQUNBO0FBQUE7OztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFBQTs7QUFBQTtBQUNBOztBQUdBO0FBRUEsZSxFQUFBO0FBQUE7QUFDQSxlO0FBQUEsYTtBQUVBO0FBT0E7O0FBQ0E7QUFDQTtBQUFBOzs7O0FBSUE7QUFFQSxlLEVBQUE7QUFBQTtBQUNBLGUsRUFBQSxJOztBQUlBLGE7QUFDQTtBQVFBOzs7O0FBQ0E7QUFDQTtBQUFBOzs7QUFFQTs7O0FBS0E7OztBQUtBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7OztBQUdBO0FBQ0E7QUFFQSxtQkFIQSxFQUdBO0FBQUE7QUFDQSxtQkFKQTtBQUlBO0FBRUEsZTtBQUNBLGE7QUFDQTtBQVFBOzs7O0FBQ0E7QUFDQTtBQUFBOzs7QUFFQTs7O0FBS0E7O0FBR0E7O0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFFQSxtQkFIQSxFQUdBO0FBQUE7QUFDQSxtQkFKQTtBQUlBO0FBRUEsZTtBQUNBLGE7QUFDQTtBQVFBOzs7O0FBQ0E7QUFDQTtBQUFBOzs7QUFFQTs7O0FBS0E7O0FBR0E7O0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFFQSxtQkFIQSxFQUdBO0FBQUE7QUFDQSxtQkFKQTtBQUlBO0FBRUEsZTtBQUNBLGE7QUFDQTtBQUVBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxpQixNQUFBO0FBQ0E7QUFDQTtBQUNBLG1CQUZBLE1BRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsZTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLGU7OztBQUdBO0FBQ0EsYTtBQUNBO0FBRUE7OztBQUNBO0FBQUE7OztBQUVBOztBQUdBLHNDO0FBQ0Esc0M7QUFDQTtBQUNBLGtDQURBO0FBR0E7QUFDQTtBQUNBO0FBTEEsbUJBTUE7QUFKQSxnQ0FJQTtBQUdBO0FBQ0E7QUFDQTtBQUxBLGlCQU5BOztBQUZBLGE7QUFrQkE7QUFFQTtBQUNBOzs7QUFHQTtBQUNBLGUsTUFBQTtBQUNBO0FBQ0EsZUFGQSxNQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSxhO0FBQ0E7QUFFQTs7O0FBQ0E7QUFDQTs7QUFHQTs7QUFDQTtBQUNBLGU7QUFDQTs7O0FBSUE7QUFDQTtBQUNBOzs7QUFJQTtBQUNBO0FBQ0E7OztBQUlBOzs7QUFDQTtBQUNBO0FBQ0EsYTs7QUFHQTtBQUNBOzs7QUFHQSxhOztBQUdBO0FBQ0EsYTs7QUFHQTtBQUNBLGE7QUFDQTtBQUNBLFc7QUFDQTtBQUVBO0FBQ0E7O0FBandCQSxPOzs7Ozs7Ozs7O0FBbFFBO0FBQUE7O0FBQUE7O0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTs7Ozs7Ozs7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OztBQUVyRDtBQUNBOzs7O0FBSUEsZUFBZTs7QUFFZjtBQUNBOztBQUVBLGFBQWEsbUJBQU8sQ0FBQyxzR0FBbUQ7O0FBRXhFOztBQUVBLEdBQUcsS0FBVSxFQUFFLEU7Ozs7Ozs7Ozs7O0FDbkJmLGU7Ozs7Ozs7Ozs7O0FDQUEsZSIsImZpbGUiOiJidW5kbGUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBnZXR0ZXIgfSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiBcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4gXHRcdH1cbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiBcdH07XG5cbiBcdC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbiBcdC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbiBcdFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XG4gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG4gXHRcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbiBcdFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xuIFx0XHRyZXR1cm4gbnM7XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gXCIuL3NyYy9tYWluLmpzXCIpO1xuIiwiKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gcihlLG4sdCl7ZnVuY3Rpb24gbyhpLGYpe2lmKCFuW2ldKXtpZighZVtpXSl7dmFyIGM9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZTtpZighZiYmYylyZXR1cm4gYyhpLCEwKTtpZih1KXJldHVybiB1KGksITApO3ZhciBhPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIraStcIidcIik7dGhyb3cgYS5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGF9dmFyIHA9bltpXT17ZXhwb3J0czp7fX07ZVtpXVswXS5jYWxsKHAuZXhwb3J0cyxmdW5jdGlvbihyKXt2YXIgbj1lW2ldWzFdW3JdO3JldHVybiBvKG58fHIpfSxwLHAuZXhwb3J0cyxyLGUsbix0KX1yZXR1cm4gbltpXS5leHBvcnRzfWZvcih2YXIgdT1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlLGk9MDtpPHQubGVuZ3RoO2krKylvKHRbaV0pO3JldHVybiBvfXJldHVybiByfSkoKSIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2Zyb20gPSByZXF1aXJlKFwiLi4vY29yZS1qcy9hcnJheS9mcm9tXCIpO1xuXG52YXIgX2Zyb20yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZnJvbSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkge1xuICAgIGZvciAodmFyIGkgPSAwLCBhcnIyID0gQXJyYXkoYXJyLmxlbmd0aCk7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFycjJbaV0gPSBhcnJbaV07XG4gICAgfVxuXG4gICAgcmV0dXJuIGFycjI7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuICgwLCBfZnJvbTIuZGVmYXVsdCkoYXJyKTtcbiAgfVxufTsiLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3InKTtcbnJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2LmFycmF5LmZyb20nKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLkFycmF5LmZyb207XG4iLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5tYXRoLmxvZzEwJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5NYXRoLmxvZzEwO1xuIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYubWF0aC5zaWduJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5NYXRoLnNpZ247XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAodHlwZW9mIGl0ICE9ICdmdW5jdGlvbicpIHRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGEgZnVuY3Rpb24hJyk7XG4gIHJldHVybiBpdDtcbn07XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmICghaXNPYmplY3QoaXQpKSB0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBhbiBvYmplY3QhJyk7XG4gIHJldHVybiBpdDtcbn07XG4iLCIvLyBmYWxzZSAtPiBBcnJheSNpbmRleE9mXG4vLyB0cnVlICAtPiBBcnJheSNpbmNsdWRlc1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIHRvQWJzb2x1dGVJbmRleCA9IHJlcXVpcmUoJy4vX3RvLWFic29sdXRlLWluZGV4Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChJU19JTkNMVURFUykge1xuICByZXR1cm4gZnVuY3Rpb24gKCR0aGlzLCBlbCwgZnJvbUluZGV4KSB7XG4gICAgdmFyIE8gPSB0b0lPYmplY3QoJHRoaXMpO1xuICAgIHZhciBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aCk7XG4gICAgdmFyIGluZGV4ID0gdG9BYnNvbHV0ZUluZGV4KGZyb21JbmRleCwgbGVuZ3RoKTtcbiAgICB2YXIgdmFsdWU7XG4gICAgLy8gQXJyYXkjaW5jbHVkZXMgdXNlcyBTYW1lVmFsdWVaZXJvIGVxdWFsaXR5IGFsZ29yaXRobVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgICBpZiAoSVNfSU5DTFVERVMgJiYgZWwgIT0gZWwpIHdoaWxlIChsZW5ndGggPiBpbmRleCkge1xuICAgICAgdmFsdWUgPSBPW2luZGV4KytdO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgICAgaWYgKHZhbHVlICE9IHZhbHVlKSByZXR1cm4gdHJ1ZTtcbiAgICAvLyBBcnJheSNpbmRleE9mIGlnbm9yZXMgaG9sZXMsIEFycmF5I2luY2x1ZGVzIC0gbm90XG4gICAgfSBlbHNlIGZvciAoO2xlbmd0aCA+IGluZGV4OyBpbmRleCsrKSBpZiAoSVNfSU5DTFVERVMgfHwgaW5kZXggaW4gTykge1xuICAgICAgaWYgKE9baW5kZXhdID09PSBlbCkgcmV0dXJuIElTX0lOQ0xVREVTIHx8IGluZGV4IHx8IDA7XG4gICAgfSByZXR1cm4gIUlTX0lOQ0xVREVTICYmIC0xO1xuICB9O1xufTtcbiIsIi8vIGdldHRpbmcgdGFnIGZyb20gMTkuMS4zLjYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZygpXG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG52YXIgVEFHID0gcmVxdWlyZSgnLi9fd2tzJykoJ3RvU3RyaW5nVGFnJyk7XG4vLyBFUzMgd3JvbmcgaGVyZVxudmFyIEFSRyA9IGNvZihmdW5jdGlvbiAoKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPT0gJ0FyZ3VtZW50cyc7XG5cbi8vIGZhbGxiYWNrIGZvciBJRTExIFNjcmlwdCBBY2Nlc3MgRGVuaWVkIGVycm9yXG52YXIgdHJ5R2V0ID0gZnVuY3Rpb24gKGl0LCBrZXkpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gaXRba2V5XTtcbiAgfSBjYXRjaCAoZSkgeyAvKiBlbXB0eSAqLyB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgTywgVCwgQjtcbiAgcmV0dXJuIGl0ID09PSB1bmRlZmluZWQgPyAnVW5kZWZpbmVkJyA6IGl0ID09PSBudWxsID8gJ051bGwnXG4gICAgLy8gQEB0b1N0cmluZ1RhZyBjYXNlXG4gICAgOiB0eXBlb2YgKFQgPSB0cnlHZXQoTyA9IE9iamVjdChpdCksIFRBRykpID09ICdzdHJpbmcnID8gVFxuICAgIC8vIGJ1aWx0aW5UYWcgY2FzZVxuICAgIDogQVJHID8gY29mKE8pXG4gICAgLy8gRVMzIGFyZ3VtZW50cyBmYWxsYmFja1xuICAgIDogKEIgPSBjb2YoTykpID09ICdPYmplY3QnICYmIHR5cGVvZiBPLmNhbGxlZSA9PSAnZnVuY3Rpb24nID8gJ0FyZ3VtZW50cycgOiBCO1xufTtcbiIsInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChpdCkuc2xpY2UoOCwgLTEpO1xufTtcbiIsInZhciBjb3JlID0gbW9kdWxlLmV4cG9ydHMgPSB7IHZlcnNpb246ICcyLjUuNycgfTtcbmlmICh0eXBlb2YgX19lID09ICdudW1iZXInKSBfX2UgPSBjb3JlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4iLCIndXNlIHN0cmljdCc7XG52YXIgJGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG52YXIgY3JlYXRlRGVzYyA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqZWN0LCBpbmRleCwgdmFsdWUpIHtcbiAgaWYgKGluZGV4IGluIG9iamVjdCkgJGRlZmluZVByb3BlcnR5LmYob2JqZWN0LCBpbmRleCwgY3JlYXRlRGVzYygwLCB2YWx1ZSkpO1xuICBlbHNlIG9iamVjdFtpbmRleF0gPSB2YWx1ZTtcbn07XG4iLCIvLyBvcHRpb25hbCAvIHNpbXBsZSBjb250ZXh0IGJpbmRpbmdcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChmbiwgdGhhdCwgbGVuZ3RoKSB7XG4gIGFGdW5jdGlvbihmbik7XG4gIGlmICh0aGF0ID09PSB1bmRlZmluZWQpIHJldHVybiBmbjtcbiAgc3dpdGNoIChsZW5ndGgpIHtcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jdGlvbiAoYSkge1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSk7XG4gICAgfTtcbiAgICBjYXNlIDI6IHJldHVybiBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYik7XG4gICAgfTtcbiAgICBjYXNlIDM6IHJldHVybiBmdW5jdGlvbiAoYSwgYiwgYykge1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYiwgYyk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24gKC8qIC4uLmFyZ3MgKi8pIHtcbiAgICByZXR1cm4gZm4uYXBwbHkodGhhdCwgYXJndW1lbnRzKTtcbiAgfTtcbn07XG4iLCIvLyA3LjIuMSBSZXF1aXJlT2JqZWN0Q29lcmNpYmxlKGFyZ3VtZW50KVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKGl0ID09IHVuZGVmaW5lZCkgdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY2FsbCBtZXRob2Qgb24gIFwiICsgaXQpO1xuICByZXR1cm4gaXQ7XG59O1xuIiwiLy8gVGhhbmsncyBJRTggZm9yIGhpcyBmdW5ueSBkZWZpbmVQcm9wZXJ0eVxubW9kdWxlLmV4cG9ydHMgPSAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdhJywgeyBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDc7IH0gfSkuYSAhPSA3O1xufSk7XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBkb2N1bWVudCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLmRvY3VtZW50O1xuLy8gdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgaXMgJ29iamVjdCcgaW4gb2xkIElFXG52YXIgaXMgPSBpc09iamVjdChkb2N1bWVudCkgJiYgaXNPYmplY3QoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXMgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGl0KSA6IHt9O1xufTtcbiIsIi8vIElFIDgtIGRvbid0IGVudW0gYnVnIGtleXNcbm1vZHVsZS5leHBvcnRzID0gKFxuICAnY29uc3RydWN0b3IsaGFzT3duUHJvcGVydHksaXNQcm90b3R5cGVPZixwcm9wZXJ0eUlzRW51bWVyYWJsZSx0b0xvY2FsZVN0cmluZyx0b1N0cmluZyx2YWx1ZU9mJ1xuKS5zcGxpdCgnLCcpO1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGNvcmUgPSByZXF1aXJlKCcuL19jb3JlJyk7XG52YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcblxudmFyICRleHBvcnQgPSBmdW5jdGlvbiAodHlwZSwgbmFtZSwgc291cmNlKSB7XG4gIHZhciBJU19GT1JDRUQgPSB0eXBlICYgJGV4cG9ydC5GO1xuICB2YXIgSVNfR0xPQkFMID0gdHlwZSAmICRleHBvcnQuRztcbiAgdmFyIElTX1NUQVRJQyA9IHR5cGUgJiAkZXhwb3J0LlM7XG4gIHZhciBJU19QUk9UTyA9IHR5cGUgJiAkZXhwb3J0LlA7XG4gIHZhciBJU19CSU5EID0gdHlwZSAmICRleHBvcnQuQjtcbiAgdmFyIElTX1dSQVAgPSB0eXBlICYgJGV4cG9ydC5XO1xuICB2YXIgZXhwb3J0cyA9IElTX0dMT0JBTCA/IGNvcmUgOiBjb3JlW25hbWVdIHx8IChjb3JlW25hbWVdID0ge30pO1xuICB2YXIgZXhwUHJvdG8gPSBleHBvcnRzW1BST1RPVFlQRV07XG4gIHZhciB0YXJnZXQgPSBJU19HTE9CQUwgPyBnbG9iYWwgOiBJU19TVEFUSUMgPyBnbG9iYWxbbmFtZV0gOiAoZ2xvYmFsW25hbWVdIHx8IHt9KVtQUk9UT1RZUEVdO1xuICB2YXIga2V5LCBvd24sIG91dDtcbiAgaWYgKElTX0dMT0JBTCkgc291cmNlID0gbmFtZTtcbiAgZm9yIChrZXkgaW4gc291cmNlKSB7XG4gICAgLy8gY29udGFpbnMgaW4gbmF0aXZlXG4gICAgb3duID0gIUlTX0ZPUkNFRCAmJiB0YXJnZXQgJiYgdGFyZ2V0W2tleV0gIT09IHVuZGVmaW5lZDtcbiAgICBpZiAob3duICYmIGhhcyhleHBvcnRzLCBrZXkpKSBjb250aW51ZTtcbiAgICAvLyBleHBvcnQgbmF0aXZlIG9yIHBhc3NlZFxuICAgIG91dCA9IG93biA/IHRhcmdldFtrZXldIDogc291cmNlW2tleV07XG4gICAgLy8gcHJldmVudCBnbG9iYWwgcG9sbHV0aW9uIGZvciBuYW1lc3BhY2VzXG4gICAgZXhwb3J0c1trZXldID0gSVNfR0xPQkFMICYmIHR5cGVvZiB0YXJnZXRba2V5XSAhPSAnZnVuY3Rpb24nID8gc291cmNlW2tleV1cbiAgICAvLyBiaW5kIHRpbWVycyB0byBnbG9iYWwgZm9yIGNhbGwgZnJvbSBleHBvcnQgY29udGV4dFxuICAgIDogSVNfQklORCAmJiBvd24gPyBjdHgob3V0LCBnbG9iYWwpXG4gICAgLy8gd3JhcCBnbG9iYWwgY29uc3RydWN0b3JzIGZvciBwcmV2ZW50IGNoYW5nZSB0aGVtIGluIGxpYnJhcnlcbiAgICA6IElTX1dSQVAgJiYgdGFyZ2V0W2tleV0gPT0gb3V0ID8gKGZ1bmN0aW9uIChDKSB7XG4gICAgICB2YXIgRiA9IGZ1bmN0aW9uIChhLCBiLCBjKSB7XG4gICAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgQykge1xuICAgICAgICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gbmV3IEMoKTtcbiAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIG5ldyBDKGEpO1xuICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gbmV3IEMoYSwgYik7XG4gICAgICAgICAgfSByZXR1cm4gbmV3IEMoYSwgYiwgYyk7XG4gICAgICAgIH0gcmV0dXJuIEMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH07XG4gICAgICBGW1BST1RPVFlQRV0gPSBDW1BST1RPVFlQRV07XG4gICAgICByZXR1cm4gRjtcbiAgICAvLyBtYWtlIHN0YXRpYyB2ZXJzaW9ucyBmb3IgcHJvdG90eXBlIG1ldGhvZHNcbiAgICB9KShvdXQpIDogSVNfUFJPVE8gJiYgdHlwZW9mIG91dCA9PSAnZnVuY3Rpb24nID8gY3R4KEZ1bmN0aW9uLmNhbGwsIG91dCkgOiBvdXQ7XG4gICAgLy8gZXhwb3J0IHByb3RvIG1ldGhvZHMgdG8gY29yZS4lQ09OU1RSVUNUT1IlLm1ldGhvZHMuJU5BTUUlXG4gICAgaWYgKElTX1BST1RPKSB7XG4gICAgICAoZXhwb3J0cy52aXJ0dWFsIHx8IChleHBvcnRzLnZpcnR1YWwgPSB7fSkpW2tleV0gPSBvdXQ7XG4gICAgICAvLyBleHBvcnQgcHJvdG8gbWV0aG9kcyB0byBjb3JlLiVDT05TVFJVQ1RPUiUucHJvdG90eXBlLiVOQU1FJVxuICAgICAgaWYgKHR5cGUgJiAkZXhwb3J0LlIgJiYgZXhwUHJvdG8gJiYgIWV4cFByb3RvW2tleV0pIGhpZGUoZXhwUHJvdG8sIGtleSwgb3V0KTtcbiAgICB9XG4gIH1cbn07XG4vLyB0eXBlIGJpdG1hcFxuJGV4cG9ydC5GID0gMTsgICAvLyBmb3JjZWRcbiRleHBvcnQuRyA9IDI7ICAgLy8gZ2xvYmFsXG4kZXhwb3J0LlMgPSA0OyAgIC8vIHN0YXRpY1xuJGV4cG9ydC5QID0gODsgICAvLyBwcm90b1xuJGV4cG9ydC5CID0gMTY7ICAvLyBiaW5kXG4kZXhwb3J0LlcgPSAzMjsgIC8vIHdyYXBcbiRleHBvcnQuVSA9IDY0OyAgLy8gc2FmZVxuJGV4cG9ydC5SID0gMTI4OyAvLyByZWFsIHByb3RvIG1ldGhvZCBmb3IgYGxpYnJhcnlgXG5tb2R1bGUuZXhwb3J0cyA9ICRleHBvcnQ7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChleGVjKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuICEhZXhlYygpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG4iLCIvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvODYjaXNzdWVjb21tZW50LTExNTc1OTAyOFxudmFyIGdsb2JhbCA9IG1vZHVsZS5leHBvcnRzID0gdHlwZW9mIHdpbmRvdyAhPSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuTWF0aCA9PSBNYXRoXG4gID8gd2luZG93IDogdHlwZW9mIHNlbGYgIT0gJ3VuZGVmaW5lZCcgJiYgc2VsZi5NYXRoID09IE1hdGggPyBzZWxmXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXctZnVuY1xuICA6IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5pZiAodHlwZW9mIF9fZyA9PSAnbnVtYmVyJykgX19nID0gZ2xvYmFsOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4iLCJ2YXIgaGFzT3duUHJvcGVydHkgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCBrZXkpIHtcbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoaXQsIGtleSk7XG59O1xuIiwidmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG52YXIgY3JlYXRlRGVzYyA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgcmV0dXJuIGRQLmYob2JqZWN0LCBrZXksIGNyZWF0ZURlc2MoMSwgdmFsdWUpKTtcbn0gOiBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIG9iamVjdFtrZXldID0gdmFsdWU7XG4gIHJldHVybiBvYmplY3Q7XG59O1xuIiwidmFyIGRvY3VtZW50ID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuZG9jdW1lbnQ7XG5tb2R1bGUuZXhwb3J0cyA9IGRvY3VtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiIsIm1vZHVsZS5leHBvcnRzID0gIXJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlcXVpcmUoJy4vX2RvbS1jcmVhdGUnKSgnZGl2JyksICdhJywgeyBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDc7IH0gfSkuYSAhPSA3O1xufSk7XG4iLCIvLyBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIGFuZCBub24tZW51bWVyYWJsZSBvbGQgVjggc3RyaW5nc1xudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGluc1xubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QoJ3onKS5wcm9wZXJ0eUlzRW51bWVyYWJsZSgwKSA/IE9iamVjdCA6IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gY29mKGl0KSA9PSAnU3RyaW5nJyA/IGl0LnNwbGl0KCcnKSA6IE9iamVjdChpdCk7XG59O1xuIiwiLy8gY2hlY2sgb24gZGVmYXVsdCBBcnJheSBpdGVyYXRvclxudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpO1xudmFyIElURVJBVE9SID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyk7XG52YXIgQXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGl0ICE9PSB1bmRlZmluZWQgJiYgKEl0ZXJhdG9ycy5BcnJheSA9PT0gaXQgfHwgQXJyYXlQcm90b1tJVEVSQVRPUl0gPT09IGl0KTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdHlwZW9mIGl0ID09PSAnb2JqZWN0JyA/IGl0ICE9PSBudWxsIDogdHlwZW9mIGl0ID09PSAnZnVuY3Rpb24nO1xufTtcbiIsIi8vIGNhbGwgc29tZXRoaW5nIG9uIGl0ZXJhdG9yIHN0ZXAgd2l0aCBzYWZlIGNsb3Npbmcgb24gZXJyb3JcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXRlcmF0b3IsIGZuLCB2YWx1ZSwgZW50cmllcykge1xuICB0cnkge1xuICAgIHJldHVybiBlbnRyaWVzID8gZm4oYW5PYmplY3QodmFsdWUpWzBdLCB2YWx1ZVsxXSkgOiBmbih2YWx1ZSk7XG4gIC8vIDcuNC42IEl0ZXJhdG9yQ2xvc2UoaXRlcmF0b3IsIGNvbXBsZXRpb24pXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB2YXIgcmV0ID0gaXRlcmF0b3JbJ3JldHVybiddO1xuICAgIGlmIChyZXQgIT09IHVuZGVmaW5lZCkgYW5PYmplY3QocmV0LmNhbGwoaXRlcmF0b3IpKTtcbiAgICB0aHJvdyBlO1xuICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGNyZWF0ZSA9IHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKTtcbnZhciBkZXNjcmlwdG9yID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpO1xudmFyIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKTtcbnZhciBJdGVyYXRvclByb3RvdHlwZSA9IHt9O1xuXG4vLyAyNS4xLjIuMS4xICVJdGVyYXRvclByb3RvdHlwZSVbQEBpdGVyYXRvcl0oKVxucmVxdWlyZSgnLi9faGlkZScpKEl0ZXJhdG9yUHJvdG90eXBlLCByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBOQU1FLCBuZXh0KSB7XG4gIENvbnN0cnVjdG9yLnByb3RvdHlwZSA9IGNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSwgeyBuZXh0OiBkZXNjcmlwdG9yKDEsIG5leHQpIH0pO1xuICBzZXRUb1N0cmluZ1RhZyhDb25zdHJ1Y3RvciwgTkFNRSArICcgSXRlcmF0b3InKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgTElCUkFSWSA9IHJlcXVpcmUoJy4vX2xpYnJhcnknKTtcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuL19yZWRlZmluZScpO1xudmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJyk7XG52YXIgJGl0ZXJDcmVhdGUgPSByZXF1aXJlKCcuL19pdGVyLWNyZWF0ZScpO1xudmFyIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKTtcbnZhciBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKTtcbnZhciBJVEVSQVRPUiA9IHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpO1xudmFyIEJVR0dZID0gIShbXS5rZXlzICYmICduZXh0JyBpbiBbXS5rZXlzKCkpOyAvLyBTYWZhcmkgaGFzIGJ1Z2d5IGl0ZXJhdG9ycyB3L28gYG5leHRgXG52YXIgRkZfSVRFUkFUT1IgPSAnQEBpdGVyYXRvcic7XG52YXIgS0VZUyA9ICdrZXlzJztcbnZhciBWQUxVRVMgPSAndmFsdWVzJztcblxudmFyIHJldHVyblRoaXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChCYXNlLCBOQU1FLCBDb25zdHJ1Y3RvciwgbmV4dCwgREVGQVVMVCwgSVNfU0VULCBGT1JDRUQpIHtcbiAgJGl0ZXJDcmVhdGUoQ29uc3RydWN0b3IsIE5BTUUsIG5leHQpO1xuICB2YXIgZ2V0TWV0aG9kID0gZnVuY3Rpb24gKGtpbmQpIHtcbiAgICBpZiAoIUJVR0dZICYmIGtpbmQgaW4gcHJvdG8pIHJldHVybiBwcm90b1traW5kXTtcbiAgICBzd2l0Y2ggKGtpbmQpIHtcbiAgICAgIGNhc2UgS0VZUzogcmV0dXJuIGZ1bmN0aW9uIGtleXMoKSB7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gICAgICBjYXNlIFZBTFVFUzogcmV0dXJuIGZ1bmN0aW9uIHZhbHVlcygpIHsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgICB9IHJldHVybiBmdW5jdGlvbiBlbnRyaWVzKCkgeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICB9O1xuICB2YXIgVEFHID0gTkFNRSArICcgSXRlcmF0b3InO1xuICB2YXIgREVGX1ZBTFVFUyA9IERFRkFVTFQgPT0gVkFMVUVTO1xuICB2YXIgVkFMVUVTX0JVRyA9IGZhbHNlO1xuICB2YXIgcHJvdG8gPSBCYXNlLnByb3RvdHlwZTtcbiAgdmFyICRuYXRpdmUgPSBwcm90b1tJVEVSQVRPUl0gfHwgcHJvdG9bRkZfSVRFUkFUT1JdIHx8IERFRkFVTFQgJiYgcHJvdG9bREVGQVVMVF07XG4gIHZhciAkZGVmYXVsdCA9ICRuYXRpdmUgfHwgZ2V0TWV0aG9kKERFRkFVTFQpO1xuICB2YXIgJGVudHJpZXMgPSBERUZBVUxUID8gIURFRl9WQUxVRVMgPyAkZGVmYXVsdCA6IGdldE1ldGhvZCgnZW50cmllcycpIDogdW5kZWZpbmVkO1xuICB2YXIgJGFueU5hdGl2ZSA9IE5BTUUgPT0gJ0FycmF5JyA/IHByb3RvLmVudHJpZXMgfHwgJG5hdGl2ZSA6ICRuYXRpdmU7XG4gIHZhciBtZXRob2RzLCBrZXksIEl0ZXJhdG9yUHJvdG90eXBlO1xuICAvLyBGaXggbmF0aXZlXG4gIGlmICgkYW55TmF0aXZlKSB7XG4gICAgSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90b3R5cGVPZigkYW55TmF0aXZlLmNhbGwobmV3IEJhc2UoKSkpO1xuICAgIGlmIChJdGVyYXRvclByb3RvdHlwZSAhPT0gT2JqZWN0LnByb3RvdHlwZSAmJiBJdGVyYXRvclByb3RvdHlwZS5uZXh0KSB7XG4gICAgICAvLyBTZXQgQEB0b1N0cmluZ1RhZyB0byBuYXRpdmUgaXRlcmF0b3JzXG4gICAgICBzZXRUb1N0cmluZ1RhZyhJdGVyYXRvclByb3RvdHlwZSwgVEFHLCB0cnVlKTtcbiAgICAgIC8vIGZpeCBmb3Igc29tZSBvbGQgZW5naW5lc1xuICAgICAgaWYgKCFMSUJSQVJZICYmIHR5cGVvZiBJdGVyYXRvclByb3RvdHlwZVtJVEVSQVRPUl0gIT0gJ2Z1bmN0aW9uJykgaGlkZShJdGVyYXRvclByb3RvdHlwZSwgSVRFUkFUT1IsIHJldHVyblRoaXMpO1xuICAgIH1cbiAgfVxuICAvLyBmaXggQXJyYXkje3ZhbHVlcywgQEBpdGVyYXRvcn0ubmFtZSBpbiBWOCAvIEZGXG4gIGlmIChERUZfVkFMVUVTICYmICRuYXRpdmUgJiYgJG5hdGl2ZS5uYW1lICE9PSBWQUxVRVMpIHtcbiAgICBWQUxVRVNfQlVHID0gdHJ1ZTtcbiAgICAkZGVmYXVsdCA9IGZ1bmN0aW9uIHZhbHVlcygpIHsgcmV0dXJuICRuYXRpdmUuY2FsbCh0aGlzKTsgfTtcbiAgfVxuICAvLyBEZWZpbmUgaXRlcmF0b3JcbiAgaWYgKCghTElCUkFSWSB8fCBGT1JDRUQpICYmIChCVUdHWSB8fCBWQUxVRVNfQlVHIHx8ICFwcm90b1tJVEVSQVRPUl0pKSB7XG4gICAgaGlkZShwcm90bywgSVRFUkFUT1IsICRkZWZhdWx0KTtcbiAgfVxuICAvLyBQbHVnIGZvciBsaWJyYXJ5XG4gIEl0ZXJhdG9yc1tOQU1FXSA9ICRkZWZhdWx0O1xuICBJdGVyYXRvcnNbVEFHXSA9IHJldHVyblRoaXM7XG4gIGlmIChERUZBVUxUKSB7XG4gICAgbWV0aG9kcyA9IHtcbiAgICAgIHZhbHVlczogREVGX1ZBTFVFUyA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKFZBTFVFUyksXG4gICAgICBrZXlzOiBJU19TRVQgPyAkZGVmYXVsdCA6IGdldE1ldGhvZChLRVlTKSxcbiAgICAgIGVudHJpZXM6ICRlbnRyaWVzXG4gICAgfTtcbiAgICBpZiAoRk9SQ0VEKSBmb3IgKGtleSBpbiBtZXRob2RzKSB7XG4gICAgICBpZiAoIShrZXkgaW4gcHJvdG8pKSByZWRlZmluZShwcm90bywga2V5LCBtZXRob2RzW2tleV0pO1xuICAgIH0gZWxzZSAkZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIChCVUdHWSB8fCBWQUxVRVNfQlVHKSwgTkFNRSwgbWV0aG9kcyk7XG4gIH1cbiAgcmV0dXJuIG1ldGhvZHM7XG59O1xuIiwidmFyIElURVJBVE9SID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyk7XG52YXIgU0FGRV9DTE9TSU5HID0gZmFsc2U7XG5cbnRyeSB7XG4gIHZhciByaXRlciA9IFs3XVtJVEVSQVRPUl0oKTtcbiAgcml0ZXJbJ3JldHVybiddID0gZnVuY3Rpb24gKCkgeyBTQUZFX0NMT1NJTkcgPSB0cnVlOyB9O1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdGhyb3ctbGl0ZXJhbFxuICBBcnJheS5mcm9tKHJpdGVyLCBmdW5jdGlvbiAoKSB7IHRocm93IDI7IH0pO1xufSBjYXRjaCAoZSkgeyAvKiBlbXB0eSAqLyB9XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGV4ZWMsIHNraXBDbG9zaW5nKSB7XG4gIGlmICghc2tpcENsb3NpbmcgJiYgIVNBRkVfQ0xPU0lORykgcmV0dXJuIGZhbHNlO1xuICB2YXIgc2FmZSA9IGZhbHNlO1xuICB0cnkge1xuICAgIHZhciBhcnIgPSBbN107XG4gICAgdmFyIGl0ZXIgPSBhcnJbSVRFUkFUT1JdKCk7XG4gICAgaXRlci5uZXh0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4geyBkb25lOiBzYWZlID0gdHJ1ZSB9OyB9O1xuICAgIGFycltJVEVSQVRPUl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiBpdGVyOyB9O1xuICAgIGV4ZWMoYXJyKTtcbiAgfSBjYXRjaCAoZSkgeyAvKiBlbXB0eSAqLyB9XG4gIHJldHVybiBzYWZlO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge307XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHRydWU7XG4iLCIvLyAyMC4yLjIuMjggTWF0aC5zaWduKHgpXG5tb2R1bGUuZXhwb3J0cyA9IE1hdGguc2lnbiB8fCBmdW5jdGlvbiBzaWduKHgpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICByZXR1cm4gKHggPSAreCkgPT0gMCB8fCB4ICE9IHggPyB4IDogeCA8IDAgPyAtMSA6IDE7XG59O1xuIiwiLy8gMTkuMS4yLjIgLyAxNS4yLjMuNSBPYmplY3QuY3JlYXRlKE8gWywgUHJvcGVydGllc10pXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBkUHMgPSByZXF1aXJlKCcuL19vYmplY3QtZHBzJyk7XG52YXIgZW51bUJ1Z0tleXMgPSByZXF1aXJlKCcuL19lbnVtLWJ1Zy1rZXlzJyk7XG52YXIgSUVfUFJPVE8gPSByZXF1aXJlKCcuL19zaGFyZWQta2V5JykoJ0lFX1BST1RPJyk7XG52YXIgRW1wdHkgPSBmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH07XG52YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG5cbi8vIENyZWF0ZSBvYmplY3Qgd2l0aCBmYWtlIGBudWxsYCBwcm90b3R5cGU6IHVzZSBpZnJhbWUgT2JqZWN0IHdpdGggY2xlYXJlZCBwcm90b3R5cGVcbnZhciBjcmVhdGVEaWN0ID0gZnVuY3Rpb24gKCkge1xuICAvLyBUaHJhc2gsIHdhc3RlIGFuZCBzb2RvbXk6IElFIEdDIGJ1Z1xuICB2YXIgaWZyYW1lID0gcmVxdWlyZSgnLi9fZG9tLWNyZWF0ZScpKCdpZnJhbWUnKTtcbiAgdmFyIGkgPSBlbnVtQnVnS2V5cy5sZW5ndGg7XG4gIHZhciBsdCA9ICc8JztcbiAgdmFyIGd0ID0gJz4nO1xuICB2YXIgaWZyYW1lRG9jdW1lbnQ7XG4gIGlmcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICByZXF1aXJlKCcuL19odG1sJykuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcbiAgaWZyYW1lLnNyYyA9ICdqYXZhc2NyaXB0Oic7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2NyaXB0LXVybFxuICAvLyBjcmVhdGVEaWN0ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuT2JqZWN0O1xuICAvLyBodG1sLnJlbW92ZUNoaWxkKGlmcmFtZSk7XG4gIGlmcmFtZURvY3VtZW50ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQ7XG4gIGlmcmFtZURvY3VtZW50Lm9wZW4oKTtcbiAgaWZyYW1lRG9jdW1lbnQud3JpdGUobHQgKyAnc2NyaXB0JyArIGd0ICsgJ2RvY3VtZW50LkY9T2JqZWN0JyArIGx0ICsgJy9zY3JpcHQnICsgZ3QpO1xuICBpZnJhbWVEb2N1bWVudC5jbG9zZSgpO1xuICBjcmVhdGVEaWN0ID0gaWZyYW1lRG9jdW1lbnQuRjtcbiAgd2hpbGUgKGktLSkgZGVsZXRlIGNyZWF0ZURpY3RbUFJPVE9UWVBFXVtlbnVtQnVnS2V5c1tpXV07XG4gIHJldHVybiBjcmVhdGVEaWN0KCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5jcmVhdGUgfHwgZnVuY3Rpb24gY3JlYXRlKE8sIFByb3BlcnRpZXMpIHtcbiAgdmFyIHJlc3VsdDtcbiAgaWYgKE8gIT09IG51bGwpIHtcbiAgICBFbXB0eVtQUk9UT1RZUEVdID0gYW5PYmplY3QoTyk7XG4gICAgcmVzdWx0ID0gbmV3IEVtcHR5KCk7XG4gICAgRW1wdHlbUFJPVE9UWVBFXSA9IG51bGw7XG4gICAgLy8gYWRkIFwiX19wcm90b19fXCIgZm9yIE9iamVjdC5nZXRQcm90b3R5cGVPZiBwb2x5ZmlsbFxuICAgIHJlc3VsdFtJRV9QUk9UT10gPSBPO1xuICB9IGVsc2UgcmVzdWx0ID0gY3JlYXRlRGljdCgpO1xuICByZXR1cm4gUHJvcGVydGllcyA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogZFBzKHJlc3VsdCwgUHJvcGVydGllcyk7XG59O1xuIiwidmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgSUU4X0RPTV9ERUZJTkUgPSByZXF1aXJlKCcuL19pZTgtZG9tLWRlZmluZScpO1xudmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJyk7XG52YXIgZFAgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG5cbmV4cG9ydHMuZiA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKSB7XG4gIGFuT2JqZWN0KE8pO1xuICBQID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XG4gIGFuT2JqZWN0KEF0dHJpYnV0ZXMpO1xuICBpZiAoSUU4X0RPTV9ERUZJTkUpIHRyeSB7XG4gICAgcmV0dXJuIGRQKE8sIFAsIEF0dHJpYnV0ZXMpO1xuICB9IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cbiAgaWYgKCdnZXQnIGluIEF0dHJpYnV0ZXMgfHwgJ3NldCcgaW4gQXR0cmlidXRlcykgdGhyb3cgVHlwZUVycm9yKCdBY2Nlc3NvcnMgbm90IHN1cHBvcnRlZCEnKTtcbiAgaWYgKCd2YWx1ZScgaW4gQXR0cmlidXRlcykgT1tQXSA9IEF0dHJpYnV0ZXMudmFsdWU7XG4gIHJldHVybiBPO1xufTtcbiIsInZhciBkUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgZ2V0S2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzIDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKSB7XG4gIGFuT2JqZWN0KE8pO1xuICB2YXIga2V5cyA9IGdldEtleXMoUHJvcGVydGllcyk7XG4gIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgdmFyIGkgPSAwO1xuICB2YXIgUDtcbiAgd2hpbGUgKGxlbmd0aCA+IGkpIGRQLmYoTywgUCA9IGtleXNbaSsrXSwgUHJvcGVydGllc1tQXSk7XG4gIHJldHVybiBPO1xufTtcbiIsIi8vIDE5LjEuMi45IC8gMTUuMi4zLjIgT2JqZWN0LmdldFByb3RvdHlwZU9mKE8pXG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciBJRV9QUk9UTyA9IHJlcXVpcmUoJy4vX3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKTtcbnZhciBPYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmdldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIChPKSB7XG4gIE8gPSB0b09iamVjdChPKTtcbiAgaWYgKGhhcyhPLCBJRV9QUk9UTykpIHJldHVybiBPW0lFX1BST1RPXTtcbiAgaWYgKHR5cGVvZiBPLmNvbnN0cnVjdG9yID09ICdmdW5jdGlvbicgJiYgTyBpbnN0YW5jZW9mIE8uY29uc3RydWN0b3IpIHtcbiAgICByZXR1cm4gTy5jb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gIH0gcmV0dXJuIE8gaW5zdGFuY2VvZiBPYmplY3QgPyBPYmplY3RQcm90byA6IG51bGw7XG59O1xuIiwidmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbnZhciBhcnJheUluZGV4T2YgPSByZXF1aXJlKCcuL19hcnJheS1pbmNsdWRlcycpKGZhbHNlKTtcbnZhciBJRV9QUk9UTyA9IHJlcXVpcmUoJy4vX3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lcykge1xuICB2YXIgTyA9IHRvSU9iamVjdChvYmplY3QpO1xuICB2YXIgaSA9IDA7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIGtleTtcbiAgZm9yIChrZXkgaW4gTykgaWYgKGtleSAhPSBJRV9QUk9UTykgaGFzKE8sIGtleSkgJiYgcmVzdWx0LnB1c2goa2V5KTtcbiAgLy8gRG9uJ3QgZW51bSBidWcgJiBoaWRkZW4ga2V5c1xuICB3aGlsZSAobmFtZXMubGVuZ3RoID4gaSkgaWYgKGhhcyhPLCBrZXkgPSBuYW1lc1tpKytdKSkge1xuICAgIH5hcnJheUluZGV4T2YocmVzdWx0LCBrZXkpIHx8IHJlc3VsdC5wdXNoKGtleSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG4iLCIvLyAxOS4xLjIuMTQgLyAxNS4yLjMuMTQgT2JqZWN0LmtleXMoTylcbnZhciAka2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzLWludGVybmFsJyk7XG52YXIgZW51bUJ1Z0tleXMgPSByZXF1aXJlKCcuL19lbnVtLWJ1Zy1rZXlzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24ga2V5cyhPKSB7XG4gIHJldHVybiAka2V5cyhPLCBlbnVtQnVnS2V5cyk7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYml0bWFwLCB2YWx1ZSkge1xuICByZXR1cm4ge1xuICAgIGVudW1lcmFibGU6ICEoYml0bWFwICYgMSksXG4gICAgY29uZmlndXJhYmxlOiAhKGJpdG1hcCAmIDIpLFxuICAgIHdyaXRhYmxlOiAhKGJpdG1hcCAmIDQpLFxuICAgIHZhbHVlOiB2YWx1ZVxuICB9O1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9faGlkZScpO1xuIiwidmFyIGRlZiA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmY7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgVEFHID0gcmVxdWlyZSgnLi9fd2tzJykoJ3RvU3RyaW5nVGFnJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCB0YWcsIHN0YXQpIHtcbiAgaWYgKGl0ICYmICFoYXMoaXQgPSBzdGF0ID8gaXQgOiBpdC5wcm90b3R5cGUsIFRBRykpIGRlZihpdCwgVEFHLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgdmFsdWU6IHRhZyB9KTtcbn07XG4iLCJ2YXIgc2hhcmVkID0gcmVxdWlyZSgnLi9fc2hhcmVkJykoJ2tleXMnKTtcbnZhciB1aWQgPSByZXF1aXJlKCcuL191aWQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gc2hhcmVkW2tleV0gfHwgKHNoYXJlZFtrZXldID0gdWlkKGtleSkpO1xufTtcbiIsInZhciBjb3JlID0gcmVxdWlyZSgnLi9fY29yZScpO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIFNIQVJFRCA9ICdfX2NvcmUtanNfc2hhcmVkX18nO1xudmFyIHN0b3JlID0gZ2xvYmFsW1NIQVJFRF0gfHwgKGdsb2JhbFtTSEFSRURdID0ge30pO1xuXG4obW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICByZXR1cm4gc3RvcmVba2V5XSB8fCAoc3RvcmVba2V5XSA9IHZhbHVlICE9PSB1bmRlZmluZWQgPyB2YWx1ZSA6IHt9KTtcbn0pKCd2ZXJzaW9ucycsIFtdKS5wdXNoKHtcbiAgdmVyc2lvbjogY29yZS52ZXJzaW9uLFxuICBtb2RlOiByZXF1aXJlKCcuL19saWJyYXJ5JykgPyAncHVyZScgOiAnZ2xvYmFsJyxcbiAgY29weXJpZ2h0OiAnwqkgMjAxOCBEZW5pcyBQdXNoa2FyZXYgKHpsb2lyb2NrLnJ1KSdcbn0pO1xuIiwidmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKTtcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xuLy8gdHJ1ZSAgLT4gU3RyaW5nI2F0XG4vLyBmYWxzZSAtPiBTdHJpbmcjY29kZVBvaW50QXRcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFRPX1NUUklORykge1xuICByZXR1cm4gZnVuY3Rpb24gKHRoYXQsIHBvcykge1xuICAgIHZhciBzID0gU3RyaW5nKGRlZmluZWQodGhhdCkpO1xuICAgIHZhciBpID0gdG9JbnRlZ2VyKHBvcyk7XG4gICAgdmFyIGwgPSBzLmxlbmd0aDtcbiAgICB2YXIgYSwgYjtcbiAgICBpZiAoaSA8IDAgfHwgaSA+PSBsKSByZXR1cm4gVE9fU1RSSU5HID8gJycgOiB1bmRlZmluZWQ7XG4gICAgYSA9IHMuY2hhckNvZGVBdChpKTtcbiAgICByZXR1cm4gYSA8IDB4ZDgwMCB8fCBhID4gMHhkYmZmIHx8IGkgKyAxID09PSBsIHx8IChiID0gcy5jaGFyQ29kZUF0KGkgKyAxKSkgPCAweGRjMDAgfHwgYiA+IDB4ZGZmZlxuICAgICAgPyBUT19TVFJJTkcgPyBzLmNoYXJBdChpKSA6IGFcbiAgICAgIDogVE9fU1RSSU5HID8gcy5zbGljZShpLCBpICsgMikgOiAoYSAtIDB4ZDgwMCA8PCAxMCkgKyAoYiAtIDB4ZGMwMCkgKyAweDEwMDAwO1xuICB9O1xufTtcbiIsInZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJyk7XG52YXIgbWF4ID0gTWF0aC5tYXg7XG52YXIgbWluID0gTWF0aC5taW47XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpbmRleCwgbGVuZ3RoKSB7XG4gIGluZGV4ID0gdG9JbnRlZ2VyKGluZGV4KTtcbiAgcmV0dXJuIGluZGV4IDwgMCA/IG1heChpbmRleCArIGxlbmd0aCwgMCkgOiBtaW4oaW5kZXgsIGxlbmd0aCk7XG59O1xuIiwiLy8gNy4xLjQgVG9JbnRlZ2VyXG52YXIgY2VpbCA9IE1hdGguY2VpbDtcbnZhciBmbG9vciA9IE1hdGguZmxvb3I7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXNOYU4oaXQgPSAraXQpID8gMCA6IChpdCA+IDAgPyBmbG9vciA6IGNlaWwpKGl0KTtcbn07XG4iLCIvLyB0byBpbmRleGVkIG9iamVjdCwgdG9PYmplY3Qgd2l0aCBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIHN0cmluZ3NcbnZhciBJT2JqZWN0ID0gcmVxdWlyZSgnLi9faW9iamVjdCcpO1xudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gSU9iamVjdChkZWZpbmVkKGl0KSk7XG59O1xuIiwiLy8gNy4xLjE1IFRvTGVuZ3RoXG52YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xudmFyIG1pbiA9IE1hdGgubWluO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGl0ID4gMCA/IG1pbih0b0ludGVnZXIoaXQpLCAweDFmZmZmZmZmZmZmZmZmKSA6IDA7IC8vIHBvdygyLCA1MykgLSAxID09IDkwMDcxOTkyNTQ3NDA5OTFcbn07XG4iLCIvLyA3LjEuMTMgVG9PYmplY3QoYXJndW1lbnQpXG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBPYmplY3QoZGVmaW5lZChpdCkpO1xufTtcbiIsIi8vIDcuMS4xIFRvUHJpbWl0aXZlKGlucHV0IFssIFByZWZlcnJlZFR5cGVdKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG4vLyBpbnN0ZWFkIG9mIHRoZSBFUzYgc3BlYyB2ZXJzaW9uLCB3ZSBkaWRuJ3QgaW1wbGVtZW50IEBAdG9QcmltaXRpdmUgY2FzZVxuLy8gYW5kIHRoZSBzZWNvbmQgYXJndW1lbnQgLSBmbGFnIC0gcHJlZmVycmVkIHR5cGUgaXMgYSBzdHJpbmdcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCBTKSB7XG4gIGlmICghaXNPYmplY3QoaXQpKSByZXR1cm4gaXQ7XG4gIHZhciBmbiwgdmFsO1xuICBpZiAoUyAmJiB0eXBlb2YgKGZuID0gaXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSkgcmV0dXJuIHZhbDtcbiAgaWYgKHR5cGVvZiAoZm4gPSBpdC52YWx1ZU9mKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpIHJldHVybiB2YWw7XG4gIGlmICghUyAmJiB0eXBlb2YgKGZuID0gaXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSkgcmV0dXJuIHZhbDtcbiAgdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY29udmVydCBvYmplY3QgdG8gcHJpbWl0aXZlIHZhbHVlXCIpO1xufTtcbiIsInZhciBpZCA9IDA7XG52YXIgcHggPSBNYXRoLnJhbmRvbSgpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiAnU3ltYm9sKCcuY29uY2F0KGtleSA9PT0gdW5kZWZpbmVkID8gJycgOiBrZXksICcpXycsICgrK2lkICsgcHgpLnRvU3RyaW5nKDM2KSk7XG59O1xuIiwidmFyIHN0b3JlID0gcmVxdWlyZSgnLi9fc2hhcmVkJykoJ3drcycpO1xudmFyIHVpZCA9IHJlcXVpcmUoJy4vX3VpZCcpO1xudmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLlN5bWJvbDtcbnZhciBVU0VfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PSAnZnVuY3Rpb24nO1xuXG52YXIgJGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiBzdG9yZVtuYW1lXSB8fCAoc3RvcmVbbmFtZV0gPVxuICAgIFVTRV9TWU1CT0wgJiYgU3ltYm9sW25hbWVdIHx8IChVU0VfU1lNQk9MID8gU3ltYm9sIDogdWlkKSgnU3ltYm9sLicgKyBuYW1lKSk7XG59O1xuXG4kZXhwb3J0cy5zdG9yZSA9IHN0b3JlO1xuIiwidmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuL19jbGFzc29mJyk7XG52YXIgSVRFUkFUT1IgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fY29yZScpLmdldEl0ZXJhdG9yTWV0aG9kID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChpdCAhPSB1bmRlZmluZWQpIHJldHVybiBpdFtJVEVSQVRPUl1cbiAgICB8fCBpdFsnQEBpdGVyYXRvciddXG4gICAgfHwgSXRlcmF0b3JzW2NsYXNzb2YoaXQpXTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgY2FsbCA9IHJlcXVpcmUoJy4vX2l0ZXItY2FsbCcpO1xudmFyIGlzQXJyYXlJdGVyID0gcmVxdWlyZSgnLi9faXMtYXJyYXktaXRlcicpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgY3JlYXRlUHJvcGVydHkgPSByZXF1aXJlKCcuL19jcmVhdGUtcHJvcGVydHknKTtcbnZhciBnZXRJdGVyRm4gPSByZXF1aXJlKCcuL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19pdGVyLWRldGVjdCcpKGZ1bmN0aW9uIChpdGVyKSB7IEFycmF5LmZyb20oaXRlcik7IH0pLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMi4xIEFycmF5LmZyb20oYXJyYXlMaWtlLCBtYXBmbiA9IHVuZGVmaW5lZCwgdGhpc0FyZyA9IHVuZGVmaW5lZClcbiAgZnJvbTogZnVuY3Rpb24gZnJvbShhcnJheUxpa2UgLyogLCBtYXBmbiA9IHVuZGVmaW5lZCwgdGhpc0FyZyA9IHVuZGVmaW5lZCAqLykge1xuICAgIHZhciBPID0gdG9PYmplY3QoYXJyYXlMaWtlKTtcbiAgICB2YXIgQyA9IHR5cGVvZiB0aGlzID09ICdmdW5jdGlvbicgPyB0aGlzIDogQXJyYXk7XG4gICAgdmFyIGFMZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciBtYXBmbiA9IGFMZW4gPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuICAgIHZhciBtYXBwaW5nID0gbWFwZm4gIT09IHVuZGVmaW5lZDtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBpdGVyRm4gPSBnZXRJdGVyRm4oTyk7XG4gICAgdmFyIGxlbmd0aCwgcmVzdWx0LCBzdGVwLCBpdGVyYXRvcjtcbiAgICBpZiAobWFwcGluZykgbWFwZm4gPSBjdHgobWFwZm4sIGFMZW4gPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkLCAyKTtcbiAgICAvLyBpZiBvYmplY3QgaXNuJ3QgaXRlcmFibGUgb3IgaXQncyBhcnJheSB3aXRoIGRlZmF1bHQgaXRlcmF0b3IgLSB1c2Ugc2ltcGxlIGNhc2VcbiAgICBpZiAoaXRlckZuICE9IHVuZGVmaW5lZCAmJiAhKEMgPT0gQXJyYXkgJiYgaXNBcnJheUl0ZXIoaXRlckZuKSkpIHtcbiAgICAgIGZvciAoaXRlcmF0b3IgPSBpdGVyRm4uY2FsbChPKSwgcmVzdWx0ID0gbmV3IEMoKTsgIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lOyBpbmRleCsrKSB7XG4gICAgICAgIGNyZWF0ZVByb3BlcnR5KHJlc3VsdCwgaW5kZXgsIG1hcHBpbmcgPyBjYWxsKGl0ZXJhdG9yLCBtYXBmbiwgW3N0ZXAudmFsdWUsIGluZGV4XSwgdHJ1ZSkgOiBzdGVwLnZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuICAgICAgZm9yIChyZXN1bHQgPSBuZXcgQyhsZW5ndGgpOyBsZW5ndGggPiBpbmRleDsgaW5kZXgrKykge1xuICAgICAgICBjcmVhdGVQcm9wZXJ0eShyZXN1bHQsIGluZGV4LCBtYXBwaW5nID8gbWFwZm4oT1tpbmRleF0sIGluZGV4KSA6IE9baW5kZXhdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0Lmxlbmd0aCA9IGluZGV4O1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn0pO1xuIiwiLy8gMjAuMi4yLjIxIE1hdGgubG9nMTAoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgbG9nMTA6IGZ1bmN0aW9uIGxvZzEwKHgpIHtcbiAgICByZXR1cm4gTWF0aC5sb2coeCkgKiBNYXRoLkxPRzEwRTtcbiAgfVxufSk7XG4iLCIvLyAyMC4yLjIuMjggTWF0aC5zaWduKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7IHNpZ246IHJlcXVpcmUoJy4vX21hdGgtc2lnbicpIH0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRhdCA9IHJlcXVpcmUoJy4vX3N0cmluZy1hdCcpKHRydWUpO1xuXG4vLyAyMS4xLjMuMjcgU3RyaW5nLnByb3RvdHlwZVtAQGl0ZXJhdG9yXSgpXG5yZXF1aXJlKCcuL19pdGVyLWRlZmluZScpKFN0cmluZywgJ1N0cmluZycsIGZ1bmN0aW9uIChpdGVyYXRlZCkge1xuICB0aGlzLl90ID0gU3RyaW5nKGl0ZXJhdGVkKTsgLy8gdGFyZ2V0XG4gIHRoaXMuX2kgPSAwOyAgICAgICAgICAgICAgICAvLyBuZXh0IGluZGV4XG4vLyAyMS4xLjUuMi4xICVTdHJpbmdJdGVyYXRvclByb3RvdHlwZSUubmV4dCgpXG59LCBmdW5jdGlvbiAoKSB7XG4gIHZhciBPID0gdGhpcy5fdDtcbiAgdmFyIGluZGV4ID0gdGhpcy5faTtcbiAgdmFyIHBvaW50O1xuICBpZiAoaW5kZXggPj0gTy5sZW5ndGgpIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgcG9pbnQgPSAkYXQoTywgaW5kZXgpO1xuICB0aGlzLl9pICs9IHBvaW50Lmxlbmd0aDtcbiAgcmV0dXJuIHsgdmFsdWU6IHBvaW50LCBkb25lOiBmYWxzZSB9O1xufSk7XG4iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwidmFyIG5leHRUaWNrID0gcmVxdWlyZSgncHJvY2Vzcy9icm93c2VyLmpzJykubmV4dFRpY2s7XG52YXIgYXBwbHkgPSBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHk7XG52YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG52YXIgaW1tZWRpYXRlSWRzID0ge307XG52YXIgbmV4dEltbWVkaWF0ZUlkID0gMDtcblxuLy8gRE9NIEFQSXMsIGZvciBjb21wbGV0ZW5lc3NcblxuZXhwb3J0cy5zZXRUaW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldFRpbWVvdXQsIHdpbmRvdywgYXJndW1lbnRzKSwgY2xlYXJUaW1lb3V0KTtcbn07XG5leHBvcnRzLnNldEludGVydmFsID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldEludGVydmFsLCB3aW5kb3csIGFyZ3VtZW50cyksIGNsZWFySW50ZXJ2YWwpO1xufTtcbmV4cG9ydHMuY2xlYXJUaW1lb3V0ID1cbmV4cG9ydHMuY2xlYXJJbnRlcnZhbCA9IGZ1bmN0aW9uKHRpbWVvdXQpIHsgdGltZW91dC5jbG9zZSgpOyB9O1xuXG5mdW5jdGlvbiBUaW1lb3V0KGlkLCBjbGVhckZuKSB7XG4gIHRoaXMuX2lkID0gaWQ7XG4gIHRoaXMuX2NsZWFyRm4gPSBjbGVhckZuO1xufVxuVGltZW91dC5wcm90b3R5cGUudW5yZWYgPSBUaW1lb3V0LnByb3RvdHlwZS5yZWYgPSBmdW5jdGlvbigpIHt9O1xuVGltZW91dC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fY2xlYXJGbi5jYWxsKHdpbmRvdywgdGhpcy5faWQpO1xufTtcblxuLy8gRG9lcyBub3Qgc3RhcnQgdGhlIHRpbWUsIGp1c3Qgc2V0cyB1cCB0aGUgbWVtYmVycyBuZWVkZWQuXG5leHBvcnRzLmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0sIG1zZWNzKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSBtc2Vjcztcbn07XG5cbmV4cG9ydHMudW5lbnJvbGwgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSAtMTtcbn07XG5cbmV4cG9ydHMuX3VucmVmQWN0aXZlID0gZXhwb3J0cy5hY3RpdmUgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcblxuICB2YXIgbXNlY3MgPSBpdGVtLl9pZGxlVGltZW91dDtcbiAgaWYgKG1zZWNzID49IDApIHtcbiAgICBpdGVtLl9pZGxlVGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiBvblRpbWVvdXQoKSB7XG4gICAgICBpZiAoaXRlbS5fb25UaW1lb3V0KVxuICAgICAgICBpdGVtLl9vblRpbWVvdXQoKTtcbiAgICB9LCBtc2Vjcyk7XG4gIH1cbn07XG5cbi8vIFRoYXQncyBub3QgaG93IG5vZGUuanMgaW1wbGVtZW50cyBpdCBidXQgdGhlIGV4cG9zZWQgYXBpIGlzIHRoZSBzYW1lLlxuZXhwb3J0cy5zZXRJbW1lZGlhdGUgPSB0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSBcImZ1bmN0aW9uXCIgPyBzZXRJbW1lZGlhdGUgOiBmdW5jdGlvbihmbikge1xuICB2YXIgaWQgPSBuZXh0SW1tZWRpYXRlSWQrKztcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoIDwgMiA/IGZhbHNlIDogc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuXG4gIGltbWVkaWF0ZUlkc1tpZF0gPSB0cnVlO1xuXG4gIG5leHRUaWNrKGZ1bmN0aW9uIG9uTmV4dFRpY2soKSB7XG4gICAgaWYgKGltbWVkaWF0ZUlkc1tpZF0pIHtcbiAgICAgIC8vIGZuLmNhbGwoKSBpcyBmYXN0ZXIgc28gd2Ugb3B0aW1pemUgZm9yIHRoZSBjb21tb24gdXNlLWNhc2VcbiAgICAgIC8vIEBzZWUgaHR0cDovL2pzcGVyZi5jb20vY2FsbC1hcHBseS1zZWd1XG4gICAgICBpZiAoYXJncykge1xuICAgICAgICBmbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZuLmNhbGwobnVsbCk7XG4gICAgICB9XG4gICAgICAvLyBQcmV2ZW50IGlkcyBmcm9tIGxlYWtpbmdcbiAgICAgIGV4cG9ydHMuY2xlYXJJbW1lZGlhdGUoaWQpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGlkO1xufTtcblxuZXhwb3J0cy5jbGVhckltbWVkaWF0ZSA9IHR5cGVvZiBjbGVhckltbWVkaWF0ZSA9PT0gXCJmdW5jdGlvblwiID8gY2xlYXJJbW1lZGlhdGUgOiBmdW5jdGlvbihpZCkge1xuICBkZWxldGUgaW1tZWRpYXRlSWRzW2lkXTtcbn07IiwidmFyIFZ1ZSAvLyBsYXRlIGJpbmRcbnZhciB2ZXJzaW9uXG52YXIgbWFwID0gKHdpbmRvdy5fX1ZVRV9IT1RfTUFQX18gPSBPYmplY3QuY3JlYXRlKG51bGwpKVxudmFyIGluc3RhbGxlZCA9IGZhbHNlXG52YXIgaXNCcm93c2VyaWZ5ID0gZmFsc2VcbnZhciBpbml0SG9va05hbWUgPSAnYmVmb3JlQ3JlYXRlJ1xuXG5leHBvcnRzLmluc3RhbGwgPSBmdW5jdGlvbiAodnVlLCBicm93c2VyaWZ5KSB7XG4gIGlmIChpbnN0YWxsZWQpIHsgcmV0dXJuIH1cbiAgaW5zdGFsbGVkID0gdHJ1ZVxuXG4gIFZ1ZSA9IHZ1ZS5fX2VzTW9kdWxlID8gdnVlLmRlZmF1bHQgOiB2dWVcbiAgdmVyc2lvbiA9IFZ1ZS52ZXJzaW9uLnNwbGl0KCcuJykubWFwKE51bWJlcilcbiAgaXNCcm93c2VyaWZ5ID0gYnJvd3NlcmlmeVxuXG4gIC8vIGNvbXBhdCB3aXRoIDwgMi4wLjAtYWxwaGEuN1xuICBpZiAoVnVlLmNvbmZpZy5fbGlmZWN5Y2xlSG9va3MuaW5kZXhPZignaW5pdCcpID4gLTEpIHtcbiAgICBpbml0SG9va05hbWUgPSAnaW5pdCdcbiAgfVxuXG4gIGV4cG9ydHMuY29tcGF0aWJsZSA9IHZlcnNpb25bMF0gPj0gMlxuICBpZiAoIWV4cG9ydHMuY29tcGF0aWJsZSkge1xuICAgIGNvbnNvbGUud2FybihcbiAgICAgICdbSE1SXSBZb3UgYXJlIHVzaW5nIGEgdmVyc2lvbiBvZiB2dWUtaG90LXJlbG9hZC1hcGkgdGhhdCBpcyAnICtcbiAgICAgICAgJ29ubHkgY29tcGF0aWJsZSB3aXRoIFZ1ZS5qcyBjb3JlIF4yLjAuMC4nXG4gICAgKVxuICAgIHJldHVyblxuICB9XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgcmVjb3JkIGZvciBhIGhvdCBtb2R1bGUsIHdoaWNoIGtlZXBzIHRyYWNrIG9mIGl0cyBjb25zdHJ1Y3RvclxuICogYW5kIGluc3RhbmNlc1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBpZFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqL1xuXG5leHBvcnRzLmNyZWF0ZVJlY29yZCA9IGZ1bmN0aW9uIChpZCwgb3B0aW9ucykge1xuICBpZihtYXBbaWRdKSB7IHJldHVybiB9XG4gIFxuICB2YXIgQ3RvciA9IG51bGxcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgQ3RvciA9IG9wdGlvbnNcbiAgICBvcHRpb25zID0gQ3Rvci5vcHRpb25zXG4gIH1cbiAgbWFrZU9wdGlvbnNIb3QoaWQsIG9wdGlvbnMpXG4gIG1hcFtpZF0gPSB7XG4gICAgQ3RvcjogQ3RvcixcbiAgICBvcHRpb25zOiBvcHRpb25zLFxuICAgIGluc3RhbmNlczogW11cbiAgfVxufVxuXG4vKipcbiAqIENoZWNrIGlmIG1vZHVsZSBpcyByZWNvcmRlZFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBpZFxuICovXG5cbmV4cG9ydHMuaXNSZWNvcmRlZCA9IGZ1bmN0aW9uIChpZCkge1xuICByZXR1cm4gdHlwZW9mIG1hcFtpZF0gIT09ICd1bmRlZmluZWQnXG59XG5cbi8qKlxuICogTWFrZSBhIENvbXBvbmVudCBvcHRpb25zIG9iamVjdCBob3QuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGlkXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICovXG5cbmZ1bmN0aW9uIG1ha2VPcHRpb25zSG90KGlkLCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zLmZ1bmN0aW9uYWwpIHtcbiAgICB2YXIgcmVuZGVyID0gb3B0aW9ucy5yZW5kZXJcbiAgICBvcHRpb25zLnJlbmRlciA9IGZ1bmN0aW9uIChoLCBjdHgpIHtcbiAgICAgIHZhciBpbnN0YW5jZXMgPSBtYXBbaWRdLmluc3RhbmNlc1xuICAgICAgaWYgKGN0eCAmJiBpbnN0YW5jZXMuaW5kZXhPZihjdHgucGFyZW50KSA8IDApIHtcbiAgICAgICAgaW5zdGFuY2VzLnB1c2goY3R4LnBhcmVudClcbiAgICAgIH1cbiAgICAgIHJldHVybiByZW5kZXIoaCwgY3R4KVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpbmplY3RIb29rKG9wdGlvbnMsIGluaXRIb29rTmFtZSwgZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcmVjb3JkID0gbWFwW2lkXVxuICAgICAgaWYgKCFyZWNvcmQuQ3Rvcikge1xuICAgICAgICByZWNvcmQuQ3RvciA9IHRoaXMuY29uc3RydWN0b3JcbiAgICAgIH1cbiAgICAgIHJlY29yZC5pbnN0YW5jZXMucHVzaCh0aGlzKVxuICAgIH0pXG4gICAgaW5qZWN0SG9vayhvcHRpb25zLCAnYmVmb3JlRGVzdHJveScsIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGluc3RhbmNlcyA9IG1hcFtpZF0uaW5zdGFuY2VzXG4gICAgICBpbnN0YW5jZXMuc3BsaWNlKGluc3RhbmNlcy5pbmRleE9mKHRoaXMpLCAxKVxuICAgIH0pXG4gIH1cbn1cblxuLyoqXG4gKiBJbmplY3QgYSBob29rIHRvIGEgaG90IHJlbG9hZGFibGUgY29tcG9uZW50IHNvIHRoYXRcbiAqIHdlIGNhbiBrZWVwIHRyYWNrIG9mIGl0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gaG9va1xuICovXG5cbmZ1bmN0aW9uIGluamVjdEhvb2sob3B0aW9ucywgbmFtZSwgaG9vaykge1xuICB2YXIgZXhpc3RpbmcgPSBvcHRpb25zW25hbWVdXG4gIG9wdGlvbnNbbmFtZV0gPSBleGlzdGluZ1xuICAgID8gQXJyYXkuaXNBcnJheShleGlzdGluZykgPyBleGlzdGluZy5jb25jYXQoaG9vaykgOiBbZXhpc3RpbmcsIGhvb2tdXG4gICAgOiBbaG9va11cbn1cblxuZnVuY3Rpb24gdHJ5V3JhcChmbikge1xuICByZXR1cm4gZnVuY3Rpb24gKGlkLCBhcmcpIHtcbiAgICB0cnkge1xuICAgICAgZm4oaWQsIGFyZylcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGUpXG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICdTb21ldGhpbmcgd2VudCB3cm9uZyBkdXJpbmcgVnVlIGNvbXBvbmVudCBob3QtcmVsb2FkLiBGdWxsIHJlbG9hZCByZXF1aXJlZC4nXG4gICAgICApXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZU9wdGlvbnMgKG9sZE9wdGlvbnMsIG5ld09wdGlvbnMpIHtcbiAgZm9yICh2YXIga2V5IGluIG9sZE9wdGlvbnMpIHtcbiAgICBpZiAoIShrZXkgaW4gbmV3T3B0aW9ucykpIHtcbiAgICAgIGRlbGV0ZSBvbGRPcHRpb25zW2tleV1cbiAgICB9XG4gIH1cbiAgZm9yICh2YXIga2V5JDEgaW4gbmV3T3B0aW9ucykge1xuICAgIG9sZE9wdGlvbnNba2V5JDFdID0gbmV3T3B0aW9uc1trZXkkMV1cbiAgfVxufVxuXG5leHBvcnRzLnJlcmVuZGVyID0gdHJ5V3JhcChmdW5jdGlvbiAoaWQsIG9wdGlvbnMpIHtcbiAgdmFyIHJlY29yZCA9IG1hcFtpZF1cbiAgaWYgKCFvcHRpb25zKSB7XG4gICAgcmVjb3JkLmluc3RhbmNlcy5zbGljZSgpLmZvckVhY2goZnVuY3Rpb24gKGluc3RhbmNlKSB7XG4gICAgICBpbnN0YW5jZS4kZm9yY2VVcGRhdGUoKVxuICAgIH0pXG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMub3B0aW9uc1xuICB9XG4gIGlmIChyZWNvcmQuQ3Rvcikge1xuICAgIHJlY29yZC5DdG9yLm9wdGlvbnMucmVuZGVyID0gb3B0aW9ucy5yZW5kZXJcbiAgICByZWNvcmQuQ3Rvci5vcHRpb25zLnN0YXRpY1JlbmRlckZucyA9IG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zXG4gICAgcmVjb3JkLmluc3RhbmNlcy5zbGljZSgpLmZvckVhY2goZnVuY3Rpb24gKGluc3RhbmNlKSB7XG4gICAgICBpbnN0YW5jZS4kb3B0aW9ucy5yZW5kZXIgPSBvcHRpb25zLnJlbmRlclxuICAgICAgaW5zdGFuY2UuJG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zID0gb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnNcbiAgICAgIC8vIHJlc2V0IHN0YXRpYyB0cmVlc1xuICAgICAgLy8gcHJlIDIuNSwgYWxsIHN0YXRpYyB0cmVlcyBhcmUgY2FoY2VkIHRvZ2V0aGVyIG9uIHRoZSBpbnN0YW5jZVxuICAgICAgaWYgKGluc3RhbmNlLl9zdGF0aWNUcmVlcykge1xuICAgICAgICBpbnN0YW5jZS5fc3RhdGljVHJlZXMgPSBbXVxuICAgICAgfVxuICAgICAgLy8gMi41LjBcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHJlY29yZC5DdG9yLm9wdGlvbnMuY2FjaGVkKSkge1xuICAgICAgICByZWNvcmQuQ3Rvci5vcHRpb25zLmNhY2hlZCA9IFtdXG4gICAgICB9XG4gICAgICAvLyAyLjUuM1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaW5zdGFuY2UuJG9wdGlvbnMuY2FjaGVkKSkge1xuICAgICAgICBpbnN0YW5jZS4kb3B0aW9ucy5jYWNoZWQgPSBbXVxuICAgICAgfVxuICAgICAgLy8gcG9zdCAyLjUuNDogdi1vbmNlIHRyZWVzIGFyZSBjYWNoZWQgb24gaW5zdGFuY2UuX3N0YXRpY1RyZWVzLlxuICAgICAgLy8gUHVyZSBzdGF0aWMgdHJlZXMgYXJlIGNhY2hlZCBvbiB0aGUgc3RhdGljUmVuZGVyRm5zIGFycmF5XG4gICAgICAvLyAoYm90aCBhbHJlYWR5IHJlc2V0IGFib3ZlKVxuICAgICAgaW5zdGFuY2UuJGZvcmNlVXBkYXRlKClcbiAgICB9KVxuICB9IGVsc2Uge1xuICAgIC8vIGZ1bmN0aW9uYWwgb3Igbm8gaW5zdGFuY2UgY3JlYXRlZCB5ZXRcbiAgICByZWNvcmQub3B0aW9ucy5yZW5kZXIgPSBvcHRpb25zLnJlbmRlclxuICAgIHJlY29yZC5vcHRpb25zLnN0YXRpY1JlbmRlckZucyA9IG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zXG5cbiAgICAvLyBoYW5kbGUgZnVuY3Rpb25hbCBjb21wb25lbnQgcmUtcmVuZGVyXG4gICAgaWYgKHJlY29yZC5vcHRpb25zLmZ1bmN0aW9uYWwpIHtcbiAgICAgIC8vIHJlcmVuZGVyIHdpdGggZnVsbCBvcHRpb25zXG4gICAgICBpZiAoT2JqZWN0LmtleXMob3B0aW9ucykubGVuZ3RoID4gMikge1xuICAgICAgICB1cGRhdGVPcHRpb25zKHJlY29yZC5vcHRpb25zLCBvcHRpb25zKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gdGVtcGxhdGUtb25seSByZXJlbmRlci5cbiAgICAgICAgLy8gbmVlZCB0byBpbmplY3QgdGhlIHN0eWxlIGluamVjdGlvbiBjb2RlIGZvciBDU1MgbW9kdWxlc1xuICAgICAgICAvLyB0byB3b3JrIHByb3Blcmx5LlxuICAgICAgICB2YXIgaW5qZWN0U3R5bGVzID0gcmVjb3JkLm9wdGlvbnMuX2luamVjdFN0eWxlc1xuICAgICAgICBpZiAoaW5qZWN0U3R5bGVzKSB7XG4gICAgICAgICAgdmFyIHJlbmRlciA9IG9wdGlvbnMucmVuZGVyXG4gICAgICAgICAgcmVjb3JkLm9wdGlvbnMucmVuZGVyID0gZnVuY3Rpb24gKGgsIGN0eCkge1xuICAgICAgICAgICAgaW5qZWN0U3R5bGVzLmNhbGwoY3R4KVxuICAgICAgICAgICAgcmV0dXJuIHJlbmRlcihoLCBjdHgpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZWNvcmQub3B0aW9ucy5fQ3RvciA9IG51bGxcbiAgICAgIC8vIDIuNS4zXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShyZWNvcmQub3B0aW9ucy5jYWNoZWQpKSB7XG4gICAgICAgIHJlY29yZC5vcHRpb25zLmNhY2hlZCA9IFtdXG4gICAgICB9XG4gICAgICByZWNvcmQuaW5zdGFuY2VzLnNsaWNlKCkuZm9yRWFjaChmdW5jdGlvbiAoaW5zdGFuY2UpIHtcbiAgICAgICAgaW5zdGFuY2UuJGZvcmNlVXBkYXRlKClcbiAgICAgIH0pXG4gICAgfVxuICB9XG59KVxuXG5leHBvcnRzLnJlbG9hZCA9IHRyeVdyYXAoZnVuY3Rpb24gKGlkLCBvcHRpb25zKSB7XG4gIHZhciByZWNvcmQgPSBtYXBbaWRdXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucy5vcHRpb25zXG4gICAgfVxuICAgIG1ha2VPcHRpb25zSG90KGlkLCBvcHRpb25zKVxuICAgIGlmIChyZWNvcmQuQ3Rvcikge1xuICAgICAgaWYgKHZlcnNpb25bMV0gPCAyKSB7XG4gICAgICAgIC8vIHByZXNlcnZlIHByZSAyLjIgYmVoYXZpb3IgZm9yIGdsb2JhbCBtaXhpbiBoYW5kbGluZ1xuICAgICAgICByZWNvcmQuQ3Rvci5leHRlbmRPcHRpb25zID0gb3B0aW9uc1xuICAgICAgfVxuICAgICAgdmFyIG5ld0N0b3IgPSByZWNvcmQuQ3Rvci5zdXBlci5leHRlbmQob3B0aW9ucylcbiAgICAgIHJlY29yZC5DdG9yLm9wdGlvbnMgPSBuZXdDdG9yLm9wdGlvbnNcbiAgICAgIHJlY29yZC5DdG9yLmNpZCA9IG5ld0N0b3IuY2lkXG4gICAgICByZWNvcmQuQ3Rvci5wcm90b3R5cGUgPSBuZXdDdG9yLnByb3RvdHlwZVxuICAgICAgaWYgKG5ld0N0b3IucmVsZWFzZSkge1xuICAgICAgICAvLyB0ZW1wb3JhcnkgZ2xvYmFsIG1peGluIHN0cmF0ZWd5IHVzZWQgaW4gPCAyLjAuMC1hbHBoYS42XG4gICAgICAgIG5ld0N0b3IucmVsZWFzZSgpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHVwZGF0ZU9wdGlvbnMocmVjb3JkLm9wdGlvbnMsIG9wdGlvbnMpXG4gICAgfVxuICB9XG4gIHJlY29yZC5pbnN0YW5jZXMuc2xpY2UoKS5mb3JFYWNoKGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICAgIGlmIChpbnN0YW5jZS4kdm5vZGUgJiYgaW5zdGFuY2UuJHZub2RlLmNvbnRleHQpIHtcbiAgICAgIGluc3RhbmNlLiR2bm9kZS5jb250ZXh0LiRmb3JjZVVwZGF0ZSgpXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgJ1Jvb3Qgb3IgbWFudWFsbHkgbW91bnRlZCBpbnN0YW5jZSBtb2RpZmllZC4gRnVsbCByZWxvYWQgcmVxdWlyZWQuJ1xuICAgICAgKVxuICAgIH1cbiAgfSlcbn0pXG4iLCIvKiFcbiAqIFZ1ZS5qcyB2Mi41LjE2XG4gKiAoYykgMjAxNC0yMDE4IEV2YW4gWW91XG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuLyogICovXG5cbnZhciBlbXB0eU9iamVjdCA9IE9iamVjdC5mcmVlemUoe30pO1xuXG4vLyB0aGVzZSBoZWxwZXJzIHByb2R1Y2VzIGJldHRlciB2bSBjb2RlIGluIEpTIGVuZ2luZXMgZHVlIHRvIHRoZWlyXG4vLyBleHBsaWNpdG5lc3MgYW5kIGZ1bmN0aW9uIGlubGluaW5nXG5mdW5jdGlvbiBpc1VuZGVmICh2KSB7XG4gIHJldHVybiB2ID09PSB1bmRlZmluZWQgfHwgdiA9PT0gbnVsbFxufVxuXG5mdW5jdGlvbiBpc0RlZiAodikge1xuICByZXR1cm4gdiAhPT0gdW5kZWZpbmVkICYmIHYgIT09IG51bGxcbn1cblxuZnVuY3Rpb24gaXNUcnVlICh2KSB7XG4gIHJldHVybiB2ID09PSB0cnVlXG59XG5cbmZ1bmN0aW9uIGlzRmFsc2UgKHYpIHtcbiAgcmV0dXJuIHYgPT09IGZhbHNlXG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdmFsdWUgaXMgcHJpbWl0aXZlXG4gKi9cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlICh2YWx1ZSkge1xuICByZXR1cm4gKFxuICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHxcbiAgICB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInIHx8XG4gICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgdHlwZW9mIHZhbHVlID09PSAnc3ltYm9sJyB8fFxuICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nXG4gIClcbn1cblxuLyoqXG4gKiBRdWljayBvYmplY3QgY2hlY2sgLSB0aGlzIGlzIHByaW1hcmlseSB1c2VkIHRvIHRlbGxcbiAqIE9iamVjdHMgZnJvbSBwcmltaXRpdmUgdmFsdWVzIHdoZW4gd2Uga25vdyB0aGUgdmFsdWVcbiAqIGlzIGEgSlNPTi1jb21wbGlhbnQgdHlwZS5cbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QgKG9iaikge1xuICByZXR1cm4gb2JqICE9PSBudWxsICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnXG59XG5cbi8qKlxuICogR2V0IHRoZSByYXcgdHlwZSBzdHJpbmcgb2YgYSB2YWx1ZSBlLmcuIFtvYmplY3QgT2JqZWN0XVxuICovXG52YXIgX3RvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuZnVuY3Rpb24gdG9SYXdUeXBlICh2YWx1ZSkge1xuICByZXR1cm4gX3RvU3RyaW5nLmNhbGwodmFsdWUpLnNsaWNlKDgsIC0xKVxufVxuXG4vKipcbiAqIFN0cmljdCBvYmplY3QgdHlwZSBjaGVjay4gT25seSByZXR1cm5zIHRydWVcbiAqIGZvciBwbGFpbiBKYXZhU2NyaXB0IG9iamVjdHMuXG4gKi9cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QgKG9iaikge1xuICByZXR1cm4gX3RvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgT2JqZWN0XSdcbn1cblxuZnVuY3Rpb24gaXNSZWdFeHAgKHYpIHtcbiAgcmV0dXJuIF90b1N0cmluZy5jYWxsKHYpID09PSAnW29iamVjdCBSZWdFeHBdJ1xufVxuXG4vKipcbiAqIENoZWNrIGlmIHZhbCBpcyBhIHZhbGlkIGFycmF5IGluZGV4LlxuICovXG5mdW5jdGlvbiBpc1ZhbGlkQXJyYXlJbmRleCAodmFsKSB7XG4gIHZhciBuID0gcGFyc2VGbG9hdChTdHJpbmcodmFsKSk7XG4gIHJldHVybiBuID49IDAgJiYgTWF0aC5mbG9vcihuKSA9PT0gbiAmJiBpc0Zpbml0ZSh2YWwpXG59XG5cbi8qKlxuICogQ29udmVydCBhIHZhbHVlIHRvIGEgc3RyaW5nIHRoYXQgaXMgYWN0dWFsbHkgcmVuZGVyZWQuXG4gKi9cbmZ1bmN0aW9uIHRvU3RyaW5nICh2YWwpIHtcbiAgcmV0dXJuIHZhbCA9PSBudWxsXG4gICAgPyAnJ1xuICAgIDogdHlwZW9mIHZhbCA9PT0gJ29iamVjdCdcbiAgICAgID8gSlNPTi5zdHJpbmdpZnkodmFsLCBudWxsLCAyKVxuICAgICAgOiBTdHJpbmcodmFsKVxufVxuXG4vKipcbiAqIENvbnZlcnQgYSBpbnB1dCB2YWx1ZSB0byBhIG51bWJlciBmb3IgcGVyc2lzdGVuY2UuXG4gKiBJZiB0aGUgY29udmVyc2lvbiBmYWlscywgcmV0dXJuIG9yaWdpbmFsIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gdG9OdW1iZXIgKHZhbCkge1xuICB2YXIgbiA9IHBhcnNlRmxvYXQodmFsKTtcbiAgcmV0dXJuIGlzTmFOKG4pID8gdmFsIDogblxufVxuXG4vKipcbiAqIE1ha2UgYSBtYXAgYW5kIHJldHVybiBhIGZ1bmN0aW9uIGZvciBjaGVja2luZyBpZiBhIGtleVxuICogaXMgaW4gdGhhdCBtYXAuXG4gKi9cbmZ1bmN0aW9uIG1ha2VNYXAgKFxuICBzdHIsXG4gIGV4cGVjdHNMb3dlckNhc2Vcbikge1xuICB2YXIgbWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdmFyIGxpc3QgPSBzdHIuc3BsaXQoJywnKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgbWFwW2xpc3RbaV1dID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZXhwZWN0c0xvd2VyQ2FzZVxuICAgID8gZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gbWFwW3ZhbC50b0xvd2VyQ2FzZSgpXTsgfVxuICAgIDogZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gbWFwW3ZhbF07IH1cbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhIHRhZyBpcyBhIGJ1aWx0LWluIHRhZy5cbiAqL1xudmFyIGlzQnVpbHRJblRhZyA9IG1ha2VNYXAoJ3Nsb3QsY29tcG9uZW50JywgdHJ1ZSk7XG5cbi8qKlxuICogQ2hlY2sgaWYgYSBhdHRyaWJ1dGUgaXMgYSByZXNlcnZlZCBhdHRyaWJ1dGUuXG4gKi9cbnZhciBpc1Jlc2VydmVkQXR0cmlidXRlID0gbWFrZU1hcCgna2V5LHJlZixzbG90LHNsb3Qtc2NvcGUsaXMnKTtcblxuLyoqXG4gKiBSZW1vdmUgYW4gaXRlbSBmcm9tIGFuIGFycmF5XG4gKi9cbmZ1bmN0aW9uIHJlbW92ZSAoYXJyLCBpdGVtKSB7XG4gIGlmIChhcnIubGVuZ3RoKSB7XG4gICAgdmFyIGluZGV4ID0gYXJyLmluZGV4T2YoaXRlbSk7XG4gICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgIHJldHVybiBhcnIuc3BsaWNlKGluZGV4LCAxKVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhlIG9iamVjdCBoYXMgdGhlIHByb3BlcnR5LlxuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuZnVuY3Rpb24gaGFzT3duIChvYmosIGtleSkge1xuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSlcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBjYWNoZWQgdmVyc2lvbiBvZiBhIHB1cmUgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNhY2hlZCAoZm4pIHtcbiAgdmFyIGNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgcmV0dXJuIChmdW5jdGlvbiBjYWNoZWRGbiAoc3RyKSB7XG4gICAgdmFyIGhpdCA9IGNhY2hlW3N0cl07XG4gICAgcmV0dXJuIGhpdCB8fCAoY2FjaGVbc3RyXSA9IGZuKHN0cikpXG4gIH0pXG59XG5cbi8qKlxuICogQ2FtZWxpemUgYSBoeXBoZW4tZGVsaW1pdGVkIHN0cmluZy5cbiAqL1xudmFyIGNhbWVsaXplUkUgPSAvLShcXHcpL2c7XG52YXIgY2FtZWxpemUgPSBjYWNoZWQoZnVuY3Rpb24gKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoY2FtZWxpemVSRSwgZnVuY3Rpb24gKF8sIGMpIHsgcmV0dXJuIGMgPyBjLnRvVXBwZXJDYXNlKCkgOiAnJzsgfSlcbn0pO1xuXG4vKipcbiAqIENhcGl0YWxpemUgYSBzdHJpbmcuXG4gKi9cbnZhciBjYXBpdGFsaXplID0gY2FjaGVkKGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKVxufSk7XG5cbi8qKlxuICogSHlwaGVuYXRlIGEgY2FtZWxDYXNlIHN0cmluZy5cbiAqL1xudmFyIGh5cGhlbmF0ZVJFID0gL1xcQihbQS1aXSkvZztcbnZhciBoeXBoZW5hdGUgPSBjYWNoZWQoZnVuY3Rpb24gKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoaHlwaGVuYXRlUkUsICctJDEnKS50b0xvd2VyQ2FzZSgpXG59KTtcblxuLyoqXG4gKiBTaW1wbGUgYmluZCBwb2x5ZmlsbCBmb3IgZW52aXJvbm1lbnRzIHRoYXQgZG8gbm90IHN1cHBvcnQgaXQuLi4gZS5nLlxuICogUGhhbnRvbUpTIDEueC4gVGVjaG5pY2FsbHkgd2UgZG9uJ3QgbmVlZCB0aGlzIGFueW1vcmUgc2luY2UgbmF0aXZlIGJpbmQgaXNcbiAqIG5vdyBtb3JlIHBlcmZvcm1hbnQgaW4gbW9zdCBicm93c2VycywgYnV0IHJlbW92aW5nIGl0IHdvdWxkIGJlIGJyZWFraW5nIGZvclxuICogY29kZSB0aGF0IHdhcyBhYmxlIHRvIHJ1biBpbiBQaGFudG9tSlMgMS54LCBzbyB0aGlzIG11c3QgYmUga2VwdCBmb3JcbiAqIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuICovXG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5mdW5jdGlvbiBwb2x5ZmlsbEJpbmQgKGZuLCBjdHgpIHtcbiAgZnVuY3Rpb24gYm91bmRGbiAoYSkge1xuICAgIHZhciBsID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICByZXR1cm4gbFxuICAgICAgPyBsID4gMVxuICAgICAgICA/IGZuLmFwcGx5KGN0eCwgYXJndW1lbnRzKVxuICAgICAgICA6IGZuLmNhbGwoY3R4LCBhKVxuICAgICAgOiBmbi5jYWxsKGN0eClcbiAgfVxuXG4gIGJvdW5kRm4uX2xlbmd0aCA9IGZuLmxlbmd0aDtcbiAgcmV0dXJuIGJvdW5kRm5cbn1cblxuZnVuY3Rpb24gbmF0aXZlQmluZCAoZm4sIGN0eCkge1xuICByZXR1cm4gZm4uYmluZChjdHgpXG59XG5cbnZhciBiaW5kID0gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmRcbiAgPyBuYXRpdmVCaW5kXG4gIDogcG9seWZpbGxCaW5kO1xuXG4vKipcbiAqIENvbnZlcnQgYW4gQXJyYXktbGlrZSBvYmplY3QgdG8gYSByZWFsIEFycmF5LlxuICovXG5mdW5jdGlvbiB0b0FycmF5IChsaXN0LCBzdGFydCkge1xuICBzdGFydCA9IHN0YXJ0IHx8IDA7XG4gIHZhciBpID0gbGlzdC5sZW5ndGggLSBzdGFydDtcbiAgdmFyIHJldCA9IG5ldyBBcnJheShpKTtcbiAgd2hpbGUgKGktLSkge1xuICAgIHJldFtpXSA9IGxpc3RbaSArIHN0YXJ0XTtcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbi8qKlxuICogTWl4IHByb3BlcnRpZXMgaW50byB0YXJnZXQgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBleHRlbmQgKHRvLCBfZnJvbSkge1xuICBmb3IgKHZhciBrZXkgaW4gX2Zyb20pIHtcbiAgICB0b1trZXldID0gX2Zyb21ba2V5XTtcbiAgfVxuICByZXR1cm4gdG9cbn1cblxuLyoqXG4gKiBNZXJnZSBhbiBBcnJheSBvZiBPYmplY3RzIGludG8gYSBzaW5nbGUgT2JqZWN0LlxuICovXG5mdW5jdGlvbiB0b09iamVjdCAoYXJyKSB7XG4gIHZhciByZXMgPSB7fTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoYXJyW2ldKSB7XG4gICAgICBleHRlbmQocmVzLCBhcnJbaV0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qKlxuICogUGVyZm9ybSBubyBvcGVyYXRpb24uXG4gKiBTdHViYmluZyBhcmdzIHRvIG1ha2UgRmxvdyBoYXBweSB3aXRob3V0IGxlYXZpbmcgdXNlbGVzcyB0cmFuc3BpbGVkIGNvZGVcbiAqIHdpdGggLi4ucmVzdCAoaHR0cHM6Ly9mbG93Lm9yZy9ibG9nLzIwMTcvMDUvMDcvU3RyaWN0LUZ1bmN0aW9uLUNhbGwtQXJpdHkvKVxuICovXG5mdW5jdGlvbiBub29wIChhLCBiLCBjKSB7fVxuXG4vKipcbiAqIEFsd2F5cyByZXR1cm4gZmFsc2UuXG4gKi9cbnZhciBubyA9IGZ1bmN0aW9uIChhLCBiLCBjKSB7IHJldHVybiBmYWxzZTsgfTtcblxuLyoqXG4gKiBSZXR1cm4gc2FtZSB2YWx1ZVxuICovXG52YXIgaWRlbnRpdHkgPSBmdW5jdGlvbiAoXykgeyByZXR1cm4gXzsgfTtcblxuLyoqXG4gKiBHZW5lcmF0ZSBhIHN0YXRpYyBrZXlzIHN0cmluZyBmcm9tIGNvbXBpbGVyIG1vZHVsZXMuXG4gKi9cblxuXG4vKipcbiAqIENoZWNrIGlmIHR3byB2YWx1ZXMgYXJlIGxvb3NlbHkgZXF1YWwgLSB0aGF0IGlzLFxuICogaWYgdGhleSBhcmUgcGxhaW4gb2JqZWN0cywgZG8gdGhleSBoYXZlIHRoZSBzYW1lIHNoYXBlP1xuICovXG5mdW5jdGlvbiBsb29zZUVxdWFsIChhLCBiKSB7XG4gIGlmIChhID09PSBiKSB7IHJldHVybiB0cnVlIH1cbiAgdmFyIGlzT2JqZWN0QSA9IGlzT2JqZWN0KGEpO1xuICB2YXIgaXNPYmplY3RCID0gaXNPYmplY3QoYik7XG4gIGlmIChpc09iamVjdEEgJiYgaXNPYmplY3RCKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBpc0FycmF5QSA9IEFycmF5LmlzQXJyYXkoYSk7XG4gICAgICB2YXIgaXNBcnJheUIgPSBBcnJheS5pc0FycmF5KGIpO1xuICAgICAgaWYgKGlzQXJyYXlBICYmIGlzQXJyYXlCKSB7XG4gICAgICAgIHJldHVybiBhLmxlbmd0aCA9PT0gYi5sZW5ndGggJiYgYS5ldmVyeShmdW5jdGlvbiAoZSwgaSkge1xuICAgICAgICAgIHJldHVybiBsb29zZUVxdWFsKGUsIGJbaV0pXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2UgaWYgKCFpc0FycmF5QSAmJiAhaXNBcnJheUIpIHtcbiAgICAgICAgdmFyIGtleXNBID0gT2JqZWN0LmtleXMoYSk7XG4gICAgICAgIHZhciBrZXlzQiA9IE9iamVjdC5rZXlzKGIpO1xuICAgICAgICByZXR1cm4ga2V5c0EubGVuZ3RoID09PSBrZXlzQi5sZW5ndGggJiYga2V5c0EuZXZlcnkoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgIHJldHVybiBsb29zZUVxdWFsKGFba2V5XSwgYltrZXldKVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfSBlbHNlIGlmICghaXNPYmplY3RBICYmICFpc09iamVjdEIpIHtcbiAgICByZXR1cm4gU3RyaW5nKGEpID09PSBTdHJpbmcoYilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5mdW5jdGlvbiBsb29zZUluZGV4T2YgKGFyciwgdmFsKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGxvb3NlRXF1YWwoYXJyW2ldLCB2YWwpKSB7IHJldHVybiBpIH1cbiAgfVxuICByZXR1cm4gLTFcbn1cblxuLyoqXG4gKiBFbnN1cmUgYSBmdW5jdGlvbiBpcyBjYWxsZWQgb25seSBvbmNlLlxuICovXG5mdW5jdGlvbiBvbmNlIChmbikge1xuICB2YXIgY2FsbGVkID0gZmFsc2U7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFjYWxsZWQpIHtcbiAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgU1NSX0FUVFIgPSAnZGF0YS1zZXJ2ZXItcmVuZGVyZWQnO1xuXG52YXIgQVNTRVRfVFlQRVMgPSBbXG4gICdjb21wb25lbnQnLFxuICAnZGlyZWN0aXZlJyxcbiAgJ2ZpbHRlcidcbl07XG5cbnZhciBMSUZFQ1lDTEVfSE9PS1MgPSBbXG4gICdiZWZvcmVDcmVhdGUnLFxuICAnY3JlYXRlZCcsXG4gICdiZWZvcmVNb3VudCcsXG4gICdtb3VudGVkJyxcbiAgJ2JlZm9yZVVwZGF0ZScsXG4gICd1cGRhdGVkJyxcbiAgJ2JlZm9yZURlc3Ryb3knLFxuICAnZGVzdHJveWVkJyxcbiAgJ2FjdGl2YXRlZCcsXG4gICdkZWFjdGl2YXRlZCcsXG4gICdlcnJvckNhcHR1cmVkJ1xuXTtcblxuLyogICovXG5cbnZhciBjb25maWcgPSAoe1xuICAvKipcbiAgICogT3B0aW9uIG1lcmdlIHN0cmF0ZWdpZXMgKHVzZWQgaW4gY29yZS91dGlsL29wdGlvbnMpXG4gICAqL1xuICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgb3B0aW9uTWVyZ2VTdHJhdGVnaWVzOiBPYmplY3QuY3JlYXRlKG51bGwpLFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIHN1cHByZXNzIHdhcm5pbmdzLlxuICAgKi9cbiAgc2lsZW50OiBmYWxzZSxcblxuICAvKipcbiAgICogU2hvdyBwcm9kdWN0aW9uIG1vZGUgdGlwIG1lc3NhZ2Ugb24gYm9vdD9cbiAgICovXG4gIHByb2R1Y3Rpb25UaXA6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicsXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gZW5hYmxlIGRldnRvb2xzXG4gICAqL1xuICBkZXZ0b29sczogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyxcblxuICAvKipcbiAgICogV2hldGhlciB0byByZWNvcmQgcGVyZlxuICAgKi9cbiAgcGVyZm9ybWFuY2U6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBFcnJvciBoYW5kbGVyIGZvciB3YXRjaGVyIGVycm9yc1xuICAgKi9cbiAgZXJyb3JIYW5kbGVyOiBudWxsLFxuXG4gIC8qKlxuICAgKiBXYXJuIGhhbmRsZXIgZm9yIHdhdGNoZXIgd2FybnNcbiAgICovXG4gIHdhcm5IYW5kbGVyOiBudWxsLFxuXG4gIC8qKlxuICAgKiBJZ25vcmUgY2VydGFpbiBjdXN0b20gZWxlbWVudHNcbiAgICovXG4gIGlnbm9yZWRFbGVtZW50czogW10sXG5cbiAgLyoqXG4gICAqIEN1c3RvbSB1c2VyIGtleSBhbGlhc2VzIGZvciB2LW9uXG4gICAqL1xuICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAga2V5Q29kZXM6IE9iamVjdC5jcmVhdGUobnVsbCksXG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGEgdGFnIGlzIHJlc2VydmVkIHNvIHRoYXQgaXQgY2Fubm90IGJlIHJlZ2lzdGVyZWQgYXMgYVxuICAgKiBjb21wb25lbnQuIFRoaXMgaXMgcGxhdGZvcm0tZGVwZW5kZW50IGFuZCBtYXkgYmUgb3ZlcndyaXR0ZW4uXG4gICAqL1xuICBpc1Jlc2VydmVkVGFnOiBubyxcblxuICAvKipcbiAgICogQ2hlY2sgaWYgYW4gYXR0cmlidXRlIGlzIHJlc2VydmVkIHNvIHRoYXQgaXQgY2Fubm90IGJlIHVzZWQgYXMgYSBjb21wb25lbnRcbiAgICogcHJvcC4gVGhpcyBpcyBwbGF0Zm9ybS1kZXBlbmRlbnQgYW5kIG1heSBiZSBvdmVyd3JpdHRlbi5cbiAgICovXG4gIGlzUmVzZXJ2ZWRBdHRyOiBubyxcblxuICAvKipcbiAgICogQ2hlY2sgaWYgYSB0YWcgaXMgYW4gdW5rbm93biBlbGVtZW50LlxuICAgKiBQbGF0Zm9ybS1kZXBlbmRlbnQuXG4gICAqL1xuICBpc1Vua25vd25FbGVtZW50OiBubyxcblxuICAvKipcbiAgICogR2V0IHRoZSBuYW1lc3BhY2Ugb2YgYW4gZWxlbWVudFxuICAgKi9cbiAgZ2V0VGFnTmFtZXNwYWNlOiBub29wLFxuXG4gIC8qKlxuICAgKiBQYXJzZSB0aGUgcmVhbCB0YWcgbmFtZSBmb3IgdGhlIHNwZWNpZmljIHBsYXRmb3JtLlxuICAgKi9cbiAgcGFyc2VQbGF0Zm9ybVRhZ05hbWU6IGlkZW50aXR5LFxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhbiBhdHRyaWJ1dGUgbXVzdCBiZSBib3VuZCB1c2luZyBwcm9wZXJ0eSwgZS5nLiB2YWx1ZVxuICAgKiBQbGF0Zm9ybS1kZXBlbmRlbnQuXG4gICAqL1xuICBtdXN0VXNlUHJvcDogbm8sXG5cbiAgLyoqXG4gICAqIEV4cG9zZWQgZm9yIGxlZ2FjeSByZWFzb25zXG4gICAqL1xuICBfbGlmZWN5Y2xlSG9va3M6IExJRkVDWUNMRV9IT09LU1xufSlcblxuLyogICovXG5cbi8qKlxuICogQ2hlY2sgaWYgYSBzdHJpbmcgc3RhcnRzIHdpdGggJCBvciBfXG4gKi9cbmZ1bmN0aW9uIGlzUmVzZXJ2ZWQgKHN0cikge1xuICB2YXIgYyA9IChzdHIgKyAnJykuY2hhckNvZGVBdCgwKTtcbiAgcmV0dXJuIGMgPT09IDB4MjQgfHwgYyA9PT0gMHg1RlxufVxuXG4vKipcbiAqIERlZmluZSBhIHByb3BlcnR5LlxuICovXG5mdW5jdGlvbiBkZWYgKG9iaiwga2V5LCB2YWwsIGVudW1lcmFibGUpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgdmFsdWU6IHZhbCxcbiAgICBlbnVtZXJhYmxlOiAhIWVudW1lcmFibGUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuXG4vKipcbiAqIFBhcnNlIHNpbXBsZSBwYXRoLlxuICovXG52YXIgYmFpbFJFID0gL1teXFx3LiRdLztcbmZ1bmN0aW9uIHBhcnNlUGF0aCAocGF0aCkge1xuICBpZiAoYmFpbFJFLnRlc3QocGF0aCkpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgc2VnbWVudHMgPSBwYXRoLnNwbGl0KCcuJyk7XG4gIHJldHVybiBmdW5jdGlvbiAob2JqKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCFvYmopIHsgcmV0dXJuIH1cbiAgICAgIG9iaiA9IG9ialtzZWdtZW50c1tpXV07XG4gICAgfVxuICAgIHJldHVybiBvYmpcbiAgfVxufVxuXG4vKiAgKi9cblxuLy8gY2FuIHdlIHVzZSBfX3Byb3RvX18/XG52YXIgaGFzUHJvdG8gPSAnX19wcm90b19fJyBpbiB7fTtcblxuLy8gQnJvd3NlciBlbnZpcm9ubWVudCBzbmlmZmluZ1xudmFyIGluQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnO1xudmFyIGluV2VleCA9IHR5cGVvZiBXWEVudmlyb25tZW50ICE9PSAndW5kZWZpbmVkJyAmJiAhIVdYRW52aXJvbm1lbnQucGxhdGZvcm07XG52YXIgd2VleFBsYXRmb3JtID0gaW5XZWV4ICYmIFdYRW52aXJvbm1lbnQucGxhdGZvcm0udG9Mb3dlckNhc2UoKTtcbnZhciBVQSA9IGluQnJvd3NlciAmJiB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpO1xudmFyIGlzSUUgPSBVQSAmJiAvbXNpZXx0cmlkZW50Ly50ZXN0KFVBKTtcbnZhciBpc0lFOSA9IFVBICYmIFVBLmluZGV4T2YoJ21zaWUgOS4wJykgPiAwO1xudmFyIGlzRWRnZSA9IFVBICYmIFVBLmluZGV4T2YoJ2VkZ2UvJykgPiAwO1xudmFyIGlzQW5kcm9pZCA9IChVQSAmJiBVQS5pbmRleE9mKCdhbmRyb2lkJykgPiAwKSB8fCAod2VleFBsYXRmb3JtID09PSAnYW5kcm9pZCcpO1xudmFyIGlzSU9TID0gKFVBICYmIC9pcGhvbmV8aXBhZHxpcG9kfGlvcy8udGVzdChVQSkpIHx8ICh3ZWV4UGxhdGZvcm0gPT09ICdpb3MnKTtcbnZhciBpc0Nocm9tZSA9IFVBICYmIC9jaHJvbWVcXC9cXGQrLy50ZXN0KFVBKSAmJiAhaXNFZGdlO1xuXG4vLyBGaXJlZm94IGhhcyBhIFwid2F0Y2hcIiBmdW5jdGlvbiBvbiBPYmplY3QucHJvdG90eXBlLi4uXG52YXIgbmF0aXZlV2F0Y2ggPSAoe30pLndhdGNoO1xuXG52YXIgc3VwcG9ydHNQYXNzaXZlID0gZmFsc2U7XG5pZiAoaW5Ccm93c2VyKSB7XG4gIHRyeSB7XG4gICAgdmFyIG9wdHMgPSB7fTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob3B0cywgJ3Bhc3NpdmUnLCAoe1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQgKCkge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICBzdXBwb3J0c1Bhc3NpdmUgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pKTsgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2Zsb3cvaXNzdWVzLzI4NVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0ZXN0LXBhc3NpdmUnLCBudWxsLCBvcHRzKTtcbiAgfSBjYXRjaCAoZSkge31cbn1cblxuLy8gdGhpcyBuZWVkcyB0byBiZSBsYXp5LWV2YWxlZCBiZWNhdXNlIHZ1ZSBtYXkgYmUgcmVxdWlyZWQgYmVmb3JlXG4vLyB2dWUtc2VydmVyLXJlbmRlcmVyIGNhbiBzZXQgVlVFX0VOVlxudmFyIF9pc1NlcnZlcjtcbnZhciBpc1NlcnZlclJlbmRlcmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKF9pc1NlcnZlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFpbkJyb3dzZXIgJiYgIWluV2VleCAmJiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgLy8gZGV0ZWN0IHByZXNlbmNlIG9mIHZ1ZS1zZXJ2ZXItcmVuZGVyZXIgYW5kIGF2b2lkXG4gICAgICAvLyBXZWJwYWNrIHNoaW1taW5nIHRoZSBwcm9jZXNzXG4gICAgICBfaXNTZXJ2ZXIgPSBnbG9iYWxbJ3Byb2Nlc3MnXS5lbnYuVlVFX0VOViA9PT0gJ3NlcnZlcic7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9pc1NlcnZlciA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gX2lzU2VydmVyXG59O1xuXG4vLyBkZXRlY3QgZGV2dG9vbHNcbnZhciBkZXZ0b29scyA9IGluQnJvd3NlciAmJiB3aW5kb3cuX19WVUVfREVWVE9PTFNfR0xPQkFMX0hPT0tfXztcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIGlzTmF0aXZlIChDdG9yKSB7XG4gIHJldHVybiB0eXBlb2YgQ3RvciA9PT0gJ2Z1bmN0aW9uJyAmJiAvbmF0aXZlIGNvZGUvLnRlc3QoQ3Rvci50b1N0cmluZygpKVxufVxuXG52YXIgaGFzU3ltYm9sID1cbiAgdHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoU3ltYm9sKSAmJlxuICB0eXBlb2YgUmVmbGVjdCAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoUmVmbGVjdC5vd25LZXlzKTtcblxudmFyIF9TZXQ7XG4vKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi8gLy8gJGZsb3ctZGlzYWJsZS1saW5lXG5pZiAodHlwZW9mIFNldCAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoU2V0KSkge1xuICAvLyB1c2UgbmF0aXZlIFNldCB3aGVuIGF2YWlsYWJsZS5cbiAgX1NldCA9IFNldDtcbn0gZWxzZSB7XG4gIC8vIGEgbm9uLXN0YW5kYXJkIFNldCBwb2x5ZmlsbCB0aGF0IG9ubHkgd29ya3Mgd2l0aCBwcmltaXRpdmUga2V5cy5cbiAgX1NldCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2V0ICgpIHtcbiAgICAgIHRoaXMuc2V0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB9XG4gICAgU2V0LnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiBoYXMgKGtleSkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0W2tleV0gPT09IHRydWVcbiAgICB9O1xuICAgIFNldC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkIChrZXkpIHtcbiAgICAgIHRoaXMuc2V0W2tleV0gPSB0cnVlO1xuICAgIH07XG4gICAgU2V0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyICgpIHtcbiAgICAgIHRoaXMuc2V0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFNldDtcbiAgfSgpKTtcbn1cblxuLyogICovXG5cbnZhciB3YXJuID0gbm9vcDtcbnZhciB0aXAgPSBub29wO1xudmFyIGdlbmVyYXRlQ29tcG9uZW50VHJhY2UgPSAobm9vcCk7IC8vIHdvcmsgYXJvdW5kIGZsb3cgY2hlY2tcbnZhciBmb3JtYXRDb21wb25lbnROYW1lID0gKG5vb3ApO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgaGFzQ29uc29sZSA9IHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJztcbiAgdmFyIGNsYXNzaWZ5UkUgPSAvKD86XnxbLV9dKShcXHcpL2c7XG4gIHZhciBjbGFzc2lmeSA9IGZ1bmN0aW9uIChzdHIpIHsgcmV0dXJuIHN0clxuICAgIC5yZXBsYWNlKGNsYXNzaWZ5UkUsIGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLnRvVXBwZXJDYXNlKCk7IH0pXG4gICAgLnJlcGxhY2UoL1stX10vZywgJycpOyB9O1xuXG4gIHdhcm4gPSBmdW5jdGlvbiAobXNnLCB2bSkge1xuICAgIHZhciB0cmFjZSA9IHZtID8gZ2VuZXJhdGVDb21wb25lbnRUcmFjZSh2bSkgOiAnJztcblxuICAgIGlmIChjb25maWcud2FybkhhbmRsZXIpIHtcbiAgICAgIGNvbmZpZy53YXJuSGFuZGxlci5jYWxsKG51bGwsIG1zZywgdm0sIHRyYWNlKTtcbiAgICB9IGVsc2UgaWYgKGhhc0NvbnNvbGUgJiYgKCFjb25maWcuc2lsZW50KSkge1xuICAgICAgY29uc29sZS5lcnJvcigoXCJbVnVlIHdhcm5dOiBcIiArIG1zZyArIHRyYWNlKSk7XG4gICAgfVxuICB9O1xuXG4gIHRpcCA9IGZ1bmN0aW9uIChtc2csIHZtKSB7XG4gICAgaWYgKGhhc0NvbnNvbGUgJiYgKCFjb25maWcuc2lsZW50KSkge1xuICAgICAgY29uc29sZS53YXJuKFwiW1Z1ZSB0aXBdOiBcIiArIG1zZyArIChcbiAgICAgICAgdm0gPyBnZW5lcmF0ZUNvbXBvbmVudFRyYWNlKHZtKSA6ICcnXG4gICAgICApKTtcbiAgICB9XG4gIH07XG5cbiAgZm9ybWF0Q29tcG9uZW50TmFtZSA9IGZ1bmN0aW9uICh2bSwgaW5jbHVkZUZpbGUpIHtcbiAgICBpZiAodm0uJHJvb3QgPT09IHZtKSB7XG4gICAgICByZXR1cm4gJzxSb290PidcbiAgICB9XG4gICAgdmFyIG9wdGlvbnMgPSB0eXBlb2Ygdm0gPT09ICdmdW5jdGlvbicgJiYgdm0uY2lkICE9IG51bGxcbiAgICAgID8gdm0ub3B0aW9uc1xuICAgICAgOiB2bS5faXNWdWVcbiAgICAgICAgPyB2bS4kb3B0aW9ucyB8fCB2bS5jb25zdHJ1Y3Rvci5vcHRpb25zXG4gICAgICAgIDogdm0gfHwge307XG4gICAgdmFyIG5hbWUgPSBvcHRpb25zLm5hbWUgfHwgb3B0aW9ucy5fY29tcG9uZW50VGFnO1xuICAgIHZhciBmaWxlID0gb3B0aW9ucy5fX2ZpbGU7XG4gICAgaWYgKCFuYW1lICYmIGZpbGUpIHtcbiAgICAgIHZhciBtYXRjaCA9IGZpbGUubWF0Y2goLyhbXi9cXFxcXSspXFwudnVlJC8pO1xuICAgICAgbmFtZSA9IG1hdGNoICYmIG1hdGNoWzFdO1xuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICAobmFtZSA/IChcIjxcIiArIChjbGFzc2lmeShuYW1lKSkgKyBcIj5cIikgOiBcIjxBbm9ueW1vdXM+XCIpICtcbiAgICAgIChmaWxlICYmIGluY2x1ZGVGaWxlICE9PSBmYWxzZSA/IChcIiBhdCBcIiArIGZpbGUpIDogJycpXG4gICAgKVxuICB9O1xuXG4gIHZhciByZXBlYXQgPSBmdW5jdGlvbiAoc3RyLCBuKSB7XG4gICAgdmFyIHJlcyA9ICcnO1xuICAgIHdoaWxlIChuKSB7XG4gICAgICBpZiAobiAlIDIgPT09IDEpIHsgcmVzICs9IHN0cjsgfVxuICAgICAgaWYgKG4gPiAxKSB7IHN0ciArPSBzdHI7IH1cbiAgICAgIG4gPj49IDE7XG4gICAgfVxuICAgIHJldHVybiByZXNcbiAgfTtcblxuICBnZW5lcmF0ZUNvbXBvbmVudFRyYWNlID0gZnVuY3Rpb24gKHZtKSB7XG4gICAgaWYgKHZtLl9pc1Z1ZSAmJiB2bS4kcGFyZW50KSB7XG4gICAgICB2YXIgdHJlZSA9IFtdO1xuICAgICAgdmFyIGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZSA9IDA7XG4gICAgICB3aGlsZSAodm0pIHtcbiAgICAgICAgaWYgKHRyZWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHZhciBsYXN0ID0gdHJlZVt0cmVlLmxlbmd0aCAtIDFdO1xuICAgICAgICAgIGlmIChsYXN0LmNvbnN0cnVjdG9yID09PSB2bS5jb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlKys7XG4gICAgICAgICAgICB2bSA9IHZtLiRwYXJlbnQ7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH0gZWxzZSBpZiAoY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlID4gMCkge1xuICAgICAgICAgICAgdHJlZVt0cmVlLmxlbmd0aCAtIDFdID0gW2xhc3QsIGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZV07XG4gICAgICAgICAgICBjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0cmVlLnB1c2godm0pO1xuICAgICAgICB2bSA9IHZtLiRwYXJlbnQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gJ1xcblxcbmZvdW5kIGluXFxuXFxuJyArIHRyZWVcbiAgICAgICAgLm1hcChmdW5jdGlvbiAodm0sIGkpIHsgcmV0dXJuIChcIlwiICsgKGkgPT09IDAgPyAnLS0tPiAnIDogcmVwZWF0KCcgJywgNSArIGkgKiAyKSkgKyAoQXJyYXkuaXNBcnJheSh2bSlcbiAgICAgICAgICAgID8gKChmb3JtYXRDb21wb25lbnROYW1lKHZtWzBdKSkgKyBcIi4uLiAoXCIgKyAodm1bMV0pICsgXCIgcmVjdXJzaXZlIGNhbGxzKVwiKVxuICAgICAgICAgICAgOiBmb3JtYXRDb21wb25lbnROYW1lKHZtKSkpOyB9KVxuICAgICAgICAuam9pbignXFxuJylcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIChcIlxcblxcbihmb3VuZCBpbiBcIiArIChmb3JtYXRDb21wb25lbnROYW1lKHZtKSkgKyBcIilcIilcbiAgICB9XG4gIH07XG59XG5cbi8qICAqL1xuXG5cbnZhciB1aWQgPSAwO1xuXG4vKipcbiAqIEEgZGVwIGlzIGFuIG9ic2VydmFibGUgdGhhdCBjYW4gaGF2ZSBtdWx0aXBsZVxuICogZGlyZWN0aXZlcyBzdWJzY3JpYmluZyB0byBpdC5cbiAqL1xudmFyIERlcCA9IGZ1bmN0aW9uIERlcCAoKSB7XG4gIHRoaXMuaWQgPSB1aWQrKztcbiAgdGhpcy5zdWJzID0gW107XG59O1xuXG5EZXAucHJvdG90eXBlLmFkZFN1YiA9IGZ1bmN0aW9uIGFkZFN1YiAoc3ViKSB7XG4gIHRoaXMuc3Vicy5wdXNoKHN1Yik7XG59O1xuXG5EZXAucHJvdG90eXBlLnJlbW92ZVN1YiA9IGZ1bmN0aW9uIHJlbW92ZVN1YiAoc3ViKSB7XG4gIHJlbW92ZSh0aGlzLnN1YnMsIHN1Yik7XG59O1xuXG5EZXAucHJvdG90eXBlLmRlcGVuZCA9IGZ1bmN0aW9uIGRlcGVuZCAoKSB7XG4gIGlmIChEZXAudGFyZ2V0KSB7XG4gICAgRGVwLnRhcmdldC5hZGREZXAodGhpcyk7XG4gIH1cbn07XG5cbkRlcC5wcm90b3R5cGUubm90aWZ5ID0gZnVuY3Rpb24gbm90aWZ5ICgpIHtcbiAgLy8gc3RhYmlsaXplIHRoZSBzdWJzY3JpYmVyIGxpc3QgZmlyc3RcbiAgdmFyIHN1YnMgPSB0aGlzLnN1YnMuc2xpY2UoKTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBzdWJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHN1YnNbaV0udXBkYXRlKCk7XG4gIH1cbn07XG5cbi8vIHRoZSBjdXJyZW50IHRhcmdldCB3YXRjaGVyIGJlaW5nIGV2YWx1YXRlZC5cbi8vIHRoaXMgaXMgZ2xvYmFsbHkgdW5pcXVlIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgb25seSBvbmVcbi8vIHdhdGNoZXIgYmVpbmcgZXZhbHVhdGVkIGF0IGFueSB0aW1lLlxuRGVwLnRhcmdldCA9IG51bGw7XG52YXIgdGFyZ2V0U3RhY2sgPSBbXTtcblxuZnVuY3Rpb24gcHVzaFRhcmdldCAoX3RhcmdldCkge1xuICBpZiAoRGVwLnRhcmdldCkgeyB0YXJnZXRTdGFjay5wdXNoKERlcC50YXJnZXQpOyB9XG4gIERlcC50YXJnZXQgPSBfdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBwb3BUYXJnZXQgKCkge1xuICBEZXAudGFyZ2V0ID0gdGFyZ2V0U3RhY2sucG9wKCk7XG59XG5cbi8qICAqL1xuXG52YXIgVk5vZGUgPSBmdW5jdGlvbiBWTm9kZSAoXG4gIHRhZyxcbiAgZGF0YSxcbiAgY2hpbGRyZW4sXG4gIHRleHQsXG4gIGVsbSxcbiAgY29udGV4dCxcbiAgY29tcG9uZW50T3B0aW9ucyxcbiAgYXN5bmNGYWN0b3J5XG4pIHtcbiAgdGhpcy50YWcgPSB0YWc7XG4gIHRoaXMuZGF0YSA9IGRhdGE7XG4gIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgdGhpcy5lbG0gPSBlbG07XG4gIHRoaXMubnMgPSB1bmRlZmluZWQ7XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMuZm5Db250ZXh0ID0gdW5kZWZpbmVkO1xuICB0aGlzLmZuT3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgdGhpcy5mblNjb3BlSWQgPSB1bmRlZmluZWQ7XG4gIHRoaXMua2V5ID0gZGF0YSAmJiBkYXRhLmtleTtcbiAgdGhpcy5jb21wb25lbnRPcHRpb25zID0gY29tcG9uZW50T3B0aW9ucztcbiAgdGhpcy5jb21wb25lbnRJbnN0YW5jZSA9IHVuZGVmaW5lZDtcbiAgdGhpcy5wYXJlbnQgPSB1bmRlZmluZWQ7XG4gIHRoaXMucmF3ID0gZmFsc2U7XG4gIHRoaXMuaXNTdGF0aWMgPSBmYWxzZTtcbiAgdGhpcy5pc1Jvb3RJbnNlcnQgPSB0cnVlO1xuICB0aGlzLmlzQ29tbWVudCA9IGZhbHNlO1xuICB0aGlzLmlzQ2xvbmVkID0gZmFsc2U7XG4gIHRoaXMuaXNPbmNlID0gZmFsc2U7XG4gIHRoaXMuYXN5bmNGYWN0b3J5ID0gYXN5bmNGYWN0b3J5O1xuICB0aGlzLmFzeW5jTWV0YSA9IHVuZGVmaW5lZDtcbiAgdGhpcy5pc0FzeW5jUGxhY2Vob2xkZXIgPSBmYWxzZTtcbn07XG5cbnZhciBwcm90b3R5cGVBY2Nlc3NvcnMgPSB7IGNoaWxkOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5cbi8vIERFUFJFQ0FURUQ6IGFsaWFzIGZvciBjb21wb25lbnRJbnN0YW5jZSBmb3IgYmFja3dhcmRzIGNvbXBhdC5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5wcm90b3R5cGVBY2Nlc3NvcnMuY2hpbGQuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5jb21wb25lbnRJbnN0YW5jZVxufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIFZOb2RlLnByb3RvdHlwZSwgcHJvdG90eXBlQWNjZXNzb3JzICk7XG5cbnZhciBjcmVhdGVFbXB0eVZOb2RlID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgaWYgKCB0ZXh0ID09PSB2b2lkIDAgKSB0ZXh0ID0gJyc7XG5cbiAgdmFyIG5vZGUgPSBuZXcgVk5vZGUoKTtcbiAgbm9kZS50ZXh0ID0gdGV4dDtcbiAgbm9kZS5pc0NvbW1lbnQgPSB0cnVlO1xuICByZXR1cm4gbm9kZVxufTtcblxuZnVuY3Rpb24gY3JlYXRlVGV4dFZOb2RlICh2YWwpIHtcbiAgcmV0dXJuIG5ldyBWTm9kZSh1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBTdHJpbmcodmFsKSlcbn1cblxuLy8gb3B0aW1pemVkIHNoYWxsb3cgY2xvbmVcbi8vIHVzZWQgZm9yIHN0YXRpYyBub2RlcyBhbmQgc2xvdCBub2RlcyBiZWNhdXNlIHRoZXkgbWF5IGJlIHJldXNlZCBhY3Jvc3Ncbi8vIG11bHRpcGxlIHJlbmRlcnMsIGNsb25pbmcgdGhlbSBhdm9pZHMgZXJyb3JzIHdoZW4gRE9NIG1hbmlwdWxhdGlvbnMgcmVseVxuLy8gb24gdGhlaXIgZWxtIHJlZmVyZW5jZS5cbmZ1bmN0aW9uIGNsb25lVk5vZGUgKHZub2RlKSB7XG4gIHZhciBjbG9uZWQgPSBuZXcgVk5vZGUoXG4gICAgdm5vZGUudGFnLFxuICAgIHZub2RlLmRhdGEsXG4gICAgdm5vZGUuY2hpbGRyZW4sXG4gICAgdm5vZGUudGV4dCxcbiAgICB2bm9kZS5lbG0sXG4gICAgdm5vZGUuY29udGV4dCxcbiAgICB2bm9kZS5jb21wb25lbnRPcHRpb25zLFxuICAgIHZub2RlLmFzeW5jRmFjdG9yeVxuICApO1xuICBjbG9uZWQubnMgPSB2bm9kZS5ucztcbiAgY2xvbmVkLmlzU3RhdGljID0gdm5vZGUuaXNTdGF0aWM7XG4gIGNsb25lZC5rZXkgPSB2bm9kZS5rZXk7XG4gIGNsb25lZC5pc0NvbW1lbnQgPSB2bm9kZS5pc0NvbW1lbnQ7XG4gIGNsb25lZC5mbkNvbnRleHQgPSB2bm9kZS5mbkNvbnRleHQ7XG4gIGNsb25lZC5mbk9wdGlvbnMgPSB2bm9kZS5mbk9wdGlvbnM7XG4gIGNsb25lZC5mblNjb3BlSWQgPSB2bm9kZS5mblNjb3BlSWQ7XG4gIGNsb25lZC5pc0Nsb25lZCA9IHRydWU7XG4gIHJldHVybiBjbG9uZWRcbn1cblxuLypcbiAqIG5vdCB0eXBlIGNoZWNraW5nIHRoaXMgZmlsZSBiZWNhdXNlIGZsb3cgZG9lc24ndCBwbGF5IHdlbGwgd2l0aFxuICogZHluYW1pY2FsbHkgYWNjZXNzaW5nIG1ldGhvZHMgb24gQXJyYXkgcHJvdG90eXBlXG4gKi9cblxudmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG52YXIgYXJyYXlNZXRob2RzID0gT2JqZWN0LmNyZWF0ZShhcnJheVByb3RvKTtcblxudmFyIG1ldGhvZHNUb1BhdGNoID0gW1xuICAncHVzaCcsXG4gICdwb3AnLFxuICAnc2hpZnQnLFxuICAndW5zaGlmdCcsXG4gICdzcGxpY2UnLFxuICAnc29ydCcsXG4gICdyZXZlcnNlJ1xuXTtcblxuLyoqXG4gKiBJbnRlcmNlcHQgbXV0YXRpbmcgbWV0aG9kcyBhbmQgZW1pdCBldmVudHNcbiAqL1xubWV0aG9kc1RvUGF0Y2guZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XG4gIC8vIGNhY2hlIG9yaWdpbmFsIG1ldGhvZFxuICB2YXIgb3JpZ2luYWwgPSBhcnJheVByb3RvW21ldGhvZF07XG4gIGRlZihhcnJheU1ldGhvZHMsIG1ldGhvZCwgZnVuY3Rpb24gbXV0YXRvciAoKSB7XG4gICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgdmFyIHJlc3VsdCA9IG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIHZhciBvYiA9IHRoaXMuX19vYl9fO1xuICAgIHZhciBpbnNlcnRlZDtcbiAgICBzd2l0Y2ggKG1ldGhvZCkge1xuICAgICAgY2FzZSAncHVzaCc6XG4gICAgICBjYXNlICd1bnNoaWZ0JzpcbiAgICAgICAgaW5zZXJ0ZWQgPSBhcmdzO1xuICAgICAgICBicmVha1xuICAgICAgY2FzZSAnc3BsaWNlJzpcbiAgICAgICAgaW5zZXJ0ZWQgPSBhcmdzLnNsaWNlKDIpO1xuICAgICAgICBicmVha1xuICAgIH1cbiAgICBpZiAoaW5zZXJ0ZWQpIHsgb2Iub2JzZXJ2ZUFycmF5KGluc2VydGVkKTsgfVxuICAgIC8vIG5vdGlmeSBjaGFuZ2VcbiAgICBvYi5kZXAubm90aWZ5KCk7XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9KTtcbn0pO1xuXG4vKiAgKi9cblxudmFyIGFycmF5S2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGFycmF5TWV0aG9kcyk7XG5cbi8qKlxuICogSW4gc29tZSBjYXNlcyB3ZSBtYXkgd2FudCB0byBkaXNhYmxlIG9ic2VydmF0aW9uIGluc2lkZSBhIGNvbXBvbmVudCdzXG4gKiB1cGRhdGUgY29tcHV0YXRpb24uXG4gKi9cbnZhciBzaG91bGRPYnNlcnZlID0gdHJ1ZTtcblxuZnVuY3Rpb24gdG9nZ2xlT2JzZXJ2aW5nICh2YWx1ZSkge1xuICBzaG91bGRPYnNlcnZlID0gdmFsdWU7XG59XG5cbi8qKlxuICogT2JzZXJ2ZXIgY2xhc3MgdGhhdCBpcyBhdHRhY2hlZCB0byBlYWNoIG9ic2VydmVkXG4gKiBvYmplY3QuIE9uY2UgYXR0YWNoZWQsIHRoZSBvYnNlcnZlciBjb252ZXJ0cyB0aGUgdGFyZ2V0XG4gKiBvYmplY3QncyBwcm9wZXJ0eSBrZXlzIGludG8gZ2V0dGVyL3NldHRlcnMgdGhhdFxuICogY29sbGVjdCBkZXBlbmRlbmNpZXMgYW5kIGRpc3BhdGNoIHVwZGF0ZXMuXG4gKi9cbnZhciBPYnNlcnZlciA9IGZ1bmN0aW9uIE9ic2VydmVyICh2YWx1ZSkge1xuICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gIHRoaXMuZGVwID0gbmV3IERlcCgpO1xuICB0aGlzLnZtQ291bnQgPSAwO1xuICBkZWYodmFsdWUsICdfX29iX18nLCB0aGlzKTtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgdmFyIGF1Z21lbnQgPSBoYXNQcm90b1xuICAgICAgPyBwcm90b0F1Z21lbnRcbiAgICAgIDogY29weUF1Z21lbnQ7XG4gICAgYXVnbWVudCh2YWx1ZSwgYXJyYXlNZXRob2RzLCBhcnJheUtleXMpO1xuICAgIHRoaXMub2JzZXJ2ZUFycmF5KHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLndhbGsodmFsdWUpO1xuICB9XG59O1xuXG4vKipcbiAqIFdhbGsgdGhyb3VnaCBlYWNoIHByb3BlcnR5IGFuZCBjb252ZXJ0IHRoZW0gaW50b1xuICogZ2V0dGVyL3NldHRlcnMuIFRoaXMgbWV0aG9kIHNob3VsZCBvbmx5IGJlIGNhbGxlZCB3aGVuXG4gKiB2YWx1ZSB0eXBlIGlzIE9iamVjdC5cbiAqL1xuT2JzZXJ2ZXIucHJvdG90eXBlLndhbGsgPSBmdW5jdGlvbiB3YWxrIChvYmopIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBkZWZpbmVSZWFjdGl2ZShvYmosIGtleXNbaV0pO1xuICB9XG59O1xuXG4vKipcbiAqIE9ic2VydmUgYSBsaXN0IG9mIEFycmF5IGl0ZW1zLlxuICovXG5PYnNlcnZlci5wcm90b3R5cGUub2JzZXJ2ZUFycmF5ID0gZnVuY3Rpb24gb2JzZXJ2ZUFycmF5IChpdGVtcykge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGl0ZW1zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIG9ic2VydmUoaXRlbXNbaV0pO1xuICB9XG59O1xuXG4vLyBoZWxwZXJzXG5cbi8qKlxuICogQXVnbWVudCBhbiB0YXJnZXQgT2JqZWN0IG9yIEFycmF5IGJ5IGludGVyY2VwdGluZ1xuICogdGhlIHByb3RvdHlwZSBjaGFpbiB1c2luZyBfX3Byb3RvX19cbiAqL1xuZnVuY3Rpb24gcHJvdG9BdWdtZW50ICh0YXJnZXQsIHNyYywga2V5cykge1xuICAvKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuICB0YXJnZXQuX19wcm90b19fID0gc3JjO1xuICAvKiBlc2xpbnQtZW5hYmxlIG5vLXByb3RvICovXG59XG5cbi8qKlxuICogQXVnbWVudCBhbiB0YXJnZXQgT2JqZWN0IG9yIEFycmF5IGJ5IGRlZmluaW5nXG4gKiBoaWRkZW4gcHJvcGVydGllcy5cbiAqL1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIGNvcHlBdWdtZW50ICh0YXJnZXQsIHNyYywga2V5cykge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgZGVmKHRhcmdldCwga2V5LCBzcmNba2V5XSk7XG4gIH1cbn1cblxuLyoqXG4gKiBBdHRlbXB0IHRvIGNyZWF0ZSBhbiBvYnNlcnZlciBpbnN0YW5jZSBmb3IgYSB2YWx1ZSxcbiAqIHJldHVybnMgdGhlIG5ldyBvYnNlcnZlciBpZiBzdWNjZXNzZnVsbHkgb2JzZXJ2ZWQsXG4gKiBvciB0aGUgZXhpc3Rpbmcgb2JzZXJ2ZXIgaWYgdGhlIHZhbHVlIGFscmVhZHkgaGFzIG9uZS5cbiAqL1xuZnVuY3Rpb24gb2JzZXJ2ZSAodmFsdWUsIGFzUm9vdERhdGEpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkgfHwgdmFsdWUgaW5zdGFuY2VvZiBWTm9kZSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBvYjtcbiAgaWYgKGhhc093bih2YWx1ZSwgJ19fb2JfXycpICYmIHZhbHVlLl9fb2JfXyBpbnN0YW5jZW9mIE9ic2VydmVyKSB7XG4gICAgb2IgPSB2YWx1ZS5fX29iX187XG4gIH0gZWxzZSBpZiAoXG4gICAgc2hvdWxkT2JzZXJ2ZSAmJlxuICAgICFpc1NlcnZlclJlbmRlcmluZygpICYmXG4gICAgKEFycmF5LmlzQXJyYXkodmFsdWUpIHx8IGlzUGxhaW5PYmplY3QodmFsdWUpKSAmJlxuICAgIE9iamVjdC5pc0V4dGVuc2libGUodmFsdWUpICYmXG4gICAgIXZhbHVlLl9pc1Z1ZVxuICApIHtcbiAgICBvYiA9IG5ldyBPYnNlcnZlcih2YWx1ZSk7XG4gIH1cbiAgaWYgKGFzUm9vdERhdGEgJiYgb2IpIHtcbiAgICBvYi52bUNvdW50Kys7XG4gIH1cbiAgcmV0dXJuIG9iXG59XG5cbi8qKlxuICogRGVmaW5lIGEgcmVhY3RpdmUgcHJvcGVydHkgb24gYW4gT2JqZWN0LlxuICovXG5mdW5jdGlvbiBkZWZpbmVSZWFjdGl2ZSAoXG4gIG9iaixcbiAga2V5LFxuICB2YWwsXG4gIGN1c3RvbVNldHRlcixcbiAgc2hhbGxvd1xuKSB7XG4gIHZhciBkZXAgPSBuZXcgRGVwKCk7XG5cbiAgdmFyIHByb3BlcnR5ID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSk7XG4gIGlmIChwcm9wZXJ0eSAmJiBwcm9wZXJ0eS5jb25maWd1cmFibGUgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvLyBjYXRlciBmb3IgcHJlLWRlZmluZWQgZ2V0dGVyL3NldHRlcnNcbiAgdmFyIGdldHRlciA9IHByb3BlcnR5ICYmIHByb3BlcnR5LmdldDtcbiAgaWYgKCFnZXR0ZXIgJiYgYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHZhbCA9IG9ialtrZXldO1xuICB9XG4gIHZhciBzZXR0ZXIgPSBwcm9wZXJ0eSAmJiBwcm9wZXJ0eS5zZXQ7XG5cbiAgdmFyIGNoaWxkT2IgPSAhc2hhbGxvdyAmJiBvYnNlcnZlKHZhbCk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gcmVhY3RpdmVHZXR0ZXIgKCkge1xuICAgICAgdmFyIHZhbHVlID0gZ2V0dGVyID8gZ2V0dGVyLmNhbGwob2JqKSA6IHZhbDtcbiAgICAgIGlmIChEZXAudGFyZ2V0KSB7XG4gICAgICAgIGRlcC5kZXBlbmQoKTtcbiAgICAgICAgaWYgKGNoaWxkT2IpIHtcbiAgICAgICAgICBjaGlsZE9iLmRlcC5kZXBlbmQoKTtcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGRlcGVuZEFycmF5KHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZVxuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiByZWFjdGl2ZVNldHRlciAobmV3VmFsKSB7XG4gICAgICB2YXIgdmFsdWUgPSBnZXR0ZXIgPyBnZXR0ZXIuY2FsbChvYmopIDogdmFsO1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tc2VsZi1jb21wYXJlICovXG4gICAgICBpZiAobmV3VmFsID09PSB2YWx1ZSB8fCAobmV3VmFsICE9PSBuZXdWYWwgJiYgdmFsdWUgIT09IHZhbHVlKSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tc2VsZi1jb21wYXJlICovXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjdXN0b21TZXR0ZXIpIHtcbiAgICAgICAgY3VzdG9tU2V0dGVyKCk7XG4gICAgICB9XG4gICAgICBpZiAoc2V0dGVyKSB7XG4gICAgICAgIHNldHRlci5jYWxsKG9iaiwgbmV3VmFsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbCA9IG5ld1ZhbDtcbiAgICAgIH1cbiAgICAgIGNoaWxkT2IgPSAhc2hhbGxvdyAmJiBvYnNlcnZlKG5ld1ZhbCk7XG4gICAgICBkZXAubm90aWZ5KCk7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBTZXQgYSBwcm9wZXJ0eSBvbiBhbiBvYmplY3QuIEFkZHMgdGhlIG5ldyBwcm9wZXJ0eSBhbmRcbiAqIHRyaWdnZXJzIGNoYW5nZSBub3RpZmljYXRpb24gaWYgdGhlIHByb3BlcnR5IGRvZXNuJ3RcbiAqIGFscmVhZHkgZXhpc3QuXG4gKi9cbmZ1bmN0aW9uIHNldCAodGFyZ2V0LCBrZXksIHZhbCkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgIChpc1VuZGVmKHRhcmdldCkgfHwgaXNQcmltaXRpdmUodGFyZ2V0KSlcbiAgKSB7XG4gICAgd2FybigoXCJDYW5ub3Qgc2V0IHJlYWN0aXZlIHByb3BlcnR5IG9uIHVuZGVmaW5lZCwgbnVsbCwgb3IgcHJpbWl0aXZlIHZhbHVlOiBcIiArICgodGFyZ2V0KSkpKTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheSh0YXJnZXQpICYmIGlzVmFsaWRBcnJheUluZGV4KGtleSkpIHtcbiAgICB0YXJnZXQubGVuZ3RoID0gTWF0aC5tYXgodGFyZ2V0Lmxlbmd0aCwga2V5KTtcbiAgICB0YXJnZXQuc3BsaWNlKGtleSwgMSwgdmFsKTtcbiAgICByZXR1cm4gdmFsXG4gIH1cbiAgaWYgKGtleSBpbiB0YXJnZXQgJiYgIShrZXkgaW4gT2JqZWN0LnByb3RvdHlwZSkpIHtcbiAgICB0YXJnZXRba2V5XSA9IHZhbDtcbiAgICByZXR1cm4gdmFsXG4gIH1cbiAgdmFyIG9iID0gKHRhcmdldCkuX19vYl9fO1xuICBpZiAodGFyZ2V0Ll9pc1Z1ZSB8fCAob2IgJiYgb2Iudm1Db3VudCkpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAnQXZvaWQgYWRkaW5nIHJlYWN0aXZlIHByb3BlcnRpZXMgdG8gYSBWdWUgaW5zdGFuY2Ugb3IgaXRzIHJvb3QgJGRhdGEgJyArXG4gICAgICAnYXQgcnVudGltZSAtIGRlY2xhcmUgaXQgdXBmcm9udCBpbiB0aGUgZGF0YSBvcHRpb24uJ1xuICAgICk7XG4gICAgcmV0dXJuIHZhbFxuICB9XG4gIGlmICghb2IpIHtcbiAgICB0YXJnZXRba2V5XSA9IHZhbDtcbiAgICByZXR1cm4gdmFsXG4gIH1cbiAgZGVmaW5lUmVhY3RpdmUob2IudmFsdWUsIGtleSwgdmFsKTtcbiAgb2IuZGVwLm5vdGlmeSgpO1xuICByZXR1cm4gdmFsXG59XG5cbi8qKlxuICogRGVsZXRlIGEgcHJvcGVydHkgYW5kIHRyaWdnZXIgY2hhbmdlIGlmIG5lY2Vzc2FyeS5cbiAqL1xuZnVuY3Rpb24gZGVsICh0YXJnZXQsIGtleSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgIChpc1VuZGVmKHRhcmdldCkgfHwgaXNQcmltaXRpdmUodGFyZ2V0KSlcbiAgKSB7XG4gICAgd2FybigoXCJDYW5ub3QgZGVsZXRlIHJlYWN0aXZlIHByb3BlcnR5IG9uIHVuZGVmaW5lZCwgbnVsbCwgb3IgcHJpbWl0aXZlIHZhbHVlOiBcIiArICgodGFyZ2V0KSkpKTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheSh0YXJnZXQpICYmIGlzVmFsaWRBcnJheUluZGV4KGtleSkpIHtcbiAgICB0YXJnZXQuc3BsaWNlKGtleSwgMSk7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIG9iID0gKHRhcmdldCkuX19vYl9fO1xuICBpZiAodGFyZ2V0Ll9pc1Z1ZSB8fCAob2IgJiYgb2Iudm1Db3VudCkpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAnQXZvaWQgZGVsZXRpbmcgcHJvcGVydGllcyBvbiBhIFZ1ZSBpbnN0YW5jZSBvciBpdHMgcm9vdCAkZGF0YSAnICtcbiAgICAgICctIGp1c3Qgc2V0IGl0IHRvIG51bGwuJ1xuICAgICk7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKCFoYXNPd24odGFyZ2V0LCBrZXkpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgZGVsZXRlIHRhcmdldFtrZXldO1xuICBpZiAoIW9iKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgb2IuZGVwLm5vdGlmeSgpO1xufVxuXG4vKipcbiAqIENvbGxlY3QgZGVwZW5kZW5jaWVzIG9uIGFycmF5IGVsZW1lbnRzIHdoZW4gdGhlIGFycmF5IGlzIHRvdWNoZWQsIHNpbmNlXG4gKiB3ZSBjYW5ub3QgaW50ZXJjZXB0IGFycmF5IGVsZW1lbnQgYWNjZXNzIGxpa2UgcHJvcGVydHkgZ2V0dGVycy5cbiAqL1xuZnVuY3Rpb24gZGVwZW5kQXJyYXkgKHZhbHVlKSB7XG4gIGZvciAodmFyIGUgPSAodm9pZCAwKSwgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBlID0gdmFsdWVbaV07XG4gICAgZSAmJiBlLl9fb2JfXyAmJiBlLl9fb2JfXy5kZXAuZGVwZW5kKCk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZSkpIHtcbiAgICAgIGRlcGVuZEFycmF5KGUpO1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBPcHRpb24gb3ZlcndyaXRpbmcgc3RyYXRlZ2llcyBhcmUgZnVuY3Rpb25zIHRoYXQgaGFuZGxlXG4gKiBob3cgdG8gbWVyZ2UgYSBwYXJlbnQgb3B0aW9uIHZhbHVlIGFuZCBhIGNoaWxkIG9wdGlvblxuICogdmFsdWUgaW50byB0aGUgZmluYWwgdmFsdWUuXG4gKi9cbnZhciBzdHJhdHMgPSBjb25maWcub3B0aW9uTWVyZ2VTdHJhdGVnaWVzO1xuXG4vKipcbiAqIE9wdGlvbnMgd2l0aCByZXN0cmljdGlvbnNcbiAqL1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgc3RyYXRzLmVsID0gc3RyYXRzLnByb3BzRGF0YSA9IGZ1bmN0aW9uIChwYXJlbnQsIGNoaWxkLCB2bSwga2V5KSB7XG4gICAgaWYgKCF2bSkge1xuICAgICAgd2FybihcbiAgICAgICAgXCJvcHRpb24gXFxcIlwiICsga2V5ICsgXCJcXFwiIGNhbiBvbmx5IGJlIHVzZWQgZHVyaW5nIGluc3RhbmNlIFwiICtcbiAgICAgICAgJ2NyZWF0aW9uIHdpdGggdGhlIGBuZXdgIGtleXdvcmQuJ1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlZmF1bHRTdHJhdChwYXJlbnQsIGNoaWxkKVxuICB9O1xufVxuXG4vKipcbiAqIEhlbHBlciB0aGF0IHJlY3Vyc2l2ZWx5IG1lcmdlcyB0d28gZGF0YSBvYmplY3RzIHRvZ2V0aGVyLlxuICovXG5mdW5jdGlvbiBtZXJnZURhdGEgKHRvLCBmcm9tKSB7XG4gIGlmICghZnJvbSkgeyByZXR1cm4gdG8gfVxuICB2YXIga2V5LCB0b1ZhbCwgZnJvbVZhbDtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhmcm9tKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAga2V5ID0ga2V5c1tpXTtcbiAgICB0b1ZhbCA9IHRvW2tleV07XG4gICAgZnJvbVZhbCA9IGZyb21ba2V5XTtcbiAgICBpZiAoIWhhc093bih0bywga2V5KSkge1xuICAgICAgc2V0KHRvLCBrZXksIGZyb21WYWwpO1xuICAgIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdCh0b1ZhbCkgJiYgaXNQbGFpbk9iamVjdChmcm9tVmFsKSkge1xuICAgICAgbWVyZ2VEYXRhKHRvVmFsLCBmcm9tVmFsKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRvXG59XG5cbi8qKlxuICogRGF0YVxuICovXG5mdW5jdGlvbiBtZXJnZURhdGFPckZuIChcbiAgcGFyZW50VmFsLFxuICBjaGlsZFZhbCxcbiAgdm1cbikge1xuICBpZiAoIXZtKSB7XG4gICAgLy8gaW4gYSBWdWUuZXh0ZW5kIG1lcmdlLCBib3RoIHNob3VsZCBiZSBmdW5jdGlvbnNcbiAgICBpZiAoIWNoaWxkVmFsKSB7XG4gICAgICByZXR1cm4gcGFyZW50VmFsXG4gICAgfVxuICAgIGlmICghcGFyZW50VmFsKSB7XG4gICAgICByZXR1cm4gY2hpbGRWYWxcbiAgICB9XG4gICAgLy8gd2hlbiBwYXJlbnRWYWwgJiBjaGlsZFZhbCBhcmUgYm90aCBwcmVzZW50LFxuICAgIC8vIHdlIG5lZWQgdG8gcmV0dXJuIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZVxuICAgIC8vIG1lcmdlZCByZXN1bHQgb2YgYm90aCBmdW5jdGlvbnMuLi4gbm8gbmVlZCB0b1xuICAgIC8vIGNoZWNrIGlmIHBhcmVudFZhbCBpcyBhIGZ1bmN0aW9uIGhlcmUgYmVjYXVzZVxuICAgIC8vIGl0IGhhcyB0byBiZSBhIGZ1bmN0aW9uIHRvIHBhc3MgcHJldmlvdXMgbWVyZ2VzLlxuICAgIHJldHVybiBmdW5jdGlvbiBtZXJnZWREYXRhRm4gKCkge1xuICAgICAgcmV0dXJuIG1lcmdlRGF0YShcbiAgICAgICAgdHlwZW9mIGNoaWxkVmFsID09PSAnZnVuY3Rpb24nID8gY2hpbGRWYWwuY2FsbCh0aGlzLCB0aGlzKSA6IGNoaWxkVmFsLFxuICAgICAgICB0eXBlb2YgcGFyZW50VmFsID09PSAnZnVuY3Rpb24nID8gcGFyZW50VmFsLmNhbGwodGhpcywgdGhpcykgOiBwYXJlbnRWYWxcbiAgICAgIClcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1lcmdlZEluc3RhbmNlRGF0YUZuICgpIHtcbiAgICAgIC8vIGluc3RhbmNlIG1lcmdlXG4gICAgICB2YXIgaW5zdGFuY2VEYXRhID0gdHlwZW9mIGNoaWxkVmFsID09PSAnZnVuY3Rpb24nXG4gICAgICAgID8gY2hpbGRWYWwuY2FsbCh2bSwgdm0pXG4gICAgICAgIDogY2hpbGRWYWw7XG4gICAgICB2YXIgZGVmYXVsdERhdGEgPSB0eXBlb2YgcGFyZW50VmFsID09PSAnZnVuY3Rpb24nXG4gICAgICAgID8gcGFyZW50VmFsLmNhbGwodm0sIHZtKVxuICAgICAgICA6IHBhcmVudFZhbDtcbiAgICAgIGlmIChpbnN0YW5jZURhdGEpIHtcbiAgICAgICAgcmV0dXJuIG1lcmdlRGF0YShpbnN0YW5jZURhdGEsIGRlZmF1bHREYXRhKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHREYXRhXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnN0cmF0cy5kYXRhID0gZnVuY3Rpb24gKFxuICBwYXJlbnRWYWwsXG4gIGNoaWxkVmFsLFxuICB2bVxuKSB7XG4gIGlmICghdm0pIHtcbiAgICBpZiAoY2hpbGRWYWwgJiYgdHlwZW9mIGNoaWxkVmFsICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgICdUaGUgXCJkYXRhXCIgb3B0aW9uIHNob3VsZCBiZSBhIGZ1bmN0aW9uICcgK1xuICAgICAgICAndGhhdCByZXR1cm5zIGEgcGVyLWluc3RhbmNlIHZhbHVlIGluIGNvbXBvbmVudCAnICtcbiAgICAgICAgJ2RlZmluaXRpb25zLicsXG4gICAgICAgIHZtXG4gICAgICApO1xuXG4gICAgICByZXR1cm4gcGFyZW50VmFsXG4gICAgfVxuICAgIHJldHVybiBtZXJnZURhdGFPckZuKHBhcmVudFZhbCwgY2hpbGRWYWwpXG4gIH1cblxuICByZXR1cm4gbWVyZ2VEYXRhT3JGbihwYXJlbnRWYWwsIGNoaWxkVmFsLCB2bSlcbn07XG5cbi8qKlxuICogSG9va3MgYW5kIHByb3BzIGFyZSBtZXJnZWQgYXMgYXJyYXlzLlxuICovXG5mdW5jdGlvbiBtZXJnZUhvb2sgKFxuICBwYXJlbnRWYWwsXG4gIGNoaWxkVmFsXG4pIHtcbiAgcmV0dXJuIGNoaWxkVmFsXG4gICAgPyBwYXJlbnRWYWxcbiAgICAgID8gcGFyZW50VmFsLmNvbmNhdChjaGlsZFZhbClcbiAgICAgIDogQXJyYXkuaXNBcnJheShjaGlsZFZhbClcbiAgICAgICAgPyBjaGlsZFZhbFxuICAgICAgICA6IFtjaGlsZFZhbF1cbiAgICA6IHBhcmVudFZhbFxufVxuXG5MSUZFQ1lDTEVfSE9PS1MuZm9yRWFjaChmdW5jdGlvbiAoaG9vaykge1xuICBzdHJhdHNbaG9va10gPSBtZXJnZUhvb2s7XG59KTtcblxuLyoqXG4gKiBBc3NldHNcbiAqXG4gKiBXaGVuIGEgdm0gaXMgcHJlc2VudCAoaW5zdGFuY2UgY3JlYXRpb24pLCB3ZSBuZWVkIHRvIGRvXG4gKiBhIHRocmVlLXdheSBtZXJnZSBiZXR3ZWVuIGNvbnN0cnVjdG9yIG9wdGlvbnMsIGluc3RhbmNlXG4gKiBvcHRpb25zIGFuZCBwYXJlbnQgb3B0aW9ucy5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VBc3NldHMgKFxuICBwYXJlbnRWYWwsXG4gIGNoaWxkVmFsLFxuICB2bSxcbiAga2V5XG4pIHtcbiAgdmFyIHJlcyA9IE9iamVjdC5jcmVhdGUocGFyZW50VmFsIHx8IG51bGwpO1xuICBpZiAoY2hpbGRWYWwpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGFzc2VydE9iamVjdFR5cGUoa2V5LCBjaGlsZFZhbCwgdm0pO1xuICAgIHJldHVybiBleHRlbmQocmVzLCBjaGlsZFZhbClcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcmVzXG4gIH1cbn1cblxuQVNTRVRfVFlQRVMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICBzdHJhdHNbdHlwZSArICdzJ10gPSBtZXJnZUFzc2V0cztcbn0pO1xuXG4vKipcbiAqIFdhdGNoZXJzLlxuICpcbiAqIFdhdGNoZXJzIGhhc2hlcyBzaG91bGQgbm90IG92ZXJ3cml0ZSBvbmVcbiAqIGFub3RoZXIsIHNvIHdlIG1lcmdlIHRoZW0gYXMgYXJyYXlzLlxuICovXG5zdHJhdHMud2F0Y2ggPSBmdW5jdGlvbiAoXG4gIHBhcmVudFZhbCxcbiAgY2hpbGRWYWwsXG4gIHZtLFxuICBrZXlcbikge1xuICAvLyB3b3JrIGFyb3VuZCBGaXJlZm94J3MgT2JqZWN0LnByb3RvdHlwZS53YXRjaC4uLlxuICBpZiAocGFyZW50VmFsID09PSBuYXRpdmVXYXRjaCkgeyBwYXJlbnRWYWwgPSB1bmRlZmluZWQ7IH1cbiAgaWYgKGNoaWxkVmFsID09PSBuYXRpdmVXYXRjaCkgeyBjaGlsZFZhbCA9IHVuZGVmaW5lZDsgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCFjaGlsZFZhbCkgeyByZXR1cm4gT2JqZWN0LmNyZWF0ZShwYXJlbnRWYWwgfHwgbnVsbCkgfVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGFzc2VydE9iamVjdFR5cGUoa2V5LCBjaGlsZFZhbCwgdm0pO1xuICB9XG4gIGlmICghcGFyZW50VmFsKSB7IHJldHVybiBjaGlsZFZhbCB9XG4gIHZhciByZXQgPSB7fTtcbiAgZXh0ZW5kKHJldCwgcGFyZW50VmFsKTtcbiAgZm9yICh2YXIga2V5JDEgaW4gY2hpbGRWYWwpIHtcbiAgICB2YXIgcGFyZW50ID0gcmV0W2tleSQxXTtcbiAgICB2YXIgY2hpbGQgPSBjaGlsZFZhbFtrZXkkMV07XG4gICAgaWYgKHBhcmVudCAmJiAhQXJyYXkuaXNBcnJheShwYXJlbnQpKSB7XG4gICAgICBwYXJlbnQgPSBbcGFyZW50XTtcbiAgICB9XG4gICAgcmV0W2tleSQxXSA9IHBhcmVudFxuICAgICAgPyBwYXJlbnQuY29uY2F0KGNoaWxkKVxuICAgICAgOiBBcnJheS5pc0FycmF5KGNoaWxkKSA/IGNoaWxkIDogW2NoaWxkXTtcbiAgfVxuICByZXR1cm4gcmV0XG59O1xuXG4vKipcbiAqIE90aGVyIG9iamVjdCBoYXNoZXMuXG4gKi9cbnN0cmF0cy5wcm9wcyA9XG5zdHJhdHMubWV0aG9kcyA9XG5zdHJhdHMuaW5qZWN0ID1cbnN0cmF0cy5jb21wdXRlZCA9IGZ1bmN0aW9uIChcbiAgcGFyZW50VmFsLFxuICBjaGlsZFZhbCxcbiAgdm0sXG4gIGtleVxuKSB7XG4gIGlmIChjaGlsZFZhbCAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgYXNzZXJ0T2JqZWN0VHlwZShrZXksIGNoaWxkVmFsLCB2bSk7XG4gIH1cbiAgaWYgKCFwYXJlbnRWYWwpIHsgcmV0dXJuIGNoaWxkVmFsIH1cbiAgdmFyIHJldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGV4dGVuZChyZXQsIHBhcmVudFZhbCk7XG4gIGlmIChjaGlsZFZhbCkgeyBleHRlbmQocmV0LCBjaGlsZFZhbCk7IH1cbiAgcmV0dXJuIHJldFxufTtcbnN0cmF0cy5wcm92aWRlID0gbWVyZ2VEYXRhT3JGbjtcblxuLyoqXG4gKiBEZWZhdWx0IHN0cmF0ZWd5LlxuICovXG52YXIgZGVmYXVsdFN0cmF0ID0gZnVuY3Rpb24gKHBhcmVudFZhbCwgY2hpbGRWYWwpIHtcbiAgcmV0dXJuIGNoaWxkVmFsID09PSB1bmRlZmluZWRcbiAgICA/IHBhcmVudFZhbFxuICAgIDogY2hpbGRWYWxcbn07XG5cbi8qKlxuICogVmFsaWRhdGUgY29tcG9uZW50IG5hbWVzXG4gKi9cbmZ1bmN0aW9uIGNoZWNrQ29tcG9uZW50cyAob3B0aW9ucykge1xuICBmb3IgKHZhciBrZXkgaW4gb3B0aW9ucy5jb21wb25lbnRzKSB7XG4gICAgdmFsaWRhdGVDb21wb25lbnROYW1lKGtleSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVDb21wb25lbnROYW1lIChuYW1lKSB7XG4gIGlmICghL15bYS16QS1aXVtcXHctXSokLy50ZXN0KG5hbWUpKSB7XG4gICAgd2FybihcbiAgICAgICdJbnZhbGlkIGNvbXBvbmVudCBuYW1lOiBcIicgKyBuYW1lICsgJ1wiLiBDb21wb25lbnQgbmFtZXMgJyArXG4gICAgICAnY2FuIG9ubHkgY29udGFpbiBhbHBoYW51bWVyaWMgY2hhcmFjdGVycyBhbmQgdGhlIGh5cGhlbiwgJyArXG4gICAgICAnYW5kIG11c3Qgc3RhcnQgd2l0aCBhIGxldHRlci4nXG4gICAgKTtcbiAgfVxuICBpZiAoaXNCdWlsdEluVGFnKG5hbWUpIHx8IGNvbmZpZy5pc1Jlc2VydmVkVGFnKG5hbWUpKSB7XG4gICAgd2FybihcbiAgICAgICdEbyBub3QgdXNlIGJ1aWx0LWluIG9yIHJlc2VydmVkIEhUTUwgZWxlbWVudHMgYXMgY29tcG9uZW50ICcgK1xuICAgICAgJ2lkOiAnICsgbmFtZVxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBFbnN1cmUgYWxsIHByb3BzIG9wdGlvbiBzeW50YXggYXJlIG5vcm1hbGl6ZWQgaW50byB0aGVcbiAqIE9iamVjdC1iYXNlZCBmb3JtYXQuXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZVByb3BzIChvcHRpb25zLCB2bSkge1xuICB2YXIgcHJvcHMgPSBvcHRpb25zLnByb3BzO1xuICBpZiAoIXByb3BzKSB7IHJldHVybiB9XG4gIHZhciByZXMgPSB7fTtcbiAgdmFyIGksIHZhbCwgbmFtZTtcbiAgaWYgKEFycmF5LmlzQXJyYXkocHJvcHMpKSB7XG4gICAgaSA9IHByb3BzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB2YWwgPSBwcm9wc1tpXTtcbiAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgICAgICBuYW1lID0gY2FtZWxpemUodmFsKTtcbiAgICAgICAgcmVzW25hbWVdID0geyB0eXBlOiBudWxsIH07XG4gICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgd2FybigncHJvcHMgbXVzdCBiZSBzdHJpbmdzIHdoZW4gdXNpbmcgYXJyYXkgc3ludGF4LicpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHByb3BzKSkge1xuICAgIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgICAgdmFsID0gcHJvcHNba2V5XTtcbiAgICAgIG5hbWUgPSBjYW1lbGl6ZShrZXkpO1xuICAgICAgcmVzW25hbWVdID0gaXNQbGFpbk9iamVjdCh2YWwpXG4gICAgICAgID8gdmFsXG4gICAgICAgIDogeyB0eXBlOiB2YWwgfTtcbiAgICB9XG4gIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHdhcm4oXG4gICAgICBcIkludmFsaWQgdmFsdWUgZm9yIG9wdGlvbiBcXFwicHJvcHNcXFwiOiBleHBlY3RlZCBhbiBBcnJheSBvciBhbiBPYmplY3QsIFwiICtcbiAgICAgIFwiYnV0IGdvdCBcIiArICh0b1Jhd1R5cGUocHJvcHMpKSArIFwiLlwiLFxuICAgICAgdm1cbiAgICApO1xuICB9XG4gIG9wdGlvbnMucHJvcHMgPSByZXM7XG59XG5cbi8qKlxuICogTm9ybWFsaXplIGFsbCBpbmplY3Rpb25zIGludG8gT2JqZWN0LWJhc2VkIGZvcm1hdFxuICovXG5mdW5jdGlvbiBub3JtYWxpemVJbmplY3QgKG9wdGlvbnMsIHZtKSB7XG4gIHZhciBpbmplY3QgPSBvcHRpb25zLmluamVjdDtcbiAgaWYgKCFpbmplY3QpIHsgcmV0dXJuIH1cbiAgdmFyIG5vcm1hbGl6ZWQgPSBvcHRpb25zLmluamVjdCA9IHt9O1xuICBpZiAoQXJyYXkuaXNBcnJheShpbmplY3QpKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbmplY3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIG5vcm1hbGl6ZWRbaW5qZWN0W2ldXSA9IHsgZnJvbTogaW5qZWN0W2ldIH07XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QoaW5qZWN0KSkge1xuICAgIGZvciAodmFyIGtleSBpbiBpbmplY3QpIHtcbiAgICAgIHZhciB2YWwgPSBpbmplY3Rba2V5XTtcbiAgICAgIG5vcm1hbGl6ZWRba2V5XSA9IGlzUGxhaW5PYmplY3QodmFsKVxuICAgICAgICA/IGV4dGVuZCh7IGZyb206IGtleSB9LCB2YWwpXG4gICAgICAgIDogeyBmcm9tOiB2YWwgfTtcbiAgICB9XG4gIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHdhcm4oXG4gICAgICBcIkludmFsaWQgdmFsdWUgZm9yIG9wdGlvbiBcXFwiaW5qZWN0XFxcIjogZXhwZWN0ZWQgYW4gQXJyYXkgb3IgYW4gT2JqZWN0LCBcIiArXG4gICAgICBcImJ1dCBnb3QgXCIgKyAodG9SYXdUeXBlKGluamVjdCkpICsgXCIuXCIsXG4gICAgICB2bVxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBOb3JtYWxpemUgcmF3IGZ1bmN0aW9uIGRpcmVjdGl2ZXMgaW50byBvYmplY3QgZm9ybWF0LlxuICovXG5mdW5jdGlvbiBub3JtYWxpemVEaXJlY3RpdmVzIChvcHRpb25zKSB7XG4gIHZhciBkaXJzID0gb3B0aW9ucy5kaXJlY3RpdmVzO1xuICBpZiAoZGlycykge1xuICAgIGZvciAodmFyIGtleSBpbiBkaXJzKSB7XG4gICAgICB2YXIgZGVmID0gZGlyc1trZXldO1xuICAgICAgaWYgKHR5cGVvZiBkZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZGlyc1trZXldID0geyBiaW5kOiBkZWYsIHVwZGF0ZTogZGVmIH07XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2VydE9iamVjdFR5cGUgKG5hbWUsIHZhbHVlLCB2bSkge1xuICBpZiAoIWlzUGxhaW5PYmplY3QodmFsdWUpKSB7XG4gICAgd2FybihcbiAgICAgIFwiSW52YWxpZCB2YWx1ZSBmb3Igb3B0aW9uIFxcXCJcIiArIG5hbWUgKyBcIlxcXCI6IGV4cGVjdGVkIGFuIE9iamVjdCwgXCIgK1xuICAgICAgXCJidXQgZ290IFwiICsgKHRvUmF3VHlwZSh2YWx1ZSkpICsgXCIuXCIsXG4gICAgICB2bVxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBNZXJnZSB0d28gb3B0aW9uIG9iamVjdHMgaW50byBhIG5ldyBvbmUuXG4gKiBDb3JlIHV0aWxpdHkgdXNlZCBpbiBib3RoIGluc3RhbnRpYXRpb24gYW5kIGluaGVyaXRhbmNlLlxuICovXG5mdW5jdGlvbiBtZXJnZU9wdGlvbnMgKFxuICBwYXJlbnQsXG4gIGNoaWxkLFxuICB2bVxuKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgY2hlY2tDb21wb25lbnRzKGNoaWxkKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgY2hpbGQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjaGlsZCA9IGNoaWxkLm9wdGlvbnM7XG4gIH1cblxuICBub3JtYWxpemVQcm9wcyhjaGlsZCwgdm0pO1xuICBub3JtYWxpemVJbmplY3QoY2hpbGQsIHZtKTtcbiAgbm9ybWFsaXplRGlyZWN0aXZlcyhjaGlsZCk7XG4gIHZhciBleHRlbmRzRnJvbSA9IGNoaWxkLmV4dGVuZHM7XG4gIGlmIChleHRlbmRzRnJvbSkge1xuICAgIHBhcmVudCA9IG1lcmdlT3B0aW9ucyhwYXJlbnQsIGV4dGVuZHNGcm9tLCB2bSk7XG4gIH1cbiAgaWYgKGNoaWxkLm1peGlucykge1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGQubWl4aW5zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgcGFyZW50ID0gbWVyZ2VPcHRpb25zKHBhcmVudCwgY2hpbGQubWl4aW5zW2ldLCB2bSk7XG4gICAgfVxuICB9XG4gIHZhciBvcHRpb25zID0ge307XG4gIHZhciBrZXk7XG4gIGZvciAoa2V5IGluIHBhcmVudCkge1xuICAgIG1lcmdlRmllbGQoa2V5KTtcbiAgfVxuICBmb3IgKGtleSBpbiBjaGlsZCkge1xuICAgIGlmICghaGFzT3duKHBhcmVudCwga2V5KSkge1xuICAgICAgbWVyZ2VGaWVsZChrZXkpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBtZXJnZUZpZWxkIChrZXkpIHtcbiAgICB2YXIgc3RyYXQgPSBzdHJhdHNba2V5XSB8fCBkZWZhdWx0U3RyYXQ7XG4gICAgb3B0aW9uc1trZXldID0gc3RyYXQocGFyZW50W2tleV0sIGNoaWxkW2tleV0sIHZtLCBrZXkpO1xuICB9XG4gIHJldHVybiBvcHRpb25zXG59XG5cbi8qKlxuICogUmVzb2x2ZSBhbiBhc3NldC5cbiAqIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCBiZWNhdXNlIGNoaWxkIGluc3RhbmNlcyBuZWVkIGFjY2Vzc1xuICogdG8gYXNzZXRzIGRlZmluZWQgaW4gaXRzIGFuY2VzdG9yIGNoYWluLlxuICovXG5mdW5jdGlvbiByZXNvbHZlQXNzZXQgKFxuICBvcHRpb25zLFxuICB0eXBlLFxuICBpZCxcbiAgd2Fybk1pc3Npbmdcbikge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHR5cGVvZiBpZCAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgYXNzZXRzID0gb3B0aW9uc1t0eXBlXTtcbiAgLy8gY2hlY2sgbG9jYWwgcmVnaXN0cmF0aW9uIHZhcmlhdGlvbnMgZmlyc3RcbiAgaWYgKGhhc093bihhc3NldHMsIGlkKSkgeyByZXR1cm4gYXNzZXRzW2lkXSB9XG4gIHZhciBjYW1lbGl6ZWRJZCA9IGNhbWVsaXplKGlkKTtcbiAgaWYgKGhhc093bihhc3NldHMsIGNhbWVsaXplZElkKSkgeyByZXR1cm4gYXNzZXRzW2NhbWVsaXplZElkXSB9XG4gIHZhciBQYXNjYWxDYXNlSWQgPSBjYXBpdGFsaXplKGNhbWVsaXplZElkKTtcbiAgaWYgKGhhc093bihhc3NldHMsIFBhc2NhbENhc2VJZCkpIHsgcmV0dXJuIGFzc2V0c1tQYXNjYWxDYXNlSWRdIH1cbiAgLy8gZmFsbGJhY2sgdG8gcHJvdG90eXBlIGNoYWluXG4gIHZhciByZXMgPSBhc3NldHNbaWRdIHx8IGFzc2V0c1tjYW1lbGl6ZWRJZF0gfHwgYXNzZXRzW1Bhc2NhbENhc2VJZF07XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm5NaXNzaW5nICYmICFyZXMpIHtcbiAgICB3YXJuKFxuICAgICAgJ0ZhaWxlZCB0byByZXNvbHZlICcgKyB0eXBlLnNsaWNlKDAsIC0xKSArICc6ICcgKyBpZCxcbiAgICAgIG9wdGlvbnNcbiAgICApO1xuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcCAoXG4gIGtleSxcbiAgcHJvcE9wdGlvbnMsXG4gIHByb3BzRGF0YSxcbiAgdm1cbikge1xuICB2YXIgcHJvcCA9IHByb3BPcHRpb25zW2tleV07XG4gIHZhciBhYnNlbnQgPSAhaGFzT3duKHByb3BzRGF0YSwga2V5KTtcbiAgdmFyIHZhbHVlID0gcHJvcHNEYXRhW2tleV07XG4gIC8vIGJvb2xlYW4gY2FzdGluZ1xuICB2YXIgYm9vbGVhbkluZGV4ID0gZ2V0VHlwZUluZGV4KEJvb2xlYW4sIHByb3AudHlwZSk7XG4gIGlmIChib29sZWFuSW5kZXggPiAtMSkge1xuICAgIGlmIChhYnNlbnQgJiYgIWhhc093bihwcm9wLCAnZGVmYXVsdCcpKSB7XG4gICAgICB2YWx1ZSA9IGZhbHNlO1xuICAgIH0gZWxzZSBpZiAodmFsdWUgPT09ICcnIHx8IHZhbHVlID09PSBoeXBoZW5hdGUoa2V5KSkge1xuICAgICAgLy8gb25seSBjYXN0IGVtcHR5IHN0cmluZyAvIHNhbWUgbmFtZSB0byBib29sZWFuIGlmXG4gICAgICAvLyBib29sZWFuIGhhcyBoaWdoZXIgcHJpb3JpdHlcbiAgICAgIHZhciBzdHJpbmdJbmRleCA9IGdldFR5cGVJbmRleChTdHJpbmcsIHByb3AudHlwZSk7XG4gICAgICBpZiAoc3RyaW5nSW5kZXggPCAwIHx8IGJvb2xlYW5JbmRleCA8IHN0cmluZ0luZGV4KSB7XG4gICAgICAgIHZhbHVlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy8gY2hlY2sgZGVmYXVsdCB2YWx1ZVxuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHZhbHVlID0gZ2V0UHJvcERlZmF1bHRWYWx1ZSh2bSwgcHJvcCwga2V5KTtcbiAgICAvLyBzaW5jZSB0aGUgZGVmYXVsdCB2YWx1ZSBpcyBhIGZyZXNoIGNvcHksXG4gICAgLy8gbWFrZSBzdXJlIHRvIG9ic2VydmUgaXQuXG4gICAgdmFyIHByZXZTaG91bGRPYnNlcnZlID0gc2hvdWxkT2JzZXJ2ZTtcbiAgICB0b2dnbGVPYnNlcnZpbmcodHJ1ZSk7XG4gICAgb2JzZXJ2ZSh2YWx1ZSk7XG4gICAgdG9nZ2xlT2JzZXJ2aW5nKHByZXZTaG91bGRPYnNlcnZlKTtcbiAgfVxuICBpZiAoXG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgIC8vIHNraXAgdmFsaWRhdGlvbiBmb3Igd2VleCByZWN5Y2xlLWxpc3QgY2hpbGQgY29tcG9uZW50IHByb3BzXG4gICAgIShmYWxzZSAmJiBpc09iamVjdCh2YWx1ZSkgJiYgKCdAYmluZGluZycgaW4gdmFsdWUpKVxuICApIHtcbiAgICBhc3NlcnRQcm9wKHByb3AsIGtleSwgdmFsdWUsIHZtLCBhYnNlbnQpO1xuICB9XG4gIHJldHVybiB2YWx1ZVxufVxuXG4vKipcbiAqIEdldCB0aGUgZGVmYXVsdCB2YWx1ZSBvZiBhIHByb3AuXG4gKi9cbmZ1bmN0aW9uIGdldFByb3BEZWZhdWx0VmFsdWUgKHZtLCBwcm9wLCBrZXkpIHtcbiAgLy8gbm8gZGVmYXVsdCwgcmV0dXJuIHVuZGVmaW5lZFxuICBpZiAoIWhhc093bihwcm9wLCAnZGVmYXVsdCcpKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZFxuICB9XG4gIHZhciBkZWYgPSBwcm9wLmRlZmF1bHQ7XG4gIC8vIHdhcm4gYWdhaW5zdCBub24tZmFjdG9yeSBkZWZhdWx0cyBmb3IgT2JqZWN0ICYgQXJyYXlcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgaXNPYmplY3QoZGVmKSkge1xuICAgIHdhcm4oXG4gICAgICAnSW52YWxpZCBkZWZhdWx0IHZhbHVlIGZvciBwcm9wIFwiJyArIGtleSArICdcIjogJyArXG4gICAgICAnUHJvcHMgd2l0aCB0eXBlIE9iamVjdC9BcnJheSBtdXN0IHVzZSBhIGZhY3RvcnkgZnVuY3Rpb24gJyArXG4gICAgICAndG8gcmV0dXJuIHRoZSBkZWZhdWx0IHZhbHVlLicsXG4gICAgICB2bVxuICAgICk7XG4gIH1cbiAgLy8gdGhlIHJhdyBwcm9wIHZhbHVlIHdhcyBhbHNvIHVuZGVmaW5lZCBmcm9tIHByZXZpb3VzIHJlbmRlcixcbiAgLy8gcmV0dXJuIHByZXZpb3VzIGRlZmF1bHQgdmFsdWUgdG8gYXZvaWQgdW5uZWNlc3Nhcnkgd2F0Y2hlciB0cmlnZ2VyXG4gIGlmICh2bSAmJiB2bS4kb3B0aW9ucy5wcm9wc0RhdGEgJiZcbiAgICB2bS4kb3B0aW9ucy5wcm9wc0RhdGFba2V5XSA9PT0gdW5kZWZpbmVkICYmXG4gICAgdm0uX3Byb3BzW2tleV0gIT09IHVuZGVmaW5lZFxuICApIHtcbiAgICByZXR1cm4gdm0uX3Byb3BzW2tleV1cbiAgfVxuICAvLyBjYWxsIGZhY3RvcnkgZnVuY3Rpb24gZm9yIG5vbi1GdW5jdGlvbiB0eXBlc1xuICAvLyBhIHZhbHVlIGlzIEZ1bmN0aW9uIGlmIGl0cyBwcm90b3R5cGUgaXMgZnVuY3Rpb24gZXZlbiBhY3Jvc3MgZGlmZmVyZW50IGV4ZWN1dGlvbiBjb250ZXh0XG4gIHJldHVybiB0eXBlb2YgZGVmID09PSAnZnVuY3Rpb24nICYmIGdldFR5cGUocHJvcC50eXBlKSAhPT0gJ0Z1bmN0aW9uJ1xuICAgID8gZGVmLmNhbGwodm0pXG4gICAgOiBkZWZcbn1cblxuLyoqXG4gKiBBc3NlcnQgd2hldGhlciBhIHByb3AgaXMgdmFsaWQuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydFByb3AgKFxuICBwcm9wLFxuICBuYW1lLFxuICB2YWx1ZSxcbiAgdm0sXG4gIGFic2VudFxuKSB7XG4gIGlmIChwcm9wLnJlcXVpcmVkICYmIGFic2VudCkge1xuICAgIHdhcm4oXG4gICAgICAnTWlzc2luZyByZXF1aXJlZCBwcm9wOiBcIicgKyBuYW1lICsgJ1wiJyxcbiAgICAgIHZtXG4gICAgKTtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAodmFsdWUgPT0gbnVsbCAmJiAhcHJvcC5yZXF1aXJlZCkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciB0eXBlID0gcHJvcC50eXBlO1xuICB2YXIgdmFsaWQgPSAhdHlwZSB8fCB0eXBlID09PSB0cnVlO1xuICB2YXIgZXhwZWN0ZWRUeXBlcyA9IFtdO1xuICBpZiAodHlwZSkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh0eXBlKSkge1xuICAgICAgdHlwZSA9IFt0eXBlXTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlLmxlbmd0aCAmJiAhdmFsaWQ7IGkrKykge1xuICAgICAgdmFyIGFzc2VydGVkVHlwZSA9IGFzc2VydFR5cGUodmFsdWUsIHR5cGVbaV0pO1xuICAgICAgZXhwZWN0ZWRUeXBlcy5wdXNoKGFzc2VydGVkVHlwZS5leHBlY3RlZFR5cGUgfHwgJycpO1xuICAgICAgdmFsaWQgPSBhc3NlcnRlZFR5cGUudmFsaWQ7XG4gICAgfVxuICB9XG4gIGlmICghdmFsaWQpIHtcbiAgICB3YXJuKFxuICAgICAgXCJJbnZhbGlkIHByb3A6IHR5cGUgY2hlY2sgZmFpbGVkIGZvciBwcm9wIFxcXCJcIiArIG5hbWUgKyBcIlxcXCIuXCIgK1xuICAgICAgXCIgRXhwZWN0ZWQgXCIgKyAoZXhwZWN0ZWRUeXBlcy5tYXAoY2FwaXRhbGl6ZSkuam9pbignLCAnKSkgK1xuICAgICAgXCIsIGdvdCBcIiArICh0b1Jhd1R5cGUodmFsdWUpKSArIFwiLlwiLFxuICAgICAgdm1cbiAgICApO1xuICAgIHJldHVyblxuICB9XG4gIHZhciB2YWxpZGF0b3IgPSBwcm9wLnZhbGlkYXRvcjtcbiAgaWYgKHZhbGlkYXRvcikge1xuICAgIGlmICghdmFsaWRhdG9yKHZhbHVlKSkge1xuICAgICAgd2FybihcbiAgICAgICAgJ0ludmFsaWQgcHJvcDogY3VzdG9tIHZhbGlkYXRvciBjaGVjayBmYWlsZWQgZm9yIHByb3AgXCInICsgbmFtZSArICdcIi4nLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIHNpbXBsZUNoZWNrUkUgPSAvXihTdHJpbmd8TnVtYmVyfEJvb2xlYW58RnVuY3Rpb258U3ltYm9sKSQvO1xuXG5mdW5jdGlvbiBhc3NlcnRUeXBlICh2YWx1ZSwgdHlwZSkge1xuICB2YXIgdmFsaWQ7XG4gIHZhciBleHBlY3RlZFR5cGUgPSBnZXRUeXBlKHR5cGUpO1xuICBpZiAoc2ltcGxlQ2hlY2tSRS50ZXN0KGV4cGVjdGVkVHlwZSkpIHtcbiAgICB2YXIgdCA9IHR5cGVvZiB2YWx1ZTtcbiAgICB2YWxpZCA9IHQgPT09IGV4cGVjdGVkVHlwZS50b0xvd2VyQ2FzZSgpO1xuICAgIC8vIGZvciBwcmltaXRpdmUgd3JhcHBlciBvYmplY3RzXG4gICAgaWYgKCF2YWxpZCAmJiB0ID09PSAnb2JqZWN0Jykge1xuICAgICAgdmFsaWQgPSB2YWx1ZSBpbnN0YW5jZW9mIHR5cGU7XG4gICAgfVxuICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gJ09iamVjdCcpIHtcbiAgICB2YWxpZCA9IGlzUGxhaW5PYmplY3QodmFsdWUpO1xuICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gJ0FycmF5Jykge1xuICAgIHZhbGlkID0gQXJyYXkuaXNBcnJheSh2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFsaWQgPSB2YWx1ZSBpbnN0YW5jZW9mIHR5cGU7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB2YWxpZDogdmFsaWQsXG4gICAgZXhwZWN0ZWRUeXBlOiBleHBlY3RlZFR5cGVcbiAgfVxufVxuXG4vKipcbiAqIFVzZSBmdW5jdGlvbiBzdHJpbmcgbmFtZSB0byBjaGVjayBidWlsdC1pbiB0eXBlcyxcbiAqIGJlY2F1c2UgYSBzaW1wbGUgZXF1YWxpdHkgY2hlY2sgd2lsbCBmYWlsIHdoZW4gcnVubmluZ1xuICogYWNyb3NzIGRpZmZlcmVudCB2bXMgLyBpZnJhbWVzLlxuICovXG5mdW5jdGlvbiBnZXRUeXBlIChmbikge1xuICB2YXIgbWF0Y2ggPSBmbiAmJiBmbi50b1N0cmluZygpLm1hdGNoKC9eXFxzKmZ1bmN0aW9uIChcXHcrKS8pO1xuICByZXR1cm4gbWF0Y2ggPyBtYXRjaFsxXSA6ICcnXG59XG5cbmZ1bmN0aW9uIGlzU2FtZVR5cGUgKGEsIGIpIHtcbiAgcmV0dXJuIGdldFR5cGUoYSkgPT09IGdldFR5cGUoYilcbn1cblxuZnVuY3Rpb24gZ2V0VHlwZUluZGV4ICh0eXBlLCBleHBlY3RlZFR5cGVzKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShleHBlY3RlZFR5cGVzKSkge1xuICAgIHJldHVybiBpc1NhbWVUeXBlKGV4cGVjdGVkVHlwZXMsIHR5cGUpID8gMCA6IC0xXG4gIH1cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGV4cGVjdGVkVHlwZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoaXNTYW1lVHlwZShleHBlY3RlZFR5cGVzW2ldLCB0eXBlKSkge1xuICAgICAgcmV0dXJuIGlcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBoYW5kbGVFcnJvciAoZXJyLCB2bSwgaW5mbykge1xuICBpZiAodm0pIHtcbiAgICB2YXIgY3VyID0gdm07XG4gICAgd2hpbGUgKChjdXIgPSBjdXIuJHBhcmVudCkpIHtcbiAgICAgIHZhciBob29rcyA9IGN1ci4kb3B0aW9ucy5lcnJvckNhcHR1cmVkO1xuICAgICAgaWYgKGhvb2tzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaG9va3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIGNhcHR1cmUgPSBob29rc1tpXS5jYWxsKGN1ciwgZXJyLCB2bSwgaW5mbykgPT09IGZhbHNlO1xuICAgICAgICAgICAgaWYgKGNhcHR1cmUpIHsgcmV0dXJuIH1cbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBnbG9iYWxIYW5kbGVFcnJvcihlLCBjdXIsICdlcnJvckNhcHR1cmVkIGhvb2snKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZ2xvYmFsSGFuZGxlRXJyb3IoZXJyLCB2bSwgaW5mbyk7XG59XG5cbmZ1bmN0aW9uIGdsb2JhbEhhbmRsZUVycm9yIChlcnIsIHZtLCBpbmZvKSB7XG4gIGlmIChjb25maWcuZXJyb3JIYW5kbGVyKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBjb25maWcuZXJyb3JIYW5kbGVyLmNhbGwobnVsbCwgZXJyLCB2bSwgaW5mbylcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBsb2dFcnJvcihlLCBudWxsLCAnY29uZmlnLmVycm9ySGFuZGxlcicpO1xuICAgIH1cbiAgfVxuICBsb2dFcnJvcihlcnIsIHZtLCBpbmZvKTtcbn1cblxuZnVuY3Rpb24gbG9nRXJyb3IgKGVyciwgdm0sIGluZm8pIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB3YXJuKChcIkVycm9yIGluIFwiICsgaW5mbyArIFwiOiBcXFwiXCIgKyAoZXJyLnRvU3RyaW5nKCkpICsgXCJcXFwiXCIpLCB2bSk7XG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKChpbkJyb3dzZXIgfHwgaW5XZWV4KSAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBjb25zb2xlLmVycm9yKGVycik7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgZXJyXG4gIH1cbn1cblxuLyogICovXG4vKiBnbG9iYWxzIE1lc3NhZ2VDaGFubmVsICovXG5cbnZhciBjYWxsYmFja3MgPSBbXTtcbnZhciBwZW5kaW5nID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGZsdXNoQ2FsbGJhY2tzICgpIHtcbiAgcGVuZGluZyA9IGZhbHNlO1xuICB2YXIgY29waWVzID0gY2FsbGJhY2tzLnNsaWNlKDApO1xuICBjYWxsYmFja3MubGVuZ3RoID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3BpZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb3BpZXNbaV0oKTtcbiAgfVxufVxuXG4vLyBIZXJlIHdlIGhhdmUgYXN5bmMgZGVmZXJyaW5nIHdyYXBwZXJzIHVzaW5nIGJvdGggbWljcm90YXNrcyBhbmQgKG1hY3JvKSB0YXNrcy5cbi8vIEluIDwgMi40IHdlIHVzZWQgbWljcm90YXNrcyBldmVyeXdoZXJlLCBidXQgdGhlcmUgYXJlIHNvbWUgc2NlbmFyaW9zIHdoZXJlXG4vLyBtaWNyb3Rhc2tzIGhhdmUgdG9vIGhpZ2ggYSBwcmlvcml0eSBhbmQgZmlyZSBpbiBiZXR3ZWVuIHN1cHBvc2VkbHlcbi8vIHNlcXVlbnRpYWwgZXZlbnRzIChlLmcuICM0NTIxLCAjNjY5MCkgb3IgZXZlbiBiZXR3ZWVuIGJ1YmJsaW5nIG9mIHRoZSBzYW1lXG4vLyBldmVudCAoIzY1NjYpLiBIb3dldmVyLCB1c2luZyAobWFjcm8pIHRhc2tzIGV2ZXJ5d2hlcmUgYWxzbyBoYXMgc3VidGxlIHByb2JsZW1zXG4vLyB3aGVuIHN0YXRlIGlzIGNoYW5nZWQgcmlnaHQgYmVmb3JlIHJlcGFpbnQgKGUuZy4gIzY4MTMsIG91dC1pbiB0cmFuc2l0aW9ucykuXG4vLyBIZXJlIHdlIHVzZSBtaWNyb3Rhc2sgYnkgZGVmYXVsdCwgYnV0IGV4cG9zZSBhIHdheSB0byBmb3JjZSAobWFjcm8pIHRhc2sgd2hlblxuLy8gbmVlZGVkIChlLmcuIGluIGV2ZW50IGhhbmRsZXJzIGF0dGFjaGVkIGJ5IHYtb24pLlxudmFyIG1pY3JvVGltZXJGdW5jO1xudmFyIG1hY3JvVGltZXJGdW5jO1xudmFyIHVzZU1hY3JvVGFzayA9IGZhbHNlO1xuXG4vLyBEZXRlcm1pbmUgKG1hY3JvKSB0YXNrIGRlZmVyIGltcGxlbWVudGF0aW9uLlxuLy8gVGVjaG5pY2FsbHkgc2V0SW1tZWRpYXRlIHNob3VsZCBiZSB0aGUgaWRlYWwgY2hvaWNlLCBidXQgaXQncyBvbmx5IGF2YWlsYWJsZVxuLy8gaW4gSUUuIFRoZSBvbmx5IHBvbHlmaWxsIHRoYXQgY29uc2lzdGVudGx5IHF1ZXVlcyB0aGUgY2FsbGJhY2sgYWZ0ZXIgYWxsIERPTVxuLy8gZXZlbnRzIHRyaWdnZXJlZCBpbiB0aGUgc2FtZSBsb29wIGlzIGJ5IHVzaW5nIE1lc3NhZ2VDaGFubmVsLlxuLyogaXN0YW5idWwgaWdub3JlIGlmICovXG5pZiAodHlwZW9mIHNldEltbWVkaWF0ZSAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoc2V0SW1tZWRpYXRlKSkge1xuICBtYWNyb1RpbWVyRnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICBzZXRJbW1lZGlhdGUoZmx1c2hDYWxsYmFja3MpO1xuICB9O1xufSBlbHNlIGlmICh0eXBlb2YgTWVzc2FnZUNoYW5uZWwgIT09ICd1bmRlZmluZWQnICYmIChcbiAgaXNOYXRpdmUoTWVzc2FnZUNoYW5uZWwpIHx8XG4gIC8vIFBoYW50b21KU1xuICBNZXNzYWdlQ2hhbm5lbC50b1N0cmluZygpID09PSAnW29iamVjdCBNZXNzYWdlQ2hhbm5lbENvbnN0cnVjdG9yXSdcbikpIHtcbiAgdmFyIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgdmFyIHBvcnQgPSBjaGFubmVsLnBvcnQyO1xuICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGZsdXNoQ2FsbGJhY2tzO1xuICBtYWNyb1RpbWVyRnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICBwb3J0LnBvc3RNZXNzYWdlKDEpO1xuICB9O1xufSBlbHNlIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgbWFjcm9UaW1lckZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgc2V0VGltZW91dChmbHVzaENhbGxiYWNrcywgMCk7XG4gIH07XG59XG5cbi8vIERldGVybWluZSBtaWNyb3Rhc2sgZGVmZXIgaW1wbGVtZW50YXRpb24uXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCwgJGZsb3ctZGlzYWJsZS1saW5lICovXG5pZiAodHlwZW9mIFByb21pc2UgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFByb21pc2UpKSB7XG4gIHZhciBwID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIG1pY3JvVGltZXJGdW5jID0gZnVuY3Rpb24gKCkge1xuICAgIHAudGhlbihmbHVzaENhbGxiYWNrcyk7XG4gICAgLy8gaW4gcHJvYmxlbWF0aWMgVUlXZWJWaWV3cywgUHJvbWlzZS50aGVuIGRvZXNuJ3QgY29tcGxldGVseSBicmVhaywgYnV0XG4gICAgLy8gaXQgY2FuIGdldCBzdHVjayBpbiBhIHdlaXJkIHN0YXRlIHdoZXJlIGNhbGxiYWNrcyBhcmUgcHVzaGVkIGludG8gdGhlXG4gICAgLy8gbWljcm90YXNrIHF1ZXVlIGJ1dCB0aGUgcXVldWUgaXNuJ3QgYmVpbmcgZmx1c2hlZCwgdW50aWwgdGhlIGJyb3dzZXJcbiAgICAvLyBuZWVkcyB0byBkbyBzb21lIG90aGVyIHdvcmssIGUuZy4gaGFuZGxlIGEgdGltZXIuIFRoZXJlZm9yZSB3ZSBjYW5cbiAgICAvLyBcImZvcmNlXCIgdGhlIG1pY3JvdGFzayBxdWV1ZSB0byBiZSBmbHVzaGVkIGJ5IGFkZGluZyBhbiBlbXB0eSB0aW1lci5cbiAgICBpZiAoaXNJT1MpIHsgc2V0VGltZW91dChub29wKTsgfVxuICB9O1xufSBlbHNlIHtcbiAgLy8gZmFsbGJhY2sgdG8gbWFjcm9cbiAgbWljcm9UaW1lckZ1bmMgPSBtYWNyb1RpbWVyRnVuYztcbn1cblxuLyoqXG4gKiBXcmFwIGEgZnVuY3Rpb24gc28gdGhhdCBpZiBhbnkgY29kZSBpbnNpZGUgdHJpZ2dlcnMgc3RhdGUgY2hhbmdlLFxuICogdGhlIGNoYW5nZXMgYXJlIHF1ZXVlZCB1c2luZyBhIChtYWNybykgdGFzayBpbnN0ZWFkIG9mIGEgbWljcm90YXNrLlxuICovXG5mdW5jdGlvbiB3aXRoTWFjcm9UYXNrIChmbikge1xuICByZXR1cm4gZm4uX3dpdGhUYXNrIHx8IChmbi5fd2l0aFRhc2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgdXNlTWFjcm9UYXNrID0gdHJ1ZTtcbiAgICB2YXIgcmVzID0gZm4uYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB1c2VNYWNyb1Rhc2sgPSBmYWxzZTtcbiAgICByZXR1cm4gcmVzXG4gIH0pXG59XG5cbmZ1bmN0aW9uIG5leHRUaWNrIChjYiwgY3R4KSB7XG4gIHZhciBfcmVzb2x2ZTtcbiAgY2FsbGJhY2tzLnB1c2goZnVuY3Rpb24gKCkge1xuICAgIGlmIChjYikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY2IuY2FsbChjdHgpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBoYW5kbGVFcnJvcihlLCBjdHgsICduZXh0VGljaycpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoX3Jlc29sdmUpIHtcbiAgICAgIF9yZXNvbHZlKGN0eCk7XG4gICAgfVxuICB9KTtcbiAgaWYgKCFwZW5kaW5nKSB7XG4gICAgcGVuZGluZyA9IHRydWU7XG4gICAgaWYgKHVzZU1hY3JvVGFzaykge1xuICAgICAgbWFjcm9UaW1lckZ1bmMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWljcm9UaW1lckZ1bmMoKTtcbiAgICB9XG4gIH1cbiAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gIGlmICghY2IgJiYgdHlwZW9mIFByb21pc2UgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICBfcmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgfSlcbiAgfVxufVxuXG4vKiAgKi9cblxuLyogbm90IHR5cGUgY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgZmxvdyBkb2Vzbid0IHBsYXkgd2VsbCB3aXRoIFByb3h5ICovXG5cbnZhciBpbml0UHJveHk7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBhbGxvd2VkR2xvYmFscyA9IG1ha2VNYXAoXG4gICAgJ0luZmluaXR5LHVuZGVmaW5lZCxOYU4saXNGaW5pdGUsaXNOYU4sJyArXG4gICAgJ3BhcnNlRmxvYXQscGFyc2VJbnQsZGVjb2RlVVJJLGRlY29kZVVSSUNvbXBvbmVudCxlbmNvZGVVUkksZW5jb2RlVVJJQ29tcG9uZW50LCcgK1xuICAgICdNYXRoLE51bWJlcixEYXRlLEFycmF5LE9iamVjdCxCb29sZWFuLFN0cmluZyxSZWdFeHAsTWFwLFNldCxKU09OLEludGwsJyArXG4gICAgJ3JlcXVpcmUnIC8vIGZvciBXZWJwYWNrL0Jyb3dzZXJpZnlcbiAgKTtcblxuICB2YXIgd2Fybk5vblByZXNlbnQgPSBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHtcbiAgICB3YXJuKFxuICAgICAgXCJQcm9wZXJ0eSBvciBtZXRob2QgXFxcIlwiICsga2V5ICsgXCJcXFwiIGlzIG5vdCBkZWZpbmVkIG9uIHRoZSBpbnN0YW5jZSBidXQgXCIgK1xuICAgICAgJ3JlZmVyZW5jZWQgZHVyaW5nIHJlbmRlci4gTWFrZSBzdXJlIHRoYXQgdGhpcyBwcm9wZXJ0eSBpcyByZWFjdGl2ZSwgJyArXG4gICAgICAnZWl0aGVyIGluIHRoZSBkYXRhIG9wdGlvbiwgb3IgZm9yIGNsYXNzLWJhc2VkIGNvbXBvbmVudHMsIGJ5ICcgK1xuICAgICAgJ2luaXRpYWxpemluZyB0aGUgcHJvcGVydHkuICcgK1xuICAgICAgJ1NlZTogaHR0cHM6Ly92dWVqcy5vcmcvdjIvZ3VpZGUvcmVhY3Rpdml0eS5odG1sI0RlY2xhcmluZy1SZWFjdGl2ZS1Qcm9wZXJ0aWVzLicsXG4gICAgICB0YXJnZXRcbiAgICApO1xuICB9O1xuXG4gIHZhciBoYXNQcm94eSA9XG4gICAgdHlwZW9mIFByb3h5ICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShQcm94eSk7XG5cbiAgaWYgKGhhc1Byb3h5KSB7XG4gICAgdmFyIGlzQnVpbHRJbk1vZGlmaWVyID0gbWFrZU1hcCgnc3RvcCxwcmV2ZW50LHNlbGYsY3RybCxzaGlmdCxhbHQsbWV0YSxleGFjdCcpO1xuICAgIGNvbmZpZy5rZXlDb2RlcyA9IG5ldyBQcm94eShjb25maWcua2V5Q29kZXMsIHtcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0ICh0YXJnZXQsIGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKGlzQnVpbHRJbk1vZGlmaWVyKGtleSkpIHtcbiAgICAgICAgICB3YXJuKChcIkF2b2lkIG92ZXJ3cml0aW5nIGJ1aWx0LWluIG1vZGlmaWVyIGluIGNvbmZpZy5rZXlDb2RlczogLlwiICsga2V5KSk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICB2YXIgaGFzSGFuZGxlciA9IHtcbiAgICBoYXM6IGZ1bmN0aW9uIGhhcyAodGFyZ2V0LCBrZXkpIHtcbiAgICAgIHZhciBoYXMgPSBrZXkgaW4gdGFyZ2V0O1xuICAgICAgdmFyIGlzQWxsb3dlZCA9IGFsbG93ZWRHbG9iYWxzKGtleSkgfHwga2V5LmNoYXJBdCgwKSA9PT0gJ18nO1xuICAgICAgaWYgKCFoYXMgJiYgIWlzQWxsb3dlZCkge1xuICAgICAgICB3YXJuTm9uUHJlc2VudCh0YXJnZXQsIGtleSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaGFzIHx8ICFpc0FsbG93ZWRcbiAgICB9XG4gIH07XG5cbiAgdmFyIGdldEhhbmRsZXIgPSB7XG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQgKHRhcmdldCwga2V5KSB7XG4gICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycgJiYgIShrZXkgaW4gdGFyZ2V0KSkge1xuICAgICAgICB3YXJuTm9uUHJlc2VudCh0YXJnZXQsIGtleSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFyZ2V0W2tleV1cbiAgICB9XG4gIH07XG5cbiAgaW5pdFByb3h5ID0gZnVuY3Rpb24gaW5pdFByb3h5ICh2bSkge1xuICAgIGlmIChoYXNQcm94eSkge1xuICAgICAgLy8gZGV0ZXJtaW5lIHdoaWNoIHByb3h5IGhhbmRsZXIgdG8gdXNlXG4gICAgICB2YXIgb3B0aW9ucyA9IHZtLiRvcHRpb25zO1xuICAgICAgdmFyIGhhbmRsZXJzID0gb3B0aW9ucy5yZW5kZXIgJiYgb3B0aW9ucy5yZW5kZXIuX3dpdGhTdHJpcHBlZFxuICAgICAgICA/IGdldEhhbmRsZXJcbiAgICAgICAgOiBoYXNIYW5kbGVyO1xuICAgICAgdm0uX3JlbmRlclByb3h5ID0gbmV3IFByb3h5KHZtLCBoYW5kbGVycyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZtLl9yZW5kZXJQcm94eSA9IHZtO1xuICAgIH1cbiAgfTtcbn1cblxuLyogICovXG5cbnZhciBzZWVuT2JqZWN0cyA9IG5ldyBfU2V0KCk7XG5cbi8qKlxuICogUmVjdXJzaXZlbHkgdHJhdmVyc2UgYW4gb2JqZWN0IHRvIGV2b2tlIGFsbCBjb252ZXJ0ZWRcbiAqIGdldHRlcnMsIHNvIHRoYXQgZXZlcnkgbmVzdGVkIHByb3BlcnR5IGluc2lkZSB0aGUgb2JqZWN0XG4gKiBpcyBjb2xsZWN0ZWQgYXMgYSBcImRlZXBcIiBkZXBlbmRlbmN5LlxuICovXG5mdW5jdGlvbiB0cmF2ZXJzZSAodmFsKSB7XG4gIF90cmF2ZXJzZSh2YWwsIHNlZW5PYmplY3RzKTtcbiAgc2Vlbk9iamVjdHMuY2xlYXIoKTtcbn1cblxuZnVuY3Rpb24gX3RyYXZlcnNlICh2YWwsIHNlZW4pIHtcbiAgdmFyIGksIGtleXM7XG4gIHZhciBpc0EgPSBBcnJheS5pc0FycmF5KHZhbCk7XG4gIGlmICgoIWlzQSAmJiAhaXNPYmplY3QodmFsKSkgfHwgT2JqZWN0LmlzRnJvemVuKHZhbCkgfHwgdmFsIGluc3RhbmNlb2YgVk5vZGUpIHtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAodmFsLl9fb2JfXykge1xuICAgIHZhciBkZXBJZCA9IHZhbC5fX29iX18uZGVwLmlkO1xuICAgIGlmIChzZWVuLmhhcyhkZXBJZCkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBzZWVuLmFkZChkZXBJZCk7XG4gIH1cbiAgaWYgKGlzQSkge1xuICAgIGkgPSB2YWwubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHsgX3RyYXZlcnNlKHZhbFtpXSwgc2Vlbik7IH1cbiAgfSBlbHNlIHtcbiAgICBrZXlzID0gT2JqZWN0LmtleXModmFsKTtcbiAgICBpID0ga2V5cy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkgeyBfdHJhdmVyc2UodmFsW2tleXNbaV1dLCBzZWVuKTsgfVxuICB9XG59XG5cbnZhciBtYXJrO1xudmFyIG1lYXN1cmU7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBwZXJmID0gaW5Ccm93c2VyICYmIHdpbmRvdy5wZXJmb3JtYW5jZTtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChcbiAgICBwZXJmICYmXG4gICAgcGVyZi5tYXJrICYmXG4gICAgcGVyZi5tZWFzdXJlICYmXG4gICAgcGVyZi5jbGVhck1hcmtzICYmXG4gICAgcGVyZi5jbGVhck1lYXN1cmVzXG4gICkge1xuICAgIG1hcmsgPSBmdW5jdGlvbiAodGFnKSB7IHJldHVybiBwZXJmLm1hcmsodGFnKTsgfTtcbiAgICBtZWFzdXJlID0gZnVuY3Rpb24gKG5hbWUsIHN0YXJ0VGFnLCBlbmRUYWcpIHtcbiAgICAgIHBlcmYubWVhc3VyZShuYW1lLCBzdGFydFRhZywgZW5kVGFnKTtcbiAgICAgIHBlcmYuY2xlYXJNYXJrcyhzdGFydFRhZyk7XG4gICAgICBwZXJmLmNsZWFyTWFya3MoZW5kVGFnKTtcbiAgICAgIHBlcmYuY2xlYXJNZWFzdXJlcyhuYW1lKTtcbiAgICB9O1xuICB9XG59XG5cbi8qICAqL1xuXG52YXIgbm9ybWFsaXplRXZlbnQgPSBjYWNoZWQoZnVuY3Rpb24gKG5hbWUpIHtcbiAgdmFyIHBhc3NpdmUgPSBuYW1lLmNoYXJBdCgwKSA9PT0gJyYnO1xuICBuYW1lID0gcGFzc2l2ZSA/IG5hbWUuc2xpY2UoMSkgOiBuYW1lO1xuICB2YXIgb25jZSQkMSA9IG5hbWUuY2hhckF0KDApID09PSAnfic7IC8vIFByZWZpeGVkIGxhc3QsIGNoZWNrZWQgZmlyc3RcbiAgbmFtZSA9IG9uY2UkJDEgPyBuYW1lLnNsaWNlKDEpIDogbmFtZTtcbiAgdmFyIGNhcHR1cmUgPSBuYW1lLmNoYXJBdCgwKSA9PT0gJyEnO1xuICBuYW1lID0gY2FwdHVyZSA/IG5hbWUuc2xpY2UoMSkgOiBuYW1lO1xuICByZXR1cm4ge1xuICAgIG5hbWU6IG5hbWUsXG4gICAgb25jZTogb25jZSQkMSxcbiAgICBjYXB0dXJlOiBjYXB0dXJlLFxuICAgIHBhc3NpdmU6IHBhc3NpdmVcbiAgfVxufSk7XG5cbmZ1bmN0aW9uIGNyZWF0ZUZuSW52b2tlciAoZm5zKSB7XG4gIGZ1bmN0aW9uIGludm9rZXIgKCkge1xuICAgIHZhciBhcmd1bWVudHMkMSA9IGFyZ3VtZW50cztcblxuICAgIHZhciBmbnMgPSBpbnZva2VyLmZucztcbiAgICBpZiAoQXJyYXkuaXNBcnJheShmbnMpKSB7XG4gICAgICB2YXIgY2xvbmVkID0gZm5zLnNsaWNlKCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsb25lZC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjbG9uZWRbaV0uYXBwbHkobnVsbCwgYXJndW1lbnRzJDEpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyByZXR1cm4gaGFuZGxlciByZXR1cm4gdmFsdWUgZm9yIHNpbmdsZSBoYW5kbGVyc1xuICAgICAgcmV0dXJuIGZucy5hcHBseShudWxsLCBhcmd1bWVudHMpXG4gICAgfVxuICB9XG4gIGludm9rZXIuZm5zID0gZm5zO1xuICByZXR1cm4gaW52b2tlclxufVxuXG5mdW5jdGlvbiB1cGRhdGVMaXN0ZW5lcnMgKFxuICBvbixcbiAgb2xkT24sXG4gIGFkZCxcbiAgcmVtb3ZlJCQxLFxuICB2bVxuKSB7XG4gIHZhciBuYW1lLCBkZWYsIGN1ciwgb2xkLCBldmVudDtcbiAgZm9yIChuYW1lIGluIG9uKSB7XG4gICAgZGVmID0gY3VyID0gb25bbmFtZV07XG4gICAgb2xkID0gb2xkT25bbmFtZV07XG4gICAgZXZlbnQgPSBub3JtYWxpemVFdmVudChuYW1lKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoaXNVbmRlZihjdXIpKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgIFwiSW52YWxpZCBoYW5kbGVyIGZvciBldmVudCBcXFwiXCIgKyAoZXZlbnQubmFtZSkgKyBcIlxcXCI6IGdvdCBcIiArIFN0cmluZyhjdXIpLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKGlzVW5kZWYob2xkKSkge1xuICAgICAgaWYgKGlzVW5kZWYoY3VyLmZucykpIHtcbiAgICAgICAgY3VyID0gb25bbmFtZV0gPSBjcmVhdGVGbkludm9rZXIoY3VyKTtcbiAgICAgIH1cbiAgICAgIGFkZChldmVudC5uYW1lLCBjdXIsIGV2ZW50Lm9uY2UsIGV2ZW50LmNhcHR1cmUsIGV2ZW50LnBhc3NpdmUsIGV2ZW50LnBhcmFtcyk7XG4gICAgfSBlbHNlIGlmIChjdXIgIT09IG9sZCkge1xuICAgICAgb2xkLmZucyA9IGN1cjtcbiAgICAgIG9uW25hbWVdID0gb2xkO1xuICAgIH1cbiAgfVxuICBmb3IgKG5hbWUgaW4gb2xkT24pIHtcbiAgICBpZiAoaXNVbmRlZihvbltuYW1lXSkpIHtcbiAgICAgIGV2ZW50ID0gbm9ybWFsaXplRXZlbnQobmFtZSk7XG4gICAgICByZW1vdmUkJDEoZXZlbnQubmFtZSwgb2xkT25bbmFtZV0sIGV2ZW50LmNhcHR1cmUpO1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gbWVyZ2VWTm9kZUhvb2sgKGRlZiwgaG9va0tleSwgaG9vaykge1xuICBpZiAoZGVmIGluc3RhbmNlb2YgVk5vZGUpIHtcbiAgICBkZWYgPSBkZWYuZGF0YS5ob29rIHx8IChkZWYuZGF0YS5ob29rID0ge30pO1xuICB9XG4gIHZhciBpbnZva2VyO1xuICB2YXIgb2xkSG9vayA9IGRlZltob29rS2V5XTtcblxuICBmdW5jdGlvbiB3cmFwcGVkSG9vayAoKSB7XG4gICAgaG9vay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIC8vIGltcG9ydGFudDogcmVtb3ZlIG1lcmdlZCBob29rIHRvIGVuc3VyZSBpdCdzIGNhbGxlZCBvbmx5IG9uY2VcbiAgICAvLyBhbmQgcHJldmVudCBtZW1vcnkgbGVha1xuICAgIHJlbW92ZShpbnZva2VyLmZucywgd3JhcHBlZEhvb2spO1xuICB9XG5cbiAgaWYgKGlzVW5kZWYob2xkSG9vaykpIHtcbiAgICAvLyBubyBleGlzdGluZyBob29rXG4gICAgaW52b2tlciA9IGNyZWF0ZUZuSW52b2tlcihbd3JhcHBlZEhvb2tdKTtcbiAgfSBlbHNlIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoaXNEZWYob2xkSG9vay5mbnMpICYmIGlzVHJ1ZShvbGRIb29rLm1lcmdlZCkpIHtcbiAgICAgIC8vIGFscmVhZHkgYSBtZXJnZWQgaW52b2tlclxuICAgICAgaW52b2tlciA9IG9sZEhvb2s7XG4gICAgICBpbnZva2VyLmZucy5wdXNoKHdyYXBwZWRIb29rKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZXhpc3RpbmcgcGxhaW4gaG9va1xuICAgICAgaW52b2tlciA9IGNyZWF0ZUZuSW52b2tlcihbb2xkSG9vaywgd3JhcHBlZEhvb2tdKTtcbiAgICB9XG4gIH1cblxuICBpbnZva2VyLm1lcmdlZCA9IHRydWU7XG4gIGRlZltob29rS2V5XSA9IGludm9rZXI7XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBleHRyYWN0UHJvcHNGcm9tVk5vZGVEYXRhIChcbiAgZGF0YSxcbiAgQ3RvcixcbiAgdGFnXG4pIHtcbiAgLy8gd2UgYXJlIG9ubHkgZXh0cmFjdGluZyByYXcgdmFsdWVzIGhlcmUuXG4gIC8vIHZhbGlkYXRpb24gYW5kIGRlZmF1bHQgdmFsdWVzIGFyZSBoYW5kbGVkIGluIHRoZSBjaGlsZFxuICAvLyBjb21wb25lbnQgaXRzZWxmLlxuICB2YXIgcHJvcE9wdGlvbnMgPSBDdG9yLm9wdGlvbnMucHJvcHM7XG4gIGlmIChpc1VuZGVmKHByb3BPcHRpb25zKSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciByZXMgPSB7fTtcbiAgdmFyIGF0dHJzID0gZGF0YS5hdHRycztcbiAgdmFyIHByb3BzID0gZGF0YS5wcm9wcztcbiAgaWYgKGlzRGVmKGF0dHJzKSB8fCBpc0RlZihwcm9wcykpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcE9wdGlvbnMpIHtcbiAgICAgIHZhciBhbHRLZXkgPSBoeXBoZW5hdGUoa2V5KTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHZhciBrZXlJbkxvd2VyQ2FzZSA9IGtleS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoXG4gICAgICAgICAga2V5ICE9PSBrZXlJbkxvd2VyQ2FzZSAmJlxuICAgICAgICAgIGF0dHJzICYmIGhhc093bihhdHRycywga2V5SW5Mb3dlckNhc2UpXG4gICAgICAgICkge1xuICAgICAgICAgIHRpcChcbiAgICAgICAgICAgIFwiUHJvcCBcXFwiXCIgKyBrZXlJbkxvd2VyQ2FzZSArIFwiXFxcIiBpcyBwYXNzZWQgdG8gY29tcG9uZW50IFwiICtcbiAgICAgICAgICAgIChmb3JtYXRDb21wb25lbnROYW1lKHRhZyB8fCBDdG9yKSkgKyBcIiwgYnV0IHRoZSBkZWNsYXJlZCBwcm9wIG5hbWUgaXNcIiArXG4gICAgICAgICAgICBcIiBcXFwiXCIgKyBrZXkgKyBcIlxcXCIuIFwiICtcbiAgICAgICAgICAgIFwiTm90ZSB0aGF0IEhUTUwgYXR0cmlidXRlcyBhcmUgY2FzZS1pbnNlbnNpdGl2ZSBhbmQgY2FtZWxDYXNlZCBcIiArXG4gICAgICAgICAgICBcInByb3BzIG5lZWQgdG8gdXNlIHRoZWlyIGtlYmFiLWNhc2UgZXF1aXZhbGVudHMgd2hlbiB1c2luZyBpbi1ET00gXCIgK1xuICAgICAgICAgICAgXCJ0ZW1wbGF0ZXMuIFlvdSBzaG91bGQgcHJvYmFibHkgdXNlIFxcXCJcIiArIGFsdEtleSArIFwiXFxcIiBpbnN0ZWFkIG9mIFxcXCJcIiArIGtleSArIFwiXFxcIi5cIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNoZWNrUHJvcChyZXMsIHByb3BzLCBrZXksIGFsdEtleSwgdHJ1ZSkgfHxcbiAgICAgIGNoZWNrUHJvcChyZXMsIGF0dHJzLCBrZXksIGFsdEtleSwgZmFsc2UpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGNoZWNrUHJvcCAoXG4gIHJlcyxcbiAgaGFzaCxcbiAga2V5LFxuICBhbHRLZXksXG4gIHByZXNlcnZlXG4pIHtcbiAgaWYgKGlzRGVmKGhhc2gpKSB7XG4gICAgaWYgKGhhc093bihoYXNoLCBrZXkpKSB7XG4gICAgICByZXNba2V5XSA9IGhhc2hba2V5XTtcbiAgICAgIGlmICghcHJlc2VydmUpIHtcbiAgICAgICAgZGVsZXRlIGhhc2hba2V5XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfSBlbHNlIGlmIChoYXNPd24oaGFzaCwgYWx0S2V5KSkge1xuICAgICAgcmVzW2tleV0gPSBoYXNoW2FsdEtleV07XG4gICAgICBpZiAoIXByZXNlcnZlKSB7XG4gICAgICAgIGRlbGV0ZSBoYXNoW2FsdEtleV07XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuLyogICovXG5cbi8vIFRoZSB0ZW1wbGF0ZSBjb21waWxlciBhdHRlbXB0cyB0byBtaW5pbWl6ZSB0aGUgbmVlZCBmb3Igbm9ybWFsaXphdGlvbiBieVxuLy8gc3RhdGljYWxseSBhbmFseXppbmcgdGhlIHRlbXBsYXRlIGF0IGNvbXBpbGUgdGltZS5cbi8vXG4vLyBGb3IgcGxhaW4gSFRNTCBtYXJrdXAsIG5vcm1hbGl6YXRpb24gY2FuIGJlIGNvbXBsZXRlbHkgc2tpcHBlZCBiZWNhdXNlIHRoZVxuLy8gZ2VuZXJhdGVkIHJlbmRlciBmdW5jdGlvbiBpcyBndWFyYW50ZWVkIHRvIHJldHVybiBBcnJheTxWTm9kZT4uIFRoZXJlIGFyZVxuLy8gdHdvIGNhc2VzIHdoZXJlIGV4dHJhIG5vcm1hbGl6YXRpb24gaXMgbmVlZGVkOlxuXG4vLyAxLiBXaGVuIHRoZSBjaGlsZHJlbiBjb250YWlucyBjb21wb25lbnRzIC0gYmVjYXVzZSBhIGZ1bmN0aW9uYWwgY29tcG9uZW50XG4vLyBtYXkgcmV0dXJuIGFuIEFycmF5IGluc3RlYWQgb2YgYSBzaW5nbGUgcm9vdC4gSW4gdGhpcyBjYXNlLCBqdXN0IGEgc2ltcGxlXG4vLyBub3JtYWxpemF0aW9uIGlzIG5lZWRlZCAtIGlmIGFueSBjaGlsZCBpcyBhbiBBcnJheSwgd2UgZmxhdHRlbiB0aGUgd2hvbGVcbi8vIHRoaW5nIHdpdGggQXJyYXkucHJvdG90eXBlLmNvbmNhdC4gSXQgaXMgZ3VhcmFudGVlZCB0byBiZSBvbmx5IDEtbGV2ZWwgZGVlcFxuLy8gYmVjYXVzZSBmdW5jdGlvbmFsIGNvbXBvbmVudHMgYWxyZWFkeSBub3JtYWxpemUgdGhlaXIgb3duIGNoaWxkcmVuLlxuZnVuY3Rpb24gc2ltcGxlTm9ybWFsaXplQ2hpbGRyZW4gKGNoaWxkcmVuKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbltpXSkpIHtcbiAgICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuY29uY2F0LmFwcGx5KFtdLCBjaGlsZHJlbilcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNoaWxkcmVuXG59XG5cbi8vIDIuIFdoZW4gdGhlIGNoaWxkcmVuIGNvbnRhaW5zIGNvbnN0cnVjdHMgdGhhdCBhbHdheXMgZ2VuZXJhdGVkIG5lc3RlZCBBcnJheXMsXG4vLyBlLmcuIDx0ZW1wbGF0ZT4sIDxzbG90Piwgdi1mb3IsIG9yIHdoZW4gdGhlIGNoaWxkcmVuIGlzIHByb3ZpZGVkIGJ5IHVzZXJcbi8vIHdpdGggaGFuZC13cml0dGVuIHJlbmRlciBmdW5jdGlvbnMgLyBKU1guIEluIHN1Y2ggY2FzZXMgYSBmdWxsIG5vcm1hbGl6YXRpb25cbi8vIGlzIG5lZWRlZCB0byBjYXRlciB0byBhbGwgcG9zc2libGUgdHlwZXMgb2YgY2hpbGRyZW4gdmFsdWVzLlxuZnVuY3Rpb24gbm9ybWFsaXplQ2hpbGRyZW4gKGNoaWxkcmVuKSB7XG4gIHJldHVybiBpc1ByaW1pdGl2ZShjaGlsZHJlbilcbiAgICA/IFtjcmVhdGVUZXh0Vk5vZGUoY2hpbGRyZW4pXVxuICAgIDogQXJyYXkuaXNBcnJheShjaGlsZHJlbilcbiAgICAgID8gbm9ybWFsaXplQXJyYXlDaGlsZHJlbihjaGlsZHJlbilcbiAgICAgIDogdW5kZWZpbmVkXG59XG5cbmZ1bmN0aW9uIGlzVGV4dE5vZGUgKG5vZGUpIHtcbiAgcmV0dXJuIGlzRGVmKG5vZGUpICYmIGlzRGVmKG5vZGUudGV4dCkgJiYgaXNGYWxzZShub2RlLmlzQ29tbWVudClcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplQXJyYXlDaGlsZHJlbiAoY2hpbGRyZW4sIG5lc3RlZEluZGV4KSB7XG4gIHZhciByZXMgPSBbXTtcbiAgdmFyIGksIGMsIGxhc3RJbmRleCwgbGFzdDtcbiAgZm9yIChpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgYyA9IGNoaWxkcmVuW2ldO1xuICAgIGlmIChpc1VuZGVmKGMpIHx8IHR5cGVvZiBjID09PSAnYm9vbGVhbicpIHsgY29udGludWUgfVxuICAgIGxhc3RJbmRleCA9IHJlcy5sZW5ndGggLSAxO1xuICAgIGxhc3QgPSByZXNbbGFzdEluZGV4XTtcbiAgICAvLyAgbmVzdGVkXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYykpIHtcbiAgICAgIGlmIChjLmxlbmd0aCA+IDApIHtcbiAgICAgICAgYyA9IG5vcm1hbGl6ZUFycmF5Q2hpbGRyZW4oYywgKChuZXN0ZWRJbmRleCB8fCAnJykgKyBcIl9cIiArIGkpKTtcbiAgICAgICAgLy8gbWVyZ2UgYWRqYWNlbnQgdGV4dCBub2Rlc1xuICAgICAgICBpZiAoaXNUZXh0Tm9kZShjWzBdKSAmJiBpc1RleHROb2RlKGxhc3QpKSB7XG4gICAgICAgICAgcmVzW2xhc3RJbmRleF0gPSBjcmVhdGVUZXh0Vk5vZGUobGFzdC50ZXh0ICsgKGNbMF0pLnRleHQpO1xuICAgICAgICAgIGMuc2hpZnQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXMucHVzaC5hcHBseShyZXMsIGMpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNQcmltaXRpdmUoYykpIHtcbiAgICAgIGlmIChpc1RleHROb2RlKGxhc3QpKSB7XG4gICAgICAgIC8vIG1lcmdlIGFkamFjZW50IHRleHQgbm9kZXNcbiAgICAgICAgLy8gdGhpcyBpcyBuZWNlc3NhcnkgZm9yIFNTUiBoeWRyYXRpb24gYmVjYXVzZSB0ZXh0IG5vZGVzIGFyZVxuICAgICAgICAvLyBlc3NlbnRpYWxseSBtZXJnZWQgd2hlbiByZW5kZXJlZCB0byBIVE1MIHN0cmluZ3NcbiAgICAgICAgcmVzW2xhc3RJbmRleF0gPSBjcmVhdGVUZXh0Vk5vZGUobGFzdC50ZXh0ICsgYyk7XG4gICAgICB9IGVsc2UgaWYgKGMgIT09ICcnKSB7XG4gICAgICAgIC8vIGNvbnZlcnQgcHJpbWl0aXZlIHRvIHZub2RlXG4gICAgICAgIHJlcy5wdXNoKGNyZWF0ZVRleHRWTm9kZShjKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChpc1RleHROb2RlKGMpICYmIGlzVGV4dE5vZGUobGFzdCkpIHtcbiAgICAgICAgLy8gbWVyZ2UgYWRqYWNlbnQgdGV4dCBub2Rlc1xuICAgICAgICByZXNbbGFzdEluZGV4XSA9IGNyZWF0ZVRleHRWTm9kZShsYXN0LnRleHQgKyBjLnRleHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZGVmYXVsdCBrZXkgZm9yIG5lc3RlZCBhcnJheSBjaGlsZHJlbiAobGlrZWx5IGdlbmVyYXRlZCBieSB2LWZvcilcbiAgICAgICAgaWYgKGlzVHJ1ZShjaGlsZHJlbi5faXNWTGlzdCkgJiZcbiAgICAgICAgICBpc0RlZihjLnRhZykgJiZcbiAgICAgICAgICBpc1VuZGVmKGMua2V5KSAmJlxuICAgICAgICAgIGlzRGVmKG5lc3RlZEluZGV4KSkge1xuICAgICAgICAgIGMua2V5ID0gXCJfX3ZsaXN0XCIgKyBuZXN0ZWRJbmRleCArIFwiX1wiICsgaSArIFwiX19cIjtcbiAgICAgICAgfVxuICAgICAgICByZXMucHVzaChjKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gZW5zdXJlQ3RvciAoY29tcCwgYmFzZSkge1xuICBpZiAoXG4gICAgY29tcC5fX2VzTW9kdWxlIHx8XG4gICAgKGhhc1N5bWJvbCAmJiBjb21wW1N5bWJvbC50b1N0cmluZ1RhZ10gPT09ICdNb2R1bGUnKVxuICApIHtcbiAgICBjb21wID0gY29tcC5kZWZhdWx0O1xuICB9XG4gIHJldHVybiBpc09iamVjdChjb21wKVxuICAgID8gYmFzZS5leHRlbmQoY29tcClcbiAgICA6IGNvbXBcbn1cblxuZnVuY3Rpb24gY3JlYXRlQXN5bmNQbGFjZWhvbGRlciAoXG4gIGZhY3RvcnksXG4gIGRhdGEsXG4gIGNvbnRleHQsXG4gIGNoaWxkcmVuLFxuICB0YWdcbikge1xuICB2YXIgbm9kZSA9IGNyZWF0ZUVtcHR5Vk5vZGUoKTtcbiAgbm9kZS5hc3luY0ZhY3RvcnkgPSBmYWN0b3J5O1xuICBub2RlLmFzeW5jTWV0YSA9IHsgZGF0YTogZGF0YSwgY29udGV4dDogY29udGV4dCwgY2hpbGRyZW46IGNoaWxkcmVuLCB0YWc6IHRhZyB9O1xuICByZXR1cm4gbm9kZVxufVxuXG5mdW5jdGlvbiByZXNvbHZlQXN5bmNDb21wb25lbnQgKFxuICBmYWN0b3J5LFxuICBiYXNlQ3RvcixcbiAgY29udGV4dFxuKSB7XG4gIGlmIChpc1RydWUoZmFjdG9yeS5lcnJvcikgJiYgaXNEZWYoZmFjdG9yeS5lcnJvckNvbXApKSB7XG4gICAgcmV0dXJuIGZhY3RvcnkuZXJyb3JDb21wXG4gIH1cblxuICBpZiAoaXNEZWYoZmFjdG9yeS5yZXNvbHZlZCkpIHtcbiAgICByZXR1cm4gZmFjdG9yeS5yZXNvbHZlZFxuICB9XG5cbiAgaWYgKGlzVHJ1ZShmYWN0b3J5LmxvYWRpbmcpICYmIGlzRGVmKGZhY3RvcnkubG9hZGluZ0NvbXApKSB7XG4gICAgcmV0dXJuIGZhY3RvcnkubG9hZGluZ0NvbXBcbiAgfVxuXG4gIGlmIChpc0RlZihmYWN0b3J5LmNvbnRleHRzKSkge1xuICAgIC8vIGFscmVhZHkgcGVuZGluZ1xuICAgIGZhY3RvcnkuY29udGV4dHMucHVzaChjb250ZXh0KTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgY29udGV4dHMgPSBmYWN0b3J5LmNvbnRleHRzID0gW2NvbnRleHRdO1xuICAgIHZhciBzeW5jID0gdHJ1ZTtcblxuICAgIHZhciBmb3JjZVJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY29udGV4dHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGNvbnRleHRzW2ldLiRmb3JjZVVwZGF0ZSgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgcmVzb2x2ZSA9IG9uY2UoZnVuY3Rpb24gKHJlcykge1xuICAgICAgLy8gY2FjaGUgcmVzb2x2ZWRcbiAgICAgIGZhY3RvcnkucmVzb2x2ZWQgPSBlbnN1cmVDdG9yKHJlcywgYmFzZUN0b3IpO1xuICAgICAgLy8gaW52b2tlIGNhbGxiYWNrcyBvbmx5IGlmIHRoaXMgaXMgbm90IGEgc3luY2hyb25vdXMgcmVzb2x2ZVxuICAgICAgLy8gKGFzeW5jIHJlc29sdmVzIGFyZSBzaGltbWVkIGFzIHN5bmNocm9ub3VzIGR1cmluZyBTU1IpXG4gICAgICBpZiAoIXN5bmMpIHtcbiAgICAgICAgZm9yY2VSZW5kZXIoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHZhciByZWplY3QgPSBvbmNlKGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgXCJGYWlsZWQgdG8gcmVzb2x2ZSBhc3luYyBjb21wb25lbnQ6IFwiICsgKFN0cmluZyhmYWN0b3J5KSkgK1xuICAgICAgICAocmVhc29uID8gKFwiXFxuUmVhc29uOiBcIiArIHJlYXNvbikgOiAnJylcbiAgICAgICk7XG4gICAgICBpZiAoaXNEZWYoZmFjdG9yeS5lcnJvckNvbXApKSB7XG4gICAgICAgIGZhY3RvcnkuZXJyb3IgPSB0cnVlO1xuICAgICAgICBmb3JjZVJlbmRlcigpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIHJlcyA9IGZhY3RvcnkocmVzb2x2ZSwgcmVqZWN0KTtcblxuICAgIGlmIChpc09iamVjdChyZXMpKSB7XG4gICAgICBpZiAodHlwZW9mIHJlcy50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vICgpID0+IFByb21pc2VcbiAgICAgICAgaWYgKGlzVW5kZWYoZmFjdG9yeS5yZXNvbHZlZCkpIHtcbiAgICAgICAgICByZXMudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlzRGVmKHJlcy5jb21wb25lbnQpICYmIHR5cGVvZiByZXMuY29tcG9uZW50LnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmVzLmNvbXBvbmVudC50aGVuKHJlc29sdmUsIHJlamVjdCk7XG5cbiAgICAgICAgaWYgKGlzRGVmKHJlcy5lcnJvcikpIHtcbiAgICAgICAgICBmYWN0b3J5LmVycm9yQ29tcCA9IGVuc3VyZUN0b3IocmVzLmVycm9yLCBiYXNlQ3Rvcik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNEZWYocmVzLmxvYWRpbmcpKSB7XG4gICAgICAgICAgZmFjdG9yeS5sb2FkaW5nQ29tcCA9IGVuc3VyZUN0b3IocmVzLmxvYWRpbmcsIGJhc2VDdG9yKTtcbiAgICAgICAgICBpZiAocmVzLmRlbGF5ID09PSAwKSB7XG4gICAgICAgICAgICBmYWN0b3J5LmxvYWRpbmcgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgaWYgKGlzVW5kZWYoZmFjdG9yeS5yZXNvbHZlZCkgJiYgaXNVbmRlZihmYWN0b3J5LmVycm9yKSkge1xuICAgICAgICAgICAgICAgIGZhY3RvcnkubG9hZGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgZm9yY2VSZW5kZXIoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgcmVzLmRlbGF5IHx8IDIwMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzRGVmKHJlcy50aW1lb3V0KSkge1xuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGlzVW5kZWYoZmFjdG9yeS5yZXNvbHZlZCkpIHtcbiAgICAgICAgICAgICAgcmVqZWN0KFxuICAgICAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbidcbiAgICAgICAgICAgICAgICAgID8gKFwidGltZW91dCAoXCIgKyAocmVzLnRpbWVvdXQpICsgXCJtcylcIilcbiAgICAgICAgICAgICAgICAgIDogbnVsbFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIHJlcy50aW1lb3V0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHN5bmMgPSBmYWxzZTtcbiAgICAvLyByZXR1cm4gaW4gY2FzZSByZXNvbHZlZCBzeW5jaHJvbm91c2x5XG4gICAgcmV0dXJuIGZhY3RvcnkubG9hZGluZ1xuICAgICAgPyBmYWN0b3J5LmxvYWRpbmdDb21wXG4gICAgICA6IGZhY3RvcnkucmVzb2x2ZWRcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaXNBc3luY1BsYWNlaG9sZGVyIChub2RlKSB7XG4gIHJldHVybiBub2RlLmlzQ29tbWVudCAmJiBub2RlLmFzeW5jRmFjdG9yeVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gZ2V0Rmlyc3RDb21wb25lbnRDaGlsZCAoY2hpbGRyZW4pIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGMgPSBjaGlsZHJlbltpXTtcbiAgICAgIGlmIChpc0RlZihjKSAmJiAoaXNEZWYoYy5jb21wb25lbnRPcHRpb25zKSB8fCBpc0FzeW5jUGxhY2Vob2xkZXIoYykpKSB7XG4gICAgICAgIHJldHVybiBjXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdEV2ZW50cyAodm0pIHtcbiAgdm0uX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHZtLl9oYXNIb29rRXZlbnQgPSBmYWxzZTtcbiAgLy8gaW5pdCBwYXJlbnQgYXR0YWNoZWQgZXZlbnRzXG4gIHZhciBsaXN0ZW5lcnMgPSB2bS4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xuICBpZiAobGlzdGVuZXJzKSB7XG4gICAgdXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzKHZtLCBsaXN0ZW5lcnMpO1xuICB9XG59XG5cbnZhciB0YXJnZXQ7XG5cbmZ1bmN0aW9uIGFkZCAoZXZlbnQsIGZuLCBvbmNlKSB7XG4gIGlmIChvbmNlKSB7XG4gICAgdGFyZ2V0LiRvbmNlKGV2ZW50LCBmbik7XG4gIH0gZWxzZSB7XG4gICAgdGFyZ2V0LiRvbihldmVudCwgZm4pO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZSQxIChldmVudCwgZm4pIHtcbiAgdGFyZ2V0LiRvZmYoZXZlbnQsIGZuKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzIChcbiAgdm0sXG4gIGxpc3RlbmVycyxcbiAgb2xkTGlzdGVuZXJzXG4pIHtcbiAgdGFyZ2V0ID0gdm07XG4gIHVwZGF0ZUxpc3RlbmVycyhsaXN0ZW5lcnMsIG9sZExpc3RlbmVycyB8fCB7fSwgYWRkLCByZW1vdmUkMSwgdm0pO1xuICB0YXJnZXQgPSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGV2ZW50c01peGluIChWdWUpIHtcbiAgdmFyIGhvb2tSRSA9IC9eaG9vazovO1xuICBWdWUucHJvdG90eXBlLiRvbiA9IGZ1bmN0aW9uIChldmVudCwgZm4pIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZXZlbnQpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGV2ZW50Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB0aGlzJDEuJG9uKGV2ZW50W2ldLCBmbik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICh2bS5fZXZlbnRzW2V2ZW50XSB8fCAodm0uX2V2ZW50c1tldmVudF0gPSBbXSkpLnB1c2goZm4pO1xuICAgICAgLy8gb3B0aW1pemUgaG9vazpldmVudCBjb3N0IGJ5IHVzaW5nIGEgYm9vbGVhbiBmbGFnIG1hcmtlZCBhdCByZWdpc3RyYXRpb25cbiAgICAgIC8vIGluc3RlYWQgb2YgYSBoYXNoIGxvb2t1cFxuICAgICAgaWYgKGhvb2tSRS50ZXN0KGV2ZW50KSkge1xuICAgICAgICB2bS5faGFzSG9va0V2ZW50ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZtXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kb25jZSA9IGZ1bmN0aW9uIChldmVudCwgZm4pIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGZ1bmN0aW9uIG9uICgpIHtcbiAgICAgIHZtLiRvZmYoZXZlbnQsIG9uKTtcbiAgICAgIGZuLmFwcGx5KHZtLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBvbi5mbiA9IGZuO1xuICAgIHZtLiRvbihldmVudCwgb24pO1xuICAgIHJldHVybiB2bVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuJG9mZiA9IGZ1bmN0aW9uIChldmVudCwgZm4pIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgLy8gYWxsXG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICB2bS5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIHJldHVybiB2bVxuICAgIH1cbiAgICAvLyBhcnJheSBvZiBldmVudHNcbiAgICBpZiAoQXJyYXkuaXNBcnJheShldmVudCkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gZXZlbnQubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHRoaXMkMS4kb2ZmKGV2ZW50W2ldLCBmbik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdm1cbiAgICB9XG4gICAgLy8gc3BlY2lmaWMgZXZlbnRcbiAgICB2YXIgY2JzID0gdm0uX2V2ZW50c1tldmVudF07XG4gICAgaWYgKCFjYnMpIHtcbiAgICAgIHJldHVybiB2bVxuICAgIH1cbiAgICBpZiAoIWZuKSB7XG4gICAgICB2bS5fZXZlbnRzW2V2ZW50XSA9IG51bGw7XG4gICAgICByZXR1cm4gdm1cbiAgICB9XG4gICAgaWYgKGZuKSB7XG4gICAgICAvLyBzcGVjaWZpYyBoYW5kbGVyXG4gICAgICB2YXIgY2I7XG4gICAgICB2YXIgaSQxID0gY2JzLmxlbmd0aDtcbiAgICAgIHdoaWxlIChpJDEtLSkge1xuICAgICAgICBjYiA9IGNic1tpJDFdO1xuICAgICAgICBpZiAoY2IgPT09IGZuIHx8IGNiLmZuID09PSBmbikge1xuICAgICAgICAgIGNicy5zcGxpY2UoaSQxLCAxKTtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2bVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuJGVtaXQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgbG93ZXJDYXNlRXZlbnQgPSBldmVudC50b0xvd2VyQ2FzZSgpO1xuICAgICAgaWYgKGxvd2VyQ2FzZUV2ZW50ICE9PSBldmVudCAmJiB2bS5fZXZlbnRzW2xvd2VyQ2FzZUV2ZW50XSkge1xuICAgICAgICB0aXAoXG4gICAgICAgICAgXCJFdmVudCBcXFwiXCIgKyBsb3dlckNhc2VFdmVudCArIFwiXFxcIiBpcyBlbWl0dGVkIGluIGNvbXBvbmVudCBcIiArXG4gICAgICAgICAgKGZvcm1hdENvbXBvbmVudE5hbWUodm0pKSArIFwiIGJ1dCB0aGUgaGFuZGxlciBpcyByZWdpc3RlcmVkIGZvciBcXFwiXCIgKyBldmVudCArIFwiXFxcIi4gXCIgK1xuICAgICAgICAgIFwiTm90ZSB0aGF0IEhUTUwgYXR0cmlidXRlcyBhcmUgY2FzZS1pbnNlbnNpdGl2ZSBhbmQgeW91IGNhbm5vdCB1c2UgXCIgK1xuICAgICAgICAgIFwidi1vbiB0byBsaXN0ZW4gdG8gY2FtZWxDYXNlIGV2ZW50cyB3aGVuIHVzaW5nIGluLURPTSB0ZW1wbGF0ZXMuIFwiICtcbiAgICAgICAgICBcIllvdSBzaG91bGQgcHJvYmFibHkgdXNlIFxcXCJcIiArIChoeXBoZW5hdGUoZXZlbnQpKSArIFwiXFxcIiBpbnN0ZWFkIG9mIFxcXCJcIiArIGV2ZW50ICsgXCJcXFwiLlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBjYnMgPSB2bS5fZXZlbnRzW2V2ZW50XTtcbiAgICBpZiAoY2JzKSB7XG4gICAgICBjYnMgPSBjYnMubGVuZ3RoID4gMSA/IHRvQXJyYXkoY2JzKSA6IGNicztcbiAgICAgIHZhciBhcmdzID0gdG9BcnJheShhcmd1bWVudHMsIDEpO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjYnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY2JzW2ldLmFwcGx5KHZtLCBhcmdzKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGhhbmRsZUVycm9yKGUsIHZtLCAoXCJldmVudCBoYW5kbGVyIGZvciBcXFwiXCIgKyBldmVudCArIFwiXFxcIlwiKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZtXG4gIH07XG59XG5cbi8qICAqL1xuXG5cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVzb2x2aW5nIHJhdyBjaGlsZHJlbiBWTm9kZXMgaW50byBhIHNsb3Qgb2JqZWN0LlxuICovXG5mdW5jdGlvbiByZXNvbHZlU2xvdHMgKFxuICBjaGlsZHJlbixcbiAgY29udGV4dFxuKSB7XG4gIHZhciBzbG90cyA9IHt9O1xuICBpZiAoIWNoaWxkcmVuKSB7XG4gICAgcmV0dXJuIHNsb3RzXG4gIH1cbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICB2YXIgZGF0YSA9IGNoaWxkLmRhdGE7XG4gICAgLy8gcmVtb3ZlIHNsb3QgYXR0cmlidXRlIGlmIHRoZSBub2RlIGlzIHJlc29sdmVkIGFzIGEgVnVlIHNsb3Qgbm9kZVxuICAgIGlmIChkYXRhICYmIGRhdGEuYXR0cnMgJiYgZGF0YS5hdHRycy5zbG90KSB7XG4gICAgICBkZWxldGUgZGF0YS5hdHRycy5zbG90O1xuICAgIH1cbiAgICAvLyBuYW1lZCBzbG90cyBzaG91bGQgb25seSBiZSByZXNwZWN0ZWQgaWYgdGhlIHZub2RlIHdhcyByZW5kZXJlZCBpbiB0aGVcbiAgICAvLyBzYW1lIGNvbnRleHQuXG4gICAgaWYgKChjaGlsZC5jb250ZXh0ID09PSBjb250ZXh0IHx8IGNoaWxkLmZuQ29udGV4dCA9PT0gY29udGV4dCkgJiZcbiAgICAgIGRhdGEgJiYgZGF0YS5zbG90ICE9IG51bGxcbiAgICApIHtcbiAgICAgIHZhciBuYW1lID0gZGF0YS5zbG90O1xuICAgICAgdmFyIHNsb3QgPSAoc2xvdHNbbmFtZV0gfHwgKHNsb3RzW25hbWVdID0gW10pKTtcbiAgICAgIGlmIChjaGlsZC50YWcgPT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgICAgc2xvdC5wdXNoLmFwcGx5KHNsb3QsIGNoaWxkLmNoaWxkcmVuIHx8IFtdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNsb3QucHVzaChjaGlsZCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIChzbG90cy5kZWZhdWx0IHx8IChzbG90cy5kZWZhdWx0ID0gW10pKS5wdXNoKGNoaWxkKTtcbiAgICB9XG4gIH1cbiAgLy8gaWdub3JlIHNsb3RzIHRoYXQgY29udGFpbnMgb25seSB3aGl0ZXNwYWNlXG4gIGZvciAodmFyIG5hbWUkMSBpbiBzbG90cykge1xuICAgIGlmIChzbG90c1tuYW1lJDFdLmV2ZXJ5KGlzV2hpdGVzcGFjZSkpIHtcbiAgICAgIGRlbGV0ZSBzbG90c1tuYW1lJDFdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc2xvdHNcbn1cblxuZnVuY3Rpb24gaXNXaGl0ZXNwYWNlIChub2RlKSB7XG4gIHJldHVybiAobm9kZS5pc0NvbW1lbnQgJiYgIW5vZGUuYXN5bmNGYWN0b3J5KSB8fCBub2RlLnRleHQgPT09ICcgJ1xufVxuXG5mdW5jdGlvbiByZXNvbHZlU2NvcGVkU2xvdHMgKFxuICBmbnMsIC8vIHNlZSBmbG93L3Zub2RlXG4gIHJlc1xuKSB7XG4gIHJlcyA9IHJlcyB8fCB7fTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBmbnMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShmbnNbaV0pKSB7XG4gICAgICByZXNvbHZlU2NvcGVkU2xvdHMoZm5zW2ldLCByZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXNbZm5zW2ldLmtleV0gPSBmbnNbaV0uZm47XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cbnZhciBhY3RpdmVJbnN0YW5jZSA9IG51bGw7XG52YXIgaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50ID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGluaXRMaWZlY3ljbGUgKHZtKSB7XG4gIHZhciBvcHRpb25zID0gdm0uJG9wdGlvbnM7XG5cbiAgLy8gbG9jYXRlIGZpcnN0IG5vbi1hYnN0cmFjdCBwYXJlbnRcbiAgdmFyIHBhcmVudCA9IG9wdGlvbnMucGFyZW50O1xuICBpZiAocGFyZW50ICYmICFvcHRpb25zLmFic3RyYWN0KSB7XG4gICAgd2hpbGUgKHBhcmVudC4kb3B0aW9ucy5hYnN0cmFjdCAmJiBwYXJlbnQuJHBhcmVudCkge1xuICAgICAgcGFyZW50ID0gcGFyZW50LiRwYXJlbnQ7XG4gICAgfVxuICAgIHBhcmVudC4kY2hpbGRyZW4ucHVzaCh2bSk7XG4gIH1cblxuICB2bS4kcGFyZW50ID0gcGFyZW50O1xuICB2bS4kcm9vdCA9IHBhcmVudCA/IHBhcmVudC4kcm9vdCA6IHZtO1xuXG4gIHZtLiRjaGlsZHJlbiA9IFtdO1xuICB2bS4kcmVmcyA9IHt9O1xuXG4gIHZtLl93YXRjaGVyID0gbnVsbDtcbiAgdm0uX2luYWN0aXZlID0gbnVsbDtcbiAgdm0uX2RpcmVjdEluYWN0aXZlID0gZmFsc2U7XG4gIHZtLl9pc01vdW50ZWQgPSBmYWxzZTtcbiAgdm0uX2lzRGVzdHJveWVkID0gZmFsc2U7XG4gIHZtLl9pc0JlaW5nRGVzdHJveWVkID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGxpZmVjeWNsZU1peGluIChWdWUpIHtcbiAgVnVlLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKHZub2RlLCBoeWRyYXRpbmcpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmICh2bS5faXNNb3VudGVkKSB7XG4gICAgICBjYWxsSG9vayh2bSwgJ2JlZm9yZVVwZGF0ZScpO1xuICAgIH1cbiAgICB2YXIgcHJldkVsID0gdm0uJGVsO1xuICAgIHZhciBwcmV2Vm5vZGUgPSB2bS5fdm5vZGU7XG4gICAgdmFyIHByZXZBY3RpdmVJbnN0YW5jZSA9IGFjdGl2ZUluc3RhbmNlO1xuICAgIGFjdGl2ZUluc3RhbmNlID0gdm07XG4gICAgdm0uX3Zub2RlID0gdm5vZGU7XG4gICAgLy8gVnVlLnByb3RvdHlwZS5fX3BhdGNoX18gaXMgaW5qZWN0ZWQgaW4gZW50cnkgcG9pbnRzXG4gICAgLy8gYmFzZWQgb24gdGhlIHJlbmRlcmluZyBiYWNrZW5kIHVzZWQuXG4gICAgaWYgKCFwcmV2Vm5vZGUpIHtcbiAgICAgIC8vIGluaXRpYWwgcmVuZGVyXG4gICAgICB2bS4kZWwgPSB2bS5fX3BhdGNoX18oXG4gICAgICAgIHZtLiRlbCwgdm5vZGUsIGh5ZHJhdGluZywgZmFsc2UgLyogcmVtb3ZlT25seSAqLyxcbiAgICAgICAgdm0uJG9wdGlvbnMuX3BhcmVudEVsbSxcbiAgICAgICAgdm0uJG9wdGlvbnMuX3JlZkVsbVxuICAgICAgKTtcbiAgICAgIC8vIG5vIG5lZWQgZm9yIHRoZSByZWYgbm9kZXMgYWZ0ZXIgaW5pdGlhbCBwYXRjaFxuICAgICAgLy8gdGhpcyBwcmV2ZW50cyBrZWVwaW5nIGEgZGV0YWNoZWQgRE9NIHRyZWUgaW4gbWVtb3J5ICgjNTg1MSlcbiAgICAgIHZtLiRvcHRpb25zLl9wYXJlbnRFbG0gPSB2bS4kb3B0aW9ucy5fcmVmRWxtID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdXBkYXRlc1xuICAgICAgdm0uJGVsID0gdm0uX19wYXRjaF9fKHByZXZWbm9kZSwgdm5vZGUpO1xuICAgIH1cbiAgICBhY3RpdmVJbnN0YW5jZSA9IHByZXZBY3RpdmVJbnN0YW5jZTtcbiAgICAvLyB1cGRhdGUgX192dWVfXyByZWZlcmVuY2VcbiAgICBpZiAocHJldkVsKSB7XG4gICAgICBwcmV2RWwuX192dWVfXyA9IG51bGw7XG4gICAgfVxuICAgIGlmICh2bS4kZWwpIHtcbiAgICAgIHZtLiRlbC5fX3Z1ZV9fID0gdm07XG4gICAgfVxuICAgIC8vIGlmIHBhcmVudCBpcyBhbiBIT0MsIHVwZGF0ZSBpdHMgJGVsIGFzIHdlbGxcbiAgICBpZiAodm0uJHZub2RlICYmIHZtLiRwYXJlbnQgJiYgdm0uJHZub2RlID09PSB2bS4kcGFyZW50Ll92bm9kZSkge1xuICAgICAgdm0uJHBhcmVudC4kZWwgPSB2bS4kZWw7XG4gICAgfVxuICAgIC8vIHVwZGF0ZWQgaG9vayBpcyBjYWxsZWQgYnkgdGhlIHNjaGVkdWxlciB0byBlbnN1cmUgdGhhdCBjaGlsZHJlbiBhcmVcbiAgICAvLyB1cGRhdGVkIGluIGEgcGFyZW50J3MgdXBkYXRlZCBob29rLlxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuJGZvcmNlVXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgaWYgKHZtLl93YXRjaGVyKSB7XG4gICAgICB2bS5fd2F0Y2hlci51cGRhdGUoKTtcbiAgICB9XG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmICh2bS5faXNCZWluZ0Rlc3Ryb3llZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGNhbGxIb29rKHZtLCAnYmVmb3JlRGVzdHJveScpO1xuICAgIHZtLl9pc0JlaW5nRGVzdHJveWVkID0gdHJ1ZTtcbiAgICAvLyByZW1vdmUgc2VsZiBmcm9tIHBhcmVudFxuICAgIHZhciBwYXJlbnQgPSB2bS4kcGFyZW50O1xuICAgIGlmIChwYXJlbnQgJiYgIXBhcmVudC5faXNCZWluZ0Rlc3Ryb3llZCAmJiAhdm0uJG9wdGlvbnMuYWJzdHJhY3QpIHtcbiAgICAgIHJlbW92ZShwYXJlbnQuJGNoaWxkcmVuLCB2bSk7XG4gICAgfVxuICAgIC8vIHRlYXJkb3duIHdhdGNoZXJzXG4gICAgaWYgKHZtLl93YXRjaGVyKSB7XG4gICAgICB2bS5fd2F0Y2hlci50ZWFyZG93bigpO1xuICAgIH1cbiAgICB2YXIgaSA9IHZtLl93YXRjaGVycy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdm0uX3dhdGNoZXJzW2ldLnRlYXJkb3duKCk7XG4gICAgfVxuICAgIC8vIHJlbW92ZSByZWZlcmVuY2UgZnJvbSBkYXRhIG9iXG4gICAgLy8gZnJvemVuIG9iamVjdCBtYXkgbm90IGhhdmUgb2JzZXJ2ZXIuXG4gICAgaWYgKHZtLl9kYXRhLl9fb2JfXykge1xuICAgICAgdm0uX2RhdGEuX19vYl9fLnZtQ291bnQtLTtcbiAgICB9XG4gICAgLy8gY2FsbCB0aGUgbGFzdCBob29rLi4uXG4gICAgdm0uX2lzRGVzdHJveWVkID0gdHJ1ZTtcbiAgICAvLyBpbnZva2UgZGVzdHJveSBob29rcyBvbiBjdXJyZW50IHJlbmRlcmVkIHRyZWVcbiAgICB2bS5fX3BhdGNoX18odm0uX3Zub2RlLCBudWxsKTtcbiAgICAvLyBmaXJlIGRlc3Ryb3llZCBob29rXG4gICAgY2FsbEhvb2sodm0sICdkZXN0cm95ZWQnKTtcbiAgICAvLyB0dXJuIG9mZiBhbGwgaW5zdGFuY2UgbGlzdGVuZXJzLlxuICAgIHZtLiRvZmYoKTtcbiAgICAvLyByZW1vdmUgX192dWVfXyByZWZlcmVuY2VcbiAgICBpZiAodm0uJGVsKSB7XG4gICAgICB2bS4kZWwuX192dWVfXyA9IG51bGw7XG4gICAgfVxuICAgIC8vIHJlbGVhc2UgY2lyY3VsYXIgcmVmZXJlbmNlICgjNjc1OSlcbiAgICBpZiAodm0uJHZub2RlKSB7XG4gICAgICB2bS4kdm5vZGUucGFyZW50ID0gbnVsbDtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIG1vdW50Q29tcG9uZW50IChcbiAgdm0sXG4gIGVsLFxuICBoeWRyYXRpbmdcbikge1xuICB2bS4kZWwgPSBlbDtcbiAgaWYgKCF2bS4kb3B0aW9ucy5yZW5kZXIpIHtcbiAgICB2bS4kb3B0aW9ucy5yZW5kZXIgPSBjcmVhdGVFbXB0eVZOb2RlO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmICgodm0uJG9wdGlvbnMudGVtcGxhdGUgJiYgdm0uJG9wdGlvbnMudGVtcGxhdGUuY2hhckF0KDApICE9PSAnIycpIHx8XG4gICAgICAgIHZtLiRvcHRpb25zLmVsIHx8IGVsKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ1lvdSBhcmUgdXNpbmcgdGhlIHJ1bnRpbWUtb25seSBidWlsZCBvZiBWdWUgd2hlcmUgdGhlIHRlbXBsYXRlICcgK1xuICAgICAgICAgICdjb21waWxlciBpcyBub3QgYXZhaWxhYmxlLiBFaXRoZXIgcHJlLWNvbXBpbGUgdGhlIHRlbXBsYXRlcyBpbnRvICcgK1xuICAgICAgICAgICdyZW5kZXIgZnVuY3Rpb25zLCBvciB1c2UgdGhlIGNvbXBpbGVyLWluY2x1ZGVkIGJ1aWxkLicsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ0ZhaWxlZCB0byBtb3VudCBjb21wb25lbnQ6IHRlbXBsYXRlIG9yIHJlbmRlciBmdW5jdGlvbiBub3QgZGVmaW5lZC4nLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNhbGxIb29rKHZtLCAnYmVmb3JlTW91bnQnKTtcblxuICB2YXIgdXBkYXRlQ29tcG9uZW50O1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICB1cGRhdGVDb21wb25lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgbmFtZSA9IHZtLl9uYW1lO1xuICAgICAgdmFyIGlkID0gdm0uX3VpZDtcbiAgICAgIHZhciBzdGFydFRhZyA9IFwidnVlLXBlcmYtc3RhcnQ6XCIgKyBpZDtcbiAgICAgIHZhciBlbmRUYWcgPSBcInZ1ZS1wZXJmLWVuZDpcIiArIGlkO1xuXG4gICAgICBtYXJrKHN0YXJ0VGFnKTtcbiAgICAgIHZhciB2bm9kZSA9IHZtLl9yZW5kZXIoKTtcbiAgICAgIG1hcmsoZW5kVGFnKTtcbiAgICAgIG1lYXN1cmUoKFwidnVlIFwiICsgbmFtZSArIFwiIHJlbmRlclwiKSwgc3RhcnRUYWcsIGVuZFRhZyk7XG5cbiAgICAgIG1hcmsoc3RhcnRUYWcpO1xuICAgICAgdm0uX3VwZGF0ZSh2bm9kZSwgaHlkcmF0aW5nKTtcbiAgICAgIG1hcmsoZW5kVGFnKTtcbiAgICAgIG1lYXN1cmUoKFwidnVlIFwiICsgbmFtZSArIFwiIHBhdGNoXCIpLCBzdGFydFRhZywgZW5kVGFnKTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHVwZGF0ZUNvbXBvbmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZtLl91cGRhdGUodm0uX3JlbmRlcigpLCBoeWRyYXRpbmcpO1xuICAgIH07XG4gIH1cblxuICAvLyB3ZSBzZXQgdGhpcyB0byB2bS5fd2F0Y2hlciBpbnNpZGUgdGhlIHdhdGNoZXIncyBjb25zdHJ1Y3RvclxuICAvLyBzaW5jZSB0aGUgd2F0Y2hlcidzIGluaXRpYWwgcGF0Y2ggbWF5IGNhbGwgJGZvcmNlVXBkYXRlIChlLmcuIGluc2lkZSBjaGlsZFxuICAvLyBjb21wb25lbnQncyBtb3VudGVkIGhvb2spLCB3aGljaCByZWxpZXMgb24gdm0uX3dhdGNoZXIgYmVpbmcgYWxyZWFkeSBkZWZpbmVkXG4gIG5ldyBXYXRjaGVyKHZtLCB1cGRhdGVDb21wb25lbnQsIG5vb3AsIG51bGwsIHRydWUgLyogaXNSZW5kZXJXYXRjaGVyICovKTtcbiAgaHlkcmF0aW5nID0gZmFsc2U7XG5cbiAgLy8gbWFudWFsbHkgbW91bnRlZCBpbnN0YW5jZSwgY2FsbCBtb3VudGVkIG9uIHNlbGZcbiAgLy8gbW91bnRlZCBpcyBjYWxsZWQgZm9yIHJlbmRlci1jcmVhdGVkIGNoaWxkIGNvbXBvbmVudHMgaW4gaXRzIGluc2VydGVkIGhvb2tcbiAgaWYgKHZtLiR2bm9kZSA9PSBudWxsKSB7XG4gICAgdm0uX2lzTW91bnRlZCA9IHRydWU7XG4gICAgY2FsbEhvb2sodm0sICdtb3VudGVkJyk7XG4gIH1cbiAgcmV0dXJuIHZtXG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUNoaWxkQ29tcG9uZW50IChcbiAgdm0sXG4gIHByb3BzRGF0YSxcbiAgbGlzdGVuZXJzLFxuICBwYXJlbnRWbm9kZSxcbiAgcmVuZGVyQ2hpbGRyZW5cbikge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCA9IHRydWU7XG4gIH1cblxuICAvLyBkZXRlcm1pbmUgd2hldGhlciBjb21wb25lbnQgaGFzIHNsb3QgY2hpbGRyZW5cbiAgLy8gd2UgbmVlZCB0byBkbyB0aGlzIGJlZm9yZSBvdmVyd3JpdGluZyAkb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW5cbiAgdmFyIGhhc0NoaWxkcmVuID0gISEoXG4gICAgcmVuZGVyQ2hpbGRyZW4gfHwgICAgICAgICAgICAgICAvLyBoYXMgbmV3IHN0YXRpYyBzbG90c1xuICAgIHZtLiRvcHRpb25zLl9yZW5kZXJDaGlsZHJlbiB8fCAgLy8gaGFzIG9sZCBzdGF0aWMgc2xvdHNcbiAgICBwYXJlbnRWbm9kZS5kYXRhLnNjb3BlZFNsb3RzIHx8IC8vIGhhcyBuZXcgc2NvcGVkIHNsb3RzXG4gICAgdm0uJHNjb3BlZFNsb3RzICE9PSBlbXB0eU9iamVjdCAvLyBoYXMgb2xkIHNjb3BlZCBzbG90c1xuICApO1xuXG4gIHZtLiRvcHRpb25zLl9wYXJlbnRWbm9kZSA9IHBhcmVudFZub2RlO1xuICB2bS4kdm5vZGUgPSBwYXJlbnRWbm9kZTsgLy8gdXBkYXRlIHZtJ3MgcGxhY2Vob2xkZXIgbm9kZSB3aXRob3V0IHJlLXJlbmRlclxuXG4gIGlmICh2bS5fdm5vZGUpIHsgLy8gdXBkYXRlIGNoaWxkIHRyZWUncyBwYXJlbnRcbiAgICB2bS5fdm5vZGUucGFyZW50ID0gcGFyZW50Vm5vZGU7XG4gIH1cbiAgdm0uJG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuID0gcmVuZGVyQ2hpbGRyZW47XG5cbiAgLy8gdXBkYXRlICRhdHRycyBhbmQgJGxpc3RlbmVycyBoYXNoXG4gIC8vIHRoZXNlIGFyZSBhbHNvIHJlYWN0aXZlIHNvIHRoZXkgbWF5IHRyaWdnZXIgY2hpbGQgdXBkYXRlIGlmIHRoZSBjaGlsZFxuICAvLyB1c2VkIHRoZW0gZHVyaW5nIHJlbmRlclxuICB2bS4kYXR0cnMgPSBwYXJlbnRWbm9kZS5kYXRhLmF0dHJzIHx8IGVtcHR5T2JqZWN0O1xuICB2bS4kbGlzdGVuZXJzID0gbGlzdGVuZXJzIHx8IGVtcHR5T2JqZWN0O1xuXG4gIC8vIHVwZGF0ZSBwcm9wc1xuICBpZiAocHJvcHNEYXRhICYmIHZtLiRvcHRpb25zLnByb3BzKSB7XG4gICAgdG9nZ2xlT2JzZXJ2aW5nKGZhbHNlKTtcbiAgICB2YXIgcHJvcHMgPSB2bS5fcHJvcHM7XG4gICAgdmFyIHByb3BLZXlzID0gdm0uJG9wdGlvbnMuX3Byb3BLZXlzIHx8IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBwcm9wS2V5c1tpXTtcbiAgICAgIHZhciBwcm9wT3B0aW9ucyA9IHZtLiRvcHRpb25zLnByb3BzOyAvLyB3dGYgZmxvdz9cbiAgICAgIHByb3BzW2tleV0gPSB2YWxpZGF0ZVByb3Aoa2V5LCBwcm9wT3B0aW9ucywgcHJvcHNEYXRhLCB2bSk7XG4gICAgfVxuICAgIHRvZ2dsZU9ic2VydmluZyh0cnVlKTtcbiAgICAvLyBrZWVwIGEgY29weSBvZiByYXcgcHJvcHNEYXRhXG4gICAgdm0uJG9wdGlvbnMucHJvcHNEYXRhID0gcHJvcHNEYXRhO1xuICB9XG5cbiAgLy8gdXBkYXRlIGxpc3RlbmVyc1xuICBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMgfHwgZW1wdHlPYmplY3Q7XG4gIHZhciBvbGRMaXN0ZW5lcnMgPSB2bS4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xuICB2bS4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzID0gbGlzdGVuZXJzO1xuICB1cGRhdGVDb21wb25lbnRMaXN0ZW5lcnModm0sIGxpc3RlbmVycywgb2xkTGlzdGVuZXJzKTtcblxuICAvLyByZXNvbHZlIHNsb3RzICsgZm9yY2UgdXBkYXRlIGlmIGhhcyBjaGlsZHJlblxuICBpZiAoaGFzQ2hpbGRyZW4pIHtcbiAgICB2bS4kc2xvdHMgPSByZXNvbHZlU2xvdHMocmVuZGVyQ2hpbGRyZW4sIHBhcmVudFZub2RlLmNvbnRleHQpO1xuICAgIHZtLiRmb3JjZVVwZGF0ZSgpO1xuICB9XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgPSBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc0luSW5hY3RpdmVUcmVlICh2bSkge1xuICB3aGlsZSAodm0gJiYgKHZtID0gdm0uJHBhcmVudCkpIHtcbiAgICBpZiAodm0uX2luYWN0aXZlKSB7IHJldHVybiB0cnVlIH1cbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gYWN0aXZhdGVDaGlsZENvbXBvbmVudCAodm0sIGRpcmVjdCkge1xuICBpZiAoZGlyZWN0KSB7XG4gICAgdm0uX2RpcmVjdEluYWN0aXZlID0gZmFsc2U7XG4gICAgaWYgKGlzSW5JbmFjdGl2ZVRyZWUodm0pKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gIH0gZWxzZSBpZiAodm0uX2RpcmVjdEluYWN0aXZlKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKHZtLl9pbmFjdGl2ZSB8fCB2bS5faW5hY3RpdmUgPT09IG51bGwpIHtcbiAgICB2bS5faW5hY3RpdmUgPSBmYWxzZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZtLiRjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgYWN0aXZhdGVDaGlsZENvbXBvbmVudCh2bS4kY2hpbGRyZW5baV0pO1xuICAgIH1cbiAgICBjYWxsSG9vayh2bSwgJ2FjdGl2YXRlZCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRlYWN0aXZhdGVDaGlsZENvbXBvbmVudCAodm0sIGRpcmVjdCkge1xuICBpZiAoZGlyZWN0KSB7XG4gICAgdm0uX2RpcmVjdEluYWN0aXZlID0gdHJ1ZTtcbiAgICBpZiAoaXNJbkluYWN0aXZlVHJlZSh2bSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgfVxuICBpZiAoIXZtLl9pbmFjdGl2ZSkge1xuICAgIHZtLl9pbmFjdGl2ZSA9IHRydWU7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2bS4kY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRlYWN0aXZhdGVDaGlsZENvbXBvbmVudCh2bS4kY2hpbGRyZW5baV0pO1xuICAgIH1cbiAgICBjYWxsSG9vayh2bSwgJ2RlYWN0aXZhdGVkJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FsbEhvb2sgKHZtLCBob29rKSB7XG4gIC8vICM3NTczIGRpc2FibGUgZGVwIGNvbGxlY3Rpb24gd2hlbiBpbnZva2luZyBsaWZlY3ljbGUgaG9va3NcbiAgcHVzaFRhcmdldCgpO1xuICB2YXIgaGFuZGxlcnMgPSB2bS4kb3B0aW9uc1tob29rXTtcbiAgaWYgKGhhbmRsZXJzKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGogPSBoYW5kbGVycy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGhhbmRsZXJzW2ldLmNhbGwodm0pO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBoYW5kbGVFcnJvcihlLCB2bSwgKGhvb2sgKyBcIiBob29rXCIpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKHZtLl9oYXNIb29rRXZlbnQpIHtcbiAgICB2bS4kZW1pdCgnaG9vazonICsgaG9vayk7XG4gIH1cbiAgcG9wVGFyZ2V0KCk7XG59XG5cbi8qICAqL1xuXG5cbnZhciBNQVhfVVBEQVRFX0NPVU5UID0gMTAwO1xuXG52YXIgcXVldWUgPSBbXTtcbnZhciBhY3RpdmF0ZWRDaGlsZHJlbiA9IFtdO1xudmFyIGhhcyA9IHt9O1xudmFyIGNpcmN1bGFyID0ge307XG52YXIgd2FpdGluZyA9IGZhbHNlO1xudmFyIGZsdXNoaW5nID0gZmFsc2U7XG52YXIgaW5kZXggPSAwO1xuXG4vKipcbiAqIFJlc2V0IHRoZSBzY2hlZHVsZXIncyBzdGF0ZS5cbiAqL1xuZnVuY3Rpb24gcmVzZXRTY2hlZHVsZXJTdGF0ZSAoKSB7XG4gIGluZGV4ID0gcXVldWUubGVuZ3RoID0gYWN0aXZhdGVkQ2hpbGRyZW4ubGVuZ3RoID0gMDtcbiAgaGFzID0ge307XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgY2lyY3VsYXIgPSB7fTtcbiAgfVxuICB3YWl0aW5nID0gZmx1c2hpbmcgPSBmYWxzZTtcbn1cblxuLyoqXG4gKiBGbHVzaCBib3RoIHF1ZXVlcyBhbmQgcnVuIHRoZSB3YXRjaGVycy5cbiAqL1xuZnVuY3Rpb24gZmx1c2hTY2hlZHVsZXJRdWV1ZSAoKSB7XG4gIGZsdXNoaW5nID0gdHJ1ZTtcbiAgdmFyIHdhdGNoZXIsIGlkO1xuXG4gIC8vIFNvcnQgcXVldWUgYmVmb3JlIGZsdXNoLlxuICAvLyBUaGlzIGVuc3VyZXMgdGhhdDpcbiAgLy8gMS4gQ29tcG9uZW50cyBhcmUgdXBkYXRlZCBmcm9tIHBhcmVudCB0byBjaGlsZC4gKGJlY2F1c2UgcGFyZW50IGlzIGFsd2F5c1xuICAvLyAgICBjcmVhdGVkIGJlZm9yZSB0aGUgY2hpbGQpXG4gIC8vIDIuIEEgY29tcG9uZW50J3MgdXNlciB3YXRjaGVycyBhcmUgcnVuIGJlZm9yZSBpdHMgcmVuZGVyIHdhdGNoZXIgKGJlY2F1c2VcbiAgLy8gICAgdXNlciB3YXRjaGVycyBhcmUgY3JlYXRlZCBiZWZvcmUgdGhlIHJlbmRlciB3YXRjaGVyKVxuICAvLyAzLiBJZiBhIGNvbXBvbmVudCBpcyBkZXN0cm95ZWQgZHVyaW5nIGEgcGFyZW50IGNvbXBvbmVudCdzIHdhdGNoZXIgcnVuLFxuICAvLyAgICBpdHMgd2F0Y2hlcnMgY2FuIGJlIHNraXBwZWQuXG4gIHF1ZXVlLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEuaWQgLSBiLmlkOyB9KTtcblxuICAvLyBkbyBub3QgY2FjaGUgbGVuZ3RoIGJlY2F1c2UgbW9yZSB3YXRjaGVycyBtaWdodCBiZSBwdXNoZWRcbiAgLy8gYXMgd2UgcnVuIGV4aXN0aW5nIHdhdGNoZXJzXG4gIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IHF1ZXVlLmxlbmd0aDsgaW5kZXgrKykge1xuICAgIHdhdGNoZXIgPSBxdWV1ZVtpbmRleF07XG4gICAgaWQgPSB3YXRjaGVyLmlkO1xuICAgIGhhc1tpZF0gPSBudWxsO1xuICAgIHdhdGNoZXIucnVuKCk7XG4gICAgLy8gaW4gZGV2IGJ1aWxkLCBjaGVjayBhbmQgc3RvcCBjaXJjdWxhciB1cGRhdGVzLlxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGhhc1tpZF0gIT0gbnVsbCkge1xuICAgICAgY2lyY3VsYXJbaWRdID0gKGNpcmN1bGFyW2lkXSB8fCAwKSArIDE7XG4gICAgICBpZiAoY2lyY3VsYXJbaWRdID4gTUFYX1VQREFURV9DT1VOVCkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdZb3UgbWF5IGhhdmUgYW4gaW5maW5pdGUgdXBkYXRlIGxvb3AgJyArIChcbiAgICAgICAgICAgIHdhdGNoZXIudXNlclxuICAgICAgICAgICAgICA/IChcImluIHdhdGNoZXIgd2l0aCBleHByZXNzaW9uIFxcXCJcIiArICh3YXRjaGVyLmV4cHJlc3Npb24pICsgXCJcXFwiXCIpXG4gICAgICAgICAgICAgIDogXCJpbiBhIGNvbXBvbmVudCByZW5kZXIgZnVuY3Rpb24uXCJcbiAgICAgICAgICApLFxuICAgICAgICAgIHdhdGNoZXIudm1cbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBrZWVwIGNvcGllcyBvZiBwb3N0IHF1ZXVlcyBiZWZvcmUgcmVzZXR0aW5nIHN0YXRlXG4gIHZhciBhY3RpdmF0ZWRRdWV1ZSA9IGFjdGl2YXRlZENoaWxkcmVuLnNsaWNlKCk7XG4gIHZhciB1cGRhdGVkUXVldWUgPSBxdWV1ZS5zbGljZSgpO1xuXG4gIHJlc2V0U2NoZWR1bGVyU3RhdGUoKTtcblxuICAvLyBjYWxsIGNvbXBvbmVudCB1cGRhdGVkIGFuZCBhY3RpdmF0ZWQgaG9va3NcbiAgY2FsbEFjdGl2YXRlZEhvb2tzKGFjdGl2YXRlZFF1ZXVlKTtcbiAgY2FsbFVwZGF0ZWRIb29rcyh1cGRhdGVkUXVldWUpO1xuXG4gIC8vIGRldnRvb2wgaG9va1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGRldnRvb2xzICYmIGNvbmZpZy5kZXZ0b29scykge1xuICAgIGRldnRvb2xzLmVtaXQoJ2ZsdXNoJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FsbFVwZGF0ZWRIb29rcyAocXVldWUpIHtcbiAgdmFyIGkgPSBxdWV1ZS5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICB2YXIgd2F0Y2hlciA9IHF1ZXVlW2ldO1xuICAgIHZhciB2bSA9IHdhdGNoZXIudm07XG4gICAgaWYgKHZtLl93YXRjaGVyID09PSB3YXRjaGVyICYmIHZtLl9pc01vdW50ZWQpIHtcbiAgICAgIGNhbGxIb29rKHZtLCAndXBkYXRlZCcpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFF1ZXVlIGEga2VwdC1hbGl2ZSBjb21wb25lbnQgdGhhdCB3YXMgYWN0aXZhdGVkIGR1cmluZyBwYXRjaC5cbiAqIFRoZSBxdWV1ZSB3aWxsIGJlIHByb2Nlc3NlZCBhZnRlciB0aGUgZW50aXJlIHRyZWUgaGFzIGJlZW4gcGF0Y2hlZC5cbiAqL1xuZnVuY3Rpb24gcXVldWVBY3RpdmF0ZWRDb21wb25lbnQgKHZtKSB7XG4gIC8vIHNldHRpbmcgX2luYWN0aXZlIHRvIGZhbHNlIGhlcmUgc28gdGhhdCBhIHJlbmRlciBmdW5jdGlvbiBjYW5cbiAgLy8gcmVseSBvbiBjaGVja2luZyB3aGV0aGVyIGl0J3MgaW4gYW4gaW5hY3RpdmUgdHJlZSAoZS5nLiByb3V0ZXItdmlldylcbiAgdm0uX2luYWN0aXZlID0gZmFsc2U7XG4gIGFjdGl2YXRlZENoaWxkcmVuLnB1c2godm0pO1xufVxuXG5mdW5jdGlvbiBjYWxsQWN0aXZhdGVkSG9va3MgKHF1ZXVlKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICBxdWV1ZVtpXS5faW5hY3RpdmUgPSB0cnVlO1xuICAgIGFjdGl2YXRlQ2hpbGRDb21wb25lbnQocXVldWVbaV0sIHRydWUgLyogdHJ1ZSAqLyk7XG4gIH1cbn1cblxuLyoqXG4gKiBQdXNoIGEgd2F0Y2hlciBpbnRvIHRoZSB3YXRjaGVyIHF1ZXVlLlxuICogSm9icyB3aXRoIGR1cGxpY2F0ZSBJRHMgd2lsbCBiZSBza2lwcGVkIHVubGVzcyBpdCdzXG4gKiBwdXNoZWQgd2hlbiB0aGUgcXVldWUgaXMgYmVpbmcgZmx1c2hlZC5cbiAqL1xuZnVuY3Rpb24gcXVldWVXYXRjaGVyICh3YXRjaGVyKSB7XG4gIHZhciBpZCA9IHdhdGNoZXIuaWQ7XG4gIGlmIChoYXNbaWRdID09IG51bGwpIHtcbiAgICBoYXNbaWRdID0gdHJ1ZTtcbiAgICBpZiAoIWZsdXNoaW5nKSB7XG4gICAgICBxdWV1ZS5wdXNoKHdhdGNoZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpZiBhbHJlYWR5IGZsdXNoaW5nLCBzcGxpY2UgdGhlIHdhdGNoZXIgYmFzZWQgb24gaXRzIGlkXG4gICAgICAvLyBpZiBhbHJlYWR5IHBhc3QgaXRzIGlkLCBpdCB3aWxsIGJlIHJ1biBuZXh0IGltbWVkaWF0ZWx5LlxuICAgICAgdmFyIGkgPSBxdWV1ZS5sZW5ndGggLSAxO1xuICAgICAgd2hpbGUgKGkgPiBpbmRleCAmJiBxdWV1ZVtpXS5pZCA+IHdhdGNoZXIuaWQpIHtcbiAgICAgICAgaS0tO1xuICAgICAgfVxuICAgICAgcXVldWUuc3BsaWNlKGkgKyAxLCAwLCB3YXRjaGVyKTtcbiAgICB9XG4gICAgLy8gcXVldWUgdGhlIGZsdXNoXG4gICAgaWYgKCF3YWl0aW5nKSB7XG4gICAgICB3YWl0aW5nID0gdHJ1ZTtcbiAgICAgIG5leHRUaWNrKGZsdXNoU2NoZWR1bGVyUXVldWUpO1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIHVpZCQxID0gMDtcblxuLyoqXG4gKiBBIHdhdGNoZXIgcGFyc2VzIGFuIGV4cHJlc3Npb24sIGNvbGxlY3RzIGRlcGVuZGVuY2llcyxcbiAqIGFuZCBmaXJlcyBjYWxsYmFjayB3aGVuIHRoZSBleHByZXNzaW9uIHZhbHVlIGNoYW5nZXMuXG4gKiBUaGlzIGlzIHVzZWQgZm9yIGJvdGggdGhlICR3YXRjaCgpIGFwaSBhbmQgZGlyZWN0aXZlcy5cbiAqL1xudmFyIFdhdGNoZXIgPSBmdW5jdGlvbiBXYXRjaGVyIChcbiAgdm0sXG4gIGV4cE9yRm4sXG4gIGNiLFxuICBvcHRpb25zLFxuICBpc1JlbmRlcldhdGNoZXJcbikge1xuICB0aGlzLnZtID0gdm07XG4gIGlmIChpc1JlbmRlcldhdGNoZXIpIHtcbiAgICB2bS5fd2F0Y2hlciA9IHRoaXM7XG4gIH1cbiAgdm0uX3dhdGNoZXJzLnB1c2godGhpcyk7XG4gIC8vIG9wdGlvbnNcbiAgaWYgKG9wdGlvbnMpIHtcbiAgICB0aGlzLmRlZXAgPSAhIW9wdGlvbnMuZGVlcDtcbiAgICB0aGlzLnVzZXIgPSAhIW9wdGlvbnMudXNlcjtcbiAgICB0aGlzLmxhenkgPSAhIW9wdGlvbnMubGF6eTtcbiAgICB0aGlzLnN5bmMgPSAhIW9wdGlvbnMuc3luYztcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmRlZXAgPSB0aGlzLnVzZXIgPSB0aGlzLmxhenkgPSB0aGlzLnN5bmMgPSBmYWxzZTtcbiAgfVxuICB0aGlzLmNiID0gY2I7XG4gIHRoaXMuaWQgPSArK3VpZCQxOyAvLyB1aWQgZm9yIGJhdGNoaW5nXG4gIHRoaXMuYWN0aXZlID0gdHJ1ZTtcbiAgdGhpcy5kaXJ0eSA9IHRoaXMubGF6eTsgLy8gZm9yIGxhenkgd2F0Y2hlcnNcbiAgdGhpcy5kZXBzID0gW107XG4gIHRoaXMubmV3RGVwcyA9IFtdO1xuICB0aGlzLmRlcElkcyA9IG5ldyBfU2V0KCk7XG4gIHRoaXMubmV3RGVwSWRzID0gbmV3IF9TZXQoKTtcbiAgdGhpcy5leHByZXNzaW9uID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJ1xuICAgID8gZXhwT3JGbi50b1N0cmluZygpXG4gICAgOiAnJztcbiAgLy8gcGFyc2UgZXhwcmVzc2lvbiBmb3IgZ2V0dGVyXG4gIGlmICh0eXBlb2YgZXhwT3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRoaXMuZ2V0dGVyID0gZXhwT3JGbjtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmdldHRlciA9IHBhcnNlUGF0aChleHBPckZuKTtcbiAgICBpZiAoIXRoaXMuZ2V0dGVyKSB7XG4gICAgICB0aGlzLmdldHRlciA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICBcIkZhaWxlZCB3YXRjaGluZyBwYXRoOiBcXFwiXCIgKyBleHBPckZuICsgXCJcXFwiIFwiICtcbiAgICAgICAgJ1dhdGNoZXIgb25seSBhY2NlcHRzIHNpbXBsZSBkb3QtZGVsaW1pdGVkIHBhdGhzLiAnICtcbiAgICAgICAgJ0ZvciBmdWxsIGNvbnRyb2wsIHVzZSBhIGZ1bmN0aW9uIGluc3RlYWQuJyxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfVxuICB9XG4gIHRoaXMudmFsdWUgPSB0aGlzLmxhenlcbiAgICA/IHVuZGVmaW5lZFxuICAgIDogdGhpcy5nZXQoKTtcbn07XG5cbi8qKlxuICogRXZhbHVhdGUgdGhlIGdldHRlciwgYW5kIHJlLWNvbGxlY3QgZGVwZW5kZW5jaWVzLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQgKCkge1xuICBwdXNoVGFyZ2V0KHRoaXMpO1xuICB2YXIgdmFsdWU7XG4gIHZhciB2bSA9IHRoaXMudm07XG4gIHRyeSB7XG4gICAgdmFsdWUgPSB0aGlzLmdldHRlci5jYWxsKHZtLCB2bSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAodGhpcy51c2VyKSB7XG4gICAgICBoYW5kbGVFcnJvcihlLCB2bSwgKFwiZ2V0dGVyIGZvciB3YXRjaGVyIFxcXCJcIiArICh0aGlzLmV4cHJlc3Npb24pICsgXCJcXFwiXCIpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgZVxuICAgIH1cbiAgfSBmaW5hbGx5IHtcbiAgICAvLyBcInRvdWNoXCIgZXZlcnkgcHJvcGVydHkgc28gdGhleSBhcmUgYWxsIHRyYWNrZWQgYXNcbiAgICAvLyBkZXBlbmRlbmNpZXMgZm9yIGRlZXAgd2F0Y2hpbmdcbiAgICBpZiAodGhpcy5kZWVwKSB7XG4gICAgICB0cmF2ZXJzZSh2YWx1ZSk7XG4gICAgfVxuICAgIHBvcFRhcmdldCgpO1xuICAgIHRoaXMuY2xlYW51cERlcHMoKTtcbiAgfVxuICByZXR1cm4gdmFsdWVcbn07XG5cbi8qKlxuICogQWRkIGEgZGVwZW5kZW5jeSB0byB0aGlzIGRpcmVjdGl2ZS5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUuYWRkRGVwID0gZnVuY3Rpb24gYWRkRGVwIChkZXApIHtcbiAgdmFyIGlkID0gZGVwLmlkO1xuICBpZiAoIXRoaXMubmV3RGVwSWRzLmhhcyhpZCkpIHtcbiAgICB0aGlzLm5ld0RlcElkcy5hZGQoaWQpO1xuICAgIHRoaXMubmV3RGVwcy5wdXNoKGRlcCk7XG4gICAgaWYgKCF0aGlzLmRlcElkcy5oYXMoaWQpKSB7XG4gICAgICBkZXAuYWRkU3ViKHRoaXMpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBDbGVhbiB1cCBmb3IgZGVwZW5kZW5jeSBjb2xsZWN0aW9uLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5jbGVhbnVwRGVwcyA9IGZ1bmN0aW9uIGNsZWFudXBEZXBzICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICB2YXIgZGVwID0gdGhpcyQxLmRlcHNbaV07XG4gICAgaWYgKCF0aGlzJDEubmV3RGVwSWRzLmhhcyhkZXAuaWQpKSB7XG4gICAgICBkZXAucmVtb3ZlU3ViKHRoaXMkMSk7XG4gICAgfVxuICB9XG4gIHZhciB0bXAgPSB0aGlzLmRlcElkcztcbiAgdGhpcy5kZXBJZHMgPSB0aGlzLm5ld0RlcElkcztcbiAgdGhpcy5uZXdEZXBJZHMgPSB0bXA7XG4gIHRoaXMubmV3RGVwSWRzLmNsZWFyKCk7XG4gIHRtcCA9IHRoaXMuZGVwcztcbiAgdGhpcy5kZXBzID0gdGhpcy5uZXdEZXBzO1xuICB0aGlzLm5ld0RlcHMgPSB0bXA7XG4gIHRoaXMubmV3RGVwcy5sZW5ndGggPSAwO1xufTtcblxuLyoqXG4gKiBTdWJzY3JpYmVyIGludGVyZmFjZS5cbiAqIFdpbGwgYmUgY2FsbGVkIHdoZW4gYSBkZXBlbmRlbmN5IGNoYW5nZXMuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSAoKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmICh0aGlzLmxhenkpIHtcbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgfSBlbHNlIGlmICh0aGlzLnN5bmMpIHtcbiAgICB0aGlzLnJ1bigpO1xuICB9IGVsc2Uge1xuICAgIHF1ZXVlV2F0Y2hlcih0aGlzKTtcbiAgfVxufTtcblxuLyoqXG4gKiBTY2hlZHVsZXIgam9iIGludGVyZmFjZS5cbiAqIFdpbGwgYmUgY2FsbGVkIGJ5IHRoZSBzY2hlZHVsZXIuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uIHJ1biAoKSB7XG4gIGlmICh0aGlzLmFjdGl2ZSkge1xuICAgIHZhciB2YWx1ZSA9IHRoaXMuZ2V0KCk7XG4gICAgaWYgKFxuICAgICAgdmFsdWUgIT09IHRoaXMudmFsdWUgfHxcbiAgICAgIC8vIERlZXAgd2F0Y2hlcnMgYW5kIHdhdGNoZXJzIG9uIE9iamVjdC9BcnJheXMgc2hvdWxkIGZpcmUgZXZlblxuICAgICAgLy8gd2hlbiB0aGUgdmFsdWUgaXMgdGhlIHNhbWUsIGJlY2F1c2UgdGhlIHZhbHVlIG1heVxuICAgICAgLy8gaGF2ZSBtdXRhdGVkLlxuICAgICAgaXNPYmplY3QodmFsdWUpIHx8XG4gICAgICB0aGlzLmRlZXBcbiAgICApIHtcbiAgICAgIC8vIHNldCBuZXcgdmFsdWVcbiAgICAgIHZhciBvbGRWYWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICBpZiAodGhpcy51c2VyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhpcy5jYi5jYWxsKHRoaXMudm0sIHZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBoYW5kbGVFcnJvcihlLCB0aGlzLnZtLCAoXCJjYWxsYmFjayBmb3Igd2F0Y2hlciBcXFwiXCIgKyAodGhpcy5leHByZXNzaW9uKSArIFwiXFxcIlwiKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY2IuY2FsbCh0aGlzLnZtLCB2YWx1ZSwgb2xkVmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBFdmFsdWF0ZSB0aGUgdmFsdWUgb2YgdGhlIHdhdGNoZXIuXG4gKiBUaGlzIG9ubHkgZ2V0cyBjYWxsZWQgZm9yIGxhenkgd2F0Y2hlcnMuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24gZXZhbHVhdGUgKCkge1xuICB0aGlzLnZhbHVlID0gdGhpcy5nZXQoKTtcbiAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xufTtcblxuLyoqXG4gKiBEZXBlbmQgb24gYWxsIGRlcHMgY29sbGVjdGVkIGJ5IHRoaXMgd2F0Y2hlci5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUuZGVwZW5kID0gZnVuY3Rpb24gZGVwZW5kICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICB0aGlzJDEuZGVwc1tpXS5kZXBlbmQoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZW1vdmUgc2VsZiBmcm9tIGFsbCBkZXBlbmRlbmNpZXMnIHN1YnNjcmliZXIgbGlzdC5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUudGVhcmRvd24gPSBmdW5jdGlvbiB0ZWFyZG93biAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgaWYgKHRoaXMuYWN0aXZlKSB7XG4gICAgLy8gcmVtb3ZlIHNlbGYgZnJvbSB2bSdzIHdhdGNoZXIgbGlzdFxuICAgIC8vIHRoaXMgaXMgYSBzb21ld2hhdCBleHBlbnNpdmUgb3BlcmF0aW9uIHNvIHdlIHNraXAgaXRcbiAgICAvLyBpZiB0aGUgdm0gaXMgYmVpbmcgZGVzdHJveWVkLlxuICAgIGlmICghdGhpcy52bS5faXNCZWluZ0Rlc3Ryb3llZCkge1xuICAgICAgcmVtb3ZlKHRoaXMudm0uX3dhdGNoZXJzLCB0aGlzKTtcbiAgICB9XG4gICAgdmFyIGkgPSB0aGlzLmRlcHMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHRoaXMkMS5kZXBzW2ldLnJlbW92ZVN1Yih0aGlzJDEpO1xuICAgIH1cbiAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICB9XG59O1xuXG4vKiAgKi9cblxudmFyIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbiA9IHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBnZXQ6IG5vb3AsXG4gIHNldDogbm9vcFxufTtcblxuZnVuY3Rpb24gcHJveHkgKHRhcmdldCwgc291cmNlS2V5LCBrZXkpIHtcbiAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLmdldCA9IGZ1bmN0aW9uIHByb3h5R2V0dGVyICgpIHtcbiAgICByZXR1cm4gdGhpc1tzb3VyY2VLZXldW2tleV1cbiAgfTtcbiAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9IGZ1bmN0aW9uIHByb3h5U2V0dGVyICh2YWwpIHtcbiAgICB0aGlzW3NvdXJjZUtleV1ba2V5XSA9IHZhbDtcbiAgfTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24pO1xufVxuXG5mdW5jdGlvbiBpbml0U3RhdGUgKHZtKSB7XG4gIHZtLl93YXRjaGVycyA9IFtdO1xuICB2YXIgb3B0cyA9IHZtLiRvcHRpb25zO1xuICBpZiAob3B0cy5wcm9wcykgeyBpbml0UHJvcHModm0sIG9wdHMucHJvcHMpOyB9XG4gIGlmIChvcHRzLm1ldGhvZHMpIHsgaW5pdE1ldGhvZHModm0sIG9wdHMubWV0aG9kcyk7IH1cbiAgaWYgKG9wdHMuZGF0YSkge1xuICAgIGluaXREYXRhKHZtKTtcbiAgfSBlbHNlIHtcbiAgICBvYnNlcnZlKHZtLl9kYXRhID0ge30sIHRydWUgLyogYXNSb290RGF0YSAqLyk7XG4gIH1cbiAgaWYgKG9wdHMuY29tcHV0ZWQpIHsgaW5pdENvbXB1dGVkKHZtLCBvcHRzLmNvbXB1dGVkKTsgfVxuICBpZiAob3B0cy53YXRjaCAmJiBvcHRzLndhdGNoICE9PSBuYXRpdmVXYXRjaCkge1xuICAgIGluaXRXYXRjaCh2bSwgb3B0cy53YXRjaCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdFByb3BzICh2bSwgcHJvcHNPcHRpb25zKSB7XG4gIHZhciBwcm9wc0RhdGEgPSB2bS4kb3B0aW9ucy5wcm9wc0RhdGEgfHwge307XG4gIHZhciBwcm9wcyA9IHZtLl9wcm9wcyA9IHt9O1xuICAvLyBjYWNoZSBwcm9wIGtleXMgc28gdGhhdCBmdXR1cmUgcHJvcHMgdXBkYXRlcyBjYW4gaXRlcmF0ZSB1c2luZyBBcnJheVxuICAvLyBpbnN0ZWFkIG9mIGR5bmFtaWMgb2JqZWN0IGtleSBlbnVtZXJhdGlvbi5cbiAgdmFyIGtleXMgPSB2bS4kb3B0aW9ucy5fcHJvcEtleXMgPSBbXTtcbiAgdmFyIGlzUm9vdCA9ICF2bS4kcGFyZW50O1xuICAvLyByb290IGluc3RhbmNlIHByb3BzIHNob3VsZCBiZSBjb252ZXJ0ZWRcbiAgaWYgKCFpc1Jvb3QpIHtcbiAgICB0b2dnbGVPYnNlcnZpbmcoZmFsc2UpO1xuICB9XG4gIHZhciBsb29wID0gZnVuY3Rpb24gKCBrZXkgKSB7XG4gICAga2V5cy5wdXNoKGtleSk7XG4gICAgdmFyIHZhbHVlID0gdmFsaWRhdGVQcm9wKGtleSwgcHJvcHNPcHRpb25zLCBwcm9wc0RhdGEsIHZtKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgaHlwaGVuYXRlZEtleSA9IGh5cGhlbmF0ZShrZXkpO1xuICAgICAgaWYgKGlzUmVzZXJ2ZWRBdHRyaWJ1dGUoaHlwaGVuYXRlZEtleSkgfHxcbiAgICAgICAgICBjb25maWcuaXNSZXNlcnZlZEF0dHIoaHlwaGVuYXRlZEtleSkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAoXCJcXFwiXCIgKyBoeXBoZW5hdGVkS2V5ICsgXCJcXFwiIGlzIGEgcmVzZXJ2ZWQgYXR0cmlidXRlIGFuZCBjYW5ub3QgYmUgdXNlZCBhcyBjb21wb25lbnQgcHJvcC5cIiksXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGRlZmluZVJlYWN0aXZlKHByb3BzLCBrZXksIHZhbHVlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh2bS4kcGFyZW50ICYmICFpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQpIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgXCJBdm9pZCBtdXRhdGluZyBhIHByb3AgZGlyZWN0bHkgc2luY2UgdGhlIHZhbHVlIHdpbGwgYmUgXCIgK1xuICAgICAgICAgICAgXCJvdmVyd3JpdHRlbiB3aGVuZXZlciB0aGUgcGFyZW50IGNvbXBvbmVudCByZS1yZW5kZXJzLiBcIiArXG4gICAgICAgICAgICBcIkluc3RlYWQsIHVzZSBhIGRhdGEgb3IgY29tcHV0ZWQgcHJvcGVydHkgYmFzZWQgb24gdGhlIHByb3AncyBcIiArXG4gICAgICAgICAgICBcInZhbHVlLiBQcm9wIGJlaW5nIG11dGF0ZWQ6IFxcXCJcIiArIGtleSArIFwiXFxcIlwiLFxuICAgICAgICAgICAgdm1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVmaW5lUmVhY3RpdmUocHJvcHMsIGtleSwgdmFsdWUpO1xuICAgIH1cbiAgICAvLyBzdGF0aWMgcHJvcHMgYXJlIGFscmVhZHkgcHJveGllZCBvbiB0aGUgY29tcG9uZW50J3MgcHJvdG90eXBlXG4gICAgLy8gZHVyaW5nIFZ1ZS5leHRlbmQoKS4gV2Ugb25seSBuZWVkIHRvIHByb3h5IHByb3BzIGRlZmluZWQgYXRcbiAgICAvLyBpbnN0YW50aWF0aW9uIGhlcmUuXG4gICAgaWYgKCEoa2V5IGluIHZtKSkge1xuICAgICAgcHJveHkodm0sIFwiX3Byb3BzXCIsIGtleSk7XG4gICAgfVxuICB9O1xuXG4gIGZvciAodmFyIGtleSBpbiBwcm9wc09wdGlvbnMpIGxvb3AoIGtleSApO1xuICB0b2dnbGVPYnNlcnZpbmcodHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIGluaXREYXRhICh2bSkge1xuICB2YXIgZGF0YSA9IHZtLiRvcHRpb25zLmRhdGE7XG4gIGRhdGEgPSB2bS5fZGF0YSA9IHR5cGVvZiBkYXRhID09PSAnZnVuY3Rpb24nXG4gICAgPyBnZXREYXRhKGRhdGEsIHZtKVxuICAgIDogZGF0YSB8fCB7fTtcbiAgaWYgKCFpc1BsYWluT2JqZWN0KGRhdGEpKSB7XG4gICAgZGF0YSA9IHt9O1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICdkYXRhIGZ1bmN0aW9ucyBzaG91bGQgcmV0dXJuIGFuIG9iamVjdDpcXG4nICtcbiAgICAgICdodHRwczovL3Z1ZWpzLm9yZy92Mi9ndWlkZS9jb21wb25lbnRzLmh0bWwjZGF0YS1NdXN0LUJlLWEtRnVuY3Rpb24nLFxuICAgICAgdm1cbiAgICApO1xuICB9XG4gIC8vIHByb3h5IGRhdGEgb24gaW5zdGFuY2VcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhkYXRhKTtcbiAgdmFyIHByb3BzID0gdm0uJG9wdGlvbnMucHJvcHM7XG4gIHZhciBtZXRob2RzID0gdm0uJG9wdGlvbnMubWV0aG9kcztcbiAgdmFyIGkgPSBrZXlzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAobWV0aG9kcyAmJiBoYXNPd24obWV0aG9kcywga2V5KSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIChcIk1ldGhvZCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaGFzIGFscmVhZHkgYmVlbiBkZWZpbmVkIGFzIGEgZGF0YSBwcm9wZXJ0eS5cIiksXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHByb3BzICYmIGhhc093bihwcm9wcywga2V5KSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICBcIlRoZSBkYXRhIHByb3BlcnR5IFxcXCJcIiArIGtleSArIFwiXFxcIiBpcyBhbHJlYWR5IGRlY2xhcmVkIGFzIGEgcHJvcC4gXCIgK1xuICAgICAgICBcIlVzZSBwcm9wIGRlZmF1bHQgdmFsdWUgaW5zdGVhZC5cIixcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfSBlbHNlIGlmICghaXNSZXNlcnZlZChrZXkpKSB7XG4gICAgICBwcm94eSh2bSwgXCJfZGF0YVwiLCBrZXkpO1xuICAgIH1cbiAgfVxuICAvLyBvYnNlcnZlIGRhdGFcbiAgb2JzZXJ2ZShkYXRhLCB0cnVlIC8qIGFzUm9vdERhdGEgKi8pO1xufVxuXG5mdW5jdGlvbiBnZXREYXRhIChkYXRhLCB2bSkge1xuICAvLyAjNzU3MyBkaXNhYmxlIGRlcCBjb2xsZWN0aW9uIHdoZW4gaW52b2tpbmcgZGF0YSBnZXR0ZXJzXG4gIHB1c2hUYXJnZXQoKTtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZGF0YS5jYWxsKHZtLCB2bSlcbiAgfSBjYXRjaCAoZSkge1xuICAgIGhhbmRsZUVycm9yKGUsIHZtLCBcImRhdGEoKVwiKTtcbiAgICByZXR1cm4ge31cbiAgfSBmaW5hbGx5IHtcbiAgICBwb3BUYXJnZXQoKTtcbiAgfVxufVxuXG52YXIgY29tcHV0ZWRXYXRjaGVyT3B0aW9ucyA9IHsgbGF6eTogdHJ1ZSB9O1xuXG5mdW5jdGlvbiBpbml0Q29tcHV0ZWQgKHZtLCBjb21wdXRlZCkge1xuICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgdmFyIHdhdGNoZXJzID0gdm0uX2NvbXB1dGVkV2F0Y2hlcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAvLyBjb21wdXRlZCBwcm9wZXJ0aWVzIGFyZSBqdXN0IGdldHRlcnMgZHVyaW5nIFNTUlxuICB2YXIgaXNTU1IgPSBpc1NlcnZlclJlbmRlcmluZygpO1xuXG4gIGZvciAodmFyIGtleSBpbiBjb21wdXRlZCkge1xuICAgIHZhciB1c2VyRGVmID0gY29tcHV0ZWRba2V5XTtcbiAgICB2YXIgZ2V0dGVyID0gdHlwZW9mIHVzZXJEZWYgPT09ICdmdW5jdGlvbicgPyB1c2VyRGVmIDogdXNlckRlZi5nZXQ7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgZ2V0dGVyID09IG51bGwpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIChcIkdldHRlciBpcyBtaXNzaW5nIGZvciBjb21wdXRlZCBwcm9wZXJ0eSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIuXCIpLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoIWlzU1NSKSB7XG4gICAgICAvLyBjcmVhdGUgaW50ZXJuYWwgd2F0Y2hlciBmb3IgdGhlIGNvbXB1dGVkIHByb3BlcnR5LlxuICAgICAgd2F0Y2hlcnNba2V5XSA9IG5ldyBXYXRjaGVyKFxuICAgICAgICB2bSxcbiAgICAgICAgZ2V0dGVyIHx8IG5vb3AsXG4gICAgICAgIG5vb3AsXG4gICAgICAgIGNvbXB1dGVkV2F0Y2hlck9wdGlvbnNcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gY29tcG9uZW50LWRlZmluZWQgY29tcHV0ZWQgcHJvcGVydGllcyBhcmUgYWxyZWFkeSBkZWZpbmVkIG9uIHRoZVxuICAgIC8vIGNvbXBvbmVudCBwcm90b3R5cGUuIFdlIG9ubHkgbmVlZCB0byBkZWZpbmUgY29tcHV0ZWQgcHJvcGVydGllcyBkZWZpbmVkXG4gICAgLy8gYXQgaW5zdGFudGlhdGlvbiBoZXJlLlxuICAgIGlmICghKGtleSBpbiB2bSkpIHtcbiAgICAgIGRlZmluZUNvbXB1dGVkKHZtLCBrZXksIHVzZXJEZWYpO1xuICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKGtleSBpbiB2bS4kZGF0YSkge1xuICAgICAgICB3YXJuKChcIlRoZSBjb21wdXRlZCBwcm9wZXJ0eSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaXMgYWxyZWFkeSBkZWZpbmVkIGluIGRhdGEuXCIpLCB2bSk7XG4gICAgICB9IGVsc2UgaWYgKHZtLiRvcHRpb25zLnByb3BzICYmIGtleSBpbiB2bS4kb3B0aW9ucy5wcm9wcykge1xuICAgICAgICB3YXJuKChcIlRoZSBjb21wdXRlZCBwcm9wZXJ0eSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaXMgYWxyZWFkeSBkZWZpbmVkIGFzIGEgcHJvcC5cIiksIHZtKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lQ29tcHV0ZWQgKFxuICB0YXJnZXQsXG4gIGtleSxcbiAgdXNlckRlZlxuKSB7XG4gIHZhciBzaG91bGRDYWNoZSA9ICFpc1NlcnZlclJlbmRlcmluZygpO1xuICBpZiAodHlwZW9mIHVzZXJEZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uZ2V0ID0gc2hvdWxkQ2FjaGVcbiAgICAgID8gY3JlYXRlQ29tcHV0ZWRHZXR0ZXIoa2V5KVxuICAgICAgOiB1c2VyRGVmO1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPSBub29wO1xuICB9IGVsc2Uge1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5nZXQgPSB1c2VyRGVmLmdldFxuICAgICAgPyBzaG91bGRDYWNoZSAmJiB1c2VyRGVmLmNhY2hlICE9PSBmYWxzZVxuICAgICAgICA/IGNyZWF0ZUNvbXB1dGVkR2V0dGVyKGtleSlcbiAgICAgICAgOiB1c2VyRGVmLmdldFxuICAgICAgOiBub29wO1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPSB1c2VyRGVmLnNldFxuICAgICAgPyB1c2VyRGVmLnNldFxuICAgICAgOiBub29wO1xuICB9XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID09PSBub29wKSB7XG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIChcIkNvbXB1dGVkIHByb3BlcnR5IFxcXCJcIiArIGtleSArIFwiXFxcIiB3YXMgYXNzaWduZWQgdG8gYnV0IGl0IGhhcyBubyBzZXR0ZXIuXCIpLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgIH07XG4gIH1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDb21wdXRlZEdldHRlciAoa2V5KSB7XG4gIHJldHVybiBmdW5jdGlvbiBjb21wdXRlZEdldHRlciAoKSB7XG4gICAgdmFyIHdhdGNoZXIgPSB0aGlzLl9jb21wdXRlZFdhdGNoZXJzICYmIHRoaXMuX2NvbXB1dGVkV2F0Y2hlcnNba2V5XTtcbiAgICBpZiAod2F0Y2hlcikge1xuICAgICAgaWYgKHdhdGNoZXIuZGlydHkpIHtcbiAgICAgICAgd2F0Y2hlci5ldmFsdWF0ZSgpO1xuICAgICAgfVxuICAgICAgaWYgKERlcC50YXJnZXQpIHtcbiAgICAgICAgd2F0Y2hlci5kZXBlbmQoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3YXRjaGVyLnZhbHVlXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRNZXRob2RzICh2bSwgbWV0aG9kcykge1xuICB2YXIgcHJvcHMgPSB2bS4kb3B0aW9ucy5wcm9wcztcbiAgZm9yICh2YXIga2V5IGluIG1ldGhvZHMpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKG1ldGhvZHNba2V5XSA9PSBudWxsKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgXCJNZXRob2QgXFxcIlwiICsga2V5ICsgXCJcXFwiIGhhcyBhbiB1bmRlZmluZWQgdmFsdWUgaW4gdGhlIGNvbXBvbmVudCBkZWZpbml0aW9uLiBcIiArXG4gICAgICAgICAgXCJEaWQgeW91IHJlZmVyZW5jZSB0aGUgZnVuY3Rpb24gY29ycmVjdGx5P1wiLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAocHJvcHMgJiYgaGFzT3duKHByb3BzLCBrZXkpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgKFwiTWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBoYXMgYWxyZWFkeSBiZWVuIGRlZmluZWQgYXMgYSBwcm9wLlwiKSxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKChrZXkgaW4gdm0pICYmIGlzUmVzZXJ2ZWQoa2V5KSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIFwiTWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBjb25mbGljdHMgd2l0aCBhbiBleGlzdGluZyBWdWUgaW5zdGFuY2UgbWV0aG9kLiBcIiArXG4gICAgICAgICAgXCJBdm9pZCBkZWZpbmluZyBjb21wb25lbnQgbWV0aG9kcyB0aGF0IHN0YXJ0IHdpdGggXyBvciAkLlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHZtW2tleV0gPSBtZXRob2RzW2tleV0gPT0gbnVsbCA/IG5vb3AgOiBiaW5kKG1ldGhvZHNba2V5XSwgdm0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRXYXRjaCAodm0sIHdhdGNoKSB7XG4gIGZvciAodmFyIGtleSBpbiB3YXRjaCkge1xuICAgIHZhciBoYW5kbGVyID0gd2F0Y2hba2V5XTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShoYW5kbGVyKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoYW5kbGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNyZWF0ZVdhdGNoZXIodm0sIGtleSwgaGFuZGxlcltpXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNyZWF0ZVdhdGNoZXIodm0sIGtleSwgaGFuZGxlcik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVdhdGNoZXIgKFxuICB2bSxcbiAgZXhwT3JGbixcbiAgaGFuZGxlcixcbiAgb3B0aW9uc1xuKSB7XG4gIGlmIChpc1BsYWluT2JqZWN0KGhhbmRsZXIpKSB7XG4gICAgb3B0aW9ucyA9IGhhbmRsZXI7XG4gICAgaGFuZGxlciA9IGhhbmRsZXIuaGFuZGxlcjtcbiAgfVxuICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgaGFuZGxlciA9IHZtW2hhbmRsZXJdO1xuICB9XG4gIHJldHVybiB2bS4kd2F0Y2goZXhwT3JGbiwgaGFuZGxlciwgb3B0aW9ucylcbn1cblxuZnVuY3Rpb24gc3RhdGVNaXhpbiAoVnVlKSB7XG4gIC8vIGZsb3cgc29tZWhvdyBoYXMgcHJvYmxlbXMgd2l0aCBkaXJlY3RseSBkZWNsYXJlZCBkZWZpbml0aW9uIG9iamVjdFxuICAvLyB3aGVuIHVzaW5nIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSwgc28gd2UgaGF2ZSB0byBwcm9jZWR1cmFsbHkgYnVpbGQgdXBcbiAgLy8gdGhlIG9iamVjdCBoZXJlLlxuICB2YXIgZGF0YURlZiA9IHt9O1xuICBkYXRhRGVmLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2RhdGEgfTtcbiAgdmFyIHByb3BzRGVmID0ge307XG4gIHByb3BzRGVmLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3Byb3BzIH07XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgZGF0YURlZi5zZXQgPSBmdW5jdGlvbiAobmV3RGF0YSkge1xuICAgICAgd2FybihcbiAgICAgICAgJ0F2b2lkIHJlcGxhY2luZyBpbnN0YW5jZSByb290ICRkYXRhLiAnICtcbiAgICAgICAgJ1VzZSBuZXN0ZWQgZGF0YSBwcm9wZXJ0aWVzIGluc3RlYWQuJyxcbiAgICAgICAgdGhpc1xuICAgICAgKTtcbiAgICB9O1xuICAgIHByb3BzRGVmLnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHdhcm4oXCIkcHJvcHMgaXMgcmVhZG9ubHkuXCIsIHRoaXMpO1xuICAgIH07XG4gIH1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZS5wcm90b3R5cGUsICckZGF0YScsIGRhdGFEZWYpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLnByb3RvdHlwZSwgJyRwcm9wcycsIHByb3BzRGVmKTtcblxuICBWdWUucHJvdG90eXBlLiRzZXQgPSBzZXQ7XG4gIFZ1ZS5wcm90b3R5cGUuJGRlbGV0ZSA9IGRlbDtcblxuICBWdWUucHJvdG90eXBlLiR3YXRjaCA9IGZ1bmN0aW9uIChcbiAgICBleHBPckZuLFxuICAgIGNiLFxuICAgIG9wdGlvbnNcbiAgKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAoaXNQbGFpbk9iamVjdChjYikpIHtcbiAgICAgIHJldHVybiBjcmVhdGVXYXRjaGVyKHZtLCBleHBPckZuLCBjYiwgb3B0aW9ucylcbiAgICB9XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgb3B0aW9ucy51c2VyID0gdHJ1ZTtcbiAgICB2YXIgd2F0Y2hlciA9IG5ldyBXYXRjaGVyKHZtLCBleHBPckZuLCBjYiwgb3B0aW9ucyk7XG4gICAgaWYgKG9wdGlvbnMuaW1tZWRpYXRlKSB7XG4gICAgICBjYi5jYWxsKHZtLCB3YXRjaGVyLnZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVud2F0Y2hGbiAoKSB7XG4gICAgICB3YXRjaGVyLnRlYXJkb3duKCk7XG4gICAgfVxuICB9O1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdFByb3ZpZGUgKHZtKSB7XG4gIHZhciBwcm92aWRlID0gdm0uJG9wdGlvbnMucHJvdmlkZTtcbiAgaWYgKHByb3ZpZGUpIHtcbiAgICB2bS5fcHJvdmlkZWQgPSB0eXBlb2YgcHJvdmlkZSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgPyBwcm92aWRlLmNhbGwodm0pXG4gICAgICA6IHByb3ZpZGU7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdEluamVjdGlvbnMgKHZtKSB7XG4gIHZhciByZXN1bHQgPSByZXNvbHZlSW5qZWN0KHZtLiRvcHRpb25zLmluamVjdCwgdm0pO1xuICBpZiAocmVzdWx0KSB7XG4gICAgdG9nZ2xlT2JzZXJ2aW5nKGZhbHNlKTtcbiAgICBPYmplY3Qua2V5cyhyZXN1bHQpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGRlZmluZVJlYWN0aXZlKHZtLCBrZXksIHJlc3VsdFtrZXldLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgIFwiQXZvaWQgbXV0YXRpbmcgYW4gaW5qZWN0ZWQgdmFsdWUgZGlyZWN0bHkgc2luY2UgdGhlIGNoYW5nZXMgd2lsbCBiZSBcIiArXG4gICAgICAgICAgICBcIm92ZXJ3cml0dGVuIHdoZW5ldmVyIHRoZSBwcm92aWRlZCBjb21wb25lbnQgcmUtcmVuZGVycy4gXCIgK1xuICAgICAgICAgICAgXCJpbmplY3Rpb24gYmVpbmcgbXV0YXRlZDogXFxcIlwiICsga2V5ICsgXCJcXFwiXCIsXG4gICAgICAgICAgICB2bVxuICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVmaW5lUmVhY3RpdmUodm0sIGtleSwgcmVzdWx0W2tleV0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRvZ2dsZU9ic2VydmluZyh0cnVlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXNvbHZlSW5qZWN0IChpbmplY3QsIHZtKSB7XG4gIGlmIChpbmplY3QpIHtcbiAgICAvLyBpbmplY3QgaXMgOmFueSBiZWNhdXNlIGZsb3cgaXMgbm90IHNtYXJ0IGVub3VnaCB0byBmaWd1cmUgb3V0IGNhY2hlZFxuICAgIHZhciByZXN1bHQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHZhciBrZXlzID0gaGFzU3ltYm9sXG4gICAgICA/IFJlZmxlY3Qub3duS2V5cyhpbmplY3QpLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGluamVjdCwga2V5KS5lbnVtZXJhYmxlXG4gICAgICB9KVxuICAgICAgOiBPYmplY3Qua2V5cyhpbmplY3QpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgIHZhciBwcm92aWRlS2V5ID0gaW5qZWN0W2tleV0uZnJvbTtcbiAgICAgIHZhciBzb3VyY2UgPSB2bTtcbiAgICAgIHdoaWxlIChzb3VyY2UpIHtcbiAgICAgICAgaWYgKHNvdXJjZS5fcHJvdmlkZWQgJiYgaGFzT3duKHNvdXJjZS5fcHJvdmlkZWQsIHByb3ZpZGVLZXkpKSB7XG4gICAgICAgICAgcmVzdWx0W2tleV0gPSBzb3VyY2UuX3Byb3ZpZGVkW3Byb3ZpZGVLZXldO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgc291cmNlID0gc291cmNlLiRwYXJlbnQ7XG4gICAgICB9XG4gICAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgICBpZiAoJ2RlZmF1bHQnIGluIGluamVjdFtrZXldKSB7XG4gICAgICAgICAgdmFyIHByb3ZpZGVEZWZhdWx0ID0gaW5qZWN0W2tleV0uZGVmYXVsdDtcbiAgICAgICAgICByZXN1bHRba2V5XSA9IHR5cGVvZiBwcm92aWRlRGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgPyBwcm92aWRlRGVmYXVsdC5jYWxsKHZtKVxuICAgICAgICAgICAgOiBwcm92aWRlRGVmYXVsdDtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgd2FybigoXCJJbmplY3Rpb24gXFxcIlwiICsga2V5ICsgXCJcXFwiIG5vdCBmb3VuZFwiKSwgdm0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRcbiAgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVuZGVyaW5nIHYtZm9yIGxpc3RzLlxuICovXG5mdW5jdGlvbiByZW5kZXJMaXN0IChcbiAgdmFsLFxuICByZW5kZXJcbikge1xuICB2YXIgcmV0LCBpLCBsLCBrZXlzLCBrZXk7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbCkgfHwgdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICByZXQgPSBuZXcgQXJyYXkodmFsLmxlbmd0aCk7XG4gICAgZm9yIChpID0gMCwgbCA9IHZhbC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHJldFtpXSA9IHJlbmRlcih2YWxbaV0sIGkpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHJldCA9IG5ldyBBcnJheSh2YWwpO1xuICAgIGZvciAoaSA9IDA7IGkgPCB2YWw7IGkrKykge1xuICAgICAgcmV0W2ldID0gcmVuZGVyKGkgKyAxLCBpKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QodmFsKSkge1xuICAgIGtleXMgPSBPYmplY3Qua2V5cyh2YWwpO1xuICAgIHJldCA9IG5ldyBBcnJheShrZXlzLmxlbmd0aCk7XG4gICAgZm9yIChpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgcmV0W2ldID0gcmVuZGVyKHZhbFtrZXldLCBrZXksIGkpO1xuICAgIH1cbiAgfVxuICBpZiAoaXNEZWYocmV0KSkge1xuICAgIChyZXQpLl9pc1ZMaXN0ID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZW5kZXJpbmcgPHNsb3Q+XG4gKi9cbmZ1bmN0aW9uIHJlbmRlclNsb3QgKFxuICBuYW1lLFxuICBmYWxsYmFjayxcbiAgcHJvcHMsXG4gIGJpbmRPYmplY3Rcbikge1xuICB2YXIgc2NvcGVkU2xvdEZuID0gdGhpcy4kc2NvcGVkU2xvdHNbbmFtZV07XG4gIHZhciBub2RlcztcbiAgaWYgKHNjb3BlZFNsb3RGbikgeyAvLyBzY29wZWQgc2xvdFxuICAgIHByb3BzID0gcHJvcHMgfHwge307XG4gICAgaWYgKGJpbmRPYmplY3QpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICFpc09iamVjdChiaW5kT2JqZWN0KSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdzbG90IHYtYmluZCB3aXRob3V0IGFyZ3VtZW50IGV4cGVjdHMgYW4gT2JqZWN0JyxcbiAgICAgICAgICB0aGlzXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBwcm9wcyA9IGV4dGVuZChleHRlbmQoe30sIGJpbmRPYmplY3QpLCBwcm9wcyk7XG4gICAgfVxuICAgIG5vZGVzID0gc2NvcGVkU2xvdEZuKHByb3BzKSB8fCBmYWxsYmFjaztcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2xvdE5vZGVzID0gdGhpcy4kc2xvdHNbbmFtZV07XG4gICAgLy8gd2FybiBkdXBsaWNhdGUgc2xvdCB1c2FnZVxuICAgIGlmIChzbG90Tm9kZXMpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHNsb3ROb2Rlcy5fcmVuZGVyZWQpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBcIkR1cGxpY2F0ZSBwcmVzZW5jZSBvZiBzbG90IFxcXCJcIiArIG5hbWUgKyBcIlxcXCIgZm91bmQgaW4gdGhlIHNhbWUgcmVuZGVyIHRyZWUgXCIgK1xuICAgICAgICAgIFwiLSB0aGlzIHdpbGwgbGlrZWx5IGNhdXNlIHJlbmRlciBlcnJvcnMuXCIsXG4gICAgICAgICAgdGhpc1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgc2xvdE5vZGVzLl9yZW5kZXJlZCA9IHRydWU7XG4gICAgfVxuICAgIG5vZGVzID0gc2xvdE5vZGVzIHx8IGZhbGxiYWNrO1xuICB9XG5cbiAgdmFyIHRhcmdldCA9IHByb3BzICYmIHByb3BzLnNsb3Q7XG4gIGlmICh0YXJnZXQpIHtcbiAgICByZXR1cm4gdGhpcy4kY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnLCB7IHNsb3Q6IHRhcmdldCB9LCBub2RlcylcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbm9kZXNcbiAgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVzb2x2aW5nIGZpbHRlcnNcbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZUZpbHRlciAoaWQpIHtcbiAgcmV0dXJuIHJlc29sdmVBc3NldCh0aGlzLiRvcHRpb25zLCAnZmlsdGVycycsIGlkLCB0cnVlKSB8fCBpZGVudGl0eVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaXNLZXlOb3RNYXRjaCAoZXhwZWN0LCBhY3R1YWwpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoZXhwZWN0KSkge1xuICAgIHJldHVybiBleHBlY3QuaW5kZXhPZihhY3R1YWwpID09PSAtMVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBleHBlY3QgIT09IGFjdHVhbFxuICB9XG59XG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIGNoZWNraW5nIGtleUNvZGVzIGZyb20gY29uZmlnLlxuICogZXhwb3NlZCBhcyBWdWUucHJvdG90eXBlLl9rXG4gKiBwYXNzaW5nIGluIGV2ZW50S2V5TmFtZSBhcyBsYXN0IGFyZ3VtZW50IHNlcGFyYXRlbHkgZm9yIGJhY2t3YXJkcyBjb21wYXRcbiAqL1xuZnVuY3Rpb24gY2hlY2tLZXlDb2RlcyAoXG4gIGV2ZW50S2V5Q29kZSxcbiAga2V5LFxuICBidWlsdEluS2V5Q29kZSxcbiAgZXZlbnRLZXlOYW1lLFxuICBidWlsdEluS2V5TmFtZVxuKSB7XG4gIHZhciBtYXBwZWRLZXlDb2RlID0gY29uZmlnLmtleUNvZGVzW2tleV0gfHwgYnVpbHRJbktleUNvZGU7XG4gIGlmIChidWlsdEluS2V5TmFtZSAmJiBldmVudEtleU5hbWUgJiYgIWNvbmZpZy5rZXlDb2Rlc1trZXldKSB7XG4gICAgcmV0dXJuIGlzS2V5Tm90TWF0Y2goYnVpbHRJbktleU5hbWUsIGV2ZW50S2V5TmFtZSlcbiAgfSBlbHNlIGlmIChtYXBwZWRLZXlDb2RlKSB7XG4gICAgcmV0dXJuIGlzS2V5Tm90TWF0Y2gobWFwcGVkS2V5Q29kZSwgZXZlbnRLZXlDb2RlKVxuICB9IGVsc2UgaWYgKGV2ZW50S2V5TmFtZSkge1xuICAgIHJldHVybiBoeXBoZW5hdGUoZXZlbnRLZXlOYW1lKSAhPT0ga2V5XG4gIH1cbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIG1lcmdpbmcgdi1iaW5kPVwib2JqZWN0XCIgaW50byBhIFZOb2RlJ3MgZGF0YS5cbiAqL1xuZnVuY3Rpb24gYmluZE9iamVjdFByb3BzIChcbiAgZGF0YSxcbiAgdGFnLFxuICB2YWx1ZSxcbiAgYXNQcm9wLFxuICBpc1N5bmNcbikge1xuICBpZiAodmFsdWUpIHtcbiAgICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICAndi1iaW5kIHdpdGhvdXQgYXJndW1lbnQgZXhwZWN0cyBhbiBPYmplY3Qgb3IgQXJyYXkgdmFsdWUnLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUgPSB0b09iamVjdCh2YWx1ZSk7XG4gICAgICB9XG4gICAgICB2YXIgaGFzaDtcbiAgICAgIHZhciBsb29wID0gZnVuY3Rpb24gKCBrZXkgKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBrZXkgPT09ICdjbGFzcycgfHxcbiAgICAgICAgICBrZXkgPT09ICdzdHlsZScgfHxcbiAgICAgICAgICBpc1Jlc2VydmVkQXR0cmlidXRlKGtleSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgaGFzaCA9IGRhdGE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHR5cGUgPSBkYXRhLmF0dHJzICYmIGRhdGEuYXR0cnMudHlwZTtcbiAgICAgICAgICBoYXNoID0gYXNQcm9wIHx8IGNvbmZpZy5tdXN0VXNlUHJvcCh0YWcsIHR5cGUsIGtleSlcbiAgICAgICAgICAgID8gZGF0YS5kb21Qcm9wcyB8fCAoZGF0YS5kb21Qcm9wcyA9IHt9KVxuICAgICAgICAgICAgOiBkYXRhLmF0dHJzIHx8IChkYXRhLmF0dHJzID0ge30pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKGtleSBpbiBoYXNoKSkge1xuICAgICAgICAgIGhhc2hba2V5XSA9IHZhbHVlW2tleV07XG5cbiAgICAgICAgICBpZiAoaXNTeW5jKSB7XG4gICAgICAgICAgICB2YXIgb24gPSBkYXRhLm9uIHx8IChkYXRhLm9uID0ge30pO1xuICAgICAgICAgICAgb25bKFwidXBkYXRlOlwiICsga2V5KV0gPSBmdW5jdGlvbiAoJGV2ZW50KSB7XG4gICAgICAgICAgICAgIHZhbHVlW2tleV0gPSAkZXZlbnQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgZm9yICh2YXIga2V5IGluIHZhbHVlKSBsb29wKCBrZXkgKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlbmRlcmluZyBzdGF0aWMgdHJlZXMuXG4gKi9cbmZ1bmN0aW9uIHJlbmRlclN0YXRpYyAoXG4gIGluZGV4LFxuICBpc0luRm9yXG4pIHtcbiAgdmFyIGNhY2hlZCA9IHRoaXMuX3N0YXRpY1RyZWVzIHx8ICh0aGlzLl9zdGF0aWNUcmVlcyA9IFtdKTtcbiAgdmFyIHRyZWUgPSBjYWNoZWRbaW5kZXhdO1xuICAvLyBpZiBoYXMgYWxyZWFkeS1yZW5kZXJlZCBzdGF0aWMgdHJlZSBhbmQgbm90IGluc2lkZSB2LWZvcixcbiAgLy8gd2UgY2FuIHJldXNlIHRoZSBzYW1lIHRyZWUuXG4gIGlmICh0cmVlICYmICFpc0luRm9yKSB7XG4gICAgcmV0dXJuIHRyZWVcbiAgfVxuICAvLyBvdGhlcndpc2UsIHJlbmRlciBhIGZyZXNoIHRyZWUuXG4gIHRyZWUgPSBjYWNoZWRbaW5kZXhdID0gdGhpcy4kb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnNbaW5kZXhdLmNhbGwoXG4gICAgdGhpcy5fcmVuZGVyUHJveHksXG4gICAgbnVsbCxcbiAgICB0aGlzIC8vIGZvciByZW5kZXIgZm5zIGdlbmVyYXRlZCBmb3IgZnVuY3Rpb25hbCBjb21wb25lbnQgdGVtcGxhdGVzXG4gICk7XG4gIG1hcmtTdGF0aWModHJlZSwgKFwiX19zdGF0aWNfX1wiICsgaW5kZXgpLCBmYWxzZSk7XG4gIHJldHVybiB0cmVlXG59XG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHYtb25jZS5cbiAqIEVmZmVjdGl2ZWx5IGl0IG1lYW5zIG1hcmtpbmcgdGhlIG5vZGUgYXMgc3RhdGljIHdpdGggYSB1bmlxdWUga2V5LlxuICovXG5mdW5jdGlvbiBtYXJrT25jZSAoXG4gIHRyZWUsXG4gIGluZGV4LFxuICBrZXlcbikge1xuICBtYXJrU3RhdGljKHRyZWUsIChcIl9fb25jZV9fXCIgKyBpbmRleCArIChrZXkgPyAoXCJfXCIgKyBrZXkpIDogXCJcIikpLCB0cnVlKTtcbiAgcmV0dXJuIHRyZWVcbn1cblxuZnVuY3Rpb24gbWFya1N0YXRpYyAoXG4gIHRyZWUsXG4gIGtleSxcbiAgaXNPbmNlXG4pIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodHJlZSkpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyZWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0cmVlW2ldICYmIHR5cGVvZiB0cmVlW2ldICE9PSAnc3RyaW5nJykge1xuICAgICAgICBtYXJrU3RhdGljTm9kZSh0cmVlW2ldLCAoa2V5ICsgXCJfXCIgKyBpKSwgaXNPbmNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbWFya1N0YXRpY05vZGUodHJlZSwga2V5LCBpc09uY2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1hcmtTdGF0aWNOb2RlIChub2RlLCBrZXksIGlzT25jZSkge1xuICBub2RlLmlzU3RhdGljID0gdHJ1ZTtcbiAgbm9kZS5rZXkgPSBrZXk7XG4gIG5vZGUuaXNPbmNlID0gaXNPbmNlO1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gYmluZE9iamVjdExpc3RlbmVycyAoZGF0YSwgdmFsdWUpIHtcbiAgaWYgKHZhbHVlKSB7XG4gICAgaWYgKCFpc1BsYWluT2JqZWN0KHZhbHVlKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICAndi1vbiB3aXRob3V0IGFyZ3VtZW50IGV4cGVjdHMgYW4gT2JqZWN0IHZhbHVlJyxcbiAgICAgICAgdGhpc1xuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG9uID0gZGF0YS5vbiA9IGRhdGEub24gPyBleHRlbmQoe30sIGRhdGEub24pIDoge307XG4gICAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICAgICAgdmFyIGV4aXN0aW5nID0gb25ba2V5XTtcbiAgICAgICAgdmFyIG91cnMgPSB2YWx1ZVtrZXldO1xuICAgICAgICBvbltrZXldID0gZXhpc3RpbmcgPyBbXS5jb25jYXQoZXhpc3RpbmcsIG91cnMpIDogb3VycztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluc3RhbGxSZW5kZXJIZWxwZXJzICh0YXJnZXQpIHtcbiAgdGFyZ2V0Ll9vID0gbWFya09uY2U7XG4gIHRhcmdldC5fbiA9IHRvTnVtYmVyO1xuICB0YXJnZXQuX3MgPSB0b1N0cmluZztcbiAgdGFyZ2V0Ll9sID0gcmVuZGVyTGlzdDtcbiAgdGFyZ2V0Ll90ID0gcmVuZGVyU2xvdDtcbiAgdGFyZ2V0Ll9xID0gbG9vc2VFcXVhbDtcbiAgdGFyZ2V0Ll9pID0gbG9vc2VJbmRleE9mO1xuICB0YXJnZXQuX20gPSByZW5kZXJTdGF0aWM7XG4gIHRhcmdldC5fZiA9IHJlc29sdmVGaWx0ZXI7XG4gIHRhcmdldC5fayA9IGNoZWNrS2V5Q29kZXM7XG4gIHRhcmdldC5fYiA9IGJpbmRPYmplY3RQcm9wcztcbiAgdGFyZ2V0Ll92ID0gY3JlYXRlVGV4dFZOb2RlO1xuICB0YXJnZXQuX2UgPSBjcmVhdGVFbXB0eVZOb2RlO1xuICB0YXJnZXQuX3UgPSByZXNvbHZlU2NvcGVkU2xvdHM7XG4gIHRhcmdldC5fZyA9IGJpbmRPYmplY3RMaXN0ZW5lcnM7XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBGdW5jdGlvbmFsUmVuZGVyQ29udGV4dCAoXG4gIGRhdGEsXG4gIHByb3BzLFxuICBjaGlsZHJlbixcbiAgcGFyZW50LFxuICBDdG9yXG4pIHtcbiAgdmFyIG9wdGlvbnMgPSBDdG9yLm9wdGlvbnM7XG4gIC8vIGVuc3VyZSB0aGUgY3JlYXRlRWxlbWVudCBmdW5jdGlvbiBpbiBmdW5jdGlvbmFsIGNvbXBvbmVudHNcbiAgLy8gZ2V0cyBhIHVuaXF1ZSBjb250ZXh0IC0gdGhpcyBpcyBuZWNlc3NhcnkgZm9yIGNvcnJlY3QgbmFtZWQgc2xvdCBjaGVja1xuICB2YXIgY29udGV4dFZtO1xuICBpZiAoaGFzT3duKHBhcmVudCwgJ191aWQnKSkge1xuICAgIGNvbnRleHRWbSA9IE9iamVjdC5jcmVhdGUocGFyZW50KTtcbiAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICBjb250ZXh0Vm0uX29yaWdpbmFsID0gcGFyZW50O1xuICB9IGVsc2Uge1xuICAgIC8vIHRoZSBjb250ZXh0IHZtIHBhc3NlZCBpbiBpcyBhIGZ1bmN0aW9uYWwgY29udGV4dCBhcyB3ZWxsLlxuICAgIC8vIGluIHRoaXMgY2FzZSB3ZSB3YW50IHRvIG1ha2Ugc3VyZSB3ZSBhcmUgYWJsZSB0byBnZXQgYSBob2xkIHRvIHRoZVxuICAgIC8vIHJlYWwgY29udGV4dCBpbnN0YW5jZS5cbiAgICBjb250ZXh0Vm0gPSBwYXJlbnQ7XG4gICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgcGFyZW50ID0gcGFyZW50Ll9vcmlnaW5hbDtcbiAgfVxuICB2YXIgaXNDb21waWxlZCA9IGlzVHJ1ZShvcHRpb25zLl9jb21waWxlZCk7XG4gIHZhciBuZWVkTm9ybWFsaXphdGlvbiA9ICFpc0NvbXBpbGVkO1xuXG4gIHRoaXMuZGF0YSA9IGRhdGE7XG4gIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgdGhpcy5saXN0ZW5lcnMgPSBkYXRhLm9uIHx8IGVtcHR5T2JqZWN0O1xuICB0aGlzLmluamVjdGlvbnMgPSByZXNvbHZlSW5qZWN0KG9wdGlvbnMuaW5qZWN0LCBwYXJlbnQpO1xuICB0aGlzLnNsb3RzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVzb2x2ZVNsb3RzKGNoaWxkcmVuLCBwYXJlbnQpOyB9O1xuXG4gIC8vIHN1cHBvcnQgZm9yIGNvbXBpbGVkIGZ1bmN0aW9uYWwgdGVtcGxhdGVcbiAgaWYgKGlzQ29tcGlsZWQpIHtcbiAgICAvLyBleHBvc2luZyAkb3B0aW9ucyBmb3IgcmVuZGVyU3RhdGljKClcbiAgICB0aGlzLiRvcHRpb25zID0gb3B0aW9ucztcbiAgICAvLyBwcmUtcmVzb2x2ZSBzbG90cyBmb3IgcmVuZGVyU2xvdCgpXG4gICAgdGhpcy4kc2xvdHMgPSB0aGlzLnNsb3RzKCk7XG4gICAgdGhpcy4kc2NvcGVkU2xvdHMgPSBkYXRhLnNjb3BlZFNsb3RzIHx8IGVtcHR5T2JqZWN0O1xuICB9XG5cbiAgaWYgKG9wdGlvbnMuX3Njb3BlSWQpIHtcbiAgICB0aGlzLl9jID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHtcbiAgICAgIHZhciB2bm9kZSA9IGNyZWF0ZUVsZW1lbnQoY29udGV4dFZtLCBhLCBiLCBjLCBkLCBuZWVkTm9ybWFsaXphdGlvbik7XG4gICAgICBpZiAodm5vZGUgJiYgIUFycmF5LmlzQXJyYXkodm5vZGUpKSB7XG4gICAgICAgIHZub2RlLmZuU2NvcGVJZCA9IG9wdGlvbnMuX3Njb3BlSWQ7XG4gICAgICAgIHZub2RlLmZuQ29udGV4dCA9IHBhcmVudDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2bm9kZVxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fYyA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7IHJldHVybiBjcmVhdGVFbGVtZW50KGNvbnRleHRWbSwgYSwgYiwgYywgZCwgbmVlZE5vcm1hbGl6YXRpb24pOyB9O1xuICB9XG59XG5cbmluc3RhbGxSZW5kZXJIZWxwZXJzKEZ1bmN0aW9uYWxSZW5kZXJDb250ZXh0LnByb3RvdHlwZSk7XG5cbmZ1bmN0aW9uIGNyZWF0ZUZ1bmN0aW9uYWxDb21wb25lbnQgKFxuICBDdG9yLFxuICBwcm9wc0RhdGEsXG4gIGRhdGEsXG4gIGNvbnRleHRWbSxcbiAgY2hpbGRyZW5cbikge1xuICB2YXIgb3B0aW9ucyA9IEN0b3Iub3B0aW9ucztcbiAgdmFyIHByb3BzID0ge307XG4gIHZhciBwcm9wT3B0aW9ucyA9IG9wdGlvbnMucHJvcHM7XG4gIGlmIChpc0RlZihwcm9wT3B0aW9ucykpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcE9wdGlvbnMpIHtcbiAgICAgIHByb3BzW2tleV0gPSB2YWxpZGF0ZVByb3Aoa2V5LCBwcm9wT3B0aW9ucywgcHJvcHNEYXRhIHx8IGVtcHR5T2JqZWN0KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGlzRGVmKGRhdGEuYXR0cnMpKSB7IG1lcmdlUHJvcHMocHJvcHMsIGRhdGEuYXR0cnMpOyB9XG4gICAgaWYgKGlzRGVmKGRhdGEucHJvcHMpKSB7IG1lcmdlUHJvcHMocHJvcHMsIGRhdGEucHJvcHMpOyB9XG4gIH1cblxuICB2YXIgcmVuZGVyQ29udGV4dCA9IG5ldyBGdW5jdGlvbmFsUmVuZGVyQ29udGV4dChcbiAgICBkYXRhLFxuICAgIHByb3BzLFxuICAgIGNoaWxkcmVuLFxuICAgIGNvbnRleHRWbSxcbiAgICBDdG9yXG4gICk7XG5cbiAgdmFyIHZub2RlID0gb3B0aW9ucy5yZW5kZXIuY2FsbChudWxsLCByZW5kZXJDb250ZXh0Ll9jLCByZW5kZXJDb250ZXh0KTtcblxuICBpZiAodm5vZGUgaW5zdGFuY2VvZiBWTm9kZSkge1xuICAgIHJldHVybiBjbG9uZUFuZE1hcmtGdW5jdGlvbmFsUmVzdWx0KHZub2RlLCBkYXRhLCByZW5kZXJDb250ZXh0LnBhcmVudCwgb3B0aW9ucylcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZub2RlKSkge1xuICAgIHZhciB2bm9kZXMgPSBub3JtYWxpemVDaGlsZHJlbih2bm9kZSkgfHwgW107XG4gICAgdmFyIHJlcyA9IG5ldyBBcnJheSh2bm9kZXMubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgcmVzW2ldID0gY2xvbmVBbmRNYXJrRnVuY3Rpb25hbFJlc3VsdCh2bm9kZXNbaV0sIGRhdGEsIHJlbmRlckNvbnRleHQucGFyZW50LCBvcHRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc1xuICB9XG59XG5cbmZ1bmN0aW9uIGNsb25lQW5kTWFya0Z1bmN0aW9uYWxSZXN1bHQgKHZub2RlLCBkYXRhLCBjb250ZXh0Vm0sIG9wdGlvbnMpIHtcbiAgLy8gIzc4MTcgY2xvbmUgbm9kZSBiZWZvcmUgc2V0dGluZyBmbkNvbnRleHQsIG90aGVyd2lzZSBpZiB0aGUgbm9kZSBpcyByZXVzZWRcbiAgLy8gKGUuZy4gaXQgd2FzIGZyb20gYSBjYWNoZWQgbm9ybWFsIHNsb3QpIHRoZSBmbkNvbnRleHQgY2F1c2VzIG5hbWVkIHNsb3RzXG4gIC8vIHRoYXQgc2hvdWxkIG5vdCBiZSBtYXRjaGVkIHRvIG1hdGNoLlxuICB2YXIgY2xvbmUgPSBjbG9uZVZOb2RlKHZub2RlKTtcbiAgY2xvbmUuZm5Db250ZXh0ID0gY29udGV4dFZtO1xuICBjbG9uZS5mbk9wdGlvbnMgPSBvcHRpb25zO1xuICBpZiAoZGF0YS5zbG90KSB7XG4gICAgKGNsb25lLmRhdGEgfHwgKGNsb25lLmRhdGEgPSB7fSkpLnNsb3QgPSBkYXRhLnNsb3Q7XG4gIH1cbiAgcmV0dXJuIGNsb25lXG59XG5cbmZ1bmN0aW9uIG1lcmdlUHJvcHMgKHRvLCBmcm9tKSB7XG4gIGZvciAodmFyIGtleSBpbiBmcm9tKSB7XG4gICAgdG9bY2FtZWxpemUoa2V5KV0gPSBmcm9tW2tleV07XG4gIH1cbn1cblxuLyogICovXG5cblxuXG5cbi8vIFJlZ2lzdGVyIHRoZSBjb21wb25lbnQgaG9vayB0byB3ZWV4IG5hdGl2ZSByZW5kZXIgZW5naW5lLlxuLy8gVGhlIGhvb2sgd2lsbCBiZSB0cmlnZ2VyZWQgYnkgbmF0aXZlLCBub3QgamF2YXNjcmlwdC5cblxuXG4vLyBVcGRhdGVzIHRoZSBzdGF0ZSBvZiB0aGUgY29tcG9uZW50IHRvIHdlZXggbmF0aXZlIHJlbmRlciBlbmdpbmUuXG5cbi8qICAqL1xuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vSGFua3MxMDEwMC93ZWV4LW5hdGl2ZS1kaXJlY3RpdmUvdHJlZS9tYXN0ZXIvY29tcG9uZW50XG5cbi8vIGxpc3RlbmluZyBvbiBuYXRpdmUgY2FsbGJhY2tcblxuLyogICovXG5cbi8qICAqL1xuXG4vLyBpbmxpbmUgaG9va3MgdG8gYmUgaW52b2tlZCBvbiBjb21wb25lbnQgVk5vZGVzIGR1cmluZyBwYXRjaFxudmFyIGNvbXBvbmVudFZOb2RlSG9va3MgPSB7XG4gIGluaXQ6IGZ1bmN0aW9uIGluaXQgKFxuICAgIHZub2RlLFxuICAgIGh5ZHJhdGluZyxcbiAgICBwYXJlbnRFbG0sXG4gICAgcmVmRWxtXG4gICkge1xuICAgIGlmIChcbiAgICAgIHZub2RlLmNvbXBvbmVudEluc3RhbmNlICYmXG4gICAgICAhdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuX2lzRGVzdHJveWVkICYmXG4gICAgICB2bm9kZS5kYXRhLmtlZXBBbGl2ZVxuICAgICkge1xuICAgICAgLy8ga2VwdC1hbGl2ZSBjb21wb25lbnRzLCB0cmVhdCBhcyBhIHBhdGNoXG4gICAgICB2YXIgbW91bnRlZE5vZGUgPSB2bm9kZTsgLy8gd29yayBhcm91bmQgZmxvd1xuICAgICAgY29tcG9uZW50Vk5vZGVIb29rcy5wcmVwYXRjaChtb3VudGVkTm9kZSwgbW91bnRlZE5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgY2hpbGQgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IGNyZWF0ZUNvbXBvbmVudEluc3RhbmNlRm9yVm5vZGUoXG4gICAgICAgIHZub2RlLFxuICAgICAgICBhY3RpdmVJbnN0YW5jZSxcbiAgICAgICAgcGFyZW50RWxtLFxuICAgICAgICByZWZFbG1cbiAgICAgICk7XG4gICAgICBjaGlsZC4kbW91bnQoaHlkcmF0aW5nID8gdm5vZGUuZWxtIDogdW5kZWZpbmVkLCBoeWRyYXRpbmcpO1xuICAgIH1cbiAgfSxcblxuICBwcmVwYXRjaDogZnVuY3Rpb24gcHJlcGF0Y2ggKG9sZFZub2RlLCB2bm9kZSkge1xuICAgIHZhciBvcHRpb25zID0gdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgICB2YXIgY2hpbGQgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IG9sZFZub2RlLmNvbXBvbmVudEluc3RhbmNlO1xuICAgIHVwZGF0ZUNoaWxkQ29tcG9uZW50KFxuICAgICAgY2hpbGQsXG4gICAgICBvcHRpb25zLnByb3BzRGF0YSwgLy8gdXBkYXRlZCBwcm9wc1xuICAgICAgb3B0aW9ucy5saXN0ZW5lcnMsIC8vIHVwZGF0ZWQgbGlzdGVuZXJzXG4gICAgICB2bm9kZSwgLy8gbmV3IHBhcmVudCB2bm9kZVxuICAgICAgb3B0aW9ucy5jaGlsZHJlbiAvLyBuZXcgY2hpbGRyZW5cbiAgICApO1xuICB9LFxuXG4gIGluc2VydDogZnVuY3Rpb24gaW5zZXJ0ICh2bm9kZSkge1xuICAgIHZhciBjb250ZXh0ID0gdm5vZGUuY29udGV4dDtcbiAgICB2YXIgY29tcG9uZW50SW5zdGFuY2UgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICBpZiAoIWNvbXBvbmVudEluc3RhbmNlLl9pc01vdW50ZWQpIHtcbiAgICAgIGNvbXBvbmVudEluc3RhbmNlLl9pc01vdW50ZWQgPSB0cnVlO1xuICAgICAgY2FsbEhvb2soY29tcG9uZW50SW5zdGFuY2UsICdtb3VudGVkJyk7XG4gICAgfVxuICAgIGlmICh2bm9kZS5kYXRhLmtlZXBBbGl2ZSkge1xuICAgICAgaWYgKGNvbnRleHQuX2lzTW91bnRlZCkge1xuICAgICAgICAvLyB2dWUtcm91dGVyIzEyMTJcbiAgICAgICAgLy8gRHVyaW5nIHVwZGF0ZXMsIGEga2VwdC1hbGl2ZSBjb21wb25lbnQncyBjaGlsZCBjb21wb25lbnRzIG1heVxuICAgICAgICAvLyBjaGFuZ2UsIHNvIGRpcmVjdGx5IHdhbGtpbmcgdGhlIHRyZWUgaGVyZSBtYXkgY2FsbCBhY3RpdmF0ZWQgaG9va3NcbiAgICAgICAgLy8gb24gaW5jb3JyZWN0IGNoaWxkcmVuLiBJbnN0ZWFkIHdlIHB1c2ggdGhlbSBpbnRvIGEgcXVldWUgd2hpY2ggd2lsbFxuICAgICAgICAvLyBiZSBwcm9jZXNzZWQgYWZ0ZXIgdGhlIHdob2xlIHBhdGNoIHByb2Nlc3MgZW5kZWQuXG4gICAgICAgIHF1ZXVlQWN0aXZhdGVkQ29tcG9uZW50KGNvbXBvbmVudEluc3RhbmNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFjdGl2YXRlQ2hpbGRDb21wb25lbnQoY29tcG9uZW50SW5zdGFuY2UsIHRydWUgLyogZGlyZWN0ICovKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSAodm5vZGUpIHtcbiAgICB2YXIgY29tcG9uZW50SW5zdGFuY2UgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICBpZiAoIWNvbXBvbmVudEluc3RhbmNlLl9pc0Rlc3Ryb3llZCkge1xuICAgICAgaWYgKCF2bm9kZS5kYXRhLmtlZXBBbGl2ZSkge1xuICAgICAgICBjb21wb25lbnRJbnN0YW5jZS4kZGVzdHJveSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KGNvbXBvbmVudEluc3RhbmNlLCB0cnVlIC8qIGRpcmVjdCAqLyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG52YXIgaG9va3NUb01lcmdlID0gT2JqZWN0LmtleXMoY29tcG9uZW50Vk5vZGVIb29rcyk7XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudCAoXG4gIEN0b3IsXG4gIGRhdGEsXG4gIGNvbnRleHQsXG4gIGNoaWxkcmVuLFxuICB0YWdcbikge1xuICBpZiAoaXNVbmRlZihDdG9yKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIGJhc2VDdG9yID0gY29udGV4dC4kb3B0aW9ucy5fYmFzZTtcblxuICAvLyBwbGFpbiBvcHRpb25zIG9iamVjdDogdHVybiBpdCBpbnRvIGEgY29uc3RydWN0b3JcbiAgaWYgKGlzT2JqZWN0KEN0b3IpKSB7XG4gICAgQ3RvciA9IGJhc2VDdG9yLmV4dGVuZChDdG9yKTtcbiAgfVxuXG4gIC8vIGlmIGF0IHRoaXMgc3RhZ2UgaXQncyBub3QgYSBjb25zdHJ1Y3RvciBvciBhbiBhc3luYyBjb21wb25lbnQgZmFjdG9yeSxcbiAgLy8gcmVqZWN0LlxuICBpZiAodHlwZW9mIEN0b3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgd2FybigoXCJJbnZhbGlkIENvbXBvbmVudCBkZWZpbml0aW9uOiBcIiArIChTdHJpbmcoQ3RvcikpKSwgY29udGV4dCk7XG4gICAgfVxuICAgIHJldHVyblxuICB9XG5cbiAgLy8gYXN5bmMgY29tcG9uZW50XG4gIHZhciBhc3luY0ZhY3Rvcnk7XG4gIGlmIChpc1VuZGVmKEN0b3IuY2lkKSkge1xuICAgIGFzeW5jRmFjdG9yeSA9IEN0b3I7XG4gICAgQ3RvciA9IHJlc29sdmVBc3luY0NvbXBvbmVudChhc3luY0ZhY3RvcnksIGJhc2VDdG9yLCBjb250ZXh0KTtcbiAgICBpZiAoQ3RvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyByZXR1cm4gYSBwbGFjZWhvbGRlciBub2RlIGZvciBhc3luYyBjb21wb25lbnQsIHdoaWNoIGlzIHJlbmRlcmVkXG4gICAgICAvLyBhcyBhIGNvbW1lbnQgbm9kZSBidXQgcHJlc2VydmVzIGFsbCB0aGUgcmF3IGluZm9ybWF0aW9uIGZvciB0aGUgbm9kZS5cbiAgICAgIC8vIHRoZSBpbmZvcm1hdGlvbiB3aWxsIGJlIHVzZWQgZm9yIGFzeW5jIHNlcnZlci1yZW5kZXJpbmcgYW5kIGh5ZHJhdGlvbi5cbiAgICAgIHJldHVybiBjcmVhdGVBc3luY1BsYWNlaG9sZGVyKFxuICAgICAgICBhc3luY0ZhY3RvcnksXG4gICAgICAgIGRhdGEsXG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGNoaWxkcmVuLFxuICAgICAgICB0YWdcbiAgICAgIClcbiAgICB9XG4gIH1cblxuICBkYXRhID0gZGF0YSB8fCB7fTtcblxuICAvLyByZXNvbHZlIGNvbnN0cnVjdG9yIG9wdGlvbnMgaW4gY2FzZSBnbG9iYWwgbWl4aW5zIGFyZSBhcHBsaWVkIGFmdGVyXG4gIC8vIGNvbXBvbmVudCBjb25zdHJ1Y3RvciBjcmVhdGlvblxuICByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zKEN0b3IpO1xuXG4gIC8vIHRyYW5zZm9ybSBjb21wb25lbnQgdi1tb2RlbCBkYXRhIGludG8gcHJvcHMgJiBldmVudHNcbiAgaWYgKGlzRGVmKGRhdGEubW9kZWwpKSB7XG4gICAgdHJhbnNmb3JtTW9kZWwoQ3Rvci5vcHRpb25zLCBkYXRhKTtcbiAgfVxuXG4gIC8vIGV4dHJhY3QgcHJvcHNcbiAgdmFyIHByb3BzRGF0YSA9IGV4dHJhY3RQcm9wc0Zyb21WTm9kZURhdGEoZGF0YSwgQ3RvciwgdGFnKTtcblxuICAvLyBmdW5jdGlvbmFsIGNvbXBvbmVudFxuICBpZiAoaXNUcnVlKEN0b3Iub3B0aW9ucy5mdW5jdGlvbmFsKSkge1xuICAgIHJldHVybiBjcmVhdGVGdW5jdGlvbmFsQ29tcG9uZW50KEN0b3IsIHByb3BzRGF0YSwgZGF0YSwgY29udGV4dCwgY2hpbGRyZW4pXG4gIH1cblxuICAvLyBleHRyYWN0IGxpc3RlbmVycywgc2luY2UgdGhlc2UgbmVlZHMgdG8gYmUgdHJlYXRlZCBhc1xuICAvLyBjaGlsZCBjb21wb25lbnQgbGlzdGVuZXJzIGluc3RlYWQgb2YgRE9NIGxpc3RlbmVyc1xuICB2YXIgbGlzdGVuZXJzID0gZGF0YS5vbjtcbiAgLy8gcmVwbGFjZSB3aXRoIGxpc3RlbmVycyB3aXRoIC5uYXRpdmUgbW9kaWZpZXJcbiAgLy8gc28gaXQgZ2V0cyBwcm9jZXNzZWQgZHVyaW5nIHBhcmVudCBjb21wb25lbnQgcGF0Y2guXG4gIGRhdGEub24gPSBkYXRhLm5hdGl2ZU9uO1xuXG4gIGlmIChpc1RydWUoQ3Rvci5vcHRpb25zLmFic3RyYWN0KSkge1xuICAgIC8vIGFic3RyYWN0IGNvbXBvbmVudHMgZG8gbm90IGtlZXAgYW55dGhpbmdcbiAgICAvLyBvdGhlciB0aGFuIHByb3BzICYgbGlzdGVuZXJzICYgc2xvdFxuXG4gICAgLy8gd29yayBhcm91bmQgZmxvd1xuICAgIHZhciBzbG90ID0gZGF0YS5zbG90O1xuICAgIGRhdGEgPSB7fTtcbiAgICBpZiAoc2xvdCkge1xuICAgICAgZGF0YS5zbG90ID0gc2xvdDtcbiAgICB9XG4gIH1cblxuICAvLyBpbnN0YWxsIGNvbXBvbmVudCBtYW5hZ2VtZW50IGhvb2tzIG9udG8gdGhlIHBsYWNlaG9sZGVyIG5vZGVcbiAgaW5zdGFsbENvbXBvbmVudEhvb2tzKGRhdGEpO1xuXG4gIC8vIHJldHVybiBhIHBsYWNlaG9sZGVyIHZub2RlXG4gIHZhciBuYW1lID0gQ3Rvci5vcHRpb25zLm5hbWUgfHwgdGFnO1xuICB2YXIgdm5vZGUgPSBuZXcgVk5vZGUoXG4gICAgKFwidnVlLWNvbXBvbmVudC1cIiArIChDdG9yLmNpZCkgKyAobmFtZSA/IChcIi1cIiArIG5hbWUpIDogJycpKSxcbiAgICBkYXRhLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb250ZXh0LFxuICAgIHsgQ3RvcjogQ3RvciwgcHJvcHNEYXRhOiBwcm9wc0RhdGEsIGxpc3RlbmVyczogbGlzdGVuZXJzLCB0YWc6IHRhZywgY2hpbGRyZW46IGNoaWxkcmVuIH0sXG4gICAgYXN5bmNGYWN0b3J5XG4gICk7XG5cbiAgLy8gV2VleCBzcGVjaWZpYzogaW52b2tlIHJlY3ljbGUtbGlzdCBvcHRpbWl6ZWQgQHJlbmRlciBmdW5jdGlvbiBmb3JcbiAgLy8gZXh0cmFjdGluZyBjZWxsLXNsb3QgdGVtcGxhdGUuXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9IYW5rczEwMTAwL3dlZXgtbmF0aXZlLWRpcmVjdGl2ZS90cmVlL21hc3Rlci9jb21wb25lbnRcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIHJldHVybiB2bm9kZVxufVxuXG5mdW5jdGlvbiBjcmVhdGVDb21wb25lbnRJbnN0YW5jZUZvclZub2RlIChcbiAgdm5vZGUsIC8vIHdlIGtub3cgaXQncyBNb3VudGVkQ29tcG9uZW50Vk5vZGUgYnV0IGZsb3cgZG9lc24ndFxuICBwYXJlbnQsIC8vIGFjdGl2ZUluc3RhbmNlIGluIGxpZmVjeWNsZSBzdGF0ZVxuICBwYXJlbnRFbG0sXG4gIHJlZkVsbVxuKSB7XG4gIHZhciBvcHRpb25zID0ge1xuICAgIF9pc0NvbXBvbmVudDogdHJ1ZSxcbiAgICBwYXJlbnQ6IHBhcmVudCxcbiAgICBfcGFyZW50Vm5vZGU6IHZub2RlLFxuICAgIF9wYXJlbnRFbG06IHBhcmVudEVsbSB8fCBudWxsLFxuICAgIF9yZWZFbG06IHJlZkVsbSB8fCBudWxsXG4gIH07XG4gIC8vIGNoZWNrIGlubGluZS10ZW1wbGF0ZSByZW5kZXIgZnVuY3Rpb25zXG4gIHZhciBpbmxpbmVUZW1wbGF0ZSA9IHZub2RlLmRhdGEuaW5saW5lVGVtcGxhdGU7XG4gIGlmIChpc0RlZihpbmxpbmVUZW1wbGF0ZSkpIHtcbiAgICBvcHRpb25zLnJlbmRlciA9IGlubGluZVRlbXBsYXRlLnJlbmRlcjtcbiAgICBvcHRpb25zLnN0YXRpY1JlbmRlckZucyA9IGlubGluZVRlbXBsYXRlLnN0YXRpY1JlbmRlckZucztcbiAgfVxuICByZXR1cm4gbmV3IHZub2RlLmNvbXBvbmVudE9wdGlvbnMuQ3RvcihvcHRpb25zKVxufVxuXG5mdW5jdGlvbiBpbnN0YWxsQ29tcG9uZW50SG9va3MgKGRhdGEpIHtcbiAgdmFyIGhvb2tzID0gZGF0YS5ob29rIHx8IChkYXRhLmhvb2sgPSB7fSk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaG9va3NUb01lcmdlLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGhvb2tzVG9NZXJnZVtpXTtcbiAgICBob29rc1trZXldID0gY29tcG9uZW50Vk5vZGVIb29rc1trZXldO1xuICB9XG59XG5cbi8vIHRyYW5zZm9ybSBjb21wb25lbnQgdi1tb2RlbCBpbmZvICh2YWx1ZSBhbmQgY2FsbGJhY2spIGludG9cbi8vIHByb3AgYW5kIGV2ZW50IGhhbmRsZXIgcmVzcGVjdGl2ZWx5LlxuZnVuY3Rpb24gdHJhbnNmb3JtTW9kZWwgKG9wdGlvbnMsIGRhdGEpIHtcbiAgdmFyIHByb3AgPSAob3B0aW9ucy5tb2RlbCAmJiBvcHRpb25zLm1vZGVsLnByb3ApIHx8ICd2YWx1ZSc7XG4gIHZhciBldmVudCA9IChvcHRpb25zLm1vZGVsICYmIG9wdGlvbnMubW9kZWwuZXZlbnQpIHx8ICdpbnB1dCc7KGRhdGEucHJvcHMgfHwgKGRhdGEucHJvcHMgPSB7fSkpW3Byb3BdID0gZGF0YS5tb2RlbC52YWx1ZTtcbiAgdmFyIG9uID0gZGF0YS5vbiB8fCAoZGF0YS5vbiA9IHt9KTtcbiAgaWYgKGlzRGVmKG9uW2V2ZW50XSkpIHtcbiAgICBvbltldmVudF0gPSBbZGF0YS5tb2RlbC5jYWxsYmFja10uY29uY2F0KG9uW2V2ZW50XSk7XG4gIH0gZWxzZSB7XG4gICAgb25bZXZlbnRdID0gZGF0YS5tb2RlbC5jYWxsYmFjaztcbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIFNJTVBMRV9OT1JNQUxJWkUgPSAxO1xudmFyIEFMV0FZU19OT1JNQUxJWkUgPSAyO1xuXG4vLyB3cmFwcGVyIGZ1bmN0aW9uIGZvciBwcm92aWRpbmcgYSBtb3JlIGZsZXhpYmxlIGludGVyZmFjZVxuLy8gd2l0aG91dCBnZXR0aW5nIHllbGxlZCBhdCBieSBmbG93XG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50IChcbiAgY29udGV4dCxcbiAgdGFnLFxuICBkYXRhLFxuICBjaGlsZHJlbixcbiAgbm9ybWFsaXphdGlvblR5cGUsXG4gIGFsd2F5c05vcm1hbGl6ZVxuKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGRhdGEpIHx8IGlzUHJpbWl0aXZlKGRhdGEpKSB7XG4gICAgbm9ybWFsaXphdGlvblR5cGUgPSBjaGlsZHJlbjtcbiAgICBjaGlsZHJlbiA9IGRhdGE7XG4gICAgZGF0YSA9IHVuZGVmaW5lZDtcbiAgfVxuICBpZiAoaXNUcnVlKGFsd2F5c05vcm1hbGl6ZSkpIHtcbiAgICBub3JtYWxpemF0aW9uVHlwZSA9IEFMV0FZU19OT1JNQUxJWkU7XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVFbGVtZW50KGNvbnRleHQsIHRhZywgZGF0YSwgY2hpbGRyZW4sIG5vcm1hbGl6YXRpb25UeXBlKVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlRWxlbWVudCAoXG4gIGNvbnRleHQsXG4gIHRhZyxcbiAgZGF0YSxcbiAgY2hpbGRyZW4sXG4gIG5vcm1hbGl6YXRpb25UeXBlXG4pIHtcbiAgaWYgKGlzRGVmKGRhdGEpICYmIGlzRGVmKChkYXRhKS5fX29iX18pKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgXCJBdm9pZCB1c2luZyBvYnNlcnZlZCBkYXRhIG9iamVjdCBhcyB2bm9kZSBkYXRhOiBcIiArIChKU09OLnN0cmluZ2lmeShkYXRhKSkgKyBcIlxcblwiICtcbiAgICAgICdBbHdheXMgY3JlYXRlIGZyZXNoIHZub2RlIGRhdGEgb2JqZWN0cyBpbiBlYWNoIHJlbmRlciEnLFxuICAgICAgY29udGV4dFxuICAgICk7XG4gICAgcmV0dXJuIGNyZWF0ZUVtcHR5Vk5vZGUoKVxuICB9XG4gIC8vIG9iamVjdCBzeW50YXggaW4gdi1iaW5kXG4gIGlmIChpc0RlZihkYXRhKSAmJiBpc0RlZihkYXRhLmlzKSkge1xuICAgIHRhZyA9IGRhdGEuaXM7XG4gIH1cbiAgaWYgKCF0YWcpIHtcbiAgICAvLyBpbiBjYXNlIG9mIGNvbXBvbmVudCA6aXMgc2V0IHRvIGZhbHN5IHZhbHVlXG4gICAgcmV0dXJuIGNyZWF0ZUVtcHR5Vk5vZGUoKVxuICB9XG4gIC8vIHdhcm4gYWdhaW5zdCBub24tcHJpbWl0aXZlIGtleVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgIGlzRGVmKGRhdGEpICYmIGlzRGVmKGRhdGEua2V5KSAmJiAhaXNQcmltaXRpdmUoZGF0YS5rZXkpXG4gICkge1xuICAgIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdBdm9pZCB1c2luZyBub24tcHJpbWl0aXZlIHZhbHVlIGFzIGtleSwgJyArXG4gICAgICAgICd1c2Ugc3RyaW5nL251bWJlciB2YWx1ZSBpbnN0ZWFkLicsXG4gICAgICAgIGNvbnRleHRcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIC8vIHN1cHBvcnQgc2luZ2xlIGZ1bmN0aW9uIGNoaWxkcmVuIGFzIGRlZmF1bHQgc2NvcGVkIHNsb3RcbiAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pICYmXG4gICAgdHlwZW9mIGNoaWxkcmVuWzBdID09PSAnZnVuY3Rpb24nXG4gICkge1xuICAgIGRhdGEgPSBkYXRhIHx8IHt9O1xuICAgIGRhdGEuc2NvcGVkU2xvdHMgPSB7IGRlZmF1bHQ6IGNoaWxkcmVuWzBdIH07XG4gICAgY2hpbGRyZW4ubGVuZ3RoID0gMDtcbiAgfVxuICBpZiAobm9ybWFsaXphdGlvblR5cGUgPT09IEFMV0FZU19OT1JNQUxJWkUpIHtcbiAgICBjaGlsZHJlbiA9IG5vcm1hbGl6ZUNoaWxkcmVuKGNoaWxkcmVuKTtcbiAgfSBlbHNlIGlmIChub3JtYWxpemF0aW9uVHlwZSA9PT0gU0lNUExFX05PUk1BTElaRSkge1xuICAgIGNoaWxkcmVuID0gc2ltcGxlTm9ybWFsaXplQ2hpbGRyZW4oY2hpbGRyZW4pO1xuICB9XG4gIHZhciB2bm9kZSwgbnM7XG4gIGlmICh0eXBlb2YgdGFnID09PSAnc3RyaW5nJykge1xuICAgIHZhciBDdG9yO1xuICAgIG5zID0gKGNvbnRleHQuJHZub2RlICYmIGNvbnRleHQuJHZub2RlLm5zKSB8fCBjb25maWcuZ2V0VGFnTmFtZXNwYWNlKHRhZyk7XG4gICAgaWYgKGNvbmZpZy5pc1Jlc2VydmVkVGFnKHRhZykpIHtcbiAgICAgIC8vIHBsYXRmb3JtIGJ1aWx0LWluIGVsZW1lbnRzXG4gICAgICB2bm9kZSA9IG5ldyBWTm9kZShcbiAgICAgICAgY29uZmlnLnBhcnNlUGxhdGZvcm1UYWdOYW1lKHRhZyksIGRhdGEsIGNoaWxkcmVuLFxuICAgICAgICB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY29udGV4dFxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKGlzRGVmKEN0b3IgPSByZXNvbHZlQXNzZXQoY29udGV4dC4kb3B0aW9ucywgJ2NvbXBvbmVudHMnLCB0YWcpKSkge1xuICAgICAgLy8gY29tcG9uZW50XG4gICAgICB2bm9kZSA9IGNyZWF0ZUNvbXBvbmVudChDdG9yLCBkYXRhLCBjb250ZXh0LCBjaGlsZHJlbiwgdGFnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdW5rbm93biBvciB1bmxpc3RlZCBuYW1lc3BhY2VkIGVsZW1lbnRzXG4gICAgICAvLyBjaGVjayBhdCBydW50aW1lIGJlY2F1c2UgaXQgbWF5IGdldCBhc3NpZ25lZCBhIG5hbWVzcGFjZSB3aGVuIGl0c1xuICAgICAgLy8gcGFyZW50IG5vcm1hbGl6ZXMgY2hpbGRyZW5cbiAgICAgIHZub2RlID0gbmV3IFZOb2RlKFxuICAgICAgICB0YWcsIGRhdGEsIGNoaWxkcmVuLFxuICAgICAgICB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY29udGV4dFxuICAgICAgKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gZGlyZWN0IGNvbXBvbmVudCBvcHRpb25zIC8gY29uc3RydWN0b3JcbiAgICB2bm9kZSA9IGNyZWF0ZUNvbXBvbmVudCh0YWcsIGRhdGEsIGNvbnRleHQsIGNoaWxkcmVuKTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheSh2bm9kZSkpIHtcbiAgICByZXR1cm4gdm5vZGVcbiAgfSBlbHNlIGlmIChpc0RlZih2bm9kZSkpIHtcbiAgICBpZiAoaXNEZWYobnMpKSB7IGFwcGx5TlModm5vZGUsIG5zKTsgfVxuICAgIGlmIChpc0RlZihkYXRhKSkgeyByZWdpc3RlckRlZXBCaW5kaW5ncyhkYXRhKTsgfVxuICAgIHJldHVybiB2bm9kZVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBjcmVhdGVFbXB0eVZOb2RlKClcbiAgfVxufVxuXG5mdW5jdGlvbiBhcHBseU5TICh2bm9kZSwgbnMsIGZvcmNlKSB7XG4gIHZub2RlLm5zID0gbnM7XG4gIGlmICh2bm9kZS50YWcgPT09ICdmb3JlaWduT2JqZWN0Jykge1xuICAgIC8vIHVzZSBkZWZhdWx0IG5hbWVzcGFjZSBpbnNpZGUgZm9yZWlnbk9iamVjdFxuICAgIG5zID0gdW5kZWZpbmVkO1xuICAgIGZvcmNlID0gdHJ1ZTtcbiAgfVxuICBpZiAoaXNEZWYodm5vZGUuY2hpbGRyZW4pKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSB2bm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBjaGlsZCA9IHZub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgaWYgKGlzRGVmKGNoaWxkLnRhZykgJiYgKFxuICAgICAgICBpc1VuZGVmKGNoaWxkLm5zKSB8fCAoaXNUcnVlKGZvcmNlKSAmJiBjaGlsZC50YWcgIT09ICdzdmcnKSkpIHtcbiAgICAgICAgYXBwbHlOUyhjaGlsZCwgbnMsIGZvcmNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLy8gcmVmICM1MzE4XG4vLyBuZWNlc3NhcnkgdG8gZW5zdXJlIHBhcmVudCByZS1yZW5kZXIgd2hlbiBkZWVwIGJpbmRpbmdzIGxpa2UgOnN0eWxlIGFuZFxuLy8gOmNsYXNzIGFyZSB1c2VkIG9uIHNsb3Qgbm9kZXNcbmZ1bmN0aW9uIHJlZ2lzdGVyRGVlcEJpbmRpbmdzIChkYXRhKSB7XG4gIGlmIChpc09iamVjdChkYXRhLnN0eWxlKSkge1xuICAgIHRyYXZlcnNlKGRhdGEuc3R5bGUpO1xuICB9XG4gIGlmIChpc09iamVjdChkYXRhLmNsYXNzKSkge1xuICAgIHRyYXZlcnNlKGRhdGEuY2xhc3MpO1xuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0UmVuZGVyICh2bSkge1xuICB2bS5fdm5vZGUgPSBudWxsOyAvLyB0aGUgcm9vdCBvZiB0aGUgY2hpbGQgdHJlZVxuICB2bS5fc3RhdGljVHJlZXMgPSBudWxsOyAvLyB2LW9uY2UgY2FjaGVkIHRyZWVzXG4gIHZhciBvcHRpb25zID0gdm0uJG9wdGlvbnM7XG4gIHZhciBwYXJlbnRWbm9kZSA9IHZtLiR2bm9kZSA9IG9wdGlvbnMuX3BhcmVudFZub2RlOyAvLyB0aGUgcGxhY2Vob2xkZXIgbm9kZSBpbiBwYXJlbnQgdHJlZVxuICB2YXIgcmVuZGVyQ29udGV4dCA9IHBhcmVudFZub2RlICYmIHBhcmVudFZub2RlLmNvbnRleHQ7XG4gIHZtLiRzbG90cyA9IHJlc29sdmVTbG90cyhvcHRpb25zLl9yZW5kZXJDaGlsZHJlbiwgcmVuZGVyQ29udGV4dCk7XG4gIHZtLiRzY29wZWRTbG90cyA9IGVtcHR5T2JqZWN0O1xuICAvLyBiaW5kIHRoZSBjcmVhdGVFbGVtZW50IGZuIHRvIHRoaXMgaW5zdGFuY2VcbiAgLy8gc28gdGhhdCB3ZSBnZXQgcHJvcGVyIHJlbmRlciBjb250ZXh0IGluc2lkZSBpdC5cbiAgLy8gYXJncyBvcmRlcjogdGFnLCBkYXRhLCBjaGlsZHJlbiwgbm9ybWFsaXphdGlvblR5cGUsIGFsd2F5c05vcm1hbGl6ZVxuICAvLyBpbnRlcm5hbCB2ZXJzaW9uIGlzIHVzZWQgYnkgcmVuZGVyIGZ1bmN0aW9ucyBjb21waWxlZCBmcm9tIHRlbXBsYXRlc1xuICB2bS5fYyA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7IHJldHVybiBjcmVhdGVFbGVtZW50KHZtLCBhLCBiLCBjLCBkLCBmYWxzZSk7IH07XG4gIC8vIG5vcm1hbGl6YXRpb24gaXMgYWx3YXlzIGFwcGxpZWQgZm9yIHRoZSBwdWJsaWMgdmVyc2lvbiwgdXNlZCBpblxuICAvLyB1c2VyLXdyaXR0ZW4gcmVuZGVyIGZ1bmN0aW9ucy5cbiAgdm0uJGNyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCkgeyByZXR1cm4gY3JlYXRlRWxlbWVudCh2bSwgYSwgYiwgYywgZCwgdHJ1ZSk7IH07XG5cbiAgLy8gJGF0dHJzICYgJGxpc3RlbmVycyBhcmUgZXhwb3NlZCBmb3IgZWFzaWVyIEhPQyBjcmVhdGlvbi5cbiAgLy8gdGhleSBuZWVkIHRvIGJlIHJlYWN0aXZlIHNvIHRoYXQgSE9DcyB1c2luZyB0aGVtIGFyZSBhbHdheXMgdXBkYXRlZFxuICB2YXIgcGFyZW50RGF0YSA9IHBhcmVudFZub2RlICYmIHBhcmVudFZub2RlLmRhdGE7XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBkZWZpbmVSZWFjdGl2ZSh2bSwgJyRhdHRycycsIHBhcmVudERhdGEgJiYgcGFyZW50RGF0YS5hdHRycyB8fCBlbXB0eU9iamVjdCwgZnVuY3Rpb24gKCkge1xuICAgICAgIWlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCAmJiB3YXJuKFwiJGF0dHJzIGlzIHJlYWRvbmx5LlwiLCB2bSk7XG4gICAgfSwgdHJ1ZSk7XG4gICAgZGVmaW5lUmVhY3RpdmUodm0sICckbGlzdGVuZXJzJywgb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzIHx8IGVtcHR5T2JqZWN0LCBmdW5jdGlvbiAoKSB7XG4gICAgICAhaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50ICYmIHdhcm4oXCIkbGlzdGVuZXJzIGlzIHJlYWRvbmx5LlwiLCB2bSk7XG4gICAgfSwgdHJ1ZSk7XG4gIH0gZWxzZSB7XG4gICAgZGVmaW5lUmVhY3RpdmUodm0sICckYXR0cnMnLCBwYXJlbnREYXRhICYmIHBhcmVudERhdGEuYXR0cnMgfHwgZW1wdHlPYmplY3QsIG51bGwsIHRydWUpO1xuICAgIGRlZmluZVJlYWN0aXZlKHZtLCAnJGxpc3RlbmVycycsIG9wdGlvbnMuX3BhcmVudExpc3RlbmVycyB8fCBlbXB0eU9iamVjdCwgbnVsbCwgdHJ1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVuZGVyTWl4aW4gKFZ1ZSkge1xuICAvLyBpbnN0YWxsIHJ1bnRpbWUgY29udmVuaWVuY2UgaGVscGVyc1xuICBpbnN0YWxsUmVuZGVySGVscGVycyhWdWUucHJvdG90eXBlKTtcblxuICBWdWUucHJvdG90eXBlLiRuZXh0VGljayA9IGZ1bmN0aW9uIChmbikge1xuICAgIHJldHVybiBuZXh0VGljayhmbiwgdGhpcylcbiAgfTtcblxuICBWdWUucHJvdG90eXBlLl9yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICB2YXIgcmVmID0gdm0uJG9wdGlvbnM7XG4gICAgdmFyIHJlbmRlciA9IHJlZi5yZW5kZXI7XG4gICAgdmFyIF9wYXJlbnRWbm9kZSA9IHJlZi5fcGFyZW50Vm5vZGU7XG5cbiAgICAvLyByZXNldCBfcmVuZGVyZWQgZmxhZyBvbiBzbG90cyBmb3IgZHVwbGljYXRlIHNsb3QgY2hlY2tcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgZm9yICh2YXIga2V5IGluIHZtLiRzbG90cykge1xuICAgICAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICAgICAgdm0uJHNsb3RzW2tleV0uX3JlbmRlcmVkID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKF9wYXJlbnRWbm9kZSkge1xuICAgICAgdm0uJHNjb3BlZFNsb3RzID0gX3BhcmVudFZub2RlLmRhdGEuc2NvcGVkU2xvdHMgfHwgZW1wdHlPYmplY3Q7XG4gICAgfVxuXG4gICAgLy8gc2V0IHBhcmVudCB2bm9kZS4gdGhpcyBhbGxvd3MgcmVuZGVyIGZ1bmN0aW9ucyB0byBoYXZlIGFjY2Vzc1xuICAgIC8vIHRvIHRoZSBkYXRhIG9uIHRoZSBwbGFjZWhvbGRlciBub2RlLlxuICAgIHZtLiR2bm9kZSA9IF9wYXJlbnRWbm9kZTtcbiAgICAvLyByZW5kZXIgc2VsZlxuICAgIHZhciB2bm9kZTtcbiAgICB0cnkge1xuICAgICAgdm5vZGUgPSByZW5kZXIuY2FsbCh2bS5fcmVuZGVyUHJveHksIHZtLiRjcmVhdGVFbGVtZW50KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBoYW5kbGVFcnJvcihlLCB2bSwgXCJyZW5kZXJcIik7XG4gICAgICAvLyByZXR1cm4gZXJyb3IgcmVuZGVyIHJlc3VsdCxcbiAgICAgIC8vIG9yIHByZXZpb3VzIHZub2RlIHRvIHByZXZlbnQgcmVuZGVyIGVycm9yIGNhdXNpbmcgYmxhbmsgY29tcG9uZW50XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKHZtLiRvcHRpb25zLnJlbmRlckVycm9yKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZub2RlID0gdm0uJG9wdGlvbnMucmVuZGVyRXJyb3IuY2FsbCh2bS5fcmVuZGVyUHJveHksIHZtLiRjcmVhdGVFbGVtZW50LCBlKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBoYW5kbGVFcnJvcihlLCB2bSwgXCJyZW5kZXJFcnJvclwiKTtcbiAgICAgICAgICAgIHZub2RlID0gdm0uX3Zub2RlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2bm9kZSA9IHZtLl92bm9kZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdm5vZGUgPSB2bS5fdm5vZGU7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIHJldHVybiBlbXB0eSB2bm9kZSBpbiBjYXNlIHRoZSByZW5kZXIgZnVuY3Rpb24gZXJyb3JlZCBvdXRcbiAgICBpZiAoISh2bm9kZSBpbnN0YW5jZW9mIFZOb2RlKSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgQXJyYXkuaXNBcnJheSh2bm9kZSkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAnTXVsdGlwbGUgcm9vdCBub2RlcyByZXR1cm5lZCBmcm9tIHJlbmRlciBmdW5jdGlvbi4gUmVuZGVyIGZ1bmN0aW9uICcgK1xuICAgICAgICAgICdzaG91bGQgcmV0dXJuIGEgc2luZ2xlIHJvb3Qgbm9kZS4nLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICB2bm9kZSA9IGNyZWF0ZUVtcHR5Vk5vZGUoKTtcbiAgICB9XG4gICAgLy8gc2V0IHBhcmVudFxuICAgIHZub2RlLnBhcmVudCA9IF9wYXJlbnRWbm9kZTtcbiAgICByZXR1cm4gdm5vZGVcbiAgfTtcbn1cblxuLyogICovXG5cbnZhciB1aWQkMyA9IDA7XG5cbmZ1bmN0aW9uIGluaXRNaXhpbiAoVnVlKSB7XG4gIFZ1ZS5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgLy8gYSB1aWRcbiAgICB2bS5fdWlkID0gdWlkJDMrKztcblxuICAgIHZhciBzdGFydFRhZywgZW5kVGFnO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XG4gICAgICBzdGFydFRhZyA9IFwidnVlLXBlcmYtc3RhcnQ6XCIgKyAodm0uX3VpZCk7XG4gICAgICBlbmRUYWcgPSBcInZ1ZS1wZXJmLWVuZDpcIiArICh2bS5fdWlkKTtcbiAgICAgIG1hcmsoc3RhcnRUYWcpO1xuICAgIH1cblxuICAgIC8vIGEgZmxhZyB0byBhdm9pZCB0aGlzIGJlaW5nIG9ic2VydmVkXG4gICAgdm0uX2lzVnVlID0gdHJ1ZTtcbiAgICAvLyBtZXJnZSBvcHRpb25zXG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5faXNDb21wb25lbnQpIHtcbiAgICAgIC8vIG9wdGltaXplIGludGVybmFsIGNvbXBvbmVudCBpbnN0YW50aWF0aW9uXG4gICAgICAvLyBzaW5jZSBkeW5hbWljIG9wdGlvbnMgbWVyZ2luZyBpcyBwcmV0dHkgc2xvdywgYW5kIG5vbmUgb2YgdGhlXG4gICAgICAvLyBpbnRlcm5hbCBjb21wb25lbnQgb3B0aW9ucyBuZWVkcyBzcGVjaWFsIHRyZWF0bWVudC5cbiAgICAgIGluaXRJbnRlcm5hbENvbXBvbmVudCh2bSwgb3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZtLiRvcHRpb25zID0gbWVyZ2VPcHRpb25zKFxuICAgICAgICByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zKHZtLmNvbnN0cnVjdG9yKSxcbiAgICAgICAgb3B0aW9ucyB8fCB7fSxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGluaXRQcm94eSh2bSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZtLl9yZW5kZXJQcm94eSA9IHZtO1xuICAgIH1cbiAgICAvLyBleHBvc2UgcmVhbCBzZWxmXG4gICAgdm0uX3NlbGYgPSB2bTtcbiAgICBpbml0TGlmZWN5Y2xlKHZtKTtcbiAgICBpbml0RXZlbnRzKHZtKTtcbiAgICBpbml0UmVuZGVyKHZtKTtcbiAgICBjYWxsSG9vayh2bSwgJ2JlZm9yZUNyZWF0ZScpO1xuICAgIGluaXRJbmplY3Rpb25zKHZtKTsgLy8gcmVzb2x2ZSBpbmplY3Rpb25zIGJlZm9yZSBkYXRhL3Byb3BzXG4gICAgaW5pdFN0YXRlKHZtKTtcbiAgICBpbml0UHJvdmlkZSh2bSk7IC8vIHJlc29sdmUgcHJvdmlkZSBhZnRlciBkYXRhL3Byb3BzXG4gICAgY2FsbEhvb2sodm0sICdjcmVhdGVkJyk7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuICAgICAgdm0uX25hbWUgPSBmb3JtYXRDb21wb25lbnROYW1lKHZtLCBmYWxzZSk7XG4gICAgICBtYXJrKGVuZFRhZyk7XG4gICAgICBtZWFzdXJlKChcInZ1ZSBcIiArICh2bS5fbmFtZSkgKyBcIiBpbml0XCIpLCBzdGFydFRhZywgZW5kVGFnKTtcbiAgICB9XG5cbiAgICBpZiAodm0uJG9wdGlvbnMuZWwpIHtcbiAgICAgIHZtLiRtb3VudCh2bS4kb3B0aW9ucy5lbCk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBpbml0SW50ZXJuYWxDb21wb25lbnQgKHZtLCBvcHRpb25zKSB7XG4gIHZhciBvcHRzID0gdm0uJG9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKHZtLmNvbnN0cnVjdG9yLm9wdGlvbnMpO1xuICAvLyBkb2luZyB0aGlzIGJlY2F1c2UgaXQncyBmYXN0ZXIgdGhhbiBkeW5hbWljIGVudW1lcmF0aW9uLlxuICB2YXIgcGFyZW50Vm5vZGUgPSBvcHRpb25zLl9wYXJlbnRWbm9kZTtcbiAgb3B0cy5wYXJlbnQgPSBvcHRpb25zLnBhcmVudDtcbiAgb3B0cy5fcGFyZW50Vm5vZGUgPSBwYXJlbnRWbm9kZTtcbiAgb3B0cy5fcGFyZW50RWxtID0gb3B0aW9ucy5fcGFyZW50RWxtO1xuICBvcHRzLl9yZWZFbG0gPSBvcHRpb25zLl9yZWZFbG07XG5cbiAgdmFyIHZub2RlQ29tcG9uZW50T3B0aW9ucyA9IHBhcmVudFZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gIG9wdHMucHJvcHNEYXRhID0gdm5vZGVDb21wb25lbnRPcHRpb25zLnByb3BzRGF0YTtcbiAgb3B0cy5fcGFyZW50TGlzdGVuZXJzID0gdm5vZGVDb21wb25lbnRPcHRpb25zLmxpc3RlbmVycztcbiAgb3B0cy5fcmVuZGVyQ2hpbGRyZW4gPSB2bm9kZUNvbXBvbmVudE9wdGlvbnMuY2hpbGRyZW47XG4gIG9wdHMuX2NvbXBvbmVudFRhZyA9IHZub2RlQ29tcG9uZW50T3B0aW9ucy50YWc7XG5cbiAgaWYgKG9wdGlvbnMucmVuZGVyKSB7XG4gICAgb3B0cy5yZW5kZXIgPSBvcHRpb25zLnJlbmRlcjtcbiAgICBvcHRzLnN0YXRpY1JlbmRlckZucyA9IG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnMgKEN0b3IpIHtcbiAgdmFyIG9wdGlvbnMgPSBDdG9yLm9wdGlvbnM7XG4gIGlmIChDdG9yLnN1cGVyKSB7XG4gICAgdmFyIHN1cGVyT3B0aW9ucyA9IHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnMoQ3Rvci5zdXBlcik7XG4gICAgdmFyIGNhY2hlZFN1cGVyT3B0aW9ucyA9IEN0b3Iuc3VwZXJPcHRpb25zO1xuICAgIGlmIChzdXBlck9wdGlvbnMgIT09IGNhY2hlZFN1cGVyT3B0aW9ucykge1xuICAgICAgLy8gc3VwZXIgb3B0aW9uIGNoYW5nZWQsXG4gICAgICAvLyBuZWVkIHRvIHJlc29sdmUgbmV3IG9wdGlvbnMuXG4gICAgICBDdG9yLnN1cGVyT3B0aW9ucyA9IHN1cGVyT3B0aW9ucztcbiAgICAgIC8vIGNoZWNrIGlmIHRoZXJlIGFyZSBhbnkgbGF0ZS1tb2RpZmllZC9hdHRhY2hlZCBvcHRpb25zICgjNDk3NilcbiAgICAgIHZhciBtb2RpZmllZE9wdGlvbnMgPSByZXNvbHZlTW9kaWZpZWRPcHRpb25zKEN0b3IpO1xuICAgICAgLy8gdXBkYXRlIGJhc2UgZXh0ZW5kIG9wdGlvbnNcbiAgICAgIGlmIChtb2RpZmllZE9wdGlvbnMpIHtcbiAgICAgICAgZXh0ZW5kKEN0b3IuZXh0ZW5kT3B0aW9ucywgbW9kaWZpZWRPcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIG9wdGlvbnMgPSBDdG9yLm9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoc3VwZXJPcHRpb25zLCBDdG9yLmV4dGVuZE9wdGlvbnMpO1xuICAgICAgaWYgKG9wdGlvbnMubmFtZSkge1xuICAgICAgICBvcHRpb25zLmNvbXBvbmVudHNbb3B0aW9ucy5uYW1lXSA9IEN0b3I7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBvcHRpb25zXG59XG5cbmZ1bmN0aW9uIHJlc29sdmVNb2RpZmllZE9wdGlvbnMgKEN0b3IpIHtcbiAgdmFyIG1vZGlmaWVkO1xuICB2YXIgbGF0ZXN0ID0gQ3Rvci5vcHRpb25zO1xuICB2YXIgZXh0ZW5kZWQgPSBDdG9yLmV4dGVuZE9wdGlvbnM7XG4gIHZhciBzZWFsZWQgPSBDdG9yLnNlYWxlZE9wdGlvbnM7XG4gIGZvciAodmFyIGtleSBpbiBsYXRlc3QpIHtcbiAgICBpZiAobGF0ZXN0W2tleV0gIT09IHNlYWxlZFtrZXldKSB7XG4gICAgICBpZiAoIW1vZGlmaWVkKSB7IG1vZGlmaWVkID0ge307IH1cbiAgICAgIG1vZGlmaWVkW2tleV0gPSBkZWR1cGUobGF0ZXN0W2tleV0sIGV4dGVuZGVkW2tleV0sIHNlYWxlZFtrZXldKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1vZGlmaWVkXG59XG5cbmZ1bmN0aW9uIGRlZHVwZSAobGF0ZXN0LCBleHRlbmRlZCwgc2VhbGVkKSB7XG4gIC8vIGNvbXBhcmUgbGF0ZXN0IGFuZCBzZWFsZWQgdG8gZW5zdXJlIGxpZmVjeWNsZSBob29rcyB3b24ndCBiZSBkdXBsaWNhdGVkXG4gIC8vIGJldHdlZW4gbWVyZ2VzXG4gIGlmIChBcnJheS5pc0FycmF5KGxhdGVzdCkpIHtcbiAgICB2YXIgcmVzID0gW107XG4gICAgc2VhbGVkID0gQXJyYXkuaXNBcnJheShzZWFsZWQpID8gc2VhbGVkIDogW3NlYWxlZF07XG4gICAgZXh0ZW5kZWQgPSBBcnJheS5pc0FycmF5KGV4dGVuZGVkKSA/IGV4dGVuZGVkIDogW2V4dGVuZGVkXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxhdGVzdC5sZW5ndGg7IGkrKykge1xuICAgICAgLy8gcHVzaCBvcmlnaW5hbCBvcHRpb25zIGFuZCBub3Qgc2VhbGVkIG9wdGlvbnMgdG8gZXhjbHVkZSBkdXBsaWNhdGVkIG9wdGlvbnNcbiAgICAgIGlmIChleHRlbmRlZC5pbmRleE9mKGxhdGVzdFtpXSkgPj0gMCB8fCBzZWFsZWQuaW5kZXhPZihsYXRlc3RbaV0pIDwgMCkge1xuICAgICAgICByZXMucHVzaChsYXRlc3RbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGxhdGVzdFxuICB9XG59XG5cbmZ1bmN0aW9uIFZ1ZSAob3B0aW9ucykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICEodGhpcyBpbnN0YW5jZW9mIFZ1ZSlcbiAgKSB7XG4gICAgd2FybignVnVlIGlzIGEgY29uc3RydWN0b3IgYW5kIHNob3VsZCBiZSBjYWxsZWQgd2l0aCB0aGUgYG5ld2Aga2V5d29yZCcpO1xuICB9XG4gIHRoaXMuX2luaXQob3B0aW9ucyk7XG59XG5cbmluaXRNaXhpbihWdWUpO1xuc3RhdGVNaXhpbihWdWUpO1xuZXZlbnRzTWl4aW4oVnVlKTtcbmxpZmVjeWNsZU1peGluKFZ1ZSk7XG5yZW5kZXJNaXhpbihWdWUpO1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdFVzZSAoVnVlKSB7XG4gIFZ1ZS51c2UgPSBmdW5jdGlvbiAocGx1Z2luKSB7XG4gICAgdmFyIGluc3RhbGxlZFBsdWdpbnMgPSAodGhpcy5faW5zdGFsbGVkUGx1Z2lucyB8fCAodGhpcy5faW5zdGFsbGVkUGx1Z2lucyA9IFtdKSk7XG4gICAgaWYgKGluc3RhbGxlZFBsdWdpbnMuaW5kZXhPZihwbHVnaW4pID4gLTEpIHtcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgLy8gYWRkaXRpb25hbCBwYXJhbWV0ZXJzXG4gICAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cywgMSk7XG4gICAgYXJncy51bnNoaWZ0KHRoaXMpO1xuICAgIGlmICh0eXBlb2YgcGx1Z2luLmluc3RhbGwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHBsdWdpbi5pbnN0YWxsLmFwcGx5KHBsdWdpbiwgYXJncyk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgcGx1Z2luID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwbHVnaW4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgfVxuICAgIGluc3RhbGxlZFBsdWdpbnMucHVzaChwbHVnaW4pO1xuICAgIHJldHVybiB0aGlzXG4gIH07XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0TWl4aW4kMSAoVnVlKSB7XG4gIFZ1ZS5taXhpbiA9IGZ1bmN0aW9uIChtaXhpbikge1xuICAgIHRoaXMub3B0aW9ucyA9IG1lcmdlT3B0aW9ucyh0aGlzLm9wdGlvbnMsIG1peGluKTtcbiAgICByZXR1cm4gdGhpc1xuICB9O1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdEV4dGVuZCAoVnVlKSB7XG4gIC8qKlxuICAgKiBFYWNoIGluc3RhbmNlIGNvbnN0cnVjdG9yLCBpbmNsdWRpbmcgVnVlLCBoYXMgYSB1bmlxdWVcbiAgICogY2lkLiBUaGlzIGVuYWJsZXMgdXMgdG8gY3JlYXRlIHdyYXBwZWQgXCJjaGlsZFxuICAgKiBjb25zdHJ1Y3RvcnNcIiBmb3IgcHJvdG90eXBhbCBpbmhlcml0YW5jZSBhbmQgY2FjaGUgdGhlbS5cbiAgICovXG4gIFZ1ZS5jaWQgPSAwO1xuICB2YXIgY2lkID0gMTtcblxuICAvKipcbiAgICogQ2xhc3MgaW5oZXJpdGFuY2VcbiAgICovXG4gIFZ1ZS5leHRlbmQgPSBmdW5jdGlvbiAoZXh0ZW5kT3B0aW9ucykge1xuICAgIGV4dGVuZE9wdGlvbnMgPSBleHRlbmRPcHRpb25zIHx8IHt9O1xuICAgIHZhciBTdXBlciA9IHRoaXM7XG4gICAgdmFyIFN1cGVySWQgPSBTdXBlci5jaWQ7XG4gICAgdmFyIGNhY2hlZEN0b3JzID0gZXh0ZW5kT3B0aW9ucy5fQ3RvciB8fCAoZXh0ZW5kT3B0aW9ucy5fQ3RvciA9IHt9KTtcbiAgICBpZiAoY2FjaGVkQ3RvcnNbU3VwZXJJZF0pIHtcbiAgICAgIHJldHVybiBjYWNoZWRDdG9yc1tTdXBlcklkXVxuICAgIH1cblxuICAgIHZhciBuYW1lID0gZXh0ZW5kT3B0aW9ucy5uYW1lIHx8IFN1cGVyLm9wdGlvbnMubmFtZTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBuYW1lKSB7XG4gICAgICB2YWxpZGF0ZUNvbXBvbmVudE5hbWUobmFtZSk7XG4gICAgfVxuXG4gICAgdmFyIFN1YiA9IGZ1bmN0aW9uIFZ1ZUNvbXBvbmVudCAob3B0aW9ucykge1xuICAgICAgdGhpcy5faW5pdChvcHRpb25zKTtcbiAgICB9O1xuICAgIFN1Yi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFN1cGVyLnByb3RvdHlwZSk7XG4gICAgU3ViLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFN1YjtcbiAgICBTdWIuY2lkID0gY2lkKys7XG4gICAgU3ViLm9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoXG4gICAgICBTdXBlci5vcHRpb25zLFxuICAgICAgZXh0ZW5kT3B0aW9uc1xuICAgICk7XG4gICAgU3ViWydzdXBlciddID0gU3VwZXI7XG5cbiAgICAvLyBGb3IgcHJvcHMgYW5kIGNvbXB1dGVkIHByb3BlcnRpZXMsIHdlIGRlZmluZSB0aGUgcHJveHkgZ2V0dGVycyBvblxuICAgIC8vIHRoZSBWdWUgaW5zdGFuY2VzIGF0IGV4dGVuc2lvbiB0aW1lLCBvbiB0aGUgZXh0ZW5kZWQgcHJvdG90eXBlLiBUaGlzXG4gICAgLy8gYXZvaWRzIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSBjYWxscyBmb3IgZWFjaCBpbnN0YW5jZSBjcmVhdGVkLlxuICAgIGlmIChTdWIub3B0aW9ucy5wcm9wcykge1xuICAgICAgaW5pdFByb3BzJDEoU3ViKTtcbiAgICB9XG4gICAgaWYgKFN1Yi5vcHRpb25zLmNvbXB1dGVkKSB7XG4gICAgICBpbml0Q29tcHV0ZWQkMShTdWIpO1xuICAgIH1cblxuICAgIC8vIGFsbG93IGZ1cnRoZXIgZXh0ZW5zaW9uL21peGluL3BsdWdpbiB1c2FnZVxuICAgIFN1Yi5leHRlbmQgPSBTdXBlci5leHRlbmQ7XG4gICAgU3ViLm1peGluID0gU3VwZXIubWl4aW47XG4gICAgU3ViLnVzZSA9IFN1cGVyLnVzZTtcblxuICAgIC8vIGNyZWF0ZSBhc3NldCByZWdpc3RlcnMsIHNvIGV4dGVuZGVkIGNsYXNzZXNcbiAgICAvLyBjYW4gaGF2ZSB0aGVpciBwcml2YXRlIGFzc2V0cyB0b28uXG4gICAgQVNTRVRfVFlQRVMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgICAgU3ViW3R5cGVdID0gU3VwZXJbdHlwZV07XG4gICAgfSk7XG4gICAgLy8gZW5hYmxlIHJlY3Vyc2l2ZSBzZWxmLWxvb2t1cFxuICAgIGlmIChuYW1lKSB7XG4gICAgICBTdWIub3B0aW9ucy5jb21wb25lbnRzW25hbWVdID0gU3ViO1xuICAgIH1cblxuICAgIC8vIGtlZXAgYSByZWZlcmVuY2UgdG8gdGhlIHN1cGVyIG9wdGlvbnMgYXQgZXh0ZW5zaW9uIHRpbWUuXG4gICAgLy8gbGF0ZXIgYXQgaW5zdGFudGlhdGlvbiB3ZSBjYW4gY2hlY2sgaWYgU3VwZXIncyBvcHRpb25zIGhhdmVcbiAgICAvLyBiZWVuIHVwZGF0ZWQuXG4gICAgU3ViLnN1cGVyT3B0aW9ucyA9IFN1cGVyLm9wdGlvbnM7XG4gICAgU3ViLmV4dGVuZE9wdGlvbnMgPSBleHRlbmRPcHRpb25zO1xuICAgIFN1Yi5zZWFsZWRPcHRpb25zID0gZXh0ZW5kKHt9LCBTdWIub3B0aW9ucyk7XG5cbiAgICAvLyBjYWNoZSBjb25zdHJ1Y3RvclxuICAgIGNhY2hlZEN0b3JzW1N1cGVySWRdID0gU3ViO1xuICAgIHJldHVybiBTdWJcbiAgfTtcbn1cblxuZnVuY3Rpb24gaW5pdFByb3BzJDEgKENvbXApIHtcbiAgdmFyIHByb3BzID0gQ29tcC5vcHRpb25zLnByb3BzO1xuICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICBwcm94eShDb21wLnByb3RvdHlwZSwgXCJfcHJvcHNcIiwga2V5KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0Q29tcHV0ZWQkMSAoQ29tcCkge1xuICB2YXIgY29tcHV0ZWQgPSBDb21wLm9wdGlvbnMuY29tcHV0ZWQ7XG4gIGZvciAodmFyIGtleSBpbiBjb21wdXRlZCkge1xuICAgIGRlZmluZUNvbXB1dGVkKENvbXAucHJvdG90eXBlLCBrZXksIGNvbXB1dGVkW2tleV0pO1xuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0QXNzZXRSZWdpc3RlcnMgKFZ1ZSkge1xuICAvKipcbiAgICogQ3JlYXRlIGFzc2V0IHJlZ2lzdHJhdGlvbiBtZXRob2RzLlxuICAgKi9cbiAgQVNTRVRfVFlQRVMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgIFZ1ZVt0eXBlXSA9IGZ1bmN0aW9uIChcbiAgICAgIGlkLFxuICAgICAgZGVmaW5pdGlvblxuICAgICkge1xuICAgICAgaWYgKCFkZWZpbml0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnNbdHlwZSArICdzJ11baWRdXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgdHlwZSA9PT0gJ2NvbXBvbmVudCcpIHtcbiAgICAgICAgICB2YWxpZGF0ZUNvbXBvbmVudE5hbWUoaWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSAnY29tcG9uZW50JyAmJiBpc1BsYWluT2JqZWN0KGRlZmluaXRpb24pKSB7XG4gICAgICAgICAgZGVmaW5pdGlvbi5uYW1lID0gZGVmaW5pdGlvbi5uYW1lIHx8IGlkO1xuICAgICAgICAgIGRlZmluaXRpb24gPSB0aGlzLm9wdGlvbnMuX2Jhc2UuZXh0ZW5kKGRlZmluaXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSAnZGlyZWN0aXZlJyAmJiB0eXBlb2YgZGVmaW5pdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGRlZmluaXRpb24gPSB7IGJpbmQ6IGRlZmluaXRpb24sIHVwZGF0ZTogZGVmaW5pdGlvbiB9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3B0aW9uc1t0eXBlICsgJ3MnXVtpZF0gPSBkZWZpbml0aW9uO1xuICAgICAgICByZXR1cm4gZGVmaW5pdGlvblxuICAgICAgfVxuICAgIH07XG4gIH0pO1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZSAob3B0cykge1xuICByZXR1cm4gb3B0cyAmJiAob3B0cy5DdG9yLm9wdGlvbnMubmFtZSB8fCBvcHRzLnRhZylcbn1cblxuZnVuY3Rpb24gbWF0Y2hlcyAocGF0dGVybiwgbmFtZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShwYXR0ZXJuKSkge1xuICAgIHJldHVybiBwYXR0ZXJuLmluZGV4T2YobmFtZSkgPiAtMVxuICB9IGVsc2UgaWYgKHR5cGVvZiBwYXR0ZXJuID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBwYXR0ZXJuLnNwbGl0KCcsJykuaW5kZXhPZihuYW1lKSA+IC0xXG4gIH0gZWxzZSBpZiAoaXNSZWdFeHAocGF0dGVybikpIHtcbiAgICByZXR1cm4gcGF0dGVybi50ZXN0KG5hbWUpXG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmZ1bmN0aW9uIHBydW5lQ2FjaGUgKGtlZXBBbGl2ZUluc3RhbmNlLCBmaWx0ZXIpIHtcbiAgdmFyIGNhY2hlID0ga2VlcEFsaXZlSW5zdGFuY2UuY2FjaGU7XG4gIHZhciBrZXlzID0ga2VlcEFsaXZlSW5zdGFuY2Uua2V5cztcbiAgdmFyIF92bm9kZSA9IGtlZXBBbGl2ZUluc3RhbmNlLl92bm9kZTtcbiAgZm9yICh2YXIga2V5IGluIGNhY2hlKSB7XG4gICAgdmFyIGNhY2hlZE5vZGUgPSBjYWNoZVtrZXldO1xuICAgIGlmIChjYWNoZWROb2RlKSB7XG4gICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWUoY2FjaGVkTm9kZS5jb21wb25lbnRPcHRpb25zKTtcbiAgICAgIGlmIChuYW1lICYmICFmaWx0ZXIobmFtZSkpIHtcbiAgICAgICAgcHJ1bmVDYWNoZUVudHJ5KGNhY2hlLCBrZXksIGtleXMsIF92bm9kZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHBydW5lQ2FjaGVFbnRyeSAoXG4gIGNhY2hlLFxuICBrZXksXG4gIGtleXMsXG4gIGN1cnJlbnRcbikge1xuICB2YXIgY2FjaGVkJCQxID0gY2FjaGVba2V5XTtcbiAgaWYgKGNhY2hlZCQkMSAmJiAoIWN1cnJlbnQgfHwgY2FjaGVkJCQxLnRhZyAhPT0gY3VycmVudC50YWcpKSB7XG4gICAgY2FjaGVkJCQxLmNvbXBvbmVudEluc3RhbmNlLiRkZXN0cm95KCk7XG4gIH1cbiAgY2FjaGVba2V5XSA9IG51bGw7XG4gIHJlbW92ZShrZXlzLCBrZXkpO1xufVxuXG52YXIgcGF0dGVyblR5cGVzID0gW1N0cmluZywgUmVnRXhwLCBBcnJheV07XG5cbnZhciBLZWVwQWxpdmUgPSB7XG4gIG5hbWU6ICdrZWVwLWFsaXZlJyxcbiAgYWJzdHJhY3Q6IHRydWUsXG5cbiAgcHJvcHM6IHtcbiAgICBpbmNsdWRlOiBwYXR0ZXJuVHlwZXMsXG4gICAgZXhjbHVkZTogcGF0dGVyblR5cGVzLFxuICAgIG1heDogW1N0cmluZywgTnVtYmVyXVxuICB9LFxuXG4gIGNyZWF0ZWQ6IGZ1bmN0aW9uIGNyZWF0ZWQgKCkge1xuICAgIHRoaXMuY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMua2V5cyA9IFtdO1xuICB9LFxuXG4gIGRlc3Ryb3llZDogZnVuY3Rpb24gZGVzdHJveWVkICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIGZvciAodmFyIGtleSBpbiB0aGlzJDEuY2FjaGUpIHtcbiAgICAgIHBydW5lQ2FjaGVFbnRyeSh0aGlzJDEuY2FjaGUsIGtleSwgdGhpcyQxLmtleXMpO1xuICAgIH1cbiAgfSxcblxuICBtb3VudGVkOiBmdW5jdGlvbiBtb3VudGVkICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHRoaXMuJHdhdGNoKCdpbmNsdWRlJywgZnVuY3Rpb24gKHZhbCkge1xuICAgICAgcHJ1bmVDYWNoZSh0aGlzJDEsIGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBtYXRjaGVzKHZhbCwgbmFtZSk7IH0pO1xuICAgIH0pO1xuICAgIHRoaXMuJHdhdGNoKCdleGNsdWRlJywgZnVuY3Rpb24gKHZhbCkge1xuICAgICAgcHJ1bmVDYWNoZSh0aGlzJDEsIGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiAhbWF0Y2hlcyh2YWwsIG5hbWUpOyB9KTtcbiAgICB9KTtcbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoKSB7XG4gICAgdmFyIHNsb3QgPSB0aGlzLiRzbG90cy5kZWZhdWx0O1xuICAgIHZhciB2bm9kZSA9IGdldEZpcnN0Q29tcG9uZW50Q2hpbGQoc2xvdCk7XG4gICAgdmFyIGNvbXBvbmVudE9wdGlvbnMgPSB2bm9kZSAmJiB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xuICAgIGlmIChjb21wb25lbnRPcHRpb25zKSB7XG4gICAgICAvLyBjaGVjayBwYXR0ZXJuXG4gICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWUoY29tcG9uZW50T3B0aW9ucyk7XG4gICAgICB2YXIgcmVmID0gdGhpcztcbiAgICAgIHZhciBpbmNsdWRlID0gcmVmLmluY2x1ZGU7XG4gICAgICB2YXIgZXhjbHVkZSA9IHJlZi5leGNsdWRlO1xuICAgICAgaWYgKFxuICAgICAgICAvLyBub3QgaW5jbHVkZWRcbiAgICAgICAgKGluY2x1ZGUgJiYgKCFuYW1lIHx8ICFtYXRjaGVzKGluY2x1ZGUsIG5hbWUpKSkgfHxcbiAgICAgICAgLy8gZXhjbHVkZWRcbiAgICAgICAgKGV4Y2x1ZGUgJiYgbmFtZSAmJiBtYXRjaGVzKGV4Y2x1ZGUsIG5hbWUpKVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiB2bm9kZVxuICAgICAgfVxuXG4gICAgICB2YXIgcmVmJDEgPSB0aGlzO1xuICAgICAgdmFyIGNhY2hlID0gcmVmJDEuY2FjaGU7XG4gICAgICB2YXIga2V5cyA9IHJlZiQxLmtleXM7XG4gICAgICB2YXIga2V5ID0gdm5vZGUua2V5ID09IG51bGxcbiAgICAgICAgLy8gc2FtZSBjb25zdHJ1Y3RvciBtYXkgZ2V0IHJlZ2lzdGVyZWQgYXMgZGlmZmVyZW50IGxvY2FsIGNvbXBvbmVudHNcbiAgICAgICAgLy8gc28gY2lkIGFsb25lIGlzIG5vdCBlbm91Z2ggKCMzMjY5KVxuICAgICAgICA/IGNvbXBvbmVudE9wdGlvbnMuQ3Rvci5jaWQgKyAoY29tcG9uZW50T3B0aW9ucy50YWcgPyAoXCI6OlwiICsgKGNvbXBvbmVudE9wdGlvbnMudGFnKSkgOiAnJylcbiAgICAgICAgOiB2bm9kZS5rZXk7XG4gICAgICBpZiAoY2FjaGVba2V5XSkge1xuICAgICAgICB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IGNhY2hlW2tleV0uY29tcG9uZW50SW5zdGFuY2U7XG4gICAgICAgIC8vIG1ha2UgY3VycmVudCBrZXkgZnJlc2hlc3RcbiAgICAgICAgcmVtb3ZlKGtleXMsIGtleSk7XG4gICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FjaGVba2V5XSA9IHZub2RlO1xuICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgICAgLy8gcHJ1bmUgb2xkZXN0IGVudHJ5XG4gICAgICAgIGlmICh0aGlzLm1heCAmJiBrZXlzLmxlbmd0aCA+IHBhcnNlSW50KHRoaXMubWF4KSkge1xuICAgICAgICAgIHBydW5lQ2FjaGVFbnRyeShjYWNoZSwga2V5c1swXSwga2V5cywgdGhpcy5fdm5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZub2RlLmRhdGEua2VlcEFsaXZlID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHZub2RlIHx8IChzbG90ICYmIHNsb3RbMF0pXG4gIH1cbn1cblxudmFyIGJ1aWx0SW5Db21wb25lbnRzID0ge1xuICBLZWVwQWxpdmU6IEtlZXBBbGl2ZVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdEdsb2JhbEFQSSAoVnVlKSB7XG4gIC8vIGNvbmZpZ1xuICB2YXIgY29uZmlnRGVmID0ge307XG4gIGNvbmZpZ0RlZi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25maWc7IH07XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgY29uZmlnRGVmLnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdEbyBub3QgcmVwbGFjZSB0aGUgVnVlLmNvbmZpZyBvYmplY3QsIHNldCBpbmRpdmlkdWFsIGZpZWxkcyBpbnN0ZWFkLidcbiAgICAgICk7XG4gICAgfTtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLCAnY29uZmlnJywgY29uZmlnRGVmKTtcblxuICAvLyBleHBvc2VkIHV0aWwgbWV0aG9kcy5cbiAgLy8gTk9URTogdGhlc2UgYXJlIG5vdCBjb25zaWRlcmVkIHBhcnQgb2YgdGhlIHB1YmxpYyBBUEkgLSBhdm9pZCByZWx5aW5nIG9uXG4gIC8vIHRoZW0gdW5sZXNzIHlvdSBhcmUgYXdhcmUgb2YgdGhlIHJpc2suXG4gIFZ1ZS51dGlsID0ge1xuICAgIHdhcm46IHdhcm4sXG4gICAgZXh0ZW5kOiBleHRlbmQsXG4gICAgbWVyZ2VPcHRpb25zOiBtZXJnZU9wdGlvbnMsXG4gICAgZGVmaW5lUmVhY3RpdmU6IGRlZmluZVJlYWN0aXZlXG4gIH07XG5cbiAgVnVlLnNldCA9IHNldDtcbiAgVnVlLmRlbGV0ZSA9IGRlbDtcbiAgVnVlLm5leHRUaWNrID0gbmV4dFRpY2s7XG5cbiAgVnVlLm9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBBU1NFVF9UWVBFUy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgVnVlLm9wdGlvbnNbdHlwZSArICdzJ10gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB9KTtcblxuICAvLyB0aGlzIGlzIHVzZWQgdG8gaWRlbnRpZnkgdGhlIFwiYmFzZVwiIGNvbnN0cnVjdG9yIHRvIGV4dGVuZCBhbGwgcGxhaW4tb2JqZWN0XG4gIC8vIGNvbXBvbmVudHMgd2l0aCBpbiBXZWV4J3MgbXVsdGktaW5zdGFuY2Ugc2NlbmFyaW9zLlxuICBWdWUub3B0aW9ucy5fYmFzZSA9IFZ1ZTtcblxuICBleHRlbmQoVnVlLm9wdGlvbnMuY29tcG9uZW50cywgYnVpbHRJbkNvbXBvbmVudHMpO1xuXG4gIGluaXRVc2UoVnVlKTtcbiAgaW5pdE1peGluJDEoVnVlKTtcbiAgaW5pdEV4dGVuZChWdWUpO1xuICBpbml0QXNzZXRSZWdpc3RlcnMoVnVlKTtcbn1cblxuaW5pdEdsb2JhbEFQSShWdWUpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLnByb3RvdHlwZSwgJyRpc1NlcnZlcicsIHtcbiAgZ2V0OiBpc1NlcnZlclJlbmRlcmluZ1xufSk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJHNzckNvbnRleHQnLCB7XG4gIGdldDogZnVuY3Rpb24gZ2V0ICgpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHJldHVybiB0aGlzLiR2bm9kZSAmJiB0aGlzLiR2bm9kZS5zc3JDb250ZXh0XG4gIH1cbn0pO1xuXG4vLyBleHBvc2UgRnVuY3Rpb25hbFJlbmRlckNvbnRleHQgZm9yIHNzciBydW50aW1lIGhlbHBlciBpbnN0YWxsYXRpb25cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUsICdGdW5jdGlvbmFsUmVuZGVyQ29udGV4dCcsIHtcbiAgdmFsdWU6IEZ1bmN0aW9uYWxSZW5kZXJDb250ZXh0XG59KTtcblxuVnVlLnZlcnNpb24gPSAnMi41LjE2JztcblxuLyogICovXG5cbi8vIHRoZXNlIGFyZSByZXNlcnZlZCBmb3Igd2ViIGJlY2F1c2UgdGhleSBhcmUgZGlyZWN0bHkgY29tcGlsZWQgYXdheVxuLy8gZHVyaW5nIHRlbXBsYXRlIGNvbXBpbGF0aW9uXG52YXIgaXNSZXNlcnZlZEF0dHIgPSBtYWtlTWFwKCdzdHlsZSxjbGFzcycpO1xuXG4vLyBhdHRyaWJ1dGVzIHRoYXQgc2hvdWxkIGJlIHVzaW5nIHByb3BzIGZvciBiaW5kaW5nXG52YXIgYWNjZXB0VmFsdWUgPSBtYWtlTWFwKCdpbnB1dCx0ZXh0YXJlYSxvcHRpb24sc2VsZWN0LHByb2dyZXNzJyk7XG52YXIgbXVzdFVzZVByb3AgPSBmdW5jdGlvbiAodGFnLCB0eXBlLCBhdHRyKSB7XG4gIHJldHVybiAoXG4gICAgKGF0dHIgPT09ICd2YWx1ZScgJiYgYWNjZXB0VmFsdWUodGFnKSkgJiYgdHlwZSAhPT0gJ2J1dHRvbicgfHxcbiAgICAoYXR0ciA9PT0gJ3NlbGVjdGVkJyAmJiB0YWcgPT09ICdvcHRpb24nKSB8fFxuICAgIChhdHRyID09PSAnY2hlY2tlZCcgJiYgdGFnID09PSAnaW5wdXQnKSB8fFxuICAgIChhdHRyID09PSAnbXV0ZWQnICYmIHRhZyA9PT0gJ3ZpZGVvJylcbiAgKVxufTtcblxudmFyIGlzRW51bWVyYXRlZEF0dHIgPSBtYWtlTWFwKCdjb250ZW50ZWRpdGFibGUsZHJhZ2dhYmxlLHNwZWxsY2hlY2snKTtcblxudmFyIGlzQm9vbGVhbkF0dHIgPSBtYWtlTWFwKFxuICAnYWxsb3dmdWxsc2NyZWVuLGFzeW5jLGF1dG9mb2N1cyxhdXRvcGxheSxjaGVja2VkLGNvbXBhY3QsY29udHJvbHMsZGVjbGFyZSwnICtcbiAgJ2RlZmF1bHQsZGVmYXVsdGNoZWNrZWQsZGVmYXVsdG11dGVkLGRlZmF1bHRzZWxlY3RlZCxkZWZlcixkaXNhYmxlZCwnICtcbiAgJ2VuYWJsZWQsZm9ybW5vdmFsaWRhdGUsaGlkZGVuLGluZGV0ZXJtaW5hdGUsaW5lcnQsaXNtYXAsaXRlbXNjb3BlLGxvb3AsbXVsdGlwbGUsJyArXG4gICdtdXRlZCxub2hyZWYsbm9yZXNpemUsbm9zaGFkZSxub3ZhbGlkYXRlLG5vd3JhcCxvcGVuLHBhdXNlb25leGl0LHJlYWRvbmx5LCcgK1xuICAncmVxdWlyZWQscmV2ZXJzZWQsc2NvcGVkLHNlYW1sZXNzLHNlbGVjdGVkLHNvcnRhYmxlLHRyYW5zbGF0ZSwnICtcbiAgJ3RydWVzcGVlZCx0eXBlbXVzdG1hdGNoLHZpc2libGUnXG4pO1xuXG52YXIgeGxpbmtOUyA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJztcblxudmFyIGlzWGxpbmsgPSBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gbmFtZS5jaGFyQXQoNSkgPT09ICc6JyAmJiBuYW1lLnNsaWNlKDAsIDUpID09PSAneGxpbmsnXG59O1xuXG52YXIgZ2V0WGxpbmtQcm9wID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIGlzWGxpbmsobmFtZSkgPyBuYW1lLnNsaWNlKDYsIG5hbWUubGVuZ3RoKSA6ICcnXG59O1xuXG52YXIgaXNGYWxzeUF0dHJWYWx1ZSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgcmV0dXJuIHZhbCA9PSBudWxsIHx8IHZhbCA9PT0gZmFsc2Vcbn07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBnZW5DbGFzc0ZvclZub2RlICh2bm9kZSkge1xuICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gIHZhciBwYXJlbnROb2RlID0gdm5vZGU7XG4gIHZhciBjaGlsZE5vZGUgPSB2bm9kZTtcbiAgd2hpbGUgKGlzRGVmKGNoaWxkTm9kZS5jb21wb25lbnRJbnN0YW5jZSkpIHtcbiAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgIGlmIChjaGlsZE5vZGUgJiYgY2hpbGROb2RlLmRhdGEpIHtcbiAgICAgIGRhdGEgPSBtZXJnZUNsYXNzRGF0YShjaGlsZE5vZGUuZGF0YSwgZGF0YSk7XG4gICAgfVxuICB9XG4gIHdoaWxlIChpc0RlZihwYXJlbnROb2RlID0gcGFyZW50Tm9kZS5wYXJlbnQpKSB7XG4gICAgaWYgKHBhcmVudE5vZGUgJiYgcGFyZW50Tm9kZS5kYXRhKSB7XG4gICAgICBkYXRhID0gbWVyZ2VDbGFzc0RhdGEoZGF0YSwgcGFyZW50Tm9kZS5kYXRhKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlbmRlckNsYXNzKGRhdGEuc3RhdGljQ2xhc3MsIGRhdGEuY2xhc3MpXG59XG5cbmZ1bmN0aW9uIG1lcmdlQ2xhc3NEYXRhIChjaGlsZCwgcGFyZW50KSB7XG4gIHJldHVybiB7XG4gICAgc3RhdGljQ2xhc3M6IGNvbmNhdChjaGlsZC5zdGF0aWNDbGFzcywgcGFyZW50LnN0YXRpY0NsYXNzKSxcbiAgICBjbGFzczogaXNEZWYoY2hpbGQuY2xhc3MpXG4gICAgICA/IFtjaGlsZC5jbGFzcywgcGFyZW50LmNsYXNzXVxuICAgICAgOiBwYXJlbnQuY2xhc3NcbiAgfVxufVxuXG5mdW5jdGlvbiByZW5kZXJDbGFzcyAoXG4gIHN0YXRpY0NsYXNzLFxuICBkeW5hbWljQ2xhc3Ncbikge1xuICBpZiAoaXNEZWYoc3RhdGljQ2xhc3MpIHx8IGlzRGVmKGR5bmFtaWNDbGFzcykpIHtcbiAgICByZXR1cm4gY29uY2F0KHN0YXRpY0NsYXNzLCBzdHJpbmdpZnlDbGFzcyhkeW5hbWljQ2xhc3MpKVxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHJldHVybiAnJ1xufVxuXG5mdW5jdGlvbiBjb25jYXQgKGEsIGIpIHtcbiAgcmV0dXJuIGEgPyBiID8gKGEgKyAnICcgKyBiKSA6IGEgOiAoYiB8fCAnJylcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5Q2xhc3MgKHZhbHVlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiBzdHJpbmdpZnlBcnJheSh2YWx1ZSlcbiAgfVxuICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIHN0cmluZ2lmeU9iamVjdCh2YWx1ZSlcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZVxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHJldHVybiAnJ1xufVxuXG5mdW5jdGlvbiBzdHJpbmdpZnlBcnJheSAodmFsdWUpIHtcbiAgdmFyIHJlcyA9ICcnO1xuICB2YXIgc3RyaW5naWZpZWQ7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKGlzRGVmKHN0cmluZ2lmaWVkID0gc3RyaW5naWZ5Q2xhc3ModmFsdWVbaV0pKSAmJiBzdHJpbmdpZmllZCAhPT0gJycpIHtcbiAgICAgIGlmIChyZXMpIHsgcmVzICs9ICcgJzsgfVxuICAgICAgcmVzICs9IHN0cmluZ2lmaWVkO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeU9iamVjdCAodmFsdWUpIHtcbiAgdmFyIHJlcyA9ICcnO1xuICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICBpZiAodmFsdWVba2V5XSkge1xuICAgICAgaWYgKHJlcykgeyByZXMgKz0gJyAnOyB9XG4gICAgICByZXMgKz0ga2V5O1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG52YXIgbmFtZXNwYWNlTWFwID0ge1xuICBzdmc6ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsXG4gIG1hdGg6ICdodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MJ1xufTtcblxudmFyIGlzSFRNTFRhZyA9IG1ha2VNYXAoXG4gICdodG1sLGJvZHksYmFzZSxoZWFkLGxpbmssbWV0YSxzdHlsZSx0aXRsZSwnICtcbiAgJ2FkZHJlc3MsYXJ0aWNsZSxhc2lkZSxmb290ZXIsaGVhZGVyLGgxLGgyLGgzLGg0LGg1LGg2LGhncm91cCxuYXYsc2VjdGlvbiwnICtcbiAgJ2RpdixkZCxkbCxkdCxmaWdjYXB0aW9uLGZpZ3VyZSxwaWN0dXJlLGhyLGltZyxsaSxtYWluLG9sLHAscHJlLHVsLCcgK1xuICAnYSxiLGFiYnIsYmRpLGJkbyxicixjaXRlLGNvZGUsZGF0YSxkZm4sZW0saSxrYmQsbWFyayxxLHJwLHJ0LHJ0YyxydWJ5LCcgK1xuICAncyxzYW1wLHNtYWxsLHNwYW4sc3Ryb25nLHN1YixzdXAsdGltZSx1LHZhcix3YnIsYXJlYSxhdWRpbyxtYXAsdHJhY2ssdmlkZW8sJyArXG4gICdlbWJlZCxvYmplY3QscGFyYW0sc291cmNlLGNhbnZhcyxzY3JpcHQsbm9zY3JpcHQsZGVsLGlucywnICtcbiAgJ2NhcHRpb24sY29sLGNvbGdyb3VwLHRhYmxlLHRoZWFkLHRib2R5LHRkLHRoLHRyLCcgK1xuICAnYnV0dG9uLGRhdGFsaXN0LGZpZWxkc2V0LGZvcm0saW5wdXQsbGFiZWwsbGVnZW5kLG1ldGVyLG9wdGdyb3VwLG9wdGlvbiwnICtcbiAgJ291dHB1dCxwcm9ncmVzcyxzZWxlY3QsdGV4dGFyZWEsJyArXG4gICdkZXRhaWxzLGRpYWxvZyxtZW51LG1lbnVpdGVtLHN1bW1hcnksJyArXG4gICdjb250ZW50LGVsZW1lbnQsc2hhZG93LHRlbXBsYXRlLGJsb2NrcXVvdGUsaWZyYW1lLHRmb290J1xuKTtcblxuLy8gdGhpcyBtYXAgaXMgaW50ZW50aW9uYWxseSBzZWxlY3RpdmUsIG9ubHkgY292ZXJpbmcgU1ZHIGVsZW1lbnRzIHRoYXQgbWF5XG4vLyBjb250YWluIGNoaWxkIGVsZW1lbnRzLlxudmFyIGlzU1ZHID0gbWFrZU1hcChcbiAgJ3N2ZyxhbmltYXRlLGNpcmNsZSxjbGlwcGF0aCxjdXJzb3IsZGVmcyxkZXNjLGVsbGlwc2UsZmlsdGVyLGZvbnQtZmFjZSwnICtcbiAgJ2ZvcmVpZ25PYmplY3QsZyxnbHlwaCxpbWFnZSxsaW5lLG1hcmtlcixtYXNrLG1pc3NpbmctZ2x5cGgscGF0aCxwYXR0ZXJuLCcgK1xuICAncG9seWdvbixwb2x5bGluZSxyZWN0LHN3aXRjaCxzeW1ib2wsdGV4dCx0ZXh0cGF0aCx0c3Bhbix1c2UsdmlldycsXG4gIHRydWVcbik7XG5cblxuXG52YXIgaXNSZXNlcnZlZFRhZyA9IGZ1bmN0aW9uICh0YWcpIHtcbiAgcmV0dXJuIGlzSFRNTFRhZyh0YWcpIHx8IGlzU1ZHKHRhZylcbn07XG5cbmZ1bmN0aW9uIGdldFRhZ05hbWVzcGFjZSAodGFnKSB7XG4gIGlmIChpc1NWRyh0YWcpKSB7XG4gICAgcmV0dXJuICdzdmcnXG4gIH1cbiAgLy8gYmFzaWMgc3VwcG9ydCBmb3IgTWF0aE1MXG4gIC8vIG5vdGUgaXQgZG9lc24ndCBzdXBwb3J0IG90aGVyIE1hdGhNTCBlbGVtZW50cyBiZWluZyBjb21wb25lbnQgcm9vdHNcbiAgaWYgKHRhZyA9PT0gJ21hdGgnKSB7XG4gICAgcmV0dXJuICdtYXRoJ1xuICB9XG59XG5cbnZhciB1bmtub3duRWxlbWVudENhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbmZ1bmN0aW9uIGlzVW5rbm93bkVsZW1lbnQgKHRhZykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCFpbkJyb3dzZXIpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIGlmIChpc1Jlc2VydmVkVGFnKHRhZykpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICB0YWcgPSB0YWcudG9Mb3dlckNhc2UoKTtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICh1bmtub3duRWxlbWVudENhY2hlW3RhZ10gIT0gbnVsbCkge1xuICAgIHJldHVybiB1bmtub3duRWxlbWVudENhY2hlW3RhZ11cbiAgfVxuICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gIGlmICh0YWcuaW5kZXhPZignLScpID4gLTEpIHtcbiAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yODIxMDM2NC8xMDcwMjQ0XG4gICAgcmV0dXJuICh1bmtub3duRWxlbWVudENhY2hlW3RhZ10gPSAoXG4gICAgICBlbC5jb25zdHJ1Y3RvciA9PT0gd2luZG93LkhUTUxVbmtub3duRWxlbWVudCB8fFxuICAgICAgZWwuY29uc3RydWN0b3IgPT09IHdpbmRvdy5IVE1MRWxlbWVudFxuICAgICkpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuICh1bmtub3duRWxlbWVudENhY2hlW3RhZ10gPSAvSFRNTFVua25vd25FbGVtZW50Ly50ZXN0KGVsLnRvU3RyaW5nKCkpKVxuICB9XG59XG5cbnZhciBpc1RleHRJbnB1dFR5cGUgPSBtYWtlTWFwKCd0ZXh0LG51bWJlcixwYXNzd29yZCxzZWFyY2gsZW1haWwsdGVsLHVybCcpO1xuXG4vKiAgKi9cblxuLyoqXG4gKiBRdWVyeSBhbiBlbGVtZW50IHNlbGVjdG9yIGlmIGl0J3Mgbm90IGFuIGVsZW1lbnQgYWxyZWFkeS5cbiAqL1xuZnVuY3Rpb24gcXVlcnkgKGVsKSB7XG4gIGlmICh0eXBlb2YgZWwgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIHNlbGVjdGVkID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihlbCk7XG4gICAgaWYgKCFzZWxlY3RlZCkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICAnQ2Fubm90IGZpbmQgZWxlbWVudDogJyArIGVsXG4gICAgICApO1xuICAgICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gICAgfVxuICAgIHJldHVybiBzZWxlY3RlZFxuICB9IGVsc2Uge1xuICAgIHJldHVybiBlbFxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50JDEgKHRhZ05hbWUsIHZub2RlKSB7XG4gIHZhciBlbG0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZ05hbWUpO1xuICBpZiAodGFnTmFtZSAhPT0gJ3NlbGVjdCcpIHtcbiAgICByZXR1cm4gZWxtXG4gIH1cbiAgLy8gZmFsc2Ugb3IgbnVsbCB3aWxsIHJlbW92ZSB0aGUgYXR0cmlidXRlIGJ1dCB1bmRlZmluZWQgd2lsbCBub3RcbiAgaWYgKHZub2RlLmRhdGEgJiYgdm5vZGUuZGF0YS5hdHRycyAmJiB2bm9kZS5kYXRhLmF0dHJzLm11bHRpcGxlICE9PSB1bmRlZmluZWQpIHtcbiAgICBlbG0uc2V0QXR0cmlidXRlKCdtdWx0aXBsZScsICdtdWx0aXBsZScpO1xuICB9XG4gIHJldHVybiBlbG1cbn1cblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudE5TIChuYW1lc3BhY2UsIHRhZ05hbWUpIHtcbiAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhuYW1lc3BhY2VNYXBbbmFtZXNwYWNlXSwgdGFnTmFtZSlcbn1cblxuZnVuY3Rpb24gY3JlYXRlVGV4dE5vZGUgKHRleHQpIHtcbiAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRleHQpXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbW1lbnQgKHRleHQpIHtcbiAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQodGV4dClcbn1cblxuZnVuY3Rpb24gaW5zZXJ0QmVmb3JlIChwYXJlbnROb2RlLCBuZXdOb2RlLCByZWZlcmVuY2VOb2RlKSB7XG4gIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5ld05vZGUsIHJlZmVyZW5jZU5vZGUpO1xufVxuXG5mdW5jdGlvbiByZW1vdmVDaGlsZCAobm9kZSwgY2hpbGQpIHtcbiAgbm9kZS5yZW1vdmVDaGlsZChjaGlsZCk7XG59XG5cbmZ1bmN0aW9uIGFwcGVuZENoaWxkIChub2RlLCBjaGlsZCkge1xuICBub2RlLmFwcGVuZENoaWxkKGNoaWxkKTtcbn1cblxuZnVuY3Rpb24gcGFyZW50Tm9kZSAobm9kZSkge1xuICByZXR1cm4gbm9kZS5wYXJlbnROb2RlXG59XG5cbmZ1bmN0aW9uIG5leHRTaWJsaW5nIChub2RlKSB7XG4gIHJldHVybiBub2RlLm5leHRTaWJsaW5nXG59XG5cbmZ1bmN0aW9uIHRhZ05hbWUgKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUudGFnTmFtZVxufVxuXG5mdW5jdGlvbiBzZXRUZXh0Q29udGVudCAobm9kZSwgdGV4dCkge1xuICBub2RlLnRleHRDb250ZW50ID0gdGV4dDtcbn1cblxuZnVuY3Rpb24gc2V0U3R5bGVTY29wZSAobm9kZSwgc2NvcGVJZCkge1xuICBub2RlLnNldEF0dHJpYnV0ZShzY29wZUlkLCAnJyk7XG59XG5cblxudmFyIG5vZGVPcHMgPSBPYmplY3QuZnJlZXplKHtcblx0Y3JlYXRlRWxlbWVudDogY3JlYXRlRWxlbWVudCQxLFxuXHRjcmVhdGVFbGVtZW50TlM6IGNyZWF0ZUVsZW1lbnROUyxcblx0Y3JlYXRlVGV4dE5vZGU6IGNyZWF0ZVRleHROb2RlLFxuXHRjcmVhdGVDb21tZW50OiBjcmVhdGVDb21tZW50LFxuXHRpbnNlcnRCZWZvcmU6IGluc2VydEJlZm9yZSxcblx0cmVtb3ZlQ2hpbGQ6IHJlbW92ZUNoaWxkLFxuXHRhcHBlbmRDaGlsZDogYXBwZW5kQ2hpbGQsXG5cdHBhcmVudE5vZGU6IHBhcmVudE5vZGUsXG5cdG5leHRTaWJsaW5nOiBuZXh0U2libGluZyxcblx0dGFnTmFtZTogdGFnTmFtZSxcblx0c2V0VGV4dENvbnRlbnQ6IHNldFRleHRDb250ZW50LFxuXHRzZXRTdHlsZVNjb3BlOiBzZXRTdHlsZVNjb3BlXG59KTtcblxuLyogICovXG5cbnZhciByZWYgPSB7XG4gIGNyZWF0ZTogZnVuY3Rpb24gY3JlYXRlIChfLCB2bm9kZSkge1xuICAgIHJlZ2lzdGVyUmVmKHZub2RlKTtcbiAgfSxcbiAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUgKG9sZFZub2RlLCB2bm9kZSkge1xuICAgIGlmIChvbGRWbm9kZS5kYXRhLnJlZiAhPT0gdm5vZGUuZGF0YS5yZWYpIHtcbiAgICAgIHJlZ2lzdGVyUmVmKG9sZFZub2RlLCB0cnVlKTtcbiAgICAgIHJlZ2lzdGVyUmVmKHZub2RlKTtcbiAgICB9XG4gIH0sXG4gIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3kgKHZub2RlKSB7XG4gICAgcmVnaXN0ZXJSZWYodm5vZGUsIHRydWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlZ2lzdGVyUmVmICh2bm9kZSwgaXNSZW1vdmFsKSB7XG4gIHZhciBrZXkgPSB2bm9kZS5kYXRhLnJlZjtcbiAgaWYgKCFpc0RlZihrZXkpKSB7IHJldHVybiB9XG5cbiAgdmFyIHZtID0gdm5vZGUuY29udGV4dDtcbiAgdmFyIHJlZiA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlIHx8IHZub2RlLmVsbTtcbiAgdmFyIHJlZnMgPSB2bS4kcmVmcztcbiAgaWYgKGlzUmVtb3ZhbCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHJlZnNba2V5XSkpIHtcbiAgICAgIHJlbW92ZShyZWZzW2tleV0sIHJlZik7XG4gICAgfSBlbHNlIGlmIChyZWZzW2tleV0gPT09IHJlZikge1xuICAgICAgcmVmc1trZXldID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAodm5vZGUuZGF0YS5yZWZJbkZvcikge1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHJlZnNba2V5XSkpIHtcbiAgICAgICAgcmVmc1trZXldID0gW3JlZl07XG4gICAgICB9IGVsc2UgaWYgKHJlZnNba2V5XS5pbmRleE9mKHJlZikgPCAwKSB7XG4gICAgICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgICAgICByZWZzW2tleV0ucHVzaChyZWYpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZWZzW2tleV0gPSByZWY7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogVmlydHVhbCBET00gcGF0Y2hpbmcgYWxnb3JpdGhtIGJhc2VkIG9uIFNuYWJiZG9tIGJ5XG4gKiBTaW1vbiBGcmlpcyBWaW5kdW0gKEBwYWxkZXBpbmQpXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2VcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9wYWxkZXBpbmQvc25hYmJkb20vYmxvYi9tYXN0ZXIvTElDRU5TRVxuICpcbiAqIG1vZGlmaWVkIGJ5IEV2YW4gWW91IChAeXl4OTkwODAzKVxuICpcbiAqIE5vdCB0eXBlLWNoZWNraW5nIHRoaXMgYmVjYXVzZSB0aGlzIGZpbGUgaXMgcGVyZi1jcml0aWNhbCBhbmQgdGhlIGNvc3RcbiAqIG9mIG1ha2luZyBmbG93IHVuZGVyc3RhbmQgaXQgaXMgbm90IHdvcnRoIGl0LlxuICovXG5cbnZhciBlbXB0eU5vZGUgPSBuZXcgVk5vZGUoJycsIHt9LCBbXSk7XG5cbnZhciBob29rcyA9IFsnY3JlYXRlJywgJ2FjdGl2YXRlJywgJ3VwZGF0ZScsICdyZW1vdmUnLCAnZGVzdHJveSddO1xuXG5mdW5jdGlvbiBzYW1lVm5vZGUgKGEsIGIpIHtcbiAgcmV0dXJuIChcbiAgICBhLmtleSA9PT0gYi5rZXkgJiYgKFxuICAgICAgKFxuICAgICAgICBhLnRhZyA9PT0gYi50YWcgJiZcbiAgICAgICAgYS5pc0NvbW1lbnQgPT09IGIuaXNDb21tZW50ICYmXG4gICAgICAgIGlzRGVmKGEuZGF0YSkgPT09IGlzRGVmKGIuZGF0YSkgJiZcbiAgICAgICAgc2FtZUlucHV0VHlwZShhLCBiKVxuICAgICAgKSB8fCAoXG4gICAgICAgIGlzVHJ1ZShhLmlzQXN5bmNQbGFjZWhvbGRlcikgJiZcbiAgICAgICAgYS5hc3luY0ZhY3RvcnkgPT09IGIuYXN5bmNGYWN0b3J5ICYmXG4gICAgICAgIGlzVW5kZWYoYi5hc3luY0ZhY3RvcnkuZXJyb3IpXG4gICAgICApXG4gICAgKVxuICApXG59XG5cbmZ1bmN0aW9uIHNhbWVJbnB1dFR5cGUgKGEsIGIpIHtcbiAgaWYgKGEudGFnICE9PSAnaW5wdXQnKSB7IHJldHVybiB0cnVlIH1cbiAgdmFyIGk7XG4gIHZhciB0eXBlQSA9IGlzRGVmKGkgPSBhLmRhdGEpICYmIGlzRGVmKGkgPSBpLmF0dHJzKSAmJiBpLnR5cGU7XG4gIHZhciB0eXBlQiA9IGlzRGVmKGkgPSBiLmRhdGEpICYmIGlzRGVmKGkgPSBpLmF0dHJzKSAmJiBpLnR5cGU7XG4gIHJldHVybiB0eXBlQSA9PT0gdHlwZUIgfHwgaXNUZXh0SW5wdXRUeXBlKHR5cGVBKSAmJiBpc1RleHRJbnB1dFR5cGUodHlwZUIpXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUtleVRvT2xkSWR4IChjaGlsZHJlbiwgYmVnaW5JZHgsIGVuZElkeCkge1xuICB2YXIgaSwga2V5O1xuICB2YXIgbWFwID0ge307XG4gIGZvciAoaSA9IGJlZ2luSWR4OyBpIDw9IGVuZElkeDsgKytpKSB7XG4gICAga2V5ID0gY2hpbGRyZW5baV0ua2V5O1xuICAgIGlmIChpc0RlZihrZXkpKSB7IG1hcFtrZXldID0gaTsgfVxuICB9XG4gIHJldHVybiBtYXBcbn1cblxuZnVuY3Rpb24gY3JlYXRlUGF0Y2hGdW5jdGlvbiAoYmFja2VuZCkge1xuICB2YXIgaSwgajtcbiAgdmFyIGNicyA9IHt9O1xuXG4gIHZhciBtb2R1bGVzID0gYmFja2VuZC5tb2R1bGVzO1xuICB2YXIgbm9kZU9wcyA9IGJhY2tlbmQubm9kZU9wcztcblxuICBmb3IgKGkgPSAwOyBpIDwgaG9va3MubGVuZ3RoOyArK2kpIHtcbiAgICBjYnNbaG9va3NbaV1dID0gW107XG4gICAgZm9yIChqID0gMDsgaiA8IG1vZHVsZXMubGVuZ3RoOyArK2opIHtcbiAgICAgIGlmIChpc0RlZihtb2R1bGVzW2pdW2hvb2tzW2ldXSkpIHtcbiAgICAgICAgY2JzW2hvb2tzW2ldXS5wdXNoKG1vZHVsZXNbal1baG9va3NbaV1dKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBlbXB0eU5vZGVBdCAoZWxtKSB7XG4gICAgcmV0dXJuIG5ldyBWTm9kZShub2RlT3BzLnRhZ05hbWUoZWxtKS50b0xvd2VyQ2FzZSgpLCB7fSwgW10sIHVuZGVmaW5lZCwgZWxtKVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlUm1DYiAoY2hpbGRFbG0sIGxpc3RlbmVycykge1xuICAgIGZ1bmN0aW9uIHJlbW92ZSAoKSB7XG4gICAgICBpZiAoLS1yZW1vdmUubGlzdGVuZXJzID09PSAwKSB7XG4gICAgICAgIHJlbW92ZU5vZGUoY2hpbGRFbG0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZW1vdmUubGlzdGVuZXJzID0gbGlzdGVuZXJzO1xuICAgIHJldHVybiByZW1vdmVcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZU5vZGUgKGVsKSB7XG4gICAgdmFyIHBhcmVudCA9IG5vZGVPcHMucGFyZW50Tm9kZShlbCk7XG4gICAgLy8gZWxlbWVudCBtYXkgaGF2ZSBhbHJlYWR5IGJlZW4gcmVtb3ZlZCBkdWUgdG8gdi1odG1sIC8gdi10ZXh0XG4gICAgaWYgKGlzRGVmKHBhcmVudCkpIHtcbiAgICAgIG5vZGVPcHMucmVtb3ZlQ2hpbGQocGFyZW50LCBlbCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNVbmtub3duRWxlbWVudCQkMSAodm5vZGUsIGluVlByZSkge1xuICAgIHJldHVybiAoXG4gICAgICAhaW5WUHJlICYmXG4gICAgICAhdm5vZGUubnMgJiZcbiAgICAgICEoXG4gICAgICAgIGNvbmZpZy5pZ25vcmVkRWxlbWVudHMubGVuZ3RoICYmXG4gICAgICAgIGNvbmZpZy5pZ25vcmVkRWxlbWVudHMuc29tZShmdW5jdGlvbiAoaWdub3JlKSB7XG4gICAgICAgICAgcmV0dXJuIGlzUmVnRXhwKGlnbm9yZSlcbiAgICAgICAgICAgID8gaWdub3JlLnRlc3Qodm5vZGUudGFnKVxuICAgICAgICAgICAgOiBpZ25vcmUgPT09IHZub2RlLnRhZ1xuICAgICAgICB9KVxuICAgICAgKSAmJlxuICAgICAgY29uZmlnLmlzVW5rbm93bkVsZW1lbnQodm5vZGUudGFnKVxuICAgIClcbiAgfVxuXG4gIHZhciBjcmVhdGluZ0VsbUluVlByZSA9IDA7XG5cbiAgZnVuY3Rpb24gY3JlYXRlRWxtIChcbiAgICB2bm9kZSxcbiAgICBpbnNlcnRlZFZub2RlUXVldWUsXG4gICAgcGFyZW50RWxtLFxuICAgIHJlZkVsbSxcbiAgICBuZXN0ZWQsXG4gICAgb3duZXJBcnJheSxcbiAgICBpbmRleFxuICApIHtcbiAgICBpZiAoaXNEZWYodm5vZGUuZWxtKSAmJiBpc0RlZihvd25lckFycmF5KSkge1xuICAgICAgLy8gVGhpcyB2bm9kZSB3YXMgdXNlZCBpbiBhIHByZXZpb3VzIHJlbmRlciFcbiAgICAgIC8vIG5vdyBpdCdzIHVzZWQgYXMgYSBuZXcgbm9kZSwgb3ZlcndyaXRpbmcgaXRzIGVsbSB3b3VsZCBjYXVzZVxuICAgICAgLy8gcG90ZW50aWFsIHBhdGNoIGVycm9ycyBkb3duIHRoZSByb2FkIHdoZW4gaXQncyB1c2VkIGFzIGFuIGluc2VydGlvblxuICAgICAgLy8gcmVmZXJlbmNlIG5vZGUuIEluc3RlYWQsIHdlIGNsb25lIHRoZSBub2RlIG9uLWRlbWFuZCBiZWZvcmUgY3JlYXRpbmdcbiAgICAgIC8vIGFzc29jaWF0ZWQgRE9NIGVsZW1lbnQgZm9yIGl0LlxuICAgICAgdm5vZGUgPSBvd25lckFycmF5W2luZGV4XSA9IGNsb25lVk5vZGUodm5vZGUpO1xuICAgIH1cblxuICAgIHZub2RlLmlzUm9vdEluc2VydCA9ICFuZXN0ZWQ7IC8vIGZvciB0cmFuc2l0aW9uIGVudGVyIGNoZWNrXG4gICAgaWYgKGNyZWF0ZUNvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICB2YXIgY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlbjtcbiAgICB2YXIgdGFnID0gdm5vZGUudGFnO1xuICAgIGlmIChpc0RlZih0YWcpKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBpZiAoZGF0YSAmJiBkYXRhLnByZSkge1xuICAgICAgICAgIGNyZWF0aW5nRWxtSW5WUHJlKys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzVW5rbm93bkVsZW1lbnQkJDEodm5vZGUsIGNyZWF0aW5nRWxtSW5WUHJlKSkge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAnVW5rbm93biBjdXN0b20gZWxlbWVudDogPCcgKyB0YWcgKyAnPiAtIGRpZCB5b3UgJyArXG4gICAgICAgICAgICAncmVnaXN0ZXIgdGhlIGNvbXBvbmVudCBjb3JyZWN0bHk/IEZvciByZWN1cnNpdmUgY29tcG9uZW50cywgJyArXG4gICAgICAgICAgICAnbWFrZSBzdXJlIHRvIHByb3ZpZGUgdGhlIFwibmFtZVwiIG9wdGlvbi4nLFxuICAgICAgICAgICAgdm5vZGUuY29udGV4dFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdm5vZGUuZWxtID0gdm5vZGUubnNcbiAgICAgICAgPyBub2RlT3BzLmNyZWF0ZUVsZW1lbnROUyh2bm9kZS5ucywgdGFnKVxuICAgICAgICA6IG5vZGVPcHMuY3JlYXRlRWxlbWVudCh0YWcsIHZub2RlKTtcbiAgICAgIHNldFNjb3BlKHZub2RlKTtcblxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICB7XG4gICAgICAgIGNyZWF0ZUNoaWxkcmVuKHZub2RlLCBjaGlsZHJlbiwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICAgICAgaW52b2tlQ3JlYXRlSG9va3Modm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBkYXRhICYmIGRhdGEucHJlKSB7XG4gICAgICAgIGNyZWF0aW5nRWxtSW5WUHJlLS07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1RydWUodm5vZGUuaXNDb21tZW50KSkge1xuICAgICAgdm5vZGUuZWxtID0gbm9kZU9wcy5jcmVhdGVDb21tZW50KHZub2RlLnRleHQpO1xuICAgICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2bm9kZS5lbG0gPSBub2RlT3BzLmNyZWF0ZVRleHROb2RlKHZub2RlLnRleHQpO1xuICAgICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudCAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pIHtcbiAgICB2YXIgaSA9IHZub2RlLmRhdGE7XG4gICAgaWYgKGlzRGVmKGkpKSB7XG4gICAgICB2YXIgaXNSZWFjdGl2YXRlZCA9IGlzRGVmKHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSAmJiBpLmtlZXBBbGl2ZTtcbiAgICAgIGlmIChpc0RlZihpID0gaS5ob29rKSAmJiBpc0RlZihpID0gaS5pbml0KSkge1xuICAgICAgICBpKHZub2RlLCBmYWxzZSAvKiBoeWRyYXRpbmcgKi8sIHBhcmVudEVsbSwgcmVmRWxtKTtcbiAgICAgIH1cbiAgICAgIC8vIGFmdGVyIGNhbGxpbmcgdGhlIGluaXQgaG9vaywgaWYgdGhlIHZub2RlIGlzIGEgY2hpbGQgY29tcG9uZW50XG4gICAgICAvLyBpdCBzaG91bGQndmUgY3JlYXRlZCBhIGNoaWxkIGluc3RhbmNlIGFuZCBtb3VudGVkIGl0LiB0aGUgY2hpbGRcbiAgICAgIC8vIGNvbXBvbmVudCBhbHNvIGhhcyBzZXQgdGhlIHBsYWNlaG9sZGVyIHZub2RlJ3MgZWxtLlxuICAgICAgLy8gaW4gdGhhdCBjYXNlIHdlIGNhbiBqdXN0IHJldHVybiB0aGUgZWxlbWVudCBhbmQgYmUgZG9uZS5cbiAgICAgIGlmIChpc0RlZih2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkpIHtcbiAgICAgICAgaW5pdENvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgaWYgKGlzVHJ1ZShpc1JlYWN0aXZhdGVkKSkge1xuICAgICAgICAgIHJlYWN0aXZhdGVDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW5pdENvbXBvbmVudCAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgIGlmIChpc0RlZih2bm9kZS5kYXRhLnBlbmRpbmdJbnNlcnQpKSB7XG4gICAgICBpbnNlcnRlZFZub2RlUXVldWUucHVzaC5hcHBseShpbnNlcnRlZFZub2RlUXVldWUsIHZub2RlLmRhdGEucGVuZGluZ0luc2VydCk7XG4gICAgICB2bm9kZS5kYXRhLnBlbmRpbmdJbnNlcnQgPSBudWxsO1xuICAgIH1cbiAgICB2bm9kZS5lbG0gPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZS4kZWw7XG4gICAgaWYgKGlzUGF0Y2hhYmxlKHZub2RlKSkge1xuICAgICAgaW52b2tlQ3JlYXRlSG9va3Modm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICBzZXRTY29wZSh2bm9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGVtcHR5IGNvbXBvbmVudCByb290LlxuICAgICAgLy8gc2tpcCBhbGwgZWxlbWVudC1yZWxhdGVkIG1vZHVsZXMgZXhjZXB0IGZvciByZWYgKCMzNDU1KVxuICAgICAgcmVnaXN0ZXJSZWYodm5vZGUpO1xuICAgICAgLy8gbWFrZSBzdXJlIHRvIGludm9rZSB0aGUgaW5zZXJ0IGhvb2tcbiAgICAgIGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoKHZub2RlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWFjdGl2YXRlQ29tcG9uZW50ICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSkge1xuICAgIHZhciBpO1xuICAgIC8vIGhhY2sgZm9yICM0MzM5OiBhIHJlYWN0aXZhdGVkIGNvbXBvbmVudCB3aXRoIGlubmVyIHRyYW5zaXRpb25cbiAgICAvLyBkb2VzIG5vdCB0cmlnZ2VyIGJlY2F1c2UgdGhlIGlubmVyIG5vZGUncyBjcmVhdGVkIGhvb2tzIGFyZSBub3QgY2FsbGVkXG4gICAgLy8gYWdhaW4uIEl0J3Mgbm90IGlkZWFsIHRvIGludm9sdmUgbW9kdWxlLXNwZWNpZmljIGxvZ2ljIGluIGhlcmUgYnV0XG4gICAgLy8gdGhlcmUgZG9lc24ndCBzZWVtIHRvIGJlIGEgYmV0dGVyIHdheSB0byBkbyBpdC5cbiAgICB2YXIgaW5uZXJOb2RlID0gdm5vZGU7XG4gICAgd2hpbGUgKGlubmVyTm9kZS5jb21wb25lbnRJbnN0YW5jZSkge1xuICAgICAgaW5uZXJOb2RlID0gaW5uZXJOb2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcbiAgICAgIGlmIChpc0RlZihpID0gaW5uZXJOb2RlLmRhdGEpICYmIGlzRGVmKGkgPSBpLnRyYW5zaXRpb24pKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMuYWN0aXZhdGUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBjYnMuYWN0aXZhdGVbaV0oZW1wdHlOb2RlLCBpbm5lck5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoKGlubmVyTm9kZSk7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICAgIC8vIHVubGlrZSBhIG5ld2x5IGNyZWF0ZWQgY29tcG9uZW50LFxuICAgIC8vIGEgcmVhY3RpdmF0ZWQga2VlcC1hbGl2ZSBjb21wb25lbnQgZG9lc24ndCBpbnNlcnQgaXRzZWxmXG4gICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5zZXJ0IChwYXJlbnQsIGVsbSwgcmVmJCQxKSB7XG4gICAgaWYgKGlzRGVmKHBhcmVudCkpIHtcbiAgICAgIGlmIChpc0RlZihyZWYkJDEpKSB7XG4gICAgICAgIGlmIChyZWYkJDEucGFyZW50Tm9kZSA9PT0gcGFyZW50KSB7XG4gICAgICAgICAgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50LCBlbG0sIHJlZiQkMSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGVPcHMuYXBwZW5kQ2hpbGQocGFyZW50LCBlbG0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNoaWxkcmVuICh2bm9kZSwgY2hpbGRyZW4sIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgY2hlY2tEdXBsaWNhdGVLZXlzKGNoaWxkcmVuKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY3JlYXRlRWxtKGNoaWxkcmVuW2ldLCBpbnNlcnRlZFZub2RlUXVldWUsIHZub2RlLmVsbSwgbnVsbCwgdHJ1ZSwgY2hpbGRyZW4sIGkpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNQcmltaXRpdmUodm5vZGUudGV4dCkpIHtcbiAgICAgIG5vZGVPcHMuYXBwZW5kQ2hpbGQodm5vZGUuZWxtLCBub2RlT3BzLmNyZWF0ZVRleHROb2RlKFN0cmluZyh2bm9kZS50ZXh0KSkpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzUGF0Y2hhYmxlICh2bm9kZSkge1xuICAgIHdoaWxlICh2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkge1xuICAgICAgdm5vZGUgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGU7XG4gICAgfVxuICAgIHJldHVybiBpc0RlZih2bm9kZS50YWcpXG4gIH1cblxuICBmdW5jdGlvbiBpbnZva2VDcmVhdGVIb29rcyAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGNicy5jcmVhdGUubGVuZ3RoOyArK2kkMSkge1xuICAgICAgY2JzLmNyZWF0ZVtpJDFdKGVtcHR5Tm9kZSwgdm5vZGUpO1xuICAgIH1cbiAgICBpID0gdm5vZGUuZGF0YS5ob29rOyAvLyBSZXVzZSB2YXJpYWJsZVxuICAgIGlmIChpc0RlZihpKSkge1xuICAgICAgaWYgKGlzRGVmKGkuY3JlYXRlKSkgeyBpLmNyZWF0ZShlbXB0eU5vZGUsIHZub2RlKTsgfVxuICAgICAgaWYgKGlzRGVmKGkuaW5zZXJ0KSkgeyBpbnNlcnRlZFZub2RlUXVldWUucHVzaCh2bm9kZSk7IH1cbiAgICB9XG4gIH1cblxuICAvLyBzZXQgc2NvcGUgaWQgYXR0cmlidXRlIGZvciBzY29wZWQgQ1NTLlxuICAvLyB0aGlzIGlzIGltcGxlbWVudGVkIGFzIGEgc3BlY2lhbCBjYXNlIHRvIGF2b2lkIHRoZSBvdmVyaGVhZFxuICAvLyBvZiBnb2luZyB0aHJvdWdoIHRoZSBub3JtYWwgYXR0cmlidXRlIHBhdGNoaW5nIHByb2Nlc3MuXG4gIGZ1bmN0aW9uIHNldFNjb3BlICh2bm9kZSkge1xuICAgIHZhciBpO1xuICAgIGlmIChpc0RlZihpID0gdm5vZGUuZm5TY29wZUlkKSkge1xuICAgICAgbm9kZU9wcy5zZXRTdHlsZVNjb3BlKHZub2RlLmVsbSwgaSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBhbmNlc3RvciA9IHZub2RlO1xuICAgICAgd2hpbGUgKGFuY2VzdG9yKSB7XG4gICAgICAgIGlmIChpc0RlZihpID0gYW5jZXN0b3IuY29udGV4dCkgJiYgaXNEZWYoaSA9IGkuJG9wdGlvbnMuX3Njb3BlSWQpKSB7XG4gICAgICAgICAgbm9kZU9wcy5zZXRTdHlsZVNjb3BlKHZub2RlLmVsbSwgaSk7XG4gICAgICAgIH1cbiAgICAgICAgYW5jZXN0b3IgPSBhbmNlc3Rvci5wYXJlbnQ7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGZvciBzbG90IGNvbnRlbnQgdGhleSBzaG91bGQgYWxzbyBnZXQgdGhlIHNjb3BlSWQgZnJvbSB0aGUgaG9zdCBpbnN0YW5jZS5cbiAgICBpZiAoaXNEZWYoaSA9IGFjdGl2ZUluc3RhbmNlKSAmJlxuICAgICAgaSAhPT0gdm5vZGUuY29udGV4dCAmJlxuICAgICAgaSAhPT0gdm5vZGUuZm5Db250ZXh0ICYmXG4gICAgICBpc0RlZihpID0gaS4kb3B0aW9ucy5fc2NvcGVJZClcbiAgICApIHtcbiAgICAgIG5vZGVPcHMuc2V0U3R5bGVTY29wZSh2bm9kZS5lbG0sIGkpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZFZub2RlcyAocGFyZW50RWxtLCByZWZFbG0sIHZub2Rlcywgc3RhcnRJZHgsIGVuZElkeCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgZm9yICg7IHN0YXJ0SWR4IDw9IGVuZElkeDsgKytzdGFydElkeCkge1xuICAgICAgY3JlYXRlRWxtKHZub2Rlc1tzdGFydElkeF0sIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0sIGZhbHNlLCB2bm9kZXMsIHN0YXJ0SWR4KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbnZva2VEZXN0cm95SG9vayAodm5vZGUpIHtcbiAgICB2YXIgaSwgajtcbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkuZGVzdHJveSkpIHsgaSh2bm9kZSk7IH1cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMuZGVzdHJveS5sZW5ndGg7ICsraSkgeyBjYnMuZGVzdHJveVtpXSh2bm9kZSk7IH1cbiAgICB9XG4gICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5jaGlsZHJlbikpIHtcbiAgICAgIGZvciAoaiA9IDA7IGogPCB2bm9kZS5jaGlsZHJlbi5sZW5ndGg7ICsraikge1xuICAgICAgICBpbnZva2VEZXN0cm95SG9vayh2bm9kZS5jaGlsZHJlbltqXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlVm5vZGVzIChwYXJlbnRFbG0sIHZub2Rlcywgc3RhcnRJZHgsIGVuZElkeCkge1xuICAgIGZvciAoOyBzdGFydElkeCA8PSBlbmRJZHg7ICsrc3RhcnRJZHgpIHtcbiAgICAgIHZhciBjaCA9IHZub2Rlc1tzdGFydElkeF07XG4gICAgICBpZiAoaXNEZWYoY2gpKSB7XG4gICAgICAgIGlmIChpc0RlZihjaC50YWcpKSB7XG4gICAgICAgICAgcmVtb3ZlQW5kSW52b2tlUmVtb3ZlSG9vayhjaCk7XG4gICAgICAgICAgaW52b2tlRGVzdHJveUhvb2soY2gpO1xuICAgICAgICB9IGVsc2UgeyAvLyBUZXh0IG5vZGVcbiAgICAgICAgICByZW1vdmVOb2RlKGNoLmVsbSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rICh2bm9kZSwgcm0pIHtcbiAgICBpZiAoaXNEZWYocm0pIHx8IGlzRGVmKHZub2RlLmRhdGEpKSB7XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsaXN0ZW5lcnMgPSBjYnMucmVtb3ZlLmxlbmd0aCArIDE7XG4gICAgICBpZiAoaXNEZWYocm0pKSB7XG4gICAgICAgIC8vIHdlIGhhdmUgYSByZWN1cnNpdmVseSBwYXNzZWQgZG93biBybSBjYWxsYmFja1xuICAgICAgICAvLyBpbmNyZWFzZSB0aGUgbGlzdGVuZXJzIGNvdW50XG4gICAgICAgIHJtLmxpc3RlbmVycyArPSBsaXN0ZW5lcnM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkaXJlY3RseSByZW1vdmluZ1xuICAgICAgICBybSA9IGNyZWF0ZVJtQ2Iodm5vZGUuZWxtLCBsaXN0ZW5lcnMpO1xuICAgICAgfVxuICAgICAgLy8gcmVjdXJzaXZlbHkgaW52b2tlIGhvb2tzIG9uIGNoaWxkIGNvbXBvbmVudCByb290IG5vZGVcbiAgICAgIGlmIChpc0RlZihpID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UpICYmIGlzRGVmKGkgPSBpLl92bm9kZSkgJiYgaXNEZWYoaS5kYXRhKSkge1xuICAgICAgICByZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rKGksIHJtKTtcbiAgICAgIH1cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMucmVtb3ZlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNicy5yZW1vdmVbaV0odm5vZGUsIHJtKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0RlZihpID0gdm5vZGUuZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5yZW1vdmUpKSB7XG4gICAgICAgIGkodm5vZGUsIHJtKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJtKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbW92ZU5vZGUodm5vZGUuZWxtKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVDaGlsZHJlbiAocGFyZW50RWxtLCBvbGRDaCwgbmV3Q2gsIGluc2VydGVkVm5vZGVRdWV1ZSwgcmVtb3ZlT25seSkge1xuICAgIHZhciBvbGRTdGFydElkeCA9IDA7XG4gICAgdmFyIG5ld1N0YXJ0SWR4ID0gMDtcbiAgICB2YXIgb2xkRW5kSWR4ID0gb2xkQ2gubGVuZ3RoIC0gMTtcbiAgICB2YXIgb2xkU3RhcnRWbm9kZSA9IG9sZENoWzBdO1xuICAgIHZhciBvbGRFbmRWbm9kZSA9IG9sZENoW29sZEVuZElkeF07XG4gICAgdmFyIG5ld0VuZElkeCA9IG5ld0NoLmxlbmd0aCAtIDE7XG4gICAgdmFyIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFswXTtcbiAgICB2YXIgbmV3RW5kVm5vZGUgPSBuZXdDaFtuZXdFbmRJZHhdO1xuICAgIHZhciBvbGRLZXlUb0lkeCwgaWR4SW5PbGQsIHZub2RlVG9Nb3ZlLCByZWZFbG07XG5cbiAgICAvLyByZW1vdmVPbmx5IGlzIGEgc3BlY2lhbCBmbGFnIHVzZWQgb25seSBieSA8dHJhbnNpdGlvbi1ncm91cD5cbiAgICAvLyB0byBlbnN1cmUgcmVtb3ZlZCBlbGVtZW50cyBzdGF5IGluIGNvcnJlY3QgcmVsYXRpdmUgcG9zaXRpb25zXG4gICAgLy8gZHVyaW5nIGxlYXZpbmcgdHJhbnNpdGlvbnNcbiAgICB2YXIgY2FuTW92ZSA9ICFyZW1vdmVPbmx5O1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGNoZWNrRHVwbGljYXRlS2V5cyhuZXdDaCk7XG4gICAgfVxuXG4gICAgd2hpbGUgKG9sZFN0YXJ0SWR4IDw9IG9sZEVuZElkeCAmJiBuZXdTdGFydElkeCA8PSBuZXdFbmRJZHgpIHtcbiAgICAgIGlmIChpc1VuZGVmKG9sZFN0YXJ0Vm5vZGUpKSB7XG4gICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTsgLy8gVm5vZGUgaGFzIGJlZW4gbW92ZWQgbGVmdFxuICAgICAgfSBlbHNlIGlmIChpc1VuZGVmKG9sZEVuZFZub2RlKSkge1xuICAgICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld1N0YXJ0Vm5vZGUpKSB7XG4gICAgICAgIHBhdGNoVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgb2xkU3RhcnRWbm9kZSA9IG9sZENoWysrb2xkU3RhcnRJZHhdO1xuICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRFbmRWbm9kZSwgbmV3RW5kVm5vZGUpKSB7XG4gICAgICAgIHBhdGNoVm5vZGUob2xkRW5kVm5vZGUsIG5ld0VuZFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcbiAgICAgICAgbmV3RW5kVm5vZGUgPSBuZXdDaFstLW5ld0VuZElkeF07XG4gICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRTdGFydFZub2RlLCBuZXdFbmRWbm9kZSkpIHsgLy8gVm5vZGUgbW92ZWQgcmlnaHRcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRTdGFydFZub2RlLCBuZXdFbmRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgY2FuTW92ZSAmJiBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtLCBub2RlT3BzLm5leHRTaWJsaW5nKG9sZEVuZFZub2RlLmVsbSkpO1xuICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07XG4gICAgICAgIG5ld0VuZFZub2RlID0gbmV3Q2hbLS1uZXdFbmRJZHhdO1xuICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkRW5kVm5vZGUsIG5ld1N0YXJ0Vm5vZGUpKSB7IC8vIFZub2RlIG1vdmVkIGxlZnRcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRFbmRWbm9kZSwgbmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgY2FuTW92ZSAmJiBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIG9sZEVuZFZub2RlLmVsbSwgb2xkU3RhcnRWbm9kZS5lbG0pO1xuICAgICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcbiAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzVW5kZWYob2xkS2V5VG9JZHgpKSB7IG9sZEtleVRvSWR4ID0gY3JlYXRlS2V5VG9PbGRJZHgob2xkQ2gsIG9sZFN0YXJ0SWR4LCBvbGRFbmRJZHgpOyB9XG4gICAgICAgIGlkeEluT2xkID0gaXNEZWYobmV3U3RhcnRWbm9kZS5rZXkpXG4gICAgICAgICAgPyBvbGRLZXlUb0lkeFtuZXdTdGFydFZub2RlLmtleV1cbiAgICAgICAgICA6IGZpbmRJZHhJbk9sZChuZXdTdGFydFZub2RlLCBvbGRDaCwgb2xkU3RhcnRJZHgsIG9sZEVuZElkeCk7XG4gICAgICAgIGlmIChpc1VuZGVmKGlkeEluT2xkKSkgeyAvLyBOZXcgZWxlbWVudFxuICAgICAgICAgIGNyZWF0ZUVsbShuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgb2xkU3RhcnRWbm9kZS5lbG0sIGZhbHNlLCBuZXdDaCwgbmV3U3RhcnRJZHgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZub2RlVG9Nb3ZlID0gb2xkQ2hbaWR4SW5PbGRdO1xuICAgICAgICAgIGlmIChzYW1lVm5vZGUodm5vZGVUb01vdmUsIG5ld1N0YXJ0Vm5vZGUpKSB7XG4gICAgICAgICAgICBwYXRjaFZub2RlKHZub2RlVG9Nb3ZlLCBuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICAgICAgb2xkQ2hbaWR4SW5PbGRdID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgY2FuTW92ZSAmJiBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIHZub2RlVG9Nb3ZlLmVsbSwgb2xkU3RhcnRWbm9kZS5lbG0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBzYW1lIGtleSBidXQgZGlmZmVyZW50IGVsZW1lbnQuIHRyZWF0IGFzIG5ldyBlbGVtZW50XG4gICAgICAgICAgICBjcmVhdGVFbG0obmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtLCBmYWxzZSwgbmV3Q2gsIG5ld1N0YXJ0SWR4KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAob2xkU3RhcnRJZHggPiBvbGRFbmRJZHgpIHtcbiAgICAgIHJlZkVsbSA9IGlzVW5kZWYobmV3Q2hbbmV3RW5kSWR4ICsgMV0pID8gbnVsbCA6IG5ld0NoW25ld0VuZElkeCArIDFdLmVsbTtcbiAgICAgIGFkZFZub2RlcyhwYXJlbnRFbG0sIHJlZkVsbSwgbmV3Q2gsIG5ld1N0YXJ0SWR4LCBuZXdFbmRJZHgsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgfSBlbHNlIGlmIChuZXdTdGFydElkeCA+IG5ld0VuZElkeCkge1xuICAgICAgcmVtb3ZlVm5vZGVzKHBhcmVudEVsbSwgb2xkQ2gsIG9sZFN0YXJ0SWR4LCBvbGRFbmRJZHgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNoZWNrRHVwbGljYXRlS2V5cyAoY2hpbGRyZW4pIHtcbiAgICB2YXIgc2VlbktleXMgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdm5vZGUgPSBjaGlsZHJlbltpXTtcbiAgICAgIHZhciBrZXkgPSB2bm9kZS5rZXk7XG4gICAgICBpZiAoaXNEZWYoa2V5KSkge1xuICAgICAgICBpZiAoc2VlbktleXNba2V5XSkge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAoXCJEdXBsaWNhdGUga2V5cyBkZXRlY3RlZDogJ1wiICsga2V5ICsgXCInLiBUaGlzIG1heSBjYXVzZSBhbiB1cGRhdGUgZXJyb3IuXCIpLFxuICAgICAgICAgICAgdm5vZGUuY29udGV4dFxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2VlbktleXNba2V5XSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBmaW5kSWR4SW5PbGQgKG5vZGUsIG9sZENoLCBzdGFydCwgZW5kKSB7XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgIHZhciBjID0gb2xkQ2hbaV07XG4gICAgICBpZiAoaXNEZWYoYykgJiYgc2FtZVZub2RlKG5vZGUsIGMpKSB7IHJldHVybiBpIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwYXRjaFZub2RlIChvbGRWbm9kZSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcmVtb3ZlT25seSkge1xuICAgIGlmIChvbGRWbm9kZSA9PT0gdm5vZGUpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHZhciBlbG0gPSB2bm9kZS5lbG0gPSBvbGRWbm9kZS5lbG07XG5cbiAgICBpZiAoaXNUcnVlKG9sZFZub2RlLmlzQXN5bmNQbGFjZWhvbGRlcikpIHtcbiAgICAgIGlmIChpc0RlZih2bm9kZS5hc3luY0ZhY3RvcnkucmVzb2x2ZWQpKSB7XG4gICAgICAgIGh5ZHJhdGUob2xkVm5vZGUuZWxtLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZub2RlLmlzQXN5bmNQbGFjZWhvbGRlciA9IHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyByZXVzZSBlbGVtZW50IGZvciBzdGF0aWMgdHJlZXMuXG4gICAgLy8gbm90ZSB3ZSBvbmx5IGRvIHRoaXMgaWYgdGhlIHZub2RlIGlzIGNsb25lZCAtXG4gICAgLy8gaWYgdGhlIG5ldyBub2RlIGlzIG5vdCBjbG9uZWQgaXQgbWVhbnMgdGhlIHJlbmRlciBmdW5jdGlvbnMgaGF2ZSBiZWVuXG4gICAgLy8gcmVzZXQgYnkgdGhlIGhvdC1yZWxvYWQtYXBpIGFuZCB3ZSBuZWVkIHRvIGRvIGEgcHJvcGVyIHJlLXJlbmRlci5cbiAgICBpZiAoaXNUcnVlKHZub2RlLmlzU3RhdGljKSAmJlxuICAgICAgaXNUcnVlKG9sZFZub2RlLmlzU3RhdGljKSAmJlxuICAgICAgdm5vZGUua2V5ID09PSBvbGRWbm9kZS5rZXkgJiZcbiAgICAgIChpc1RydWUodm5vZGUuaXNDbG9uZWQpIHx8IGlzVHJ1ZSh2bm9kZS5pc09uY2UpKVxuICAgICkge1xuICAgICAgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSBvbGRWbm9kZS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHZhciBpO1xuICAgIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICBpZiAoaXNEZWYoZGF0YSkgJiYgaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkucHJlcGF0Y2gpKSB7XG4gICAgICBpKG9sZFZub2RlLCB2bm9kZSk7XG4gICAgfVxuXG4gICAgdmFyIG9sZENoID0gb2xkVm5vZGUuY2hpbGRyZW47XG4gICAgdmFyIGNoID0gdm5vZGUuY2hpbGRyZW47XG4gICAgaWYgKGlzRGVmKGRhdGEpICYmIGlzUGF0Y2hhYmxlKHZub2RlKSkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGNicy51cGRhdGUubGVuZ3RoOyArK2kpIHsgY2JzLnVwZGF0ZVtpXShvbGRWbm9kZSwgdm5vZGUpOyB9XG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkudXBkYXRlKSkgeyBpKG9sZFZub2RlLCB2bm9kZSk7IH1cbiAgICB9XG4gICAgaWYgKGlzVW5kZWYodm5vZGUudGV4dCkpIHtcbiAgICAgIGlmIChpc0RlZihvbGRDaCkgJiYgaXNEZWYoY2gpKSB7XG4gICAgICAgIGlmIChvbGRDaCAhPT0gY2gpIHsgdXBkYXRlQ2hpbGRyZW4oZWxtLCBvbGRDaCwgY2gsIGluc2VydGVkVm5vZGVRdWV1ZSwgcmVtb3ZlT25seSk7IH1cbiAgICAgIH0gZWxzZSBpZiAoaXNEZWYoY2gpKSB7XG4gICAgICAgIGlmIChpc0RlZihvbGRWbm9kZS50ZXh0KSkgeyBub2RlT3BzLnNldFRleHRDb250ZW50KGVsbSwgJycpOyB9XG4gICAgICAgIGFkZFZub2RlcyhlbG0sIG51bGwsIGNoLCAwLCBjaC5sZW5ndGggLSAxLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgfSBlbHNlIGlmIChpc0RlZihvbGRDaCkpIHtcbiAgICAgICAgcmVtb3ZlVm5vZGVzKGVsbSwgb2xkQ2gsIDAsIG9sZENoLmxlbmd0aCAtIDEpO1xuICAgICAgfSBlbHNlIGlmIChpc0RlZihvbGRWbm9kZS50ZXh0KSkge1xuICAgICAgICBub2RlT3BzLnNldFRleHRDb250ZW50KGVsbSwgJycpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAob2xkVm5vZGUudGV4dCAhPT0gdm5vZGUudGV4dCkge1xuICAgICAgbm9kZU9wcy5zZXRUZXh0Q29udGVudChlbG0sIHZub2RlLnRleHQpO1xuICAgIH1cbiAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgIGlmIChpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5wb3N0cGF0Y2gpKSB7IGkob2xkVm5vZGUsIHZub2RlKTsgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGludm9rZUluc2VydEhvb2sgKHZub2RlLCBxdWV1ZSwgaW5pdGlhbCkge1xuICAgIC8vIGRlbGF5IGluc2VydCBob29rcyBmb3IgY29tcG9uZW50IHJvb3Qgbm9kZXMsIGludm9rZSB0aGVtIGFmdGVyIHRoZVxuICAgIC8vIGVsZW1lbnQgaXMgcmVhbGx5IGluc2VydGVkXG4gICAgaWYgKGlzVHJ1ZShpbml0aWFsKSAmJiBpc0RlZih2bm9kZS5wYXJlbnQpKSB7XG4gICAgICB2bm9kZS5wYXJlbnQuZGF0YS5wZW5kaW5nSW5zZXJ0ID0gcXVldWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgcXVldWVbaV0uZGF0YS5ob29rLmluc2VydChxdWV1ZVtpXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGh5ZHJhdGlvbkJhaWxlZCA9IGZhbHNlO1xuICAvLyBsaXN0IG9mIG1vZHVsZXMgdGhhdCBjYW4gc2tpcCBjcmVhdGUgaG9vayBkdXJpbmcgaHlkcmF0aW9uIGJlY2F1c2UgdGhleVxuICAvLyBhcmUgYWxyZWFkeSByZW5kZXJlZCBvbiB0aGUgY2xpZW50IG9yIGhhcyBubyBuZWVkIGZvciBpbml0aWFsaXphdGlvblxuICAvLyBOb3RlOiBzdHlsZSBpcyBleGNsdWRlZCBiZWNhdXNlIGl0IHJlbGllcyBvbiBpbml0aWFsIGNsb25lIGZvciBmdXR1cmVcbiAgLy8gZGVlcCB1cGRhdGVzICgjNzA2MykuXG4gIHZhciBpc1JlbmRlcmVkTW9kdWxlID0gbWFrZU1hcCgnYXR0cnMsY2xhc3Msc3RhdGljQ2xhc3Msc3RhdGljU3R5bGUsa2V5Jyk7XG5cbiAgLy8gTm90ZTogdGhpcyBpcyBhIGJyb3dzZXItb25seSBmdW5jdGlvbiBzbyB3ZSBjYW4gYXNzdW1lIGVsbXMgYXJlIERPTSBub2Rlcy5cbiAgZnVuY3Rpb24gaHlkcmF0ZSAoZWxtLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBpblZQcmUpIHtcbiAgICB2YXIgaTtcbiAgICB2YXIgdGFnID0gdm5vZGUudGFnO1xuICAgIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICB2YXIgY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlbjtcbiAgICBpblZQcmUgPSBpblZQcmUgfHwgKGRhdGEgJiYgZGF0YS5wcmUpO1xuICAgIHZub2RlLmVsbSA9IGVsbTtcblxuICAgIGlmIChpc1RydWUodm5vZGUuaXNDb21tZW50KSAmJiBpc0RlZih2bm9kZS5hc3luY0ZhY3RvcnkpKSB7XG4gICAgICB2bm9kZS5pc0FzeW5jUGxhY2Vob2xkZXIgPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgLy8gYXNzZXJ0IG5vZGUgbWF0Y2hcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKCFhc3NlcnROb2RlTWF0Y2goZWxtLCB2bm9kZSwgaW5WUHJlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkuaW5pdCkpIHsgaSh2bm9kZSwgdHJ1ZSAvKiBoeWRyYXRpbmcgKi8pOyB9XG4gICAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSkge1xuICAgICAgICAvLyBjaGlsZCBjb21wb25lbnQuIGl0IHNob3VsZCBoYXZlIGh5ZHJhdGVkIGl0cyBvd24gdHJlZS5cbiAgICAgICAgaW5pdENvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzRGVmKHRhZykpIHtcbiAgICAgIGlmIChpc0RlZihjaGlsZHJlbikpIHtcbiAgICAgICAgLy8gZW1wdHkgZWxlbWVudCwgYWxsb3cgY2xpZW50IHRvIHBpY2sgdXAgYW5kIHBvcHVsYXRlIGNoaWxkcmVuXG4gICAgICAgIGlmICghZWxtLmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgICAgIGNyZWF0ZUNoaWxkcmVuKHZub2RlLCBjaGlsZHJlbiwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyB2LWh0bWwgYW5kIGRvbVByb3BzOiBpbm5lckhUTUxcbiAgICAgICAgICBpZiAoaXNEZWYoaSA9IGRhdGEpICYmIGlzRGVmKGkgPSBpLmRvbVByb3BzKSAmJiBpc0RlZihpID0gaS5pbm5lckhUTUwpKSB7XG4gICAgICAgICAgICBpZiAoaSAhPT0gZWxtLmlubmVySFRNTCkge1xuICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgICAgICAhaHlkcmF0aW9uQmFpbGVkXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGh5ZHJhdGlvbkJhaWxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdQYXJlbnQ6ICcsIGVsbSk7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdzZXJ2ZXIgaW5uZXJIVE1MOiAnLCBpKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ2NsaWVudCBpbm5lckhUTUw6ICcsIGVsbS5pbm5lckhUTUwpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBpdGVyYXRlIGFuZCBjb21wYXJlIGNoaWxkcmVuIGxpc3RzXG4gICAgICAgICAgICB2YXIgY2hpbGRyZW5NYXRjaCA9IHRydWU7XG4gICAgICAgICAgICB2YXIgY2hpbGROb2RlID0gZWxtLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBjaGlsZHJlbi5sZW5ndGg7IGkkMSsrKSB7XG4gICAgICAgICAgICAgIGlmICghY2hpbGROb2RlIHx8ICFoeWRyYXRlKGNoaWxkTm9kZSwgY2hpbGRyZW5baSQxXSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBpblZQcmUpKSB7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW5NYXRjaCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2hpbGROb2RlID0gY2hpbGROb2RlLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaWYgY2hpbGROb2RlIGlzIG5vdCBudWxsLCBpdCBtZWFucyB0aGUgYWN0dWFsIGNoaWxkTm9kZXMgbGlzdCBpc1xuICAgICAgICAgICAgLy8gbG9uZ2VyIHRoYW4gdGhlIHZpcnR1YWwgY2hpbGRyZW4gbGlzdC5cbiAgICAgICAgICAgIGlmICghY2hpbGRyZW5NYXRjaCB8fCBjaGlsZE5vZGUpIHtcbiAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICAgICAgIWh5ZHJhdGlvbkJhaWxlZFxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBoeWRyYXRpb25CYWlsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignUGFyZW50OiAnLCBlbG0pO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignTWlzbWF0Y2hpbmcgY2hpbGROb2RlcyB2cy4gVk5vZGVzOiAnLCBlbG0uY2hpbGROb2RlcywgY2hpbGRyZW4pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICAgIHZhciBmdWxsSW52b2tlID0gZmFsc2U7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBkYXRhKSB7XG4gICAgICAgICAgaWYgKCFpc1JlbmRlcmVkTW9kdWxlKGtleSkpIHtcbiAgICAgICAgICAgIGZ1bGxJbnZva2UgPSB0cnVlO1xuICAgICAgICAgICAgaW52b2tlQ3JlYXRlSG9va3Modm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWZ1bGxJbnZva2UgJiYgZGF0YVsnY2xhc3MnXSkge1xuICAgICAgICAgIC8vIGVuc3VyZSBjb2xsZWN0aW5nIGRlcHMgZm9yIGRlZXAgY2xhc3MgYmluZGluZ3MgZm9yIGZ1dHVyZSB1cGRhdGVzXG4gICAgICAgICAgdHJhdmVyc2UoZGF0YVsnY2xhc3MnXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGVsbS5kYXRhICE9PSB2bm9kZS50ZXh0KSB7XG4gICAgICBlbG0uZGF0YSA9IHZub2RlLnRleHQ7XG4gICAgfVxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBmdW5jdGlvbiBhc3NlcnROb2RlTWF0Y2ggKG5vZGUsIHZub2RlLCBpblZQcmUpIHtcbiAgICBpZiAoaXNEZWYodm5vZGUudGFnKSkge1xuICAgICAgcmV0dXJuIHZub2RlLnRhZy5pbmRleE9mKCd2dWUtY29tcG9uZW50JykgPT09IDAgfHwgKFxuICAgICAgICAhaXNVbmtub3duRWxlbWVudCQkMSh2bm9kZSwgaW5WUHJlKSAmJlxuICAgICAgICB2bm9kZS50YWcudG9Mb3dlckNhc2UoKSA9PT0gKG5vZGUudGFnTmFtZSAmJiBub2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSlcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5vZGUubm9kZVR5cGUgPT09ICh2bm9kZS5pc0NvbW1lbnQgPyA4IDogMylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gcGF0Y2ggKG9sZFZub2RlLCB2bm9kZSwgaHlkcmF0aW5nLCByZW1vdmVPbmx5LCBwYXJlbnRFbG0sIHJlZkVsbSkge1xuICAgIGlmIChpc1VuZGVmKHZub2RlKSkge1xuICAgICAgaWYgKGlzRGVmKG9sZFZub2RlKSkgeyBpbnZva2VEZXN0cm95SG9vayhvbGRWbm9kZSk7IH1cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHZhciBpc0luaXRpYWxQYXRjaCA9IGZhbHNlO1xuICAgIHZhciBpbnNlcnRlZFZub2RlUXVldWUgPSBbXTtcblxuICAgIGlmIChpc1VuZGVmKG9sZFZub2RlKSkge1xuICAgICAgLy8gZW1wdHkgbW91bnQgKGxpa2VseSBhcyBjb21wb25lbnQpLCBjcmVhdGUgbmV3IHJvb3QgZWxlbWVudFxuICAgICAgaXNJbml0aWFsUGF0Y2ggPSB0cnVlO1xuICAgICAgY3JlYXRlRWxtKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGlzUmVhbEVsZW1lbnQgPSBpc0RlZihvbGRWbm9kZS5ub2RlVHlwZSk7XG4gICAgICBpZiAoIWlzUmVhbEVsZW1lbnQgJiYgc2FtZVZub2RlKG9sZFZub2RlLCB2bm9kZSkpIHtcbiAgICAgICAgLy8gcGF0Y2ggZXhpc3Rpbmcgcm9vdCBub2RlXG4gICAgICAgIHBhdGNoVm5vZGUob2xkVm5vZGUsIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHJlbW92ZU9ubHkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzUmVhbEVsZW1lbnQpIHtcbiAgICAgICAgICAvLyBtb3VudGluZyB0byBhIHJlYWwgZWxlbWVudFxuICAgICAgICAgIC8vIGNoZWNrIGlmIHRoaXMgaXMgc2VydmVyLXJlbmRlcmVkIGNvbnRlbnQgYW5kIGlmIHdlIGNhbiBwZXJmb3JtXG4gICAgICAgICAgLy8gYSBzdWNjZXNzZnVsIGh5ZHJhdGlvbi5cbiAgICAgICAgICBpZiAob2xkVm5vZGUubm9kZVR5cGUgPT09IDEgJiYgb2xkVm5vZGUuaGFzQXR0cmlidXRlKFNTUl9BVFRSKSkge1xuICAgICAgICAgICAgb2xkVm5vZGUucmVtb3ZlQXR0cmlidXRlKFNTUl9BVFRSKTtcbiAgICAgICAgICAgIGh5ZHJhdGluZyA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc1RydWUoaHlkcmF0aW5nKSkge1xuICAgICAgICAgICAgaWYgKGh5ZHJhdGUob2xkVm5vZGUsIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpKSB7XG4gICAgICAgICAgICAgIGludm9rZUluc2VydEhvb2sodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgIHJldHVybiBvbGRWbm9kZVxuICAgICAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgICAgJ1RoZSBjbGllbnQtc2lkZSByZW5kZXJlZCB2aXJ0dWFsIERPTSB0cmVlIGlzIG5vdCBtYXRjaGluZyAnICtcbiAgICAgICAgICAgICAgICAnc2VydmVyLXJlbmRlcmVkIGNvbnRlbnQuIFRoaXMgaXMgbGlrZWx5IGNhdXNlZCBieSBpbmNvcnJlY3QgJyArXG4gICAgICAgICAgICAgICAgJ0hUTUwgbWFya3VwLCBmb3IgZXhhbXBsZSBuZXN0aW5nIGJsb2NrLWxldmVsIGVsZW1lbnRzIGluc2lkZSAnICtcbiAgICAgICAgICAgICAgICAnPHA+LCBvciBtaXNzaW5nIDx0Ym9keT4uIEJhaWxpbmcgaHlkcmF0aW9uIGFuZCBwZXJmb3JtaW5nICcgK1xuICAgICAgICAgICAgICAgICdmdWxsIGNsaWVudC1zaWRlIHJlbmRlci4nXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGVpdGhlciBub3Qgc2VydmVyLXJlbmRlcmVkLCBvciBoeWRyYXRpb24gZmFpbGVkLlxuICAgICAgICAgIC8vIGNyZWF0ZSBhbiBlbXB0eSBub2RlIGFuZCByZXBsYWNlIGl0XG4gICAgICAgICAgb2xkVm5vZGUgPSBlbXB0eU5vZGVBdChvbGRWbm9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZXBsYWNpbmcgZXhpc3RpbmcgZWxlbWVudFxuICAgICAgICB2YXIgb2xkRWxtID0gb2xkVm5vZGUuZWxtO1xuICAgICAgICB2YXIgcGFyZW50RWxtJDEgPSBub2RlT3BzLnBhcmVudE5vZGUob2xkRWxtKTtcblxuICAgICAgICAvLyBjcmVhdGUgbmV3IG5vZGVcbiAgICAgICAgY3JlYXRlRWxtKFxuICAgICAgICAgIHZub2RlLFxuICAgICAgICAgIGluc2VydGVkVm5vZGVRdWV1ZSxcbiAgICAgICAgICAvLyBleHRyZW1lbHkgcmFyZSBlZGdlIGNhc2U6IGRvIG5vdCBpbnNlcnQgaWYgb2xkIGVsZW1lbnQgaXMgaW4gYVxuICAgICAgICAgIC8vIGxlYXZpbmcgdHJhbnNpdGlvbi4gT25seSBoYXBwZW5zIHdoZW4gY29tYmluaW5nIHRyYW5zaXRpb24gK1xuICAgICAgICAgIC8vIGtlZXAtYWxpdmUgKyBIT0NzLiAoIzQ1OTApXG4gICAgICAgICAgb2xkRWxtLl9sZWF2ZUNiID8gbnVsbCA6IHBhcmVudEVsbSQxLFxuICAgICAgICAgIG5vZGVPcHMubmV4dFNpYmxpbmcob2xkRWxtKVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIHVwZGF0ZSBwYXJlbnQgcGxhY2Vob2xkZXIgbm9kZSBlbGVtZW50LCByZWN1cnNpdmVseVxuICAgICAgICBpZiAoaXNEZWYodm5vZGUucGFyZW50KSkge1xuICAgICAgICAgIHZhciBhbmNlc3RvciA9IHZub2RlLnBhcmVudDtcbiAgICAgICAgICB2YXIgcGF0Y2hhYmxlID0gaXNQYXRjaGFibGUodm5vZGUpO1xuICAgICAgICAgIHdoaWxlIChhbmNlc3Rvcikge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYnMuZGVzdHJveS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICBjYnMuZGVzdHJveVtpXShhbmNlc3Rvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhbmNlc3Rvci5lbG0gPSB2bm9kZS5lbG07XG4gICAgICAgICAgICBpZiAocGF0Y2hhYmxlKSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGNicy5jcmVhdGUubGVuZ3RoOyArK2kkMSkge1xuICAgICAgICAgICAgICAgIGNicy5jcmVhdGVbaSQxXShlbXB0eU5vZGUsIGFuY2VzdG9yKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyAjNjUxM1xuICAgICAgICAgICAgICAvLyBpbnZva2UgaW5zZXJ0IGhvb2tzIHRoYXQgbWF5IGhhdmUgYmVlbiBtZXJnZWQgYnkgY3JlYXRlIGhvb2tzLlxuICAgICAgICAgICAgICAvLyBlLmcuIGZvciBkaXJlY3RpdmVzIHRoYXQgdXNlcyB0aGUgXCJpbnNlcnRlZFwiIGhvb2suXG4gICAgICAgICAgICAgIHZhciBpbnNlcnQgPSBhbmNlc3Rvci5kYXRhLmhvb2suaW5zZXJ0O1xuICAgICAgICAgICAgICBpZiAoaW5zZXJ0Lm1lcmdlZCkge1xuICAgICAgICAgICAgICAgIC8vIHN0YXJ0IGF0IGluZGV4IDEgdG8gYXZvaWQgcmUtaW52b2tpbmcgY29tcG9uZW50IG1vdW50ZWQgaG9va1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkkMiA9IDE7IGkkMiA8IGluc2VydC5mbnMubGVuZ3RoOyBpJDIrKykge1xuICAgICAgICAgICAgICAgICAgaW5zZXJ0LmZuc1tpJDJdKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZWdpc3RlclJlZihhbmNlc3Rvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhbmNlc3RvciA9IGFuY2VzdG9yLnBhcmVudDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBkZXN0cm95IG9sZCBub2RlXG4gICAgICAgIGlmIChpc0RlZihwYXJlbnRFbG0kMSkpIHtcbiAgICAgICAgICByZW1vdmVWbm9kZXMocGFyZW50RWxtJDEsIFtvbGRWbm9kZV0sIDAsIDApO1xuICAgICAgICB9IGVsc2UgaWYgKGlzRGVmKG9sZFZub2RlLnRhZykpIHtcbiAgICAgICAgICBpbnZva2VEZXN0cm95SG9vayhvbGRWbm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpbnZva2VJbnNlcnRIb29rKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIGlzSW5pdGlhbFBhdGNoKTtcbiAgICByZXR1cm4gdm5vZGUuZWxtXG4gIH1cbn1cblxuLyogICovXG5cbnZhciBkaXJlY3RpdmVzID0ge1xuICBjcmVhdGU6IHVwZGF0ZURpcmVjdGl2ZXMsXG4gIHVwZGF0ZTogdXBkYXRlRGlyZWN0aXZlcyxcbiAgZGVzdHJveTogZnVuY3Rpb24gdW5iaW5kRGlyZWN0aXZlcyAodm5vZGUpIHtcbiAgICB1cGRhdGVEaXJlY3RpdmVzKHZub2RlLCBlbXB0eU5vZGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZURpcmVjdGl2ZXMgKG9sZFZub2RlLCB2bm9kZSkge1xuICBpZiAob2xkVm5vZGUuZGF0YS5kaXJlY3RpdmVzIHx8IHZub2RlLmRhdGEuZGlyZWN0aXZlcykge1xuICAgIF91cGRhdGUob2xkVm5vZGUsIHZub2RlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfdXBkYXRlIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgdmFyIGlzQ3JlYXRlID0gb2xkVm5vZGUgPT09IGVtcHR5Tm9kZTtcbiAgdmFyIGlzRGVzdHJveSA9IHZub2RlID09PSBlbXB0eU5vZGU7XG4gIHZhciBvbGREaXJzID0gbm9ybWFsaXplRGlyZWN0aXZlcyQxKG9sZFZub2RlLmRhdGEuZGlyZWN0aXZlcywgb2xkVm5vZGUuY29udGV4dCk7XG4gIHZhciBuZXdEaXJzID0gbm9ybWFsaXplRGlyZWN0aXZlcyQxKHZub2RlLmRhdGEuZGlyZWN0aXZlcywgdm5vZGUuY29udGV4dCk7XG5cbiAgdmFyIGRpcnNXaXRoSW5zZXJ0ID0gW107XG4gIHZhciBkaXJzV2l0aFBvc3RwYXRjaCA9IFtdO1xuXG4gIHZhciBrZXksIG9sZERpciwgZGlyO1xuICBmb3IgKGtleSBpbiBuZXdEaXJzKSB7XG4gICAgb2xkRGlyID0gb2xkRGlyc1trZXldO1xuICAgIGRpciA9IG5ld0RpcnNba2V5XTtcbiAgICBpZiAoIW9sZERpcikge1xuICAgICAgLy8gbmV3IGRpcmVjdGl2ZSwgYmluZFxuICAgICAgY2FsbEhvb2skMShkaXIsICdiaW5kJywgdm5vZGUsIG9sZFZub2RlKTtcbiAgICAgIGlmIChkaXIuZGVmICYmIGRpci5kZWYuaW5zZXJ0ZWQpIHtcbiAgICAgICAgZGlyc1dpdGhJbnNlcnQucHVzaChkaXIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBleGlzdGluZyBkaXJlY3RpdmUsIHVwZGF0ZVxuICAgICAgZGlyLm9sZFZhbHVlID0gb2xkRGlyLnZhbHVlO1xuICAgICAgY2FsbEhvb2skMShkaXIsICd1cGRhdGUnLCB2bm9kZSwgb2xkVm5vZGUpO1xuICAgICAgaWYgKGRpci5kZWYgJiYgZGlyLmRlZi5jb21wb25lbnRVcGRhdGVkKSB7XG4gICAgICAgIGRpcnNXaXRoUG9zdHBhdGNoLnB1c2goZGlyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoZGlyc1dpdGhJbnNlcnQubGVuZ3RoKSB7XG4gICAgdmFyIGNhbGxJbnNlcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpcnNXaXRoSW5zZXJ0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNhbGxIb29rJDEoZGlyc1dpdGhJbnNlcnRbaV0sICdpbnNlcnRlZCcsIHZub2RlLCBvbGRWbm9kZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAoaXNDcmVhdGUpIHtcbiAgICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLCAnaW5zZXJ0JywgY2FsbEluc2VydCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbGxJbnNlcnQoKTtcbiAgICB9XG4gIH1cblxuICBpZiAoZGlyc1dpdGhQb3N0cGF0Y2gubGVuZ3RoKSB7XG4gICAgbWVyZ2VWTm9kZUhvb2sodm5vZGUsICdwb3N0cGF0Y2gnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpcnNXaXRoUG9zdHBhdGNoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNhbGxIb29rJDEoZGlyc1dpdGhQb3N0cGF0Y2hbaV0sICdjb21wb25lbnRVcGRhdGVkJywgdm5vZGUsIG9sZFZub2RlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGlmICghaXNDcmVhdGUpIHtcbiAgICBmb3IgKGtleSBpbiBvbGREaXJzKSB7XG4gICAgICBpZiAoIW5ld0RpcnNba2V5XSkge1xuICAgICAgICAvLyBubyBsb25nZXIgcHJlc2VudCwgdW5iaW5kXG4gICAgICAgIGNhbGxIb29rJDEob2xkRGlyc1trZXldLCAndW5iaW5kJywgb2xkVm5vZGUsIG9sZFZub2RlLCBpc0Rlc3Ryb3kpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgZW1wdHlNb2RpZmllcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG5mdW5jdGlvbiBub3JtYWxpemVEaXJlY3RpdmVzJDEgKFxuICBkaXJzLFxuICB2bVxuKSB7XG4gIHZhciByZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBpZiAoIWRpcnMpIHtcbiAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICByZXR1cm4gcmVzXG4gIH1cbiAgdmFyIGksIGRpcjtcbiAgZm9yIChpID0gMDsgaSA8IGRpcnMubGVuZ3RoOyBpKyspIHtcbiAgICBkaXIgPSBkaXJzW2ldO1xuICAgIGlmICghZGlyLm1vZGlmaWVycykge1xuICAgICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgICBkaXIubW9kaWZpZXJzID0gZW1wdHlNb2RpZmllcnM7XG4gICAgfVxuICAgIHJlc1tnZXRSYXdEaXJOYW1lKGRpcildID0gZGlyO1xuICAgIGRpci5kZWYgPSByZXNvbHZlQXNzZXQodm0uJG9wdGlvbnMsICdkaXJlY3RpdmVzJywgZGlyLm5hbWUsIHRydWUpO1xuICB9XG4gIC8vICRmbG93LWRpc2FibGUtbGluZVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGdldFJhd0Rpck5hbWUgKGRpcikge1xuICByZXR1cm4gZGlyLnJhd05hbWUgfHwgKChkaXIubmFtZSkgKyBcIi5cIiArIChPYmplY3Qua2V5cyhkaXIubW9kaWZpZXJzIHx8IHt9KS5qb2luKCcuJykpKVxufVxuXG5mdW5jdGlvbiBjYWxsSG9vayQxIChkaXIsIGhvb2ssIHZub2RlLCBvbGRWbm9kZSwgaXNEZXN0cm95KSB7XG4gIHZhciBmbiA9IGRpci5kZWYgJiYgZGlyLmRlZltob29rXTtcbiAgaWYgKGZuKSB7XG4gICAgdHJ5IHtcbiAgICAgIGZuKHZub2RlLmVsbSwgZGlyLCB2bm9kZSwgb2xkVm5vZGUsIGlzRGVzdHJveSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaGFuZGxlRXJyb3IoZSwgdm5vZGUuY29udGV4dCwgKFwiZGlyZWN0aXZlIFwiICsgKGRpci5uYW1lKSArIFwiIFwiICsgaG9vayArIFwiIGhvb2tcIikpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgYmFzZU1vZHVsZXMgPSBbXG4gIHJlZixcbiAgZGlyZWN0aXZlc1xuXVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gdXBkYXRlQXR0cnMgKG9sZFZub2RlLCB2bm9kZSkge1xuICB2YXIgb3B0cyA9IHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gIGlmIChpc0RlZihvcHRzKSAmJiBvcHRzLkN0b3Iub3B0aW9ucy5pbmhlcml0QXR0cnMgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKGlzVW5kZWYob2xkVm5vZGUuZGF0YS5hdHRycykgJiYgaXNVbmRlZih2bm9kZS5kYXRhLmF0dHJzKSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBrZXksIGN1ciwgb2xkO1xuICB2YXIgZWxtID0gdm5vZGUuZWxtO1xuICB2YXIgb2xkQXR0cnMgPSBvbGRWbm9kZS5kYXRhLmF0dHJzIHx8IHt9O1xuICB2YXIgYXR0cnMgPSB2bm9kZS5kYXRhLmF0dHJzIHx8IHt9O1xuICAvLyBjbG9uZSBvYnNlcnZlZCBvYmplY3RzLCBhcyB0aGUgdXNlciBwcm9iYWJseSB3YW50cyB0byBtdXRhdGUgaXRcbiAgaWYgKGlzRGVmKGF0dHJzLl9fb2JfXykpIHtcbiAgICBhdHRycyA9IHZub2RlLmRhdGEuYXR0cnMgPSBleHRlbmQoe30sIGF0dHJzKTtcbiAgfVxuXG4gIGZvciAoa2V5IGluIGF0dHJzKSB7XG4gICAgY3VyID0gYXR0cnNba2V5XTtcbiAgICBvbGQgPSBvbGRBdHRyc1trZXldO1xuICAgIGlmIChvbGQgIT09IGN1cikge1xuICAgICAgc2V0QXR0cihlbG0sIGtleSwgY3VyKTtcbiAgICB9XG4gIH1cbiAgLy8gIzQzOTE6IGluIElFOSwgc2V0dGluZyB0eXBlIGNhbiByZXNldCB2YWx1ZSBmb3IgaW5wdXRbdHlwZT1yYWRpb11cbiAgLy8gIzY2NjY6IElFL0VkZ2UgZm9yY2VzIHByb2dyZXNzIHZhbHVlIGRvd24gdG8gMSBiZWZvcmUgc2V0dGluZyBhIG1heFxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKChpc0lFIHx8IGlzRWRnZSkgJiYgYXR0cnMudmFsdWUgIT09IG9sZEF0dHJzLnZhbHVlKSB7XG4gICAgc2V0QXR0cihlbG0sICd2YWx1ZScsIGF0dHJzLnZhbHVlKTtcbiAgfVxuICBmb3IgKGtleSBpbiBvbGRBdHRycykge1xuICAgIGlmIChpc1VuZGVmKGF0dHJzW2tleV0pKSB7XG4gICAgICBpZiAoaXNYbGluayhrZXkpKSB7XG4gICAgICAgIGVsbS5yZW1vdmVBdHRyaWJ1dGVOUyh4bGlua05TLCBnZXRYbGlua1Byb3Aoa2V5KSk7XG4gICAgICB9IGVsc2UgaWYgKCFpc0VudW1lcmF0ZWRBdHRyKGtleSkpIHtcbiAgICAgICAgZWxtLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzZXRBdHRyIChlbCwga2V5LCB2YWx1ZSkge1xuICBpZiAoZWwudGFnTmFtZS5pbmRleE9mKCctJykgPiAtMSkge1xuICAgIGJhc2VTZXRBdHRyKGVsLCBrZXksIHZhbHVlKTtcbiAgfSBlbHNlIGlmIChpc0Jvb2xlYW5BdHRyKGtleSkpIHtcbiAgICAvLyBzZXQgYXR0cmlidXRlIGZvciBibGFuayB2YWx1ZVxuICAgIC8vIGUuZy4gPG9wdGlvbiBkaXNhYmxlZD5TZWxlY3Qgb25lPC9vcHRpb24+XG4gICAgaWYgKGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdGVjaG5pY2FsbHkgYWxsb3dmdWxsc2NyZWVuIGlzIGEgYm9vbGVhbiBhdHRyaWJ1dGUgZm9yIDxpZnJhbWU+LFxuICAgICAgLy8gYnV0IEZsYXNoIGV4cGVjdHMgYSB2YWx1ZSBvZiBcInRydWVcIiB3aGVuIHVzZWQgb24gPGVtYmVkPiB0YWdcbiAgICAgIHZhbHVlID0ga2V5ID09PSAnYWxsb3dmdWxsc2NyZWVuJyAmJiBlbC50YWdOYW1lID09PSAnRU1CRUQnXG4gICAgICAgID8gJ3RydWUnXG4gICAgICAgIDoga2V5O1xuICAgICAgZWwuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc0VudW1lcmF0ZWRBdHRyKGtleSkpIHtcbiAgICBlbC5zZXRBdHRyaWJ1dGUoa2V5LCBpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSB8fCB2YWx1ZSA9PT0gJ2ZhbHNlJyA/ICdmYWxzZScgOiAndHJ1ZScpO1xuICB9IGVsc2UgaWYgKGlzWGxpbmsoa2V5KSkge1xuICAgIGlmIChpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlTlMoeGxpbmtOUywgZ2V0WGxpbmtQcm9wKGtleSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGVOUyh4bGlua05TLCBrZXksIHZhbHVlKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYmFzZVNldEF0dHIoZWwsIGtleSwgdmFsdWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2VTZXRBdHRyIChlbCwga2V5LCB2YWx1ZSkge1xuICBpZiAoaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkpIHtcbiAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgfSBlbHNlIHtcbiAgICAvLyAjNzEzODogSUUxMCAmIDExIGZpcmVzIGlucHV0IGV2ZW50IHdoZW4gc2V0dGluZyBwbGFjZWhvbGRlciBvblxuICAgIC8vIDx0ZXh0YXJlYT4uLi4gYmxvY2sgdGhlIGZpcnN0IGlucHV0IGV2ZW50IGFuZCByZW1vdmUgdGhlIGJsb2NrZXJcbiAgICAvLyBpbW1lZGlhdGVseS5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoXG4gICAgICBpc0lFICYmICFpc0lFOSAmJlxuICAgICAgZWwudGFnTmFtZSA9PT0gJ1RFWFRBUkVBJyAmJlxuICAgICAga2V5ID09PSAncGxhY2Vob2xkZXInICYmICFlbC5fX2llcGhcbiAgICApIHtcbiAgICAgIHZhciBibG9ja2VyID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignaW5wdXQnLCBibG9ja2VyKTtcbiAgICAgIH07XG4gICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdpbnB1dCcsIGJsb2NrZXIpO1xuICAgICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgICBlbC5fX2llcGggPSB0cnVlOyAvKiBJRSBwbGFjZWhvbGRlciBwYXRjaGVkICovXG4gICAgfVxuICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgfVxufVxuXG52YXIgYXR0cnMgPSB7XG4gIGNyZWF0ZTogdXBkYXRlQXR0cnMsXG4gIHVwZGF0ZTogdXBkYXRlQXR0cnNcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIHVwZGF0ZUNsYXNzIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgdmFyIGVsID0gdm5vZGUuZWxtO1xuICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gIHZhciBvbGREYXRhID0gb2xkVm5vZGUuZGF0YTtcbiAgaWYgKFxuICAgIGlzVW5kZWYoZGF0YS5zdGF0aWNDbGFzcykgJiZcbiAgICBpc1VuZGVmKGRhdGEuY2xhc3MpICYmIChcbiAgICAgIGlzVW5kZWYob2xkRGF0YSkgfHwgKFxuICAgICAgICBpc1VuZGVmKG9sZERhdGEuc3RhdGljQ2xhc3MpICYmXG4gICAgICAgIGlzVW5kZWYob2xkRGF0YS5jbGFzcylcbiAgICAgIClcbiAgICApXG4gICkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIGNscyA9IGdlbkNsYXNzRm9yVm5vZGUodm5vZGUpO1xuXG4gIC8vIGhhbmRsZSB0cmFuc2l0aW9uIGNsYXNzZXNcbiAgdmFyIHRyYW5zaXRpb25DbGFzcyA9IGVsLl90cmFuc2l0aW9uQ2xhc3NlcztcbiAgaWYgKGlzRGVmKHRyYW5zaXRpb25DbGFzcykpIHtcbiAgICBjbHMgPSBjb25jYXQoY2xzLCBzdHJpbmdpZnlDbGFzcyh0cmFuc2l0aW9uQ2xhc3MpKTtcbiAgfVxuXG4gIC8vIHNldCB0aGUgY2xhc3NcbiAgaWYgKGNscyAhPT0gZWwuX3ByZXZDbGFzcykge1xuICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBjbHMpO1xuICAgIGVsLl9wcmV2Q2xhc3MgPSBjbHM7XG4gIH1cbn1cblxudmFyIGtsYXNzID0ge1xuICBjcmVhdGU6IHVwZGF0ZUNsYXNzLFxuICB1cGRhdGU6IHVwZGF0ZUNsYXNzXG59XG5cbi8qICAqL1xuXG4vKiAgKi9cblxuXG5cblxuXG5cblxuXG5cbi8vIGFkZCBhIHJhdyBhdHRyICh1c2UgdGhpcyBpbiBwcmVUcmFuc2Zvcm1zKVxuXG5cblxuXG5cblxuXG5cbi8vIG5vdGU6IHRoaXMgb25seSByZW1vdmVzIHRoZSBhdHRyIGZyb20gdGhlIEFycmF5IChhdHRyc0xpc3QpIHNvIHRoYXQgaXRcbi8vIGRvZXNuJ3QgZ2V0IHByb2Nlc3NlZCBieSBwcm9jZXNzQXR0cnMuXG4vLyBCeSBkZWZhdWx0IGl0IGRvZXMgTk9UIHJlbW92ZSBpdCBmcm9tIHRoZSBtYXAgKGF0dHJzTWFwKSBiZWNhdXNlIHRoZSBtYXAgaXNcbi8vIG5lZWRlZCBkdXJpbmcgY29kZWdlbi5cblxuLyogICovXG5cbi8qKlxuICogQ3Jvc3MtcGxhdGZvcm0gY29kZSBnZW5lcmF0aW9uIGZvciBjb21wb25lbnQgdi1tb2RlbFxuICovXG5cblxuLyoqXG4gKiBDcm9zcy1wbGF0Zm9ybSBjb2RlZ2VuIGhlbHBlciBmb3IgZ2VuZXJhdGluZyB2LW1vZGVsIHZhbHVlIGFzc2lnbm1lbnQgY29kZS5cbiAqL1xuXG4vKiAgKi9cblxuLy8gaW4gc29tZSBjYXNlcywgdGhlIGV2ZW50IHVzZWQgaGFzIHRvIGJlIGRldGVybWluZWQgYXQgcnVudGltZVxuLy8gc28gd2UgdXNlZCBzb21lIHJlc2VydmVkIHRva2VucyBkdXJpbmcgY29tcGlsZS5cbnZhciBSQU5HRV9UT0tFTiA9ICdfX3InO1xudmFyIENIRUNLQk9YX1JBRElPX1RPS0VOID0gJ19fYyc7XG5cbi8qICAqL1xuXG4vLyBub3JtYWxpemUgdi1tb2RlbCBldmVudCB0b2tlbnMgdGhhdCBjYW4gb25seSBiZSBkZXRlcm1pbmVkIGF0IHJ1bnRpbWUuXG4vLyBpdCdzIGltcG9ydGFudCB0byBwbGFjZSB0aGUgZXZlbnQgYXMgdGhlIGZpcnN0IGluIHRoZSBhcnJheSBiZWNhdXNlXG4vLyB0aGUgd2hvbGUgcG9pbnQgaXMgZW5zdXJpbmcgdGhlIHYtbW9kZWwgY2FsbGJhY2sgZ2V0cyBjYWxsZWQgYmVmb3JlXG4vLyB1c2VyLWF0dGFjaGVkIGhhbmRsZXJzLlxuZnVuY3Rpb24gbm9ybWFsaXplRXZlbnRzIChvbikge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGlzRGVmKG9uW1JBTkdFX1RPS0VOXSkpIHtcbiAgICAvLyBJRSBpbnB1dFt0eXBlPXJhbmdlXSBvbmx5IHN1cHBvcnRzIGBjaGFuZ2VgIGV2ZW50XG4gICAgdmFyIGV2ZW50ID0gaXNJRSA/ICdjaGFuZ2UnIDogJ2lucHV0JztcbiAgICBvbltldmVudF0gPSBbXS5jb25jYXQob25bUkFOR0VfVE9LRU5dLCBvbltldmVudF0gfHwgW10pO1xuICAgIGRlbGV0ZSBvbltSQU5HRV9UT0tFTl07XG4gIH1cbiAgLy8gVGhpcyB3YXMgb3JpZ2luYWxseSBpbnRlbmRlZCB0byBmaXggIzQ1MjEgYnV0IG5vIGxvbmdlciBuZWNlc3NhcnlcbiAgLy8gYWZ0ZXIgMi41LiBLZWVwaW5nIGl0IGZvciBiYWNrd2FyZHMgY29tcGF0IHdpdGggZ2VuZXJhdGVkIGNvZGUgZnJvbSA8IDIuNFxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGlzRGVmKG9uW0NIRUNLQk9YX1JBRElPX1RPS0VOXSkpIHtcbiAgICBvbi5jaGFuZ2UgPSBbXS5jb25jYXQob25bQ0hFQ0tCT1hfUkFESU9fVE9LRU5dLCBvbi5jaGFuZ2UgfHwgW10pO1xuICAgIGRlbGV0ZSBvbltDSEVDS0JPWF9SQURJT19UT0tFTl07XG4gIH1cbn1cblxudmFyIHRhcmdldCQxO1xuXG5mdW5jdGlvbiBjcmVhdGVPbmNlSGFuZGxlciAoaGFuZGxlciwgZXZlbnQsIGNhcHR1cmUpIHtcbiAgdmFyIF90YXJnZXQgPSB0YXJnZXQkMTsgLy8gc2F2ZSBjdXJyZW50IHRhcmdldCBlbGVtZW50IGluIGNsb3N1cmVcbiAgcmV0dXJuIGZ1bmN0aW9uIG9uY2VIYW5kbGVyICgpIHtcbiAgICB2YXIgcmVzID0gaGFuZGxlci5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIGlmIChyZXMgIT09IG51bGwpIHtcbiAgICAgIHJlbW92ZSQyKGV2ZW50LCBvbmNlSGFuZGxlciwgY2FwdHVyZSwgX3RhcmdldCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFkZCQxIChcbiAgZXZlbnQsXG4gIGhhbmRsZXIsXG4gIG9uY2UkJDEsXG4gIGNhcHR1cmUsXG4gIHBhc3NpdmVcbikge1xuICBoYW5kbGVyID0gd2l0aE1hY3JvVGFzayhoYW5kbGVyKTtcbiAgaWYgKG9uY2UkJDEpIHsgaGFuZGxlciA9IGNyZWF0ZU9uY2VIYW5kbGVyKGhhbmRsZXIsIGV2ZW50LCBjYXB0dXJlKTsgfVxuICB0YXJnZXQkMS5hZGRFdmVudExpc3RlbmVyKFxuICAgIGV2ZW50LFxuICAgIGhhbmRsZXIsXG4gICAgc3VwcG9ydHNQYXNzaXZlXG4gICAgICA/IHsgY2FwdHVyZTogY2FwdHVyZSwgcGFzc2l2ZTogcGFzc2l2ZSB9XG4gICAgICA6IGNhcHR1cmVcbiAgKTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlJDIgKFxuICBldmVudCxcbiAgaGFuZGxlcixcbiAgY2FwdHVyZSxcbiAgX3RhcmdldFxuKSB7XG4gIChfdGFyZ2V0IHx8IHRhcmdldCQxKS5yZW1vdmVFdmVudExpc3RlbmVyKFxuICAgIGV2ZW50LFxuICAgIGhhbmRsZXIuX3dpdGhUYXNrIHx8IGhhbmRsZXIsXG4gICAgY2FwdHVyZVxuICApO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVET01MaXN0ZW5lcnMgKG9sZFZub2RlLCB2bm9kZSkge1xuICBpZiAoaXNVbmRlZihvbGRWbm9kZS5kYXRhLm9uKSAmJiBpc1VuZGVmKHZub2RlLmRhdGEub24pKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIG9uID0gdm5vZGUuZGF0YS5vbiB8fCB7fTtcbiAgdmFyIG9sZE9uID0gb2xkVm5vZGUuZGF0YS5vbiB8fCB7fTtcbiAgdGFyZ2V0JDEgPSB2bm9kZS5lbG07XG4gIG5vcm1hbGl6ZUV2ZW50cyhvbik7XG4gIHVwZGF0ZUxpc3RlbmVycyhvbiwgb2xkT24sIGFkZCQxLCByZW1vdmUkMiwgdm5vZGUuY29udGV4dCk7XG4gIHRhcmdldCQxID0gdW5kZWZpbmVkO1xufVxuXG52YXIgZXZlbnRzID0ge1xuICBjcmVhdGU6IHVwZGF0ZURPTUxpc3RlbmVycyxcbiAgdXBkYXRlOiB1cGRhdGVET01MaXN0ZW5lcnNcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIHVwZGF0ZURPTVByb3BzIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgaWYgKGlzVW5kZWYob2xkVm5vZGUuZGF0YS5kb21Qcm9wcykgJiYgaXNVbmRlZih2bm9kZS5kYXRhLmRvbVByb3BzKSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBrZXksIGN1cjtcbiAgdmFyIGVsbSA9IHZub2RlLmVsbTtcbiAgdmFyIG9sZFByb3BzID0gb2xkVm5vZGUuZGF0YS5kb21Qcm9wcyB8fCB7fTtcbiAgdmFyIHByb3BzID0gdm5vZGUuZGF0YS5kb21Qcm9wcyB8fCB7fTtcbiAgLy8gY2xvbmUgb2JzZXJ2ZWQgb2JqZWN0cywgYXMgdGhlIHVzZXIgcHJvYmFibHkgd2FudHMgdG8gbXV0YXRlIGl0XG4gIGlmIChpc0RlZihwcm9wcy5fX29iX18pKSB7XG4gICAgcHJvcHMgPSB2bm9kZS5kYXRhLmRvbVByb3BzID0gZXh0ZW5kKHt9LCBwcm9wcyk7XG4gIH1cblxuICBmb3IgKGtleSBpbiBvbGRQcm9wcykge1xuICAgIGlmIChpc1VuZGVmKHByb3BzW2tleV0pKSB7XG4gICAgICBlbG1ba2V5XSA9ICcnO1xuICAgIH1cbiAgfVxuICBmb3IgKGtleSBpbiBwcm9wcykge1xuICAgIGN1ciA9IHByb3BzW2tleV07XG4gICAgLy8gaWdub3JlIGNoaWxkcmVuIGlmIHRoZSBub2RlIGhhcyB0ZXh0Q29udGVudCBvciBpbm5lckhUTUwsXG4gICAgLy8gYXMgdGhlc2Ugd2lsbCB0aHJvdyBhd2F5IGV4aXN0aW5nIERPTSBub2RlcyBhbmQgY2F1c2UgcmVtb3ZhbCBlcnJvcnNcbiAgICAvLyBvbiBzdWJzZXF1ZW50IHBhdGNoZXMgKCMzMzYwKVxuICAgIGlmIChrZXkgPT09ICd0ZXh0Q29udGVudCcgfHwga2V5ID09PSAnaW5uZXJIVE1MJykge1xuICAgICAgaWYgKHZub2RlLmNoaWxkcmVuKSB7IHZub2RlLmNoaWxkcmVuLmxlbmd0aCA9IDA7IH1cbiAgICAgIGlmIChjdXIgPT09IG9sZFByb3BzW2tleV0pIHsgY29udGludWUgfVxuICAgICAgLy8gIzY2MDEgd29yayBhcm91bmQgQ2hyb21lIHZlcnNpb24gPD0gNTUgYnVnIHdoZXJlIHNpbmdsZSB0ZXh0Tm9kZVxuICAgICAgLy8gcmVwbGFjZWQgYnkgaW5uZXJIVE1ML3RleHRDb250ZW50IHJldGFpbnMgaXRzIHBhcmVudE5vZGUgcHJvcGVydHlcbiAgICAgIGlmIChlbG0uY2hpbGROb2Rlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgZWxtLnJlbW92ZUNoaWxkKGVsbS5jaGlsZE5vZGVzWzBdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoa2V5ID09PSAndmFsdWUnKSB7XG4gICAgICAvLyBzdG9yZSB2YWx1ZSBhcyBfdmFsdWUgYXMgd2VsbCBzaW5jZVxuICAgICAgLy8gbm9uLXN0cmluZyB2YWx1ZXMgd2lsbCBiZSBzdHJpbmdpZmllZFxuICAgICAgZWxtLl92YWx1ZSA9IGN1cjtcbiAgICAgIC8vIGF2b2lkIHJlc2V0dGluZyBjdXJzb3IgcG9zaXRpb24gd2hlbiB2YWx1ZSBpcyB0aGUgc2FtZVxuICAgICAgdmFyIHN0ckN1ciA9IGlzVW5kZWYoY3VyKSA/ICcnIDogU3RyaW5nKGN1cik7XG4gICAgICBpZiAoc2hvdWxkVXBkYXRlVmFsdWUoZWxtLCBzdHJDdXIpKSB7XG4gICAgICAgIGVsbS52YWx1ZSA9IHN0ckN1cjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZWxtW2tleV0gPSBjdXI7XG4gICAgfVxuICB9XG59XG5cbi8vIGNoZWNrIHBsYXRmb3Jtcy93ZWIvdXRpbC9hdHRycy5qcyBhY2NlcHRWYWx1ZVxuXG5cbmZ1bmN0aW9uIHNob3VsZFVwZGF0ZVZhbHVlIChlbG0sIGNoZWNrVmFsKSB7XG4gIHJldHVybiAoIWVsbS5jb21wb3NpbmcgJiYgKFxuICAgIGVsbS50YWdOYW1lID09PSAnT1BUSU9OJyB8fFxuICAgIGlzTm90SW5Gb2N1c0FuZERpcnR5KGVsbSwgY2hlY2tWYWwpIHx8XG4gICAgaXNEaXJ0eVdpdGhNb2RpZmllcnMoZWxtLCBjaGVja1ZhbClcbiAgKSlcbn1cblxuZnVuY3Rpb24gaXNOb3RJbkZvY3VzQW5kRGlydHkgKGVsbSwgY2hlY2tWYWwpIHtcbiAgLy8gcmV0dXJuIHRydWUgd2hlbiB0ZXh0Ym94ICgubnVtYmVyIGFuZCAudHJpbSkgbG9zZXMgZm9jdXMgYW5kIGl0cyB2YWx1ZSBpc1xuICAvLyBub3QgZXF1YWwgdG8gdGhlIHVwZGF0ZWQgdmFsdWVcbiAgdmFyIG5vdEluRm9jdXMgPSB0cnVlO1xuICAvLyAjNjE1N1xuICAvLyB3b3JrIGFyb3VuZCBJRSBidWcgd2hlbiBhY2Nlc3NpbmcgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCBpbiBhbiBpZnJhbWVcbiAgdHJ5IHsgbm90SW5Gb2N1cyA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgIT09IGVsbTsgfSBjYXRjaCAoZSkge31cbiAgcmV0dXJuIG5vdEluRm9jdXMgJiYgZWxtLnZhbHVlICE9PSBjaGVja1ZhbFxufVxuXG5mdW5jdGlvbiBpc0RpcnR5V2l0aE1vZGlmaWVycyAoZWxtLCBuZXdWYWwpIHtcbiAgdmFyIHZhbHVlID0gZWxtLnZhbHVlO1xuICB2YXIgbW9kaWZpZXJzID0gZWxtLl92TW9kaWZpZXJzOyAvLyBpbmplY3RlZCBieSB2LW1vZGVsIHJ1bnRpbWVcbiAgaWYgKGlzRGVmKG1vZGlmaWVycykpIHtcbiAgICBpZiAobW9kaWZpZXJzLmxhenkpIHtcbiAgICAgIC8vIGlucHV0cyB3aXRoIGxhenkgc2hvdWxkIG9ubHkgYmUgdXBkYXRlZCB3aGVuIG5vdCBpbiBmb2N1c1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIGlmIChtb2RpZmllcnMubnVtYmVyKSB7XG4gICAgICByZXR1cm4gdG9OdW1iZXIodmFsdWUpICE9PSB0b051bWJlcihuZXdWYWwpXG4gICAgfVxuICAgIGlmIChtb2RpZmllcnMudHJpbSkge1xuICAgICAgcmV0dXJuIHZhbHVlLnRyaW0oKSAhPT0gbmV3VmFsLnRyaW0oKVxuICAgIH1cbiAgfVxuICByZXR1cm4gdmFsdWUgIT09IG5ld1ZhbFxufVxuXG52YXIgZG9tUHJvcHMgPSB7XG4gIGNyZWF0ZTogdXBkYXRlRE9NUHJvcHMsXG4gIHVwZGF0ZTogdXBkYXRlRE9NUHJvcHNcbn1cblxuLyogICovXG5cbnZhciBwYXJzZVN0eWxlVGV4dCA9IGNhY2hlZChmdW5jdGlvbiAoY3NzVGV4dCkge1xuICB2YXIgcmVzID0ge307XG4gIHZhciBsaXN0RGVsaW1pdGVyID0gLzsoPyFbXihdKlxcKSkvZztcbiAgdmFyIHByb3BlcnR5RGVsaW1pdGVyID0gLzooLispLztcbiAgY3NzVGV4dC5zcGxpdChsaXN0RGVsaW1pdGVyKS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgaWYgKGl0ZW0pIHtcbiAgICAgIHZhciB0bXAgPSBpdGVtLnNwbGl0KHByb3BlcnR5RGVsaW1pdGVyKTtcbiAgICAgIHRtcC5sZW5ndGggPiAxICYmIChyZXNbdG1wWzBdLnRyaW0oKV0gPSB0bXBbMV0udHJpbSgpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzXG59KTtcblxuLy8gbWVyZ2Ugc3RhdGljIGFuZCBkeW5hbWljIHN0eWxlIGRhdGEgb24gdGhlIHNhbWUgdm5vZGVcbmZ1bmN0aW9uIG5vcm1hbGl6ZVN0eWxlRGF0YSAoZGF0YSkge1xuICB2YXIgc3R5bGUgPSBub3JtYWxpemVTdHlsZUJpbmRpbmcoZGF0YS5zdHlsZSk7XG4gIC8vIHN0YXRpYyBzdHlsZSBpcyBwcmUtcHJvY2Vzc2VkIGludG8gYW4gb2JqZWN0IGR1cmluZyBjb21waWxhdGlvblxuICAvLyBhbmQgaXMgYWx3YXlzIGEgZnJlc2ggb2JqZWN0LCBzbyBpdCdzIHNhZmUgdG8gbWVyZ2UgaW50byBpdFxuICByZXR1cm4gZGF0YS5zdGF0aWNTdHlsZVxuICAgID8gZXh0ZW5kKGRhdGEuc3RhdGljU3R5bGUsIHN0eWxlKVxuICAgIDogc3R5bGVcbn1cblxuLy8gbm9ybWFsaXplIHBvc3NpYmxlIGFycmF5IC8gc3RyaW5nIHZhbHVlcyBpbnRvIE9iamVjdFxuZnVuY3Rpb24gbm9ybWFsaXplU3R5bGVCaW5kaW5nIChiaW5kaW5nU3R5bGUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYmluZGluZ1N0eWxlKSkge1xuICAgIHJldHVybiB0b09iamVjdChiaW5kaW5nU3R5bGUpXG4gIH1cbiAgaWYgKHR5cGVvZiBiaW5kaW5nU3R5bGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHBhcnNlU3R5bGVUZXh0KGJpbmRpbmdTdHlsZSlcbiAgfVxuICByZXR1cm4gYmluZGluZ1N0eWxlXG59XG5cbi8qKlxuICogcGFyZW50IGNvbXBvbmVudCBzdHlsZSBzaG91bGQgYmUgYWZ0ZXIgY2hpbGQnc1xuICogc28gdGhhdCBwYXJlbnQgY29tcG9uZW50J3Mgc3R5bGUgY291bGQgb3ZlcnJpZGUgaXRcbiAqL1xuZnVuY3Rpb24gZ2V0U3R5bGUgKHZub2RlLCBjaGVja0NoaWxkKSB7XG4gIHZhciByZXMgPSB7fTtcbiAgdmFyIHN0eWxlRGF0YTtcblxuICBpZiAoY2hlY2tDaGlsZCkge1xuICAgIHZhciBjaGlsZE5vZGUgPSB2bm9kZTtcbiAgICB3aGlsZSAoY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlKSB7XG4gICAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgICAgaWYgKFxuICAgICAgICBjaGlsZE5vZGUgJiYgY2hpbGROb2RlLmRhdGEgJiZcbiAgICAgICAgKHN0eWxlRGF0YSA9IG5vcm1hbGl6ZVN0eWxlRGF0YShjaGlsZE5vZGUuZGF0YSkpXG4gICAgICApIHtcbiAgICAgICAgZXh0ZW5kKHJlcywgc3R5bGVEYXRhKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoKHN0eWxlRGF0YSA9IG5vcm1hbGl6ZVN0eWxlRGF0YSh2bm9kZS5kYXRhKSkpIHtcbiAgICBleHRlbmQocmVzLCBzdHlsZURhdGEpO1xuICB9XG5cbiAgdmFyIHBhcmVudE5vZGUgPSB2bm9kZTtcbiAgd2hpbGUgKChwYXJlbnROb2RlID0gcGFyZW50Tm9kZS5wYXJlbnQpKSB7XG4gICAgaWYgKHBhcmVudE5vZGUuZGF0YSAmJiAoc3R5bGVEYXRhID0gbm9ybWFsaXplU3R5bGVEYXRhKHBhcmVudE5vZGUuZGF0YSkpKSB7XG4gICAgICBleHRlbmQocmVzLCBzdHlsZURhdGEpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG52YXIgY3NzVmFyUkUgPSAvXi0tLztcbnZhciBpbXBvcnRhbnRSRSA9IC9cXHMqIWltcG9ydGFudCQvO1xudmFyIHNldFByb3AgPSBmdW5jdGlvbiAoZWwsIG5hbWUsIHZhbCkge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGNzc1ZhclJFLnRlc3QobmFtZSkpIHtcbiAgICBlbC5zdHlsZS5zZXRQcm9wZXJ0eShuYW1lLCB2YWwpO1xuICB9IGVsc2UgaWYgKGltcG9ydGFudFJFLnRlc3QodmFsKSkge1xuICAgIGVsLnN0eWxlLnNldFByb3BlcnR5KG5hbWUsIHZhbC5yZXBsYWNlKGltcG9ydGFudFJFLCAnJyksICdpbXBvcnRhbnQnKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbm9ybWFsaXplZE5hbWUgPSBub3JtYWxpemUobmFtZSk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgLy8gU3VwcG9ydCB2YWx1ZXMgYXJyYXkgY3JlYXRlZCBieSBhdXRvcHJlZml4ZXIsIGUuZy5cbiAgICAgIC8vIHtkaXNwbGF5OiBbXCItd2Via2l0LWJveFwiLCBcIi1tcy1mbGV4Ym94XCIsIFwiZmxleFwiXX1cbiAgICAgIC8vIFNldCB0aGVtIG9uZSBieSBvbmUsIGFuZCB0aGUgYnJvd3NlciB3aWxsIG9ubHkgc2V0IHRob3NlIGl0IGNhbiByZWNvZ25pemVcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB2YWwubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgZWwuc3R5bGVbbm9ybWFsaXplZE5hbWVdID0gdmFsW2ldO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zdHlsZVtub3JtYWxpemVkTmFtZV0gPSB2YWw7XG4gICAgfVxuICB9XG59O1xuXG52YXIgdmVuZG9yTmFtZXMgPSBbJ1dlYmtpdCcsICdNb3onLCAnbXMnXTtcblxudmFyIGVtcHR5U3R5bGU7XG52YXIgbm9ybWFsaXplID0gY2FjaGVkKGZ1bmN0aW9uIChwcm9wKSB7XG4gIGVtcHR5U3R5bGUgPSBlbXB0eVN0eWxlIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLnN0eWxlO1xuICBwcm9wID0gY2FtZWxpemUocHJvcCk7XG4gIGlmIChwcm9wICE9PSAnZmlsdGVyJyAmJiAocHJvcCBpbiBlbXB0eVN0eWxlKSkge1xuICAgIHJldHVybiBwcm9wXG4gIH1cbiAgdmFyIGNhcE5hbWUgPSBwcm9wLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgcHJvcC5zbGljZSgxKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB2ZW5kb3JOYW1lcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBuYW1lID0gdmVuZG9yTmFtZXNbaV0gKyBjYXBOYW1lO1xuICAgIGlmIChuYW1lIGluIGVtcHR5U3R5bGUpIHtcbiAgICAgIHJldHVybiBuYW1lXG4gICAgfVxuICB9XG59KTtcblxuZnVuY3Rpb24gdXBkYXRlU3R5bGUgKG9sZFZub2RlLCB2bm9kZSkge1xuICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gIHZhciBvbGREYXRhID0gb2xkVm5vZGUuZGF0YTtcblxuICBpZiAoaXNVbmRlZihkYXRhLnN0YXRpY1N0eWxlKSAmJiBpc1VuZGVmKGRhdGEuc3R5bGUpICYmXG4gICAgaXNVbmRlZihvbGREYXRhLnN0YXRpY1N0eWxlKSAmJiBpc1VuZGVmKG9sZERhdGEuc3R5bGUpXG4gICkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIGN1ciwgbmFtZTtcbiAgdmFyIGVsID0gdm5vZGUuZWxtO1xuICB2YXIgb2xkU3RhdGljU3R5bGUgPSBvbGREYXRhLnN0YXRpY1N0eWxlO1xuICB2YXIgb2xkU3R5bGVCaW5kaW5nID0gb2xkRGF0YS5ub3JtYWxpemVkU3R5bGUgfHwgb2xkRGF0YS5zdHlsZSB8fCB7fTtcblxuICAvLyBpZiBzdGF0aWMgc3R5bGUgZXhpc3RzLCBzdHlsZWJpbmRpbmcgYWxyZWFkeSBtZXJnZWQgaW50byBpdCB3aGVuIGRvaW5nIG5vcm1hbGl6ZVN0eWxlRGF0YVxuICB2YXIgb2xkU3R5bGUgPSBvbGRTdGF0aWNTdHlsZSB8fCBvbGRTdHlsZUJpbmRpbmc7XG5cbiAgdmFyIHN0eWxlID0gbm9ybWFsaXplU3R5bGVCaW5kaW5nKHZub2RlLmRhdGEuc3R5bGUpIHx8IHt9O1xuXG4gIC8vIHN0b3JlIG5vcm1hbGl6ZWQgc3R5bGUgdW5kZXIgYSBkaWZmZXJlbnQga2V5IGZvciBuZXh0IGRpZmZcbiAgLy8gbWFrZSBzdXJlIHRvIGNsb25lIGl0IGlmIGl0J3MgcmVhY3RpdmUsIHNpbmNlIHRoZSB1c2VyIGxpa2VseSB3YW50c1xuICAvLyB0byBtdXRhdGUgaXQuXG4gIHZub2RlLmRhdGEubm9ybWFsaXplZFN0eWxlID0gaXNEZWYoc3R5bGUuX19vYl9fKVxuICAgID8gZXh0ZW5kKHt9LCBzdHlsZSlcbiAgICA6IHN0eWxlO1xuXG4gIHZhciBuZXdTdHlsZSA9IGdldFN0eWxlKHZub2RlLCB0cnVlKTtcblxuICBmb3IgKG5hbWUgaW4gb2xkU3R5bGUpIHtcbiAgICBpZiAoaXNVbmRlZihuZXdTdHlsZVtuYW1lXSkpIHtcbiAgICAgIHNldFByb3AoZWwsIG5hbWUsICcnKTtcbiAgICB9XG4gIH1cbiAgZm9yIChuYW1lIGluIG5ld1N0eWxlKSB7XG4gICAgY3VyID0gbmV3U3R5bGVbbmFtZV07XG4gICAgaWYgKGN1ciAhPT0gb2xkU3R5bGVbbmFtZV0pIHtcbiAgICAgIC8vIGllOSBzZXR0aW5nIHRvIG51bGwgaGFzIG5vIGVmZmVjdCwgbXVzdCB1c2UgZW1wdHkgc3RyaW5nXG4gICAgICBzZXRQcm9wKGVsLCBuYW1lLCBjdXIgPT0gbnVsbCA/ICcnIDogY3VyKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIHN0eWxlID0ge1xuICBjcmVhdGU6IHVwZGF0ZVN0eWxlLFxuICB1cGRhdGU6IHVwZGF0ZVN0eWxlXG59XG5cbi8qICAqL1xuXG4vKipcbiAqIEFkZCBjbGFzcyB3aXRoIGNvbXBhdGliaWxpdHkgZm9yIFNWRyBzaW5jZSBjbGFzc0xpc3QgaXMgbm90IHN1cHBvcnRlZCBvblxuICogU1ZHIGVsZW1lbnRzIGluIElFXG4gKi9cbmZ1bmN0aW9uIGFkZENsYXNzIChlbCwgY2xzKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIWNscyB8fCAhKGNscyA9IGNscy50cmltKCkpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoZWwuY2xhc3NMaXN0KSB7XG4gICAgaWYgKGNscy5pbmRleE9mKCcgJykgPiAtMSkge1xuICAgICAgY2xzLnNwbGl0KC9cXHMrLykuZm9yRWFjaChmdW5jdGlvbiAoYykgeyByZXR1cm4gZWwuY2xhc3NMaXN0LmFkZChjKTsgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLmNsYXNzTGlzdC5hZGQoY2xzKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGN1ciA9IFwiIFwiICsgKGVsLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSB8fCAnJykgKyBcIiBcIjtcbiAgICBpZiAoY3VyLmluZGV4T2YoJyAnICsgY2xzICsgJyAnKSA8IDApIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAoY3VyICsgY2xzKS50cmltKCkpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZSBjbGFzcyB3aXRoIGNvbXBhdGliaWxpdHkgZm9yIFNWRyBzaW5jZSBjbGFzc0xpc3QgaXMgbm90IHN1cHBvcnRlZCBvblxuICogU1ZHIGVsZW1lbnRzIGluIElFXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUNsYXNzIChlbCwgY2xzKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIWNscyB8fCAhKGNscyA9IGNscy50cmltKCkpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoZWwuY2xhc3NMaXN0KSB7XG4gICAgaWYgKGNscy5pbmRleE9mKCcgJykgPiAtMSkge1xuICAgICAgY2xzLnNwbGl0KC9cXHMrLykuZm9yRWFjaChmdW5jdGlvbiAoYykgeyByZXR1cm4gZWwuY2xhc3NMaXN0LnJlbW92ZShjKTsgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoY2xzKTtcbiAgICB9XG4gICAgaWYgKCFlbC5jbGFzc0xpc3QubGVuZ3RoKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ2NsYXNzJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBjdXIgPSBcIiBcIiArIChlbC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgfHwgJycpICsgXCIgXCI7XG4gICAgdmFyIHRhciA9ICcgJyArIGNscyArICcgJztcbiAgICB3aGlsZSAoY3VyLmluZGV4T2YodGFyKSA+PSAwKSB7XG4gICAgICBjdXIgPSBjdXIucmVwbGFjZSh0YXIsICcgJyk7XG4gICAgfVxuICAgIGN1ciA9IGN1ci50cmltKCk7XG4gICAgaWYgKGN1cikge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIGN1cik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZSgnY2xhc3MnKTtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIHJlc29sdmVUcmFuc2l0aW9uIChkZWYpIHtcbiAgaWYgKCFkZWYpIHtcbiAgICByZXR1cm5cbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAodHlwZW9mIGRlZiA9PT0gJ29iamVjdCcpIHtcbiAgICB2YXIgcmVzID0ge307XG4gICAgaWYgKGRlZi5jc3MgIT09IGZhbHNlKSB7XG4gICAgICBleHRlbmQocmVzLCBhdXRvQ3NzVHJhbnNpdGlvbihkZWYubmFtZSB8fCAndicpKTtcbiAgICB9XG4gICAgZXh0ZW5kKHJlcywgZGVmKTtcbiAgICByZXR1cm4gcmVzXG4gIH0gZWxzZSBpZiAodHlwZW9mIGRlZiA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gYXV0b0Nzc1RyYW5zaXRpb24oZGVmKVxuICB9XG59XG5cbnZhciBhdXRvQ3NzVHJhbnNpdGlvbiA9IGNhY2hlZChmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4ge1xuICAgIGVudGVyQ2xhc3M6IChuYW1lICsgXCItZW50ZXJcIiksXG4gICAgZW50ZXJUb0NsYXNzOiAobmFtZSArIFwiLWVudGVyLXRvXCIpLFxuICAgIGVudGVyQWN0aXZlQ2xhc3M6IChuYW1lICsgXCItZW50ZXItYWN0aXZlXCIpLFxuICAgIGxlYXZlQ2xhc3M6IChuYW1lICsgXCItbGVhdmVcIiksXG4gICAgbGVhdmVUb0NsYXNzOiAobmFtZSArIFwiLWxlYXZlLXRvXCIpLFxuICAgIGxlYXZlQWN0aXZlQ2xhc3M6IChuYW1lICsgXCItbGVhdmUtYWN0aXZlXCIpXG4gIH1cbn0pO1xuXG52YXIgaGFzVHJhbnNpdGlvbiA9IGluQnJvd3NlciAmJiAhaXNJRTk7XG52YXIgVFJBTlNJVElPTiA9ICd0cmFuc2l0aW9uJztcbnZhciBBTklNQVRJT04gPSAnYW5pbWF0aW9uJztcblxuLy8gVHJhbnNpdGlvbiBwcm9wZXJ0eS9ldmVudCBzbmlmZmluZ1xudmFyIHRyYW5zaXRpb25Qcm9wID0gJ3RyYW5zaXRpb24nO1xudmFyIHRyYW5zaXRpb25FbmRFdmVudCA9ICd0cmFuc2l0aW9uZW5kJztcbnZhciBhbmltYXRpb25Qcm9wID0gJ2FuaW1hdGlvbic7XG52YXIgYW5pbWF0aW9uRW5kRXZlbnQgPSAnYW5pbWF0aW9uZW5kJztcbmlmIChoYXNUcmFuc2l0aW9uKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAod2luZG93Lm9udHJhbnNpdGlvbmVuZCA9PT0gdW5kZWZpbmVkICYmXG4gICAgd2luZG93Lm9ud2Via2l0dHJhbnNpdGlvbmVuZCAhPT0gdW5kZWZpbmVkXG4gICkge1xuICAgIHRyYW5zaXRpb25Qcm9wID0gJ1dlYmtpdFRyYW5zaXRpb24nO1xuICAgIHRyYW5zaXRpb25FbmRFdmVudCA9ICd3ZWJraXRUcmFuc2l0aW9uRW5kJztcbiAgfVxuICBpZiAod2luZG93Lm9uYW5pbWF0aW9uZW5kID09PSB1bmRlZmluZWQgJiZcbiAgICB3aW5kb3cub253ZWJraXRhbmltYXRpb25lbmQgIT09IHVuZGVmaW5lZFxuICApIHtcbiAgICBhbmltYXRpb25Qcm9wID0gJ1dlYmtpdEFuaW1hdGlvbic7XG4gICAgYW5pbWF0aW9uRW5kRXZlbnQgPSAnd2Via2l0QW5pbWF0aW9uRW5kJztcbiAgfVxufVxuXG4vLyBiaW5kaW5nIHRvIHdpbmRvdyBpcyBuZWNlc3NhcnkgdG8gbWFrZSBob3QgcmVsb2FkIHdvcmsgaW4gSUUgaW4gc3RyaWN0IG1vZGVcbnZhciByYWYgPSBpbkJyb3dzZXJcbiAgPyB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gICAgPyB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lLmJpbmQod2luZG93KVxuICAgIDogc2V0VGltZW91dFxuICA6IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIGZ1bmN0aW9uIChmbikgeyByZXR1cm4gZm4oKTsgfTtcblxuZnVuY3Rpb24gbmV4dEZyYW1lIChmbikge1xuICByYWYoZnVuY3Rpb24gKCkge1xuICAgIHJhZihmbik7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBhZGRUcmFuc2l0aW9uQ2xhc3MgKGVsLCBjbHMpIHtcbiAgdmFyIHRyYW5zaXRpb25DbGFzc2VzID0gZWwuX3RyYW5zaXRpb25DbGFzc2VzIHx8IChlbC5fdHJhbnNpdGlvbkNsYXNzZXMgPSBbXSk7XG4gIGlmICh0cmFuc2l0aW9uQ2xhc3Nlcy5pbmRleE9mKGNscykgPCAwKSB7XG4gICAgdHJhbnNpdGlvbkNsYXNzZXMucHVzaChjbHMpO1xuICAgIGFkZENsYXNzKGVsLCBjbHMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVRyYW5zaXRpb25DbGFzcyAoZWwsIGNscykge1xuICBpZiAoZWwuX3RyYW5zaXRpb25DbGFzc2VzKSB7XG4gICAgcmVtb3ZlKGVsLl90cmFuc2l0aW9uQ2xhc3NlcywgY2xzKTtcbiAgfVxuICByZW1vdmVDbGFzcyhlbCwgY2xzKTtcbn1cblxuZnVuY3Rpb24gd2hlblRyYW5zaXRpb25FbmRzIChcbiAgZWwsXG4gIGV4cGVjdGVkVHlwZSxcbiAgY2Jcbikge1xuICB2YXIgcmVmID0gZ2V0VHJhbnNpdGlvbkluZm8oZWwsIGV4cGVjdGVkVHlwZSk7XG4gIHZhciB0eXBlID0gcmVmLnR5cGU7XG4gIHZhciB0aW1lb3V0ID0gcmVmLnRpbWVvdXQ7XG4gIHZhciBwcm9wQ291bnQgPSByZWYucHJvcENvdW50O1xuICBpZiAoIXR5cGUpIHsgcmV0dXJuIGNiKCkgfVxuICB2YXIgZXZlbnQgPSB0eXBlID09PSBUUkFOU0lUSU9OID8gdHJhbnNpdGlvbkVuZEV2ZW50IDogYW5pbWF0aW9uRW5kRXZlbnQ7XG4gIHZhciBlbmRlZCA9IDA7XG4gIHZhciBlbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgb25FbmQpO1xuICAgIGNiKCk7XG4gIH07XG4gIHZhciBvbkVuZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGUudGFyZ2V0ID09PSBlbCkge1xuICAgICAgaWYgKCsrZW5kZWQgPj0gcHJvcENvdW50KSB7XG4gICAgICAgIGVuZCgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGVuZGVkIDwgcHJvcENvdW50KSB7XG4gICAgICBlbmQoKTtcbiAgICB9XG4gIH0sIHRpbWVvdXQgKyAxKTtcbiAgZWwuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgb25FbmQpO1xufVxuXG52YXIgdHJhbnNmb3JtUkUgPSAvXFxiKHRyYW5zZm9ybXxhbGwpKCx8JCkvO1xuXG5mdW5jdGlvbiBnZXRUcmFuc2l0aW9uSW5mbyAoZWwsIGV4cGVjdGVkVHlwZSkge1xuICB2YXIgc3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpO1xuICB2YXIgdHJhbnNpdGlvbkRlbGF5cyA9IHN0eWxlc1t0cmFuc2l0aW9uUHJvcCArICdEZWxheSddLnNwbGl0KCcsICcpO1xuICB2YXIgdHJhbnNpdGlvbkR1cmF0aW9ucyA9IHN0eWxlc1t0cmFuc2l0aW9uUHJvcCArICdEdXJhdGlvbiddLnNwbGl0KCcsICcpO1xuICB2YXIgdHJhbnNpdGlvblRpbWVvdXQgPSBnZXRUaW1lb3V0KHRyYW5zaXRpb25EZWxheXMsIHRyYW5zaXRpb25EdXJhdGlvbnMpO1xuICB2YXIgYW5pbWF0aW9uRGVsYXlzID0gc3R5bGVzW2FuaW1hdGlvblByb3AgKyAnRGVsYXknXS5zcGxpdCgnLCAnKTtcbiAgdmFyIGFuaW1hdGlvbkR1cmF0aW9ucyA9IHN0eWxlc1thbmltYXRpb25Qcm9wICsgJ0R1cmF0aW9uJ10uc3BsaXQoJywgJyk7XG4gIHZhciBhbmltYXRpb25UaW1lb3V0ID0gZ2V0VGltZW91dChhbmltYXRpb25EZWxheXMsIGFuaW1hdGlvbkR1cmF0aW9ucyk7XG5cbiAgdmFyIHR5cGU7XG4gIHZhciB0aW1lb3V0ID0gMDtcbiAgdmFyIHByb3BDb3VudCA9IDA7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoZXhwZWN0ZWRUeXBlID09PSBUUkFOU0lUSU9OKSB7XG4gICAgaWYgKHRyYW5zaXRpb25UaW1lb3V0ID4gMCkge1xuICAgICAgdHlwZSA9IFRSQU5TSVRJT047XG4gICAgICB0aW1lb3V0ID0gdHJhbnNpdGlvblRpbWVvdXQ7XG4gICAgICBwcm9wQ291bnQgPSB0cmFuc2l0aW9uRHVyYXRpb25zLmxlbmd0aDtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSBBTklNQVRJT04pIHtcbiAgICBpZiAoYW5pbWF0aW9uVGltZW91dCA+IDApIHtcbiAgICAgIHR5cGUgPSBBTklNQVRJT047XG4gICAgICB0aW1lb3V0ID0gYW5pbWF0aW9uVGltZW91dDtcbiAgICAgIHByb3BDb3VudCA9IGFuaW1hdGlvbkR1cmF0aW9ucy5sZW5ndGg7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRpbWVvdXQgPSBNYXRoLm1heCh0cmFuc2l0aW9uVGltZW91dCwgYW5pbWF0aW9uVGltZW91dCk7XG4gICAgdHlwZSA9IHRpbWVvdXQgPiAwXG4gICAgICA/IHRyYW5zaXRpb25UaW1lb3V0ID4gYW5pbWF0aW9uVGltZW91dFxuICAgICAgICA/IFRSQU5TSVRJT05cbiAgICAgICAgOiBBTklNQVRJT05cbiAgICAgIDogbnVsbDtcbiAgICBwcm9wQ291bnQgPSB0eXBlXG4gICAgICA/IHR5cGUgPT09IFRSQU5TSVRJT05cbiAgICAgICAgPyB0cmFuc2l0aW9uRHVyYXRpb25zLmxlbmd0aFxuICAgICAgICA6IGFuaW1hdGlvbkR1cmF0aW9ucy5sZW5ndGhcbiAgICAgIDogMDtcbiAgfVxuICB2YXIgaGFzVHJhbnNmb3JtID1cbiAgICB0eXBlID09PSBUUkFOU0lUSU9OICYmXG4gICAgdHJhbnNmb3JtUkUudGVzdChzdHlsZXNbdHJhbnNpdGlvblByb3AgKyAnUHJvcGVydHknXSk7XG4gIHJldHVybiB7XG4gICAgdHlwZTogdHlwZSxcbiAgICB0aW1lb3V0OiB0aW1lb3V0LFxuICAgIHByb3BDb3VudDogcHJvcENvdW50LFxuICAgIGhhc1RyYW5zZm9ybTogaGFzVHJhbnNmb3JtXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0VGltZW91dCAoZGVsYXlzLCBkdXJhdGlvbnMpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgd2hpbGUgKGRlbGF5cy5sZW5ndGggPCBkdXJhdGlvbnMubGVuZ3RoKSB7XG4gICAgZGVsYXlzID0gZGVsYXlzLmNvbmNhdChkZWxheXMpO1xuICB9XG5cbiAgcmV0dXJuIE1hdGgubWF4LmFwcGx5KG51bGwsIGR1cmF0aW9ucy5tYXAoZnVuY3Rpb24gKGQsIGkpIHtcbiAgICByZXR1cm4gdG9NcyhkKSArIHRvTXMoZGVsYXlzW2ldKVxuICB9KSlcbn1cblxuZnVuY3Rpb24gdG9NcyAocykge1xuICByZXR1cm4gTnVtYmVyKHMuc2xpY2UoMCwgLTEpKSAqIDEwMDBcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGVudGVyICh2bm9kZSwgdG9nZ2xlRGlzcGxheSkge1xuICB2YXIgZWwgPSB2bm9kZS5lbG07XG5cbiAgLy8gY2FsbCBsZWF2ZSBjYWxsYmFjayBub3dcbiAgaWYgKGlzRGVmKGVsLl9sZWF2ZUNiKSkge1xuICAgIGVsLl9sZWF2ZUNiLmNhbmNlbGxlZCA9IHRydWU7XG4gICAgZWwuX2xlYXZlQ2IoKTtcbiAgfVxuXG4gIHZhciBkYXRhID0gcmVzb2x2ZVRyYW5zaXRpb24odm5vZGUuZGF0YS50cmFuc2l0aW9uKTtcbiAgaWYgKGlzVW5kZWYoZGF0YSkpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaXNEZWYoZWwuX2VudGVyQ2IpIHx8IGVsLm5vZGVUeXBlICE9PSAxKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgY3NzID0gZGF0YS5jc3M7XG4gIHZhciB0eXBlID0gZGF0YS50eXBlO1xuICB2YXIgZW50ZXJDbGFzcyA9IGRhdGEuZW50ZXJDbGFzcztcbiAgdmFyIGVudGVyVG9DbGFzcyA9IGRhdGEuZW50ZXJUb0NsYXNzO1xuICB2YXIgZW50ZXJBY3RpdmVDbGFzcyA9IGRhdGEuZW50ZXJBY3RpdmVDbGFzcztcbiAgdmFyIGFwcGVhckNsYXNzID0gZGF0YS5hcHBlYXJDbGFzcztcbiAgdmFyIGFwcGVhclRvQ2xhc3MgPSBkYXRhLmFwcGVhclRvQ2xhc3M7XG4gIHZhciBhcHBlYXJBY3RpdmVDbGFzcyA9IGRhdGEuYXBwZWFyQWN0aXZlQ2xhc3M7XG4gIHZhciBiZWZvcmVFbnRlciA9IGRhdGEuYmVmb3JlRW50ZXI7XG4gIHZhciBlbnRlciA9IGRhdGEuZW50ZXI7XG4gIHZhciBhZnRlckVudGVyID0gZGF0YS5hZnRlckVudGVyO1xuICB2YXIgZW50ZXJDYW5jZWxsZWQgPSBkYXRhLmVudGVyQ2FuY2VsbGVkO1xuICB2YXIgYmVmb3JlQXBwZWFyID0gZGF0YS5iZWZvcmVBcHBlYXI7XG4gIHZhciBhcHBlYXIgPSBkYXRhLmFwcGVhcjtcbiAgdmFyIGFmdGVyQXBwZWFyID0gZGF0YS5hZnRlckFwcGVhcjtcbiAgdmFyIGFwcGVhckNhbmNlbGxlZCA9IGRhdGEuYXBwZWFyQ2FuY2VsbGVkO1xuICB2YXIgZHVyYXRpb24gPSBkYXRhLmR1cmF0aW9uO1xuXG4gIC8vIGFjdGl2ZUluc3RhbmNlIHdpbGwgYWx3YXlzIGJlIHRoZSA8dHJhbnNpdGlvbj4gY29tcG9uZW50IG1hbmFnaW5nIHRoaXNcbiAgLy8gdHJhbnNpdGlvbi4gT25lIGVkZ2UgY2FzZSB0byBjaGVjayBpcyB3aGVuIHRoZSA8dHJhbnNpdGlvbj4gaXMgcGxhY2VkXG4gIC8vIGFzIHRoZSByb290IG5vZGUgb2YgYSBjaGlsZCBjb21wb25lbnQuIEluIHRoYXQgY2FzZSB3ZSBuZWVkIHRvIGNoZWNrXG4gIC8vIDx0cmFuc2l0aW9uPidzIHBhcmVudCBmb3IgYXBwZWFyIGNoZWNrLlxuICB2YXIgY29udGV4dCA9IGFjdGl2ZUluc3RhbmNlO1xuICB2YXIgdHJhbnNpdGlvbk5vZGUgPSBhY3RpdmVJbnN0YW5jZS4kdm5vZGU7XG4gIHdoaWxlICh0cmFuc2l0aW9uTm9kZSAmJiB0cmFuc2l0aW9uTm9kZS5wYXJlbnQpIHtcbiAgICB0cmFuc2l0aW9uTm9kZSA9IHRyYW5zaXRpb25Ob2RlLnBhcmVudDtcbiAgICBjb250ZXh0ID0gdHJhbnNpdGlvbk5vZGUuY29udGV4dDtcbiAgfVxuXG4gIHZhciBpc0FwcGVhciA9ICFjb250ZXh0Ll9pc01vdW50ZWQgfHwgIXZub2RlLmlzUm9vdEluc2VydDtcblxuICBpZiAoaXNBcHBlYXIgJiYgIWFwcGVhciAmJiBhcHBlYXIgIT09ICcnKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgc3RhcnRDbGFzcyA9IGlzQXBwZWFyICYmIGFwcGVhckNsYXNzXG4gICAgPyBhcHBlYXJDbGFzc1xuICAgIDogZW50ZXJDbGFzcztcbiAgdmFyIGFjdGl2ZUNsYXNzID0gaXNBcHBlYXIgJiYgYXBwZWFyQWN0aXZlQ2xhc3NcbiAgICA/IGFwcGVhckFjdGl2ZUNsYXNzXG4gICAgOiBlbnRlckFjdGl2ZUNsYXNzO1xuICB2YXIgdG9DbGFzcyA9IGlzQXBwZWFyICYmIGFwcGVhclRvQ2xhc3NcbiAgICA/IGFwcGVhclRvQ2xhc3NcbiAgICA6IGVudGVyVG9DbGFzcztcblxuICB2YXIgYmVmb3JlRW50ZXJIb29rID0gaXNBcHBlYXJcbiAgICA/IChiZWZvcmVBcHBlYXIgfHwgYmVmb3JlRW50ZXIpXG4gICAgOiBiZWZvcmVFbnRlcjtcbiAgdmFyIGVudGVySG9vayA9IGlzQXBwZWFyXG4gICAgPyAodHlwZW9mIGFwcGVhciA9PT0gJ2Z1bmN0aW9uJyA/IGFwcGVhciA6IGVudGVyKVxuICAgIDogZW50ZXI7XG4gIHZhciBhZnRlckVudGVySG9vayA9IGlzQXBwZWFyXG4gICAgPyAoYWZ0ZXJBcHBlYXIgfHwgYWZ0ZXJFbnRlcilcbiAgICA6IGFmdGVyRW50ZXI7XG4gIHZhciBlbnRlckNhbmNlbGxlZEhvb2sgPSBpc0FwcGVhclxuICAgID8gKGFwcGVhckNhbmNlbGxlZCB8fCBlbnRlckNhbmNlbGxlZClcbiAgICA6IGVudGVyQ2FuY2VsbGVkO1xuXG4gIHZhciBleHBsaWNpdEVudGVyRHVyYXRpb24gPSB0b051bWJlcihcbiAgICBpc09iamVjdChkdXJhdGlvbilcbiAgICAgID8gZHVyYXRpb24uZW50ZXJcbiAgICAgIDogZHVyYXRpb25cbiAgKTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBleHBsaWNpdEVudGVyRHVyYXRpb24gIT0gbnVsbCkge1xuICAgIGNoZWNrRHVyYXRpb24oZXhwbGljaXRFbnRlckR1cmF0aW9uLCAnZW50ZXInLCB2bm9kZSk7XG4gIH1cblxuICB2YXIgZXhwZWN0c0NTUyA9IGNzcyAhPT0gZmFsc2UgJiYgIWlzSUU5O1xuICB2YXIgdXNlcldhbnRzQ29udHJvbCA9IGdldEhvb2tBcmd1bWVudHNMZW5ndGgoZW50ZXJIb29rKTtcblxuICB2YXIgY2IgPSBlbC5fZW50ZXJDYiA9IG9uY2UoZnVuY3Rpb24gKCkge1xuICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIHRvQ2xhc3MpO1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBhY3RpdmVDbGFzcyk7XG4gICAgfVxuICAgIGlmIChjYi5jYW5jZWxsZWQpIHtcbiAgICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgc3RhcnRDbGFzcyk7XG4gICAgICB9XG4gICAgICBlbnRlckNhbmNlbGxlZEhvb2sgJiYgZW50ZXJDYW5jZWxsZWRIb29rKGVsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWZ0ZXJFbnRlckhvb2sgJiYgYWZ0ZXJFbnRlckhvb2soZWwpO1xuICAgIH1cbiAgICBlbC5fZW50ZXJDYiA9IG51bGw7XG4gIH0pO1xuXG4gIGlmICghdm5vZGUuZGF0YS5zaG93KSB7XG4gICAgLy8gcmVtb3ZlIHBlbmRpbmcgbGVhdmUgZWxlbWVudCBvbiBlbnRlciBieSBpbmplY3RpbmcgYW4gaW5zZXJ0IGhvb2tcbiAgICBtZXJnZVZOb2RlSG9vayh2bm9kZSwgJ2luc2VydCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBwYXJlbnQgPSBlbC5wYXJlbnROb2RlO1xuICAgICAgdmFyIHBlbmRpbmdOb2RlID0gcGFyZW50ICYmIHBhcmVudC5fcGVuZGluZyAmJiBwYXJlbnQuX3BlbmRpbmdbdm5vZGUua2V5XTtcbiAgICAgIGlmIChwZW5kaW5nTm9kZSAmJlxuICAgICAgICBwZW5kaW5nTm9kZS50YWcgPT09IHZub2RlLnRhZyAmJlxuICAgICAgICBwZW5kaW5nTm9kZS5lbG0uX2xlYXZlQ2JcbiAgICAgICkge1xuICAgICAgICBwZW5kaW5nTm9kZS5lbG0uX2xlYXZlQ2IoKTtcbiAgICAgIH1cbiAgICAgIGVudGVySG9vayAmJiBlbnRlckhvb2soZWwsIGNiKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIHN0YXJ0IGVudGVyIHRyYW5zaXRpb25cbiAgYmVmb3JlRW50ZXJIb29rICYmIGJlZm9yZUVudGVySG9vayhlbCk7XG4gIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBzdGFydENsYXNzKTtcbiAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGFjdGl2ZUNsYXNzKTtcbiAgICBuZXh0RnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBzdGFydENsYXNzKTtcbiAgICAgIGlmICghY2IuY2FuY2VsbGVkKSB7XG4gICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgdG9DbGFzcyk7XG4gICAgICAgIGlmICghdXNlcldhbnRzQ29udHJvbCkge1xuICAgICAgICAgIGlmIChpc1ZhbGlkRHVyYXRpb24oZXhwbGljaXRFbnRlckR1cmF0aW9uKSkge1xuICAgICAgICAgICAgc2V0VGltZW91dChjYiwgZXhwbGljaXRFbnRlckR1cmF0aW9uKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd2hlblRyYW5zaXRpb25FbmRzKGVsLCB0eXBlLCBjYik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBpZiAodm5vZGUuZGF0YS5zaG93KSB7XG4gICAgdG9nZ2xlRGlzcGxheSAmJiB0b2dnbGVEaXNwbGF5KCk7XG4gICAgZW50ZXJIb29rICYmIGVudGVySG9vayhlbCwgY2IpO1xuICB9XG5cbiAgaWYgKCFleHBlY3RzQ1NTICYmICF1c2VyV2FudHNDb250cm9sKSB7XG4gICAgY2IoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBsZWF2ZSAodm5vZGUsIHJtKSB7XG4gIHZhciBlbCA9IHZub2RlLmVsbTtcblxuICAvLyBjYWxsIGVudGVyIGNhbGxiYWNrIG5vd1xuICBpZiAoaXNEZWYoZWwuX2VudGVyQ2IpKSB7XG4gICAgZWwuX2VudGVyQ2IuY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICBlbC5fZW50ZXJDYigpO1xuICB9XG5cbiAgdmFyIGRhdGEgPSByZXNvbHZlVHJhbnNpdGlvbih2bm9kZS5kYXRhLnRyYW5zaXRpb24pO1xuICBpZiAoaXNVbmRlZihkYXRhKSB8fCBlbC5ub2RlVHlwZSAhPT0gMSkge1xuICAgIHJldHVybiBybSgpXG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGlzRGVmKGVsLl9sZWF2ZUNiKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIGNzcyA9IGRhdGEuY3NzO1xuICB2YXIgdHlwZSA9IGRhdGEudHlwZTtcbiAgdmFyIGxlYXZlQ2xhc3MgPSBkYXRhLmxlYXZlQ2xhc3M7XG4gIHZhciBsZWF2ZVRvQ2xhc3MgPSBkYXRhLmxlYXZlVG9DbGFzcztcbiAgdmFyIGxlYXZlQWN0aXZlQ2xhc3MgPSBkYXRhLmxlYXZlQWN0aXZlQ2xhc3M7XG4gIHZhciBiZWZvcmVMZWF2ZSA9IGRhdGEuYmVmb3JlTGVhdmU7XG4gIHZhciBsZWF2ZSA9IGRhdGEubGVhdmU7XG4gIHZhciBhZnRlckxlYXZlID0gZGF0YS5hZnRlckxlYXZlO1xuICB2YXIgbGVhdmVDYW5jZWxsZWQgPSBkYXRhLmxlYXZlQ2FuY2VsbGVkO1xuICB2YXIgZGVsYXlMZWF2ZSA9IGRhdGEuZGVsYXlMZWF2ZTtcbiAgdmFyIGR1cmF0aW9uID0gZGF0YS5kdXJhdGlvbjtcblxuICB2YXIgZXhwZWN0c0NTUyA9IGNzcyAhPT0gZmFsc2UgJiYgIWlzSUU5O1xuICB2YXIgdXNlcldhbnRzQ29udHJvbCA9IGdldEhvb2tBcmd1bWVudHNMZW5ndGgobGVhdmUpO1xuXG4gIHZhciBleHBsaWNpdExlYXZlRHVyYXRpb24gPSB0b051bWJlcihcbiAgICBpc09iamVjdChkdXJhdGlvbilcbiAgICAgID8gZHVyYXRpb24ubGVhdmVcbiAgICAgIDogZHVyYXRpb25cbiAgKTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBpc0RlZihleHBsaWNpdExlYXZlRHVyYXRpb24pKSB7XG4gICAgY2hlY2tEdXJhdGlvbihleHBsaWNpdExlYXZlRHVyYXRpb24sICdsZWF2ZScsIHZub2RlKTtcbiAgfVxuXG4gIHZhciBjYiA9IGVsLl9sZWF2ZUNiID0gb25jZShmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGVsLnBhcmVudE5vZGUgJiYgZWwucGFyZW50Tm9kZS5fcGVuZGluZykge1xuICAgICAgZWwucGFyZW50Tm9kZS5fcGVuZGluZ1t2bm9kZS5rZXldID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVUb0NsYXNzKTtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVBY3RpdmVDbGFzcyk7XG4gICAgfVxuICAgIGlmIChjYi5jYW5jZWxsZWQpIHtcbiAgICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVDbGFzcyk7XG4gICAgICB9XG4gICAgICBsZWF2ZUNhbmNlbGxlZCAmJiBsZWF2ZUNhbmNlbGxlZChlbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJtKCk7XG4gICAgICBhZnRlckxlYXZlICYmIGFmdGVyTGVhdmUoZWwpO1xuICAgIH1cbiAgICBlbC5fbGVhdmVDYiA9IG51bGw7XG4gIH0pO1xuXG4gIGlmIChkZWxheUxlYXZlKSB7XG4gICAgZGVsYXlMZWF2ZShwZXJmb3JtTGVhdmUpO1xuICB9IGVsc2Uge1xuICAgIHBlcmZvcm1MZWF2ZSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVyZm9ybUxlYXZlICgpIHtcbiAgICAvLyB0aGUgZGVsYXllZCBsZWF2ZSBtYXkgaGF2ZSBhbHJlYWR5IGJlZW4gY2FuY2VsbGVkXG4gICAgaWYgKGNiLmNhbmNlbGxlZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIC8vIHJlY29yZCBsZWF2aW5nIGVsZW1lbnRcbiAgICBpZiAoIXZub2RlLmRhdGEuc2hvdykge1xuICAgICAgKGVsLnBhcmVudE5vZGUuX3BlbmRpbmcgfHwgKGVsLnBhcmVudE5vZGUuX3BlbmRpbmcgPSB7fSkpWyh2bm9kZS5rZXkpXSA9IHZub2RlO1xuICAgIH1cbiAgICBiZWZvcmVMZWF2ZSAmJiBiZWZvcmVMZWF2ZShlbCk7XG4gICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVDbGFzcyk7XG4gICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQWN0aXZlQ2xhc3MpO1xuICAgICAgbmV4dEZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUNsYXNzKTtcbiAgICAgICAgaWYgKCFjYi5jYW5jZWxsZWQpIHtcbiAgICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlVG9DbGFzcyk7XG4gICAgICAgICAgaWYgKCF1c2VyV2FudHNDb250cm9sKSB7XG4gICAgICAgICAgICBpZiAoaXNWYWxpZER1cmF0aW9uKGV4cGxpY2l0TGVhdmVEdXJhdGlvbikpIHtcbiAgICAgICAgICAgICAgc2V0VGltZW91dChjYiwgZXhwbGljaXRMZWF2ZUR1cmF0aW9uKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHdoZW5UcmFuc2l0aW9uRW5kcyhlbCwgdHlwZSwgY2IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGxlYXZlICYmIGxlYXZlKGVsLCBjYik7XG4gICAgaWYgKCFleHBlY3RzQ1NTICYmICF1c2VyV2FudHNDb250cm9sKSB7XG4gICAgICBjYigpO1xuICAgIH1cbiAgfVxufVxuXG4vLyBvbmx5IHVzZWQgaW4gZGV2IG1vZGVcbmZ1bmN0aW9uIGNoZWNrRHVyYXRpb24gKHZhbCwgbmFtZSwgdm5vZGUpIHtcbiAgaWYgKHR5cGVvZiB2YWwgIT09ICdudW1iZXInKSB7XG4gICAgd2FybihcbiAgICAgIFwiPHRyYW5zaXRpb24+IGV4cGxpY2l0IFwiICsgbmFtZSArIFwiIGR1cmF0aW9uIGlzIG5vdCBhIHZhbGlkIG51bWJlciAtIFwiICtcbiAgICAgIFwiZ290IFwiICsgKEpTT04uc3RyaW5naWZ5KHZhbCkpICsgXCIuXCIsXG4gICAgICB2bm9kZS5jb250ZXh0XG4gICAgKTtcbiAgfSBlbHNlIGlmIChpc05hTih2YWwpKSB7XG4gICAgd2FybihcbiAgICAgIFwiPHRyYW5zaXRpb24+IGV4cGxpY2l0IFwiICsgbmFtZSArIFwiIGR1cmF0aW9uIGlzIE5hTiAtIFwiICtcbiAgICAgICd0aGUgZHVyYXRpb24gZXhwcmVzc2lvbiBtaWdodCBiZSBpbmNvcnJlY3QuJyxcbiAgICAgIHZub2RlLmNvbnRleHRcbiAgICApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzVmFsaWREdXJhdGlvbiAodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAnbnVtYmVyJyAmJiAhaXNOYU4odmFsKVxufVxuXG4vKipcbiAqIE5vcm1hbGl6ZSBhIHRyYW5zaXRpb24gaG9vaydzIGFyZ3VtZW50IGxlbmd0aC4gVGhlIGhvb2sgbWF5IGJlOlxuICogLSBhIG1lcmdlZCBob29rIChpbnZva2VyKSB3aXRoIHRoZSBvcmlnaW5hbCBpbiAuZm5zXG4gKiAtIGEgd3JhcHBlZCBjb21wb25lbnQgbWV0aG9kIChjaGVjayAuX2xlbmd0aClcbiAqIC0gYSBwbGFpbiBmdW5jdGlvbiAoLmxlbmd0aClcbiAqL1xuZnVuY3Rpb24gZ2V0SG9va0FyZ3VtZW50c0xlbmd0aCAoZm4pIHtcbiAgaWYgKGlzVW5kZWYoZm4pKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgdmFyIGludm9rZXJGbnMgPSBmbi5mbnM7XG4gIGlmIChpc0RlZihpbnZva2VyRm5zKSkge1xuICAgIC8vIGludm9rZXJcbiAgICByZXR1cm4gZ2V0SG9va0FyZ3VtZW50c0xlbmd0aChcbiAgICAgIEFycmF5LmlzQXJyYXkoaW52b2tlckZucylcbiAgICAgICAgPyBpbnZva2VyRm5zWzBdXG4gICAgICAgIDogaW52b2tlckZuc1xuICAgIClcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKGZuLl9sZW5ndGggfHwgZm4ubGVuZ3RoKSA+IDFcbiAgfVxufVxuXG5mdW5jdGlvbiBfZW50ZXIgKF8sIHZub2RlKSB7XG4gIGlmICh2bm9kZS5kYXRhLnNob3cgIT09IHRydWUpIHtcbiAgICBlbnRlcih2bm9kZSk7XG4gIH1cbn1cblxudmFyIHRyYW5zaXRpb24gPSBpbkJyb3dzZXIgPyB7XG4gIGNyZWF0ZTogX2VudGVyLFxuICBhY3RpdmF0ZTogX2VudGVyLFxuICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSQkMSAodm5vZGUsIHJtKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAodm5vZGUuZGF0YS5zaG93ICE9PSB0cnVlKSB7XG4gICAgICBsZWF2ZSh2bm9kZSwgcm0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBybSgpO1xuICAgIH1cbiAgfVxufSA6IHt9XG5cbnZhciBwbGF0Zm9ybU1vZHVsZXMgPSBbXG4gIGF0dHJzLFxuICBrbGFzcyxcbiAgZXZlbnRzLFxuICBkb21Qcm9wcyxcbiAgc3R5bGUsXG4gIHRyYW5zaXRpb25cbl1cblxuLyogICovXG5cbi8vIHRoZSBkaXJlY3RpdmUgbW9kdWxlIHNob3VsZCBiZSBhcHBsaWVkIGxhc3QsIGFmdGVyIGFsbFxuLy8gYnVpbHQtaW4gbW9kdWxlcyBoYXZlIGJlZW4gYXBwbGllZC5cbnZhciBtb2R1bGVzID0gcGxhdGZvcm1Nb2R1bGVzLmNvbmNhdChiYXNlTW9kdWxlcyk7XG5cbnZhciBwYXRjaCA9IGNyZWF0ZVBhdGNoRnVuY3Rpb24oeyBub2RlT3BzOiBub2RlT3BzLCBtb2R1bGVzOiBtb2R1bGVzIH0pO1xuXG4vKipcbiAqIE5vdCB0eXBlIGNoZWNraW5nIHRoaXMgZmlsZSBiZWNhdXNlIGZsb3cgZG9lc24ndCBsaWtlIGF0dGFjaGluZ1xuICogcHJvcGVydGllcyB0byBFbGVtZW50cy5cbiAqL1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbmlmIChpc0lFOSkge1xuICAvLyBodHRwOi8vd3d3Lm1hdHRzNDExLmNvbS9wb3N0L2ludGVybmV0LWV4cGxvcmVyLTktb25pbnB1dC9cbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignc2VsZWN0aW9uY2hhbmdlJywgZnVuY3Rpb24gKCkge1xuICAgIHZhciBlbCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgaWYgKGVsICYmIGVsLnZtb2RlbCkge1xuICAgICAgdHJpZ2dlcihlbCwgJ2lucHV0Jyk7XG4gICAgfVxuICB9KTtcbn1cblxudmFyIGRpcmVjdGl2ZSA9IHtcbiAgaW5zZXJ0ZWQ6IGZ1bmN0aW9uIGluc2VydGVkIChlbCwgYmluZGluZywgdm5vZGUsIG9sZFZub2RlKSB7XG4gICAgaWYgKHZub2RlLnRhZyA9PT0gJ3NlbGVjdCcpIHtcbiAgICAgIC8vICM2OTAzXG4gICAgICBpZiAob2xkVm5vZGUuZWxtICYmICFvbGRWbm9kZS5lbG0uX3ZPcHRpb25zKSB7XG4gICAgICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLCAncG9zdHBhdGNoJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGRpcmVjdGl2ZS5jb21wb25lbnRVcGRhdGVkKGVsLCBiaW5kaW5nLCB2bm9kZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0U2VsZWN0ZWQoZWwsIGJpbmRpbmcsIHZub2RlLmNvbnRleHQpO1xuICAgICAgfVxuICAgICAgZWwuX3ZPcHRpb25zID0gW10ubWFwLmNhbGwoZWwub3B0aW9ucywgZ2V0VmFsdWUpO1xuICAgIH0gZWxzZSBpZiAodm5vZGUudGFnID09PSAndGV4dGFyZWEnIHx8IGlzVGV4dElucHV0VHlwZShlbC50eXBlKSkge1xuICAgICAgZWwuX3ZNb2RpZmllcnMgPSBiaW5kaW5nLm1vZGlmaWVycztcbiAgICAgIGlmICghYmluZGluZy5tb2RpZmllcnMubGF6eSkge1xuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdjb21wb3NpdGlvbnN0YXJ0Jywgb25Db21wb3NpdGlvblN0YXJ0KTtcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY29tcG9zaXRpb25lbmQnLCBvbkNvbXBvc2l0aW9uRW5kKTtcbiAgICAgICAgLy8gU2FmYXJpIDwgMTAuMiAmIFVJV2ViVmlldyBkb2Vzbid0IGZpcmUgY29tcG9zaXRpb25lbmQgd2hlblxuICAgICAgICAvLyBzd2l0Y2hpbmcgZm9jdXMgYmVmb3JlIGNvbmZpcm1pbmcgY29tcG9zaXRpb24gY2hvaWNlXG4gICAgICAgIC8vIHRoaXMgYWxzbyBmaXhlcyB0aGUgaXNzdWUgd2hlcmUgc29tZSBicm93c2VycyBlLmcuIGlPUyBDaHJvbWVcbiAgICAgICAgLy8gZmlyZXMgXCJjaGFuZ2VcIiBpbnN0ZWFkIG9mIFwiaW5wdXRcIiBvbiBhdXRvY29tcGxldGUuXG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIG9uQ29tcG9zaXRpb25FbmQpO1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKGlzSUU5KSB7XG4gICAgICAgICAgZWwudm1vZGVsID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBjb21wb25lbnRVcGRhdGVkOiBmdW5jdGlvbiBjb21wb25lbnRVcGRhdGVkIChlbCwgYmluZGluZywgdm5vZGUpIHtcbiAgICBpZiAodm5vZGUudGFnID09PSAnc2VsZWN0Jykge1xuICAgICAgc2V0U2VsZWN0ZWQoZWwsIGJpbmRpbmcsIHZub2RlLmNvbnRleHQpO1xuICAgICAgLy8gaW4gY2FzZSB0aGUgb3B0aW9ucyByZW5kZXJlZCBieSB2LWZvciBoYXZlIGNoYW5nZWQsXG4gICAgICAvLyBpdCdzIHBvc3NpYmxlIHRoYXQgdGhlIHZhbHVlIGlzIG91dC1vZi1zeW5jIHdpdGggdGhlIHJlbmRlcmVkIG9wdGlvbnMuXG4gICAgICAvLyBkZXRlY3Qgc3VjaCBjYXNlcyBhbmQgZmlsdGVyIG91dCB2YWx1ZXMgdGhhdCBubyBsb25nZXIgaGFzIGEgbWF0Y2hpbmdcbiAgICAgIC8vIG9wdGlvbiBpbiB0aGUgRE9NLlxuICAgICAgdmFyIHByZXZPcHRpb25zID0gZWwuX3ZPcHRpb25zO1xuICAgICAgdmFyIGN1ck9wdGlvbnMgPSBlbC5fdk9wdGlvbnMgPSBbXS5tYXAuY2FsbChlbC5vcHRpb25zLCBnZXRWYWx1ZSk7XG4gICAgICBpZiAoY3VyT3B0aW9ucy5zb21lKGZ1bmN0aW9uIChvLCBpKSB7IHJldHVybiAhbG9vc2VFcXVhbChvLCBwcmV2T3B0aW9uc1tpXSk7IH0pKSB7XG4gICAgICAgIC8vIHRyaWdnZXIgY2hhbmdlIGV2ZW50IGlmXG4gICAgICAgIC8vIG5vIG1hdGNoaW5nIG9wdGlvbiBmb3VuZCBmb3IgYXQgbGVhc3Qgb25lIHZhbHVlXG4gICAgICAgIHZhciBuZWVkUmVzZXQgPSBlbC5tdWx0aXBsZVxuICAgICAgICAgID8gYmluZGluZy52YWx1ZS5zb21lKGZ1bmN0aW9uICh2KSB7IHJldHVybiBoYXNOb01hdGNoaW5nT3B0aW9uKHYsIGN1ck9wdGlvbnMpOyB9KVxuICAgICAgICAgIDogYmluZGluZy52YWx1ZSAhPT0gYmluZGluZy5vbGRWYWx1ZSAmJiBoYXNOb01hdGNoaW5nT3B0aW9uKGJpbmRpbmcudmFsdWUsIGN1ck9wdGlvbnMpO1xuICAgICAgICBpZiAobmVlZFJlc2V0KSB7XG4gICAgICAgICAgdHJpZ2dlcihlbCwgJ2NoYW5nZScpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBzZXRTZWxlY3RlZCAoZWwsIGJpbmRpbmcsIHZtKSB7XG4gIGFjdHVhbGx5U2V0U2VsZWN0ZWQoZWwsIGJpbmRpbmcsIHZtKTtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChpc0lFIHx8IGlzRWRnZSkge1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgYWN0dWFsbHlTZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm0pO1xuICAgIH0sIDApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFjdHVhbGx5U2V0U2VsZWN0ZWQgKGVsLCBiaW5kaW5nLCB2bSkge1xuICB2YXIgdmFsdWUgPSBiaW5kaW5nLnZhbHVlO1xuICB2YXIgaXNNdWx0aXBsZSA9IGVsLm11bHRpcGxlO1xuICBpZiAoaXNNdWx0aXBsZSAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICBcIjxzZWxlY3QgbXVsdGlwbGUgdi1tb2RlbD1cXFwiXCIgKyAoYmluZGluZy5leHByZXNzaW9uKSArIFwiXFxcIj4gXCIgK1xuICAgICAgXCJleHBlY3RzIGFuIEFycmF5IHZhbHVlIGZvciBpdHMgYmluZGluZywgYnV0IGdvdCBcIiArIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLnNsaWNlKDgsIC0xKSksXG4gICAgICB2bVxuICAgICk7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHNlbGVjdGVkLCBvcHRpb247XG4gIGZvciAodmFyIGkgPSAwLCBsID0gZWwub3B0aW9ucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBvcHRpb24gPSBlbC5vcHRpb25zW2ldO1xuICAgIGlmIChpc011bHRpcGxlKSB7XG4gICAgICBzZWxlY3RlZCA9IGxvb3NlSW5kZXhPZih2YWx1ZSwgZ2V0VmFsdWUob3B0aW9uKSkgPiAtMTtcbiAgICAgIGlmIChvcHRpb24uc2VsZWN0ZWQgIT09IHNlbGVjdGVkKSB7XG4gICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IHNlbGVjdGVkO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAobG9vc2VFcXVhbChnZXRWYWx1ZShvcHRpb24pLCB2YWx1ZSkpIHtcbiAgICAgICAgaWYgKGVsLnNlbGVjdGVkSW5kZXggIT09IGkpIHtcbiAgICAgICAgICBlbC5zZWxlY3RlZEluZGV4ID0gaTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKCFpc011bHRpcGxlKSB7XG4gICAgZWwuc2VsZWN0ZWRJbmRleCA9IC0xO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhc05vTWF0Y2hpbmdPcHRpb24gKHZhbHVlLCBvcHRpb25zKSB7XG4gIHJldHVybiBvcHRpb25zLmV2ZXJ5KGZ1bmN0aW9uIChvKSB7IHJldHVybiAhbG9vc2VFcXVhbChvLCB2YWx1ZSk7IH0pXG59XG5cbmZ1bmN0aW9uIGdldFZhbHVlIChvcHRpb24pIHtcbiAgcmV0dXJuICdfdmFsdWUnIGluIG9wdGlvblxuICAgID8gb3B0aW9uLl92YWx1ZVxuICAgIDogb3B0aW9uLnZhbHVlXG59XG5cbmZ1bmN0aW9uIG9uQ29tcG9zaXRpb25TdGFydCAoZSkge1xuICBlLnRhcmdldC5jb21wb3NpbmcgPSB0cnVlO1xufVxuXG5mdW5jdGlvbiBvbkNvbXBvc2l0aW9uRW5kIChlKSB7XG4gIC8vIHByZXZlbnQgdHJpZ2dlcmluZyBhbiBpbnB1dCBldmVudCBmb3Igbm8gcmVhc29uXG4gIGlmICghZS50YXJnZXQuY29tcG9zaW5nKSB7IHJldHVybiB9XG4gIGUudGFyZ2V0LmNvbXBvc2luZyA9IGZhbHNlO1xuICB0cmlnZ2VyKGUudGFyZ2V0LCAnaW5wdXQnKTtcbn1cblxuZnVuY3Rpb24gdHJpZ2dlciAoZWwsIHR5cGUpIHtcbiAgdmFyIGUgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnSFRNTEV2ZW50cycpO1xuICBlLmluaXRFdmVudCh0eXBlLCB0cnVlLCB0cnVlKTtcbiAgZWwuZGlzcGF0Y2hFdmVudChlKTtcbn1cblxuLyogICovXG5cbi8vIHJlY3Vyc2l2ZWx5IHNlYXJjaCBmb3IgcG9zc2libGUgdHJhbnNpdGlvbiBkZWZpbmVkIGluc2lkZSB0aGUgY29tcG9uZW50IHJvb3RcbmZ1bmN0aW9uIGxvY2F0ZU5vZGUgKHZub2RlKSB7XG4gIHJldHVybiB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSAmJiAoIXZub2RlLmRhdGEgfHwgIXZub2RlLmRhdGEudHJhbnNpdGlvbilcbiAgICA/IGxvY2F0ZU5vZGUodm5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlKVxuICAgIDogdm5vZGVcbn1cblxudmFyIHNob3cgPSB7XG4gIGJpbmQ6IGZ1bmN0aW9uIGJpbmQgKGVsLCByZWYsIHZub2RlKSB7XG4gICAgdmFyIHZhbHVlID0gcmVmLnZhbHVlO1xuXG4gICAgdm5vZGUgPSBsb2NhdGVOb2RlKHZub2RlKTtcbiAgICB2YXIgdHJhbnNpdGlvbiQkMSA9IHZub2RlLmRhdGEgJiYgdm5vZGUuZGF0YS50cmFuc2l0aW9uO1xuICAgIHZhciBvcmlnaW5hbERpc3BsYXkgPSBlbC5fX3ZPcmlnaW5hbERpc3BsYXkgPVxuICAgICAgZWwuc3R5bGUuZGlzcGxheSA9PT0gJ25vbmUnID8gJycgOiBlbC5zdHlsZS5kaXNwbGF5O1xuICAgIGlmICh2YWx1ZSAmJiB0cmFuc2l0aW9uJCQxKSB7XG4gICAgICB2bm9kZS5kYXRhLnNob3cgPSB0cnVlO1xuICAgICAgZW50ZXIodm5vZGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IG9yaWdpbmFsRGlzcGxheTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gdmFsdWUgPyBvcmlnaW5hbERpc3BsYXkgOiAnbm9uZSc7XG4gICAgfVxuICB9LFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlIChlbCwgcmVmLCB2bm9kZSkge1xuICAgIHZhciB2YWx1ZSA9IHJlZi52YWx1ZTtcbiAgICB2YXIgb2xkVmFsdWUgPSByZWYub2xkVmFsdWU7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIXZhbHVlID09PSAhb2xkVmFsdWUpIHsgcmV0dXJuIH1cbiAgICB2bm9kZSA9IGxvY2F0ZU5vZGUodm5vZGUpO1xuICAgIHZhciB0cmFuc2l0aW9uJCQxID0gdm5vZGUuZGF0YSAmJiB2bm9kZS5kYXRhLnRyYW5zaXRpb247XG4gICAgaWYgKHRyYW5zaXRpb24kJDEpIHtcbiAgICAgIHZub2RlLmRhdGEuc2hvdyA9IHRydWU7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgZW50ZXIodm5vZGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gZWwuX192T3JpZ2luYWxEaXNwbGF5O1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxlYXZlKHZub2RlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZSA/IGVsLl9fdk9yaWdpbmFsRGlzcGxheSA6ICdub25lJztcbiAgICB9XG4gIH0sXG5cbiAgdW5iaW5kOiBmdW5jdGlvbiB1bmJpbmQgKFxuICAgIGVsLFxuICAgIGJpbmRpbmcsXG4gICAgdm5vZGUsXG4gICAgb2xkVm5vZGUsXG4gICAgaXNEZXN0cm95XG4gICkge1xuICAgIGlmICghaXNEZXN0cm95KSB7XG4gICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gZWwuX192T3JpZ2luYWxEaXNwbGF5O1xuICAgIH1cbiAgfVxufVxuXG52YXIgcGxhdGZvcm1EaXJlY3RpdmVzID0ge1xuICBtb2RlbDogZGlyZWN0aXZlLFxuICBzaG93OiBzaG93XG59XG5cbi8qICAqL1xuXG4vLyBQcm92aWRlcyB0cmFuc2l0aW9uIHN1cHBvcnQgZm9yIGEgc2luZ2xlIGVsZW1lbnQvY29tcG9uZW50LlxuLy8gc3VwcG9ydHMgdHJhbnNpdGlvbiBtb2RlIChvdXQtaW4gLyBpbi1vdXQpXG5cbnZhciB0cmFuc2l0aW9uUHJvcHMgPSB7XG4gIG5hbWU6IFN0cmluZyxcbiAgYXBwZWFyOiBCb29sZWFuLFxuICBjc3M6IEJvb2xlYW4sXG4gIG1vZGU6IFN0cmluZyxcbiAgdHlwZTogU3RyaW5nLFxuICBlbnRlckNsYXNzOiBTdHJpbmcsXG4gIGxlYXZlQ2xhc3M6IFN0cmluZyxcbiAgZW50ZXJUb0NsYXNzOiBTdHJpbmcsXG4gIGxlYXZlVG9DbGFzczogU3RyaW5nLFxuICBlbnRlckFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gIGxlYXZlQWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgYXBwZWFyQ2xhc3M6IFN0cmluZyxcbiAgYXBwZWFyQWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgYXBwZWFyVG9DbGFzczogU3RyaW5nLFxuICBkdXJhdGlvbjogW051bWJlciwgU3RyaW5nLCBPYmplY3RdXG59O1xuXG4vLyBpbiBjYXNlIHRoZSBjaGlsZCBpcyBhbHNvIGFuIGFic3RyYWN0IGNvbXBvbmVudCwgZS5nLiA8a2VlcC1hbGl2ZT5cbi8vIHdlIHdhbnQgdG8gcmVjdXJzaXZlbHkgcmV0cmlldmUgdGhlIHJlYWwgY29tcG9uZW50IHRvIGJlIHJlbmRlcmVkXG5mdW5jdGlvbiBnZXRSZWFsQ2hpbGQgKHZub2RlKSB7XG4gIHZhciBjb21wT3B0aW9ucyA9IHZub2RlICYmIHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gIGlmIChjb21wT3B0aW9ucyAmJiBjb21wT3B0aW9ucy5DdG9yLm9wdGlvbnMuYWJzdHJhY3QpIHtcbiAgICByZXR1cm4gZ2V0UmVhbENoaWxkKGdldEZpcnN0Q29tcG9uZW50Q2hpbGQoY29tcE9wdGlvbnMuY2hpbGRyZW4pKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiB2bm9kZVxuICB9XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RUcmFuc2l0aW9uRGF0YSAoY29tcCkge1xuICB2YXIgZGF0YSA9IHt9O1xuICB2YXIgb3B0aW9ucyA9IGNvbXAuJG9wdGlvbnM7XG4gIC8vIHByb3BzXG4gIGZvciAodmFyIGtleSBpbiBvcHRpb25zLnByb3BzRGF0YSkge1xuICAgIGRhdGFba2V5XSA9IGNvbXBba2V5XTtcbiAgfVxuICAvLyBldmVudHMuXG4gIC8vIGV4dHJhY3QgbGlzdGVuZXJzIGFuZCBwYXNzIHRoZW0gZGlyZWN0bHkgdG8gdGhlIHRyYW5zaXRpb24gbWV0aG9kc1xuICB2YXIgbGlzdGVuZXJzID0gb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xuICBmb3IgKHZhciBrZXkkMSBpbiBsaXN0ZW5lcnMpIHtcbiAgICBkYXRhW2NhbWVsaXplKGtleSQxKV0gPSBsaXN0ZW5lcnNba2V5JDFdO1xuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbmZ1bmN0aW9uIHBsYWNlaG9sZGVyIChoLCByYXdDaGlsZCkge1xuICBpZiAoL1xcZC1rZWVwLWFsaXZlJC8udGVzdChyYXdDaGlsZC50YWcpKSB7XG4gICAgcmV0dXJuIGgoJ2tlZXAtYWxpdmUnLCB7XG4gICAgICBwcm9wczogcmF3Q2hpbGQuY29tcG9uZW50T3B0aW9ucy5wcm9wc0RhdGFcbiAgICB9KVxuICB9XG59XG5cbmZ1bmN0aW9uIGhhc1BhcmVudFRyYW5zaXRpb24gKHZub2RlKSB7XG4gIHdoaWxlICgodm5vZGUgPSB2bm9kZS5wYXJlbnQpKSB7XG4gICAgaWYgKHZub2RlLmRhdGEudHJhbnNpdGlvbikge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNTYW1lQ2hpbGQgKGNoaWxkLCBvbGRDaGlsZCkge1xuICByZXR1cm4gb2xkQ2hpbGQua2V5ID09PSBjaGlsZC5rZXkgJiYgb2xkQ2hpbGQudGFnID09PSBjaGlsZC50YWdcbn1cblxudmFyIFRyYW5zaXRpb24gPSB7XG4gIG5hbWU6ICd0cmFuc2l0aW9uJyxcbiAgcHJvcHM6IHRyYW5zaXRpb25Qcm9wcyxcbiAgYWJzdHJhY3Q6IHRydWUsXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKGgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuJHNsb3RzLmRlZmF1bHQ7XG4gICAgaWYgKCFjaGlsZHJlbikge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gZmlsdGVyIG91dCB0ZXh0IG5vZGVzIChwb3NzaWJsZSB3aGl0ZXNwYWNlcylcbiAgICBjaGlsZHJlbiA9IGNoaWxkcmVuLmZpbHRlcihmdW5jdGlvbiAoYykgeyByZXR1cm4gYy50YWcgfHwgaXNBc3luY1BsYWNlaG9sZGVyKGMpOyB9KTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gd2FybiBtdWx0aXBsZSBlbGVtZW50c1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNoaWxkcmVuLmxlbmd0aCA+IDEpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICc8dHJhbnNpdGlvbj4gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIHNpbmdsZSBlbGVtZW50LiBVc2UgJyArXG4gICAgICAgICc8dHJhbnNpdGlvbi1ncm91cD4gZm9yIGxpc3RzLicsXG4gICAgICAgIHRoaXMuJHBhcmVudFxuICAgICAgKTtcbiAgICB9XG5cbiAgICB2YXIgbW9kZSA9IHRoaXMubW9kZTtcblxuICAgIC8vIHdhcm4gaW52YWxpZCBtb2RlXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgIG1vZGUgJiYgbW9kZSAhPT0gJ2luLW91dCcgJiYgbW9kZSAhPT0gJ291dC1pbidcbiAgICApIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdpbnZhbGlkIDx0cmFuc2l0aW9uPiBtb2RlOiAnICsgbW9kZSxcbiAgICAgICAgdGhpcy4kcGFyZW50XG4gICAgICApO1xuICAgIH1cblxuICAgIHZhciByYXdDaGlsZCA9IGNoaWxkcmVuWzBdO1xuXG4gICAgLy8gaWYgdGhpcyBpcyBhIGNvbXBvbmVudCByb290IG5vZGUgYW5kIHRoZSBjb21wb25lbnQnc1xuICAgIC8vIHBhcmVudCBjb250YWluZXIgbm9kZSBhbHNvIGhhcyB0cmFuc2l0aW9uLCBza2lwLlxuICAgIGlmIChoYXNQYXJlbnRUcmFuc2l0aW9uKHRoaXMuJHZub2RlKSkge1xuICAgICAgcmV0dXJuIHJhd0NoaWxkXG4gICAgfVxuXG4gICAgLy8gYXBwbHkgdHJhbnNpdGlvbiBkYXRhIHRvIGNoaWxkXG4gICAgLy8gdXNlIGdldFJlYWxDaGlsZCgpIHRvIGlnbm9yZSBhYnN0cmFjdCBjb21wb25lbnRzIGUuZy4ga2VlcC1hbGl2ZVxuICAgIHZhciBjaGlsZCA9IGdldFJlYWxDaGlsZChyYXdDaGlsZCk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFjaGlsZCkge1xuICAgICAgcmV0dXJuIHJhd0NoaWxkXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2xlYXZpbmcpIHtcbiAgICAgIHJldHVybiBwbGFjZWhvbGRlcihoLCByYXdDaGlsZClcbiAgICB9XG5cbiAgICAvLyBlbnN1cmUgYSBrZXkgdGhhdCBpcyB1bmlxdWUgdG8gdGhlIHZub2RlIHR5cGUgYW5kIHRvIHRoaXMgdHJhbnNpdGlvblxuICAgIC8vIGNvbXBvbmVudCBpbnN0YW5jZS4gVGhpcyBrZXkgd2lsbCBiZSB1c2VkIHRvIHJlbW92ZSBwZW5kaW5nIGxlYXZpbmcgbm9kZXNcbiAgICAvLyBkdXJpbmcgZW50ZXJpbmcuXG4gICAgdmFyIGlkID0gXCJfX3RyYW5zaXRpb24tXCIgKyAodGhpcy5fdWlkKSArIFwiLVwiO1xuICAgIGNoaWxkLmtleSA9IGNoaWxkLmtleSA9PSBudWxsXG4gICAgICA/IGNoaWxkLmlzQ29tbWVudFxuICAgICAgICA/IGlkICsgJ2NvbW1lbnQnXG4gICAgICAgIDogaWQgKyBjaGlsZC50YWdcbiAgICAgIDogaXNQcmltaXRpdmUoY2hpbGQua2V5KVxuICAgICAgICA/IChTdHJpbmcoY2hpbGQua2V5KS5pbmRleE9mKGlkKSA9PT0gMCA/IGNoaWxkLmtleSA6IGlkICsgY2hpbGQua2V5KVxuICAgICAgICA6IGNoaWxkLmtleTtcblxuICAgIHZhciBkYXRhID0gKGNoaWxkLmRhdGEgfHwgKGNoaWxkLmRhdGEgPSB7fSkpLnRyYW5zaXRpb24gPSBleHRyYWN0VHJhbnNpdGlvbkRhdGEodGhpcyk7XG4gICAgdmFyIG9sZFJhd0NoaWxkID0gdGhpcy5fdm5vZGU7XG4gICAgdmFyIG9sZENoaWxkID0gZ2V0UmVhbENoaWxkKG9sZFJhd0NoaWxkKTtcblxuICAgIC8vIG1hcmsgdi1zaG93XG4gICAgLy8gc28gdGhhdCB0aGUgdHJhbnNpdGlvbiBtb2R1bGUgY2FuIGhhbmQgb3ZlciB0aGUgY29udHJvbCB0byB0aGUgZGlyZWN0aXZlXG4gICAgaWYgKGNoaWxkLmRhdGEuZGlyZWN0aXZlcyAmJiBjaGlsZC5kYXRhLmRpcmVjdGl2ZXMuc29tZShmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC5uYW1lID09PSAnc2hvdyc7IH0pKSB7XG4gICAgICBjaGlsZC5kYXRhLnNob3cgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChcbiAgICAgIG9sZENoaWxkICYmXG4gICAgICBvbGRDaGlsZC5kYXRhICYmXG4gICAgICAhaXNTYW1lQ2hpbGQoY2hpbGQsIG9sZENoaWxkKSAmJlxuICAgICAgIWlzQXN5bmNQbGFjZWhvbGRlcihvbGRDaGlsZCkgJiZcbiAgICAgIC8vICM2Njg3IGNvbXBvbmVudCByb290IGlzIGEgY29tbWVudCBub2RlXG4gICAgICAhKG9sZENoaWxkLmNvbXBvbmVudEluc3RhbmNlICYmIG9sZENoaWxkLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZS5pc0NvbW1lbnQpXG4gICAgKSB7XG4gICAgICAvLyByZXBsYWNlIG9sZCBjaGlsZCB0cmFuc2l0aW9uIGRhdGEgd2l0aCBmcmVzaCBvbmVcbiAgICAgIC8vIGltcG9ydGFudCBmb3IgZHluYW1pYyB0cmFuc2l0aW9ucyFcbiAgICAgIHZhciBvbGREYXRhID0gb2xkQ2hpbGQuZGF0YS50cmFuc2l0aW9uID0gZXh0ZW5kKHt9LCBkYXRhKTtcbiAgICAgIC8vIGhhbmRsZSB0cmFuc2l0aW9uIG1vZGVcbiAgICAgIGlmIChtb2RlID09PSAnb3V0LWluJykge1xuICAgICAgICAvLyByZXR1cm4gcGxhY2Vob2xkZXIgbm9kZSBhbmQgcXVldWUgdXBkYXRlIHdoZW4gbGVhdmUgZmluaXNoZXNcbiAgICAgICAgdGhpcy5fbGVhdmluZyA9IHRydWU7XG4gICAgICAgIG1lcmdlVk5vZGVIb29rKG9sZERhdGEsICdhZnRlckxlYXZlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoaXMkMS5fbGVhdmluZyA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMkMS4kZm9yY2VVcGRhdGUoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwbGFjZWhvbGRlcihoLCByYXdDaGlsZClcbiAgICAgIH0gZWxzZSBpZiAobW9kZSA9PT0gJ2luLW91dCcpIHtcbiAgICAgICAgaWYgKGlzQXN5bmNQbGFjZWhvbGRlcihjaGlsZCkpIHtcbiAgICAgICAgICByZXR1cm4gb2xkUmF3Q2hpbGRcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGVsYXllZExlYXZlO1xuICAgICAgICB2YXIgcGVyZm9ybUxlYXZlID0gZnVuY3Rpb24gKCkgeyBkZWxheWVkTGVhdmUoKTsgfTtcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2soZGF0YSwgJ2FmdGVyRW50ZXInLCBwZXJmb3JtTGVhdmUpO1xuICAgICAgICBtZXJnZVZOb2RlSG9vayhkYXRhLCAnZW50ZXJDYW5jZWxsZWQnLCBwZXJmb3JtTGVhdmUpO1xuICAgICAgICBtZXJnZVZOb2RlSG9vayhvbGREYXRhLCAnZGVsYXlMZWF2ZScsIGZ1bmN0aW9uIChsZWF2ZSkgeyBkZWxheWVkTGVhdmUgPSBsZWF2ZTsgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJhd0NoaWxkXG4gIH1cbn1cblxuLyogICovXG5cbi8vIFByb3ZpZGVzIHRyYW5zaXRpb24gc3VwcG9ydCBmb3IgbGlzdCBpdGVtcy5cbi8vIHN1cHBvcnRzIG1vdmUgdHJhbnNpdGlvbnMgdXNpbmcgdGhlIEZMSVAgdGVjaG5pcXVlLlxuXG4vLyBCZWNhdXNlIHRoZSB2ZG9tJ3MgY2hpbGRyZW4gdXBkYXRlIGFsZ29yaXRobSBpcyBcInVuc3RhYmxlXCIgLSBpLmUuXG4vLyBpdCBkb2Vzbid0IGd1YXJhbnRlZSB0aGUgcmVsYXRpdmUgcG9zaXRpb25pbmcgb2YgcmVtb3ZlZCBlbGVtZW50cyxcbi8vIHdlIGZvcmNlIHRyYW5zaXRpb24tZ3JvdXAgdG8gdXBkYXRlIGl0cyBjaGlsZHJlbiBpbnRvIHR3byBwYXNzZXM6XG4vLyBpbiB0aGUgZmlyc3QgcGFzcywgd2UgcmVtb3ZlIGFsbCBub2RlcyB0aGF0IG5lZWQgdG8gYmUgcmVtb3ZlZCxcbi8vIHRyaWdnZXJpbmcgdGhlaXIgbGVhdmluZyB0cmFuc2l0aW9uOyBpbiB0aGUgc2Vjb25kIHBhc3MsIHdlIGluc2VydC9tb3ZlXG4vLyBpbnRvIHRoZSBmaW5hbCBkZXNpcmVkIHN0YXRlLiBUaGlzIHdheSBpbiB0aGUgc2Vjb25kIHBhc3MgcmVtb3ZlZFxuLy8gbm9kZXMgd2lsbCByZW1haW4gd2hlcmUgdGhleSBzaG91bGQgYmUuXG5cbnZhciBwcm9wcyA9IGV4dGVuZCh7XG4gIHRhZzogU3RyaW5nLFxuICBtb3ZlQ2xhc3M6IFN0cmluZ1xufSwgdHJhbnNpdGlvblByb3BzKTtcblxuZGVsZXRlIHByb3BzLm1vZGU7XG5cbnZhciBUcmFuc2l0aW9uR3JvdXAgPSB7XG4gIHByb3BzOiBwcm9wcyxcblxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoaCkge1xuICAgIHZhciB0YWcgPSB0aGlzLnRhZyB8fCB0aGlzLiR2bm9kZS5kYXRhLnRhZyB8fCAnc3Bhbic7XG4gICAgdmFyIG1hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdmFyIHByZXZDaGlsZHJlbiA9IHRoaXMucHJldkNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbjtcbiAgICB2YXIgcmF3Q2hpbGRyZW4gPSB0aGlzLiRzbG90cy5kZWZhdWx0IHx8IFtdO1xuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4gPSBbXTtcbiAgICB2YXIgdHJhbnNpdGlvbkRhdGEgPSBleHRyYWN0VHJhbnNpdGlvbkRhdGEodGhpcyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJhd0NoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYyA9IHJhd0NoaWxkcmVuW2ldO1xuICAgICAgaWYgKGMudGFnKSB7XG4gICAgICAgIGlmIChjLmtleSAhPSBudWxsICYmIFN0cmluZyhjLmtleSkuaW5kZXhPZignX192bGlzdCcpICE9PSAwKSB7XG4gICAgICAgICAgY2hpbGRyZW4ucHVzaChjKTtcbiAgICAgICAgICBtYXBbYy5rZXldID0gY1xuICAgICAgICAgIDsoYy5kYXRhIHx8IChjLmRhdGEgPSB7fSkpLnRyYW5zaXRpb24gPSB0cmFuc2l0aW9uRGF0YTtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgdmFyIG9wdHMgPSBjLmNvbXBvbmVudE9wdGlvbnM7XG4gICAgICAgICAgdmFyIG5hbWUgPSBvcHRzID8gKG9wdHMuQ3Rvci5vcHRpb25zLm5hbWUgfHwgb3B0cy50YWcgfHwgJycpIDogYy50YWc7XG4gICAgICAgICAgd2FybigoXCI8dHJhbnNpdGlvbi1ncm91cD4gY2hpbGRyZW4gbXVzdCBiZSBrZXllZDogPFwiICsgbmFtZSArIFwiPlwiKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocHJldkNoaWxkcmVuKSB7XG4gICAgICB2YXIga2VwdCA9IFtdO1xuICAgICAgdmFyIHJlbW92ZWQgPSBbXTtcbiAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IHByZXZDaGlsZHJlbi5sZW5ndGg7IGkkMSsrKSB7XG4gICAgICAgIHZhciBjJDEgPSBwcmV2Q2hpbGRyZW5baSQxXTtcbiAgICAgICAgYyQxLmRhdGEudHJhbnNpdGlvbiA9IHRyYW5zaXRpb25EYXRhO1xuICAgICAgICBjJDEuZGF0YS5wb3MgPSBjJDEuZWxtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBpZiAobWFwW2MkMS5rZXldKSB7XG4gICAgICAgICAga2VwdC5wdXNoKGMkMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVtb3ZlZC5wdXNoKGMkMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMua2VwdCA9IGgodGFnLCBudWxsLCBrZXB0KTtcbiAgICAgIHRoaXMucmVtb3ZlZCA9IHJlbW92ZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGgodGFnLCBudWxsLCBjaGlsZHJlbilcbiAgfSxcblxuICBiZWZvcmVVcGRhdGU6IGZ1bmN0aW9uIGJlZm9yZVVwZGF0ZSAoKSB7XG4gICAgLy8gZm9yY2UgcmVtb3ZpbmcgcGFzc1xuICAgIHRoaXMuX19wYXRjaF9fKFxuICAgICAgdGhpcy5fdm5vZGUsXG4gICAgICB0aGlzLmtlcHQsXG4gICAgICBmYWxzZSwgLy8gaHlkcmF0aW5nXG4gICAgICB0cnVlIC8vIHJlbW92ZU9ubHkgKCFpbXBvcnRhbnQsIGF2b2lkcyB1bm5lY2Vzc2FyeSBtb3ZlcylcbiAgICApO1xuICAgIHRoaXMuX3Zub2RlID0gdGhpcy5rZXB0O1xuICB9LFxuXG4gIHVwZGF0ZWQ6IGZ1bmN0aW9uIHVwZGF0ZWQgKCkge1xuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMucHJldkNoaWxkcmVuO1xuICAgIHZhciBtb3ZlQ2xhc3MgPSB0aGlzLm1vdmVDbGFzcyB8fCAoKHRoaXMubmFtZSB8fCAndicpICsgJy1tb3ZlJyk7XG4gICAgaWYgKCFjaGlsZHJlbi5sZW5ndGggfHwgIXRoaXMuaGFzTW92ZShjaGlsZHJlblswXS5lbG0sIG1vdmVDbGFzcykpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIHdlIGRpdmlkZSB0aGUgd29yayBpbnRvIHRocmVlIGxvb3BzIHRvIGF2b2lkIG1peGluZyBET00gcmVhZHMgYW5kIHdyaXRlc1xuICAgIC8vIGluIGVhY2ggaXRlcmF0aW9uIC0gd2hpY2ggaGVscHMgcHJldmVudCBsYXlvdXQgdGhyYXNoaW5nLlxuICAgIGNoaWxkcmVuLmZvckVhY2goY2FsbFBlbmRpbmdDYnMpO1xuICAgIGNoaWxkcmVuLmZvckVhY2gocmVjb3JkUG9zaXRpb24pO1xuICAgIGNoaWxkcmVuLmZvckVhY2goYXBwbHlUcmFuc2xhdGlvbik7XG5cbiAgICAvLyBmb3JjZSByZWZsb3cgdG8gcHV0IGV2ZXJ5dGhpbmcgaW4gcG9zaXRpb25cbiAgICAvLyBhc3NpZ24gdG8gdGhpcyB0byBhdm9pZCBiZWluZyByZW1vdmVkIGluIHRyZWUtc2hha2luZ1xuICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgIHRoaXMuX3JlZmxvdyA9IGRvY3VtZW50LmJvZHkub2Zmc2V0SGVpZ2h0O1xuXG4gICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgaWYgKGMuZGF0YS5tb3ZlZCkge1xuICAgICAgICB2YXIgZWwgPSBjLmVsbTtcbiAgICAgICAgdmFyIHMgPSBlbC5zdHlsZTtcbiAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBtb3ZlQ2xhc3MpO1xuICAgICAgICBzLnRyYW5zZm9ybSA9IHMuV2Via2l0VHJhbnNmb3JtID0gcy50cmFuc2l0aW9uRHVyYXRpb24gPSAnJztcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcih0cmFuc2l0aW9uRW5kRXZlbnQsIGVsLl9tb3ZlQ2IgPSBmdW5jdGlvbiBjYiAoZSkge1xuICAgICAgICAgIGlmICghZSB8fCAvdHJhbnNmb3JtJC8udGVzdChlLnByb3BlcnR5TmFtZSkpIHtcbiAgICAgICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIodHJhbnNpdGlvbkVuZEV2ZW50LCBjYik7XG4gICAgICAgICAgICBlbC5fbW92ZUNiID0gbnVsbDtcbiAgICAgICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbW92ZUNsYXNzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIG1ldGhvZHM6IHtcbiAgICBoYXNNb3ZlOiBmdW5jdGlvbiBoYXNNb3ZlIChlbCwgbW92ZUNsYXNzKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmICghaGFzVHJhbnNpdGlvbikge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKHRoaXMuX2hhc01vdmUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hhc01vdmVcbiAgICAgIH1cbiAgICAgIC8vIERldGVjdCB3aGV0aGVyIGFuIGVsZW1lbnQgd2l0aCB0aGUgbW92ZSBjbGFzcyBhcHBsaWVkIGhhc1xuICAgICAgLy8gQ1NTIHRyYW5zaXRpb25zLiBTaW5jZSB0aGUgZWxlbWVudCBtYXkgYmUgaW5zaWRlIGFuIGVudGVyaW5nXG4gICAgICAvLyB0cmFuc2l0aW9uIGF0IHRoaXMgdmVyeSBtb21lbnQsIHdlIG1ha2UgYSBjbG9uZSBvZiBpdCBhbmQgcmVtb3ZlXG4gICAgICAvLyBhbGwgb3RoZXIgdHJhbnNpdGlvbiBjbGFzc2VzIGFwcGxpZWQgdG8gZW5zdXJlIG9ubHkgdGhlIG1vdmUgY2xhc3NcbiAgICAgIC8vIGlzIGFwcGxpZWQuXG4gICAgICB2YXIgY2xvbmUgPSBlbC5jbG9uZU5vZGUoKTtcbiAgICAgIGlmIChlbC5fdHJhbnNpdGlvbkNsYXNzZXMpIHtcbiAgICAgICAgZWwuX3RyYW5zaXRpb25DbGFzc2VzLmZvckVhY2goZnVuY3Rpb24gKGNscykgeyByZW1vdmVDbGFzcyhjbG9uZSwgY2xzKTsgfSk7XG4gICAgICB9XG4gICAgICBhZGRDbGFzcyhjbG9uZSwgbW92ZUNsYXNzKTtcbiAgICAgIGNsb25lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICB0aGlzLiRlbC5hcHBlbmRDaGlsZChjbG9uZSk7XG4gICAgICB2YXIgaW5mbyA9IGdldFRyYW5zaXRpb25JbmZvKGNsb25lKTtcbiAgICAgIHRoaXMuJGVsLnJlbW92ZUNoaWxkKGNsb25lKTtcbiAgICAgIHJldHVybiAodGhpcy5faGFzTW92ZSA9IGluZm8uaGFzVHJhbnNmb3JtKVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjYWxsUGVuZGluZ0NicyAoYykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGMuZWxtLl9tb3ZlQ2IpIHtcbiAgICBjLmVsbS5fbW92ZUNiKCk7XG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChjLmVsbS5fZW50ZXJDYikge1xuICAgIGMuZWxtLl9lbnRlckNiKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVjb3JkUG9zaXRpb24gKGMpIHtcbiAgYy5kYXRhLm5ld1BvcyA9IGMuZWxtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xufVxuXG5mdW5jdGlvbiBhcHBseVRyYW5zbGF0aW9uIChjKSB7XG4gIHZhciBvbGRQb3MgPSBjLmRhdGEucG9zO1xuICB2YXIgbmV3UG9zID0gYy5kYXRhLm5ld1BvcztcbiAgdmFyIGR4ID0gb2xkUG9zLmxlZnQgLSBuZXdQb3MubGVmdDtcbiAgdmFyIGR5ID0gb2xkUG9zLnRvcCAtIG5ld1Bvcy50b3A7XG4gIGlmIChkeCB8fCBkeSkge1xuICAgIGMuZGF0YS5tb3ZlZCA9IHRydWU7XG4gICAgdmFyIHMgPSBjLmVsbS5zdHlsZTtcbiAgICBzLnRyYW5zZm9ybSA9IHMuV2Via2l0VHJhbnNmb3JtID0gXCJ0cmFuc2xhdGUoXCIgKyBkeCArIFwicHgsXCIgKyBkeSArIFwicHgpXCI7XG4gICAgcy50cmFuc2l0aW9uRHVyYXRpb24gPSAnMHMnO1xuICB9XG59XG5cbnZhciBwbGF0Zm9ybUNvbXBvbmVudHMgPSB7XG4gIFRyYW5zaXRpb246IFRyYW5zaXRpb24sXG4gIFRyYW5zaXRpb25Hcm91cDogVHJhbnNpdGlvbkdyb3VwXG59XG5cbi8qICAqL1xuXG4vLyBpbnN0YWxsIHBsYXRmb3JtIHNwZWNpZmljIHV0aWxzXG5WdWUuY29uZmlnLm11c3RVc2VQcm9wID0gbXVzdFVzZVByb3A7XG5WdWUuY29uZmlnLmlzUmVzZXJ2ZWRUYWcgPSBpc1Jlc2VydmVkVGFnO1xuVnVlLmNvbmZpZy5pc1Jlc2VydmVkQXR0ciA9IGlzUmVzZXJ2ZWRBdHRyO1xuVnVlLmNvbmZpZy5nZXRUYWdOYW1lc3BhY2UgPSBnZXRUYWdOYW1lc3BhY2U7XG5WdWUuY29uZmlnLmlzVW5rbm93bkVsZW1lbnQgPSBpc1Vua25vd25FbGVtZW50O1xuXG4vLyBpbnN0YWxsIHBsYXRmb3JtIHJ1bnRpbWUgZGlyZWN0aXZlcyAmIGNvbXBvbmVudHNcbmV4dGVuZChWdWUub3B0aW9ucy5kaXJlY3RpdmVzLCBwbGF0Zm9ybURpcmVjdGl2ZXMpO1xuZXh0ZW5kKFZ1ZS5vcHRpb25zLmNvbXBvbmVudHMsIHBsYXRmb3JtQ29tcG9uZW50cyk7XG5cbi8vIGluc3RhbGwgcGxhdGZvcm0gcGF0Y2ggZnVuY3Rpb25cblZ1ZS5wcm90b3R5cGUuX19wYXRjaF9fID0gaW5Ccm93c2VyID8gcGF0Y2ggOiBub29wO1xuXG4vLyBwdWJsaWMgbW91bnQgbWV0aG9kXG5WdWUucHJvdG90eXBlLiRtb3VudCA9IGZ1bmN0aW9uIChcbiAgZWwsXG4gIGh5ZHJhdGluZ1xuKSB7XG4gIGVsID0gZWwgJiYgaW5Ccm93c2VyID8gcXVlcnkoZWwpIDogdW5kZWZpbmVkO1xuICByZXR1cm4gbW91bnRDb21wb25lbnQodGhpcywgZWwsIGh5ZHJhdGluZylcbn07XG5cbi8vIGRldnRvb2xzIGdsb2JhbCBob29rXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuaWYgKGluQnJvd3Nlcikge1xuICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoY29uZmlnLmRldnRvb2xzKSB7XG4gICAgICBpZiAoZGV2dG9vbHMpIHtcbiAgICAgICAgZGV2dG9vbHMuZW1pdCgnaW5pdCcsIFZ1ZSk7XG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAndGVzdCcgJiZcbiAgICAgICAgaXNDaHJvbWVcbiAgICAgICkge1xuICAgICAgICBjb25zb2xlW2NvbnNvbGUuaW5mbyA/ICdpbmZvJyA6ICdsb2cnXShcbiAgICAgICAgICAnRG93bmxvYWQgdGhlIFZ1ZSBEZXZ0b29scyBleHRlbnNpb24gZm9yIGEgYmV0dGVyIGRldmVsb3BtZW50IGV4cGVyaWVuY2U6XFxuJyArXG4gICAgICAgICAgJ2h0dHBzOi8vZ2l0aHViLmNvbS92dWVqcy92dWUtZGV2dG9vbHMnXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Rlc3QnICYmXG4gICAgICBjb25maWcucHJvZHVjdGlvblRpcCAhPT0gZmFsc2UgJiZcbiAgICAgIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJ1xuICAgICkge1xuICAgICAgY29uc29sZVtjb25zb2xlLmluZm8gPyAnaW5mbycgOiAnbG9nJ10oXG4gICAgICAgIFwiWW91IGFyZSBydW5uaW5nIFZ1ZSBpbiBkZXZlbG9wbWVudCBtb2RlLlxcblwiICtcbiAgICAgICAgXCJNYWtlIHN1cmUgdG8gdHVybiBvbiBwcm9kdWN0aW9uIG1vZGUgd2hlbiBkZXBsb3lpbmcgZm9yIHByb2R1Y3Rpb24uXFxuXCIgK1xuICAgICAgICBcIlNlZSBtb3JlIHRpcHMgYXQgaHR0cHM6Ly92dWVqcy5vcmcvZ3VpZGUvZGVwbG95bWVudC5odG1sXCJcbiAgICAgICk7XG4gICAgfVxuICB9LCAwKTtcbn1cblxuLyogICovXG5cbm1vZHVsZS5leHBvcnRzID0gVnVlO1xuIiwidmFyIGluc2VydGVkID0gZXhwb3J0cy5jYWNoZSA9IHt9XG5cbmZ1bmN0aW9uIG5vb3AgKCkge31cblxuZXhwb3J0cy5pbnNlcnQgPSBmdW5jdGlvbiAoY3NzKSB7XG4gIGlmIChpbnNlcnRlZFtjc3NdKSByZXR1cm4gbm9vcFxuICBpbnNlcnRlZFtjc3NdID0gdHJ1ZVxuXG4gIHZhciBlbGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKVxuICBlbGVtLnNldEF0dHJpYnV0ZSgndHlwZScsICd0ZXh0L2NzcycpXG5cbiAgaWYgKCd0ZXh0Q29udGVudCcgaW4gZWxlbSkge1xuICAgIGVsZW0udGV4dENvbnRlbnQgPSBjc3NcbiAgfSBlbHNlIHtcbiAgICBlbGVtLnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzc1xuICB9XG5cbiAgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXS5hcHBlbmRDaGlsZChlbGVtKVxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF0ucmVtb3ZlQ2hpbGQoZWxlbSlcbiAgICBpbnNlcnRlZFtjc3NdID0gZmFsc2VcbiAgfVxufVxuIiwiZXhwb3J0IGRlZmF1bHQgKCB2YWx1ZSwgbWVzc2FnZSApID0+IHtcbiAgaWYgKCB2YWx1ZSApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoIG1lc3NhZ2UgKTtcbiAgfVxufTsiLCJpbXBvcnQgQ2xvY2sgZnJvbSAnLi9jbG9jayc7XG5cbi8qKlxuICogKipVc3VhbGx5IHlvdSBkb24ndCBuZWVkIHRvIGtub3cgYWJvdXQgdGhpcyBjbGFzcy4qKlxuICogQ2xhc3MgdGhhdCBkZWFscyB3aXRoIHRpbWUuXG4gKiBUaGlzIGlzIFwiZnJhbWVcIiB0eXBlIGNsb2NrLCB0aGUgZnJhbWUgaW5jcmVhc2VzIGV2ZXJ5IHVwZGF0ZSBjYWxsLlxuICogQGV4dGVuZHMgQ2xvY2tcbiAqIEBwYXJhbSB7QXV0b21hdG9ufSBfYXV0b21hdG9uIFBhcmVudCBhdXRvbWF0b24gb2JqZWN0XG4gKiBAcGFyYW0ge251bWJlcn0gX2ZwcyBGcmFtZXMgcGVyIHNlY29uZFxuICovXG5jb25zdCBDbG9ja0ZyYW1lID0gY2xhc3MgZXh0ZW5kcyBDbG9jayB7XG4gIGNvbnN0cnVjdG9yKCBfYXV0b21hdG9uLCBfZnBzICkge1xuICAgIHN1cGVyKCBfYXV0b21hdG9uICk7XG5cbiAgICB0aGlzLmZyYW1lID0gMC4wO1xuICAgIHRoaXMuZnBzID0gX2ZwcztcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIGNsb2NrLiBJdCB3aWxsIGluY3JlYXNlIHRoZSBmcmFtZSBieSAxLlxuICAgKiBAcmV0dXJucyB7dm9pZH0gdm9pZFxuICAgKi9cbiAgdXBkYXRlKCkge1xuICAgIGlmICggdGhpcy5pc1BsYXlpbmcgKSB7XG4gICAgICB0aGlzLnRpbWUgPSB0aGlzLmZyYW1lIC8gdGhpcy5mcHM7XG4gICAgICB0aGlzLmRlbHRhVGltZSA9IDEuMCAvIHRoaXMuZnBzO1xuICAgICAgdGhpcy5mcmFtZSArKztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kZWx0YVRpbWUgPSAwLjA7XG4gICAgfVxuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBDbG9ja0ZyYW1lOyIsImltcG9ydCBDbG9jayBmcm9tICcuL2Nsb2NrJztcblxuLyoqXG4gKiAqKlVzdWFsbHkgeW91IGRvbid0IG5lZWQgdG8ga25vdyBhYm91dCB0aGlzIGNsYXNzLioqXG4gKiBDbGFzcyB0aGF0IGRlYWxzIHdpdGggdGltZS5cbiAqIFRoaXMgaXMgXCJyZWFsdGltZVwiIHR5cGUgY2xvY2ssIHRoZSB0aW1lIGdvZXMgb24gYXMgcmVhbCB3b3JsZC5cbiAqIEBleHRlbmRzIENsb2NrXG4gKiBAcGFyYW0ge0F1dG9tYXRvbn0gX2F1dG9tYXRvbiBQYXJlbnQgYXV0b21hdG9uIG9iamVjdFxuICovXG5jb25zdCBDbG9ja1JlYWx0aW1lID0gY2xhc3MgZXh0ZW5kcyBDbG9jayB7XG4gIGNvbnN0cnVjdG9yKCBfYXV0b21hdG9uICkge1xuICAgIHN1cGVyKCBfYXV0b21hdG9uICk7XG5cbiAgICB0aGlzLnJlYWx0aW1lID0gdHJ1ZTtcbiAgICB0aGlzLnJ0VGltZSA9IDAuMDtcbiAgICB0aGlzLnJ0RGF0ZSA9ICtuZXcgRGF0ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgY2xvY2suIFRpbWUgaXMgY2FsY3VsYXRlZCBiYXNlZCBvbiB0aW1lIGluIHJlYWwgd29ybGQuXG4gICAqIEByZXR1cm5zIHt2b2lkfSB2b2lkXG4gICAqL1xuICB1cGRhdGUoKSB7XG4gICAgaWYgKCB0aGlzLmlzUGxheWluZyApIHtcbiAgICAgIGNvbnN0IHByZXZUaW1lID0gdGhpcy50aW1lO1xuICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgIGNvbnN0IGRlbHRhRGF0ZSA9ICggbm93IC0gdGhpcy5ydERhdGUgKTtcbiAgICAgIHRoaXMudGltZSA9IHRoaXMucnRUaW1lICsgZGVsdGFEYXRlIC8gMTAwMC4wO1xuICAgICAgdGhpcy5kZWx0YVRpbWUgPSB0aGlzLnRpbWUgLSBwcmV2VGltZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5ydFRpbWUgPSB0aGlzLnRpbWU7XG4gICAgICB0aGlzLnJ0RGF0ZSA9ICtuZXcgRGF0ZSgpO1xuICAgICAgdGhpcy5kZWx0YVRpbWUgPSAwLjA7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgdGltZSBtYW51YWxseS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IF90aW1lIFRpbWVcbiAgICogQHJldHVybnMge3ZvaWR9IHZvaWRcbiAgICovXG4gIHNldFRpbWUoIF90aW1lICkge1xuICAgIHRoaXMudGltZSA9IF90aW1lO1xuICAgIHRoaXMucnRUaW1lID0gdGhpcy50aW1lO1xuICAgIHRoaXMucnREYXRlID0gK25ldyBEYXRlKCk7XG4gIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IENsb2NrUmVhbHRpbWU7IiwiLyoqXG4gKiAqKlVzdWFsbHkgeW91IGRvbid0IG5lZWQgdG8ga25vdyBhYm91dCB0aGlzIGNsYXNzLioqXG4gKiBDbGFzcyB0aGF0IGRlYWxzIHdpdGggdGltZS5cbiAqIEluIHRoaXMgYmFzZSBjbGFzcywgeW91IG5lZWQgdG8gc2V0IHRpbWUgbWFudWFsbHkgZnJvbSBgQXV0b21hdG9uLnVwZGF0ZSgpYC5cbiAqIEJlc3QgZm9yIHN5bmMgd2l0aCBleHRlcm5hbCBjbG9jayBzdHVmZi5cbiAqIEBwYXJhbSB7QXV0b21hdG9ufSBfYXV0b21hdG9uIFBhcmVudCBhdXRvbWF0b24gb2JqZWN0XG4gKi9cbmNvbnN0IENsb2NrID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvciggX2F1dG9tYXRvbiApIHtcbiAgICB0aGlzLmF1dG9tYXRvbiA9IF9hdXRvbWF0b247XG5cbiAgICB0aGlzLnRpbWUgPSAwLjA7XG4gICAgdGhpcy5kZWx0YVRpbWUgPSAwLjA7XG4gICAgdGhpcy5pc1BsYXlpbmcgPSB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgY2xvY2suXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBfdGltZSBUaW1lLiBZb3UgbmVlZCB0byBzZXQgbWFudWFsbHlcbiAgICogQHJldHVybnMge3ZvaWR9IHZvaWRcbiAgICovXG4gIHVwZGF0ZSggX3RpbWUgKSB7XG4gICAgY29uc3QgcHJldlRpbWUgPSB0aGlzLnRpbWU7XG4gICAgdGhpcy50aW1lID0gX3RpbWU7XG4gICAgdGhpcy5kZWx0YVRpbWUgPSB0aGlzLnRpbWUgLSBwcmV2VGltZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdGFydCB0aGUgY2xvY2suXG4gICAqIEByZXR1cm5zIHt2b2lkfSB2b2lkXG4gICAqL1xuICBwbGF5KCkge1xuICAgIHRoaXMuaXNQbGF5aW5nID0gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdG9wIHRoZSBjbG9jay5cbiAgICogQHJldHVybnMge3ZvaWR9IHZvaWRcbiAgICovXG4gIHBhdXNlKCkge1xuICAgIHRoaXMuaXNQbGF5aW5nID0gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSB0aW1lIG1hbnVhbGx5LlxuICAgKiBAcGFyYW0ge251bWJlcn0gX3RpbWUgVGltZVxuICAgKiBAcmV0dXJucyB7dm9pZH0gdm9pZFxuICAgKi9cbiAgc2V0VGltZSggX3RpbWUgKSB7XG4gICAgdGhpcy50aW1lID0gX3RpbWU7XG4gIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IENsb2NrOyIsImNvbnN0IGRlZmF1bHREYXRhID0ge1xuICB2OiBcIjIuMC4xXCIsXG5cbiAgbGVuZ3RoOiAxLjAsXG4gIHJlc29sdXRpb246IDEwMDAuMCxcbiAgcGFyYW1zOiB7fSxcblxuICBndWlTZXR0aW5nczoge1xuICAgIHNuYXBBY3RpdmU6IGZhbHNlLFxuICAgIHNuYXBUaW1lOiAwLjEsXG4gICAgc25hcFZhbHVlOiAwLjFcbiAgfVxufTtcblxuY29uc3QgY29tcGF0ID0gKCBfZGF0YSApID0+IHtcbiAgaWYgKCAhX2RhdGEgKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oIHt9LCBkZWZhdWx0RGF0YSApO1xuICB9XG5cbiAgbGV0IGRhdGE7XG4gIGlmICggdHlwZW9mIF9kYXRhID09PSAnb2JqZWN0JyApIHtcbiAgICBkYXRhID0gX2RhdGE7XG4gIH0gZWxzZSBpZiAoIHR5cGVvZiBfZGF0YSA9PT0gJ3N0cmluZycgKSB7XG4gICAgdHJ5IHtcbiAgICAgIGRhdGEgPSBKU09OLnBhcnNlKCBfZGF0YSApO1xuICAgIH0gY2F0Y2ggKCBlICkge1xuICAgICAgY29uc29sZS5lcnJvciggJ0xvYWRlZCBkYXRhIGlzIGludmFsaWQnICk7XG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbigge30sIGRlZmF1bHREYXRhICk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNvbnNvbGUuZXJyb3IoICdMb2FkZWQgZGF0YSBpcyBpbnZhbGlkJyApO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKCB7fSwgZGVmYXVsdERhdGEgKTtcbiAgfVxuXG4gIGxldCB2ID0gcGFyc2VGbG9hdCggZGF0YS52ICk7XG5cbiAgaWYgKCAhdiAmJiAhZGF0YS5yZXYgKSB7XG4gICAgaWYgKCBkYXRhLmd1aSApIHsgLy8gXCJTaGlmdFwiIHZlcnNpb24gb2YgYXV0b21hdG9uLCBoYXMgaW5jb21wYXRpYmxlIGd1aSBwYXJhbXNcbiAgICAgIGRlbGV0ZSBkYXRhLmd1aTtcbiAgICAgIGRhdGEuZ3VpID0gT2JqZWN0LmFzc2lnbigge30sIGRlZmF1bHREYXRhLmd1aSApO1xuICAgIH0gZWxzZSB7IC8vIHd0ZiBpcyB0aGlzXG4gICAgICBjb25zb2xlLmVycm9yKCAnTG9hZGVkIGRhdGEgaXMgbm90IGNvbXBhdGlibGUgd2l0aCB0aGlzIHJldmlzaW9uJyApO1xuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oIHt9LCBkZWZhdWx0RGF0YSApO1xuICAgIH1cbiAgfVxuXG4gIGlmICggZGF0YS5yZXYgKSB7IC8vIGZ1Y2tcbiAgICB2ID0gMS4wO1xuICAgIGRlbGV0ZSBkYXRhLnJldjtcbiAgfVxuXG4gIGlmICggdiA8IDIuMCApIHsgLy8gdjEsIG1vZGVzIGFuZCBtb2RpZmllcnMsIENVUlNFRFxuICAgIGZvciAoIGNvbnN0IG5hbWUgaW4gZGF0YS5wYXJhbXMgKSB7XG4gICAgICBjb25zdCBvbGRQYXJhbSA9IGRhdGEucGFyYW1zWyBuYW1lIF07XG4gICAgICBjb25zdCBuZXdQYXJhbSA9IHtcbiAgICAgICAgbm9kZXM6IG9sZFBhcmFtLm1hcCggKCBub2RlLCBpICkgPT4gKCB7XG4gICAgICAgICAgdGltZTogbm9kZS50aW1lLFxuICAgICAgICAgIHZhbHVlOiBub2RlLnZhbHVlLFxuICAgICAgICAgIGluOiBpID09PSAwID8gdW5kZWZpbmVkIDogeyB0aW1lOiAwLjAsIHZhbHVlOiAwLjAgfSxcbiAgICAgICAgICBvdXQ6ICggaSA9PT0gb2xkUGFyYW0ubGVuZ3RoIC0gMSApID8gdW5kZWZpbmVkIDogeyB0aW1lOiAwLjAsIHZhbHVlOiAwLjAgfVxuICAgICAgICB9ICkgKSxcbiAgICAgICAgZnhzOiBbXVxuICAgICAgfTtcblxuICAgICAgbGV0IGhlYWQgPSAwO1xuICAgICAgZm9yICggbGV0IGkgPSAxOyBpIDwgb2xkUGFyYW0ubGVuZ3RoOyBpICsrICkge1xuICAgICAgICBoZWFkICsrO1xuXG4gICAgICAgIGlmICggb2xkUGFyYW1bIGkgXS5tb2RlID09PSAwICkgeyAvLyBob2xkXG4gICAgICAgICAgbmV3UGFyYW0ubm9kZXMuc3BsaWNlKCBoZWFkLCAwLCB7XG4gICAgICAgICAgICB0aW1lOiBvbGRQYXJhbVsgaSBdLnRpbWUsXG4gICAgICAgICAgICB2YWx1ZTogb2xkUGFyYW1bIGkgLSAxIF0udmFsdWUsXG4gICAgICAgICAgICBpbjogeyB0aW1lOiAwLjAsIHZhbHVlOiAwLjAgfSxcbiAgICAgICAgICAgIG91dDogeyB0aW1lOiAwLjAsIHZhbHVlOiAwLjAgfVxuICAgICAgICAgIH0gKTtcbiAgICAgICAgICBoZWFkICsrO1xuICAgICAgICB9IGVsc2UgaWYgKCBvbGRQYXJhbVsgaSBdLm1vZGUgPT09IDEgKSB7IC8vIGxpbmVhclxuICAgICAgICAgIC8vIGRvIG5vdGhpbmdcbiAgICAgICAgfSBlbHNlIGlmICggb2xkUGFyYW1bIGkgXS5tb2RlID09PSAyICkgeyAvLyBjb3NpbmVcbiAgICAgICAgICBjb25zdCBsID0gbmV3UGFyYW0ubm9kZXNbIGhlYWQgXS50aW1lIC0gbmV3UGFyYW0ubm9kZXNbIGhlYWQgLSAxIF0udGltZTtcbiAgICAgICAgICBuZXdQYXJhbS5ub2Rlc1sgaGVhZCAtIDEgXS5vdXQgPSB7IHRpbWU6IGwgKiAwLjM3LCB2YWx1ZTogMC4wIH07XG4gICAgICAgICAgbmV3UGFyYW0ubm9kZXNbIGhlYWQgXS5pbiA9IHsgdGltZTogLWwgKiAwLjM3LCB2YWx1ZTogMC4wIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV3UGFyYW0ubm9kZXMuc3BsaWNlKCBoZWFkLCAwLCB7XG4gICAgICAgICAgICB0aW1lOiBvbGRQYXJhbVsgaSAtIDEgXS50aW1lLFxuICAgICAgICAgICAgdmFsdWU6IG9sZFBhcmFtWyBpIF0udmFsdWUsXG4gICAgICAgICAgICBpbjogeyB0aW1lOiAwLjAsIHZhbHVlOiAwLjAgfSxcbiAgICAgICAgICAgIG91dDogeyB0aW1lOiAwLjAsIHZhbHVlOiAwLjAgfVxuICAgICAgICAgIH0gKTtcbiAgICAgICAgICBoZWFkICsrO1xuXG4gICAgICAgICAgaWYgKCBvbGRQYXJhbVsgaSBdLm1vZGUgPT09IDMgKSB7IC8vIGV4cFxuICAgICAgICAgICAgbmV3UGFyYW0uZnhzLnB1c2goIHtcbiAgICAgICAgICAgICAgbmFtZTogJ0V4cG9uZW50aWFsIFNtb290aGluZycsXG4gICAgICAgICAgICAgIGJ5cGFzczogZmFsc2UsXG4gICAgICAgICAgICAgIHJvdzogMCxcbiAgICAgICAgICAgICAgdGltZTogb2xkUGFyYW1bIGkgLSAxIF0udGltZSAtIDEuMCAvIGRhdGEucmVzb2x1dGlvbiwgLy8g8J+UpVxuICAgICAgICAgICAgICBsZW5ndGg6IG9sZFBhcmFtWyBpIF0udGltZSAtIG9sZFBhcmFtWyBpIC0gMSBdLnRpbWUsXG4gICAgICAgICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgICAgIGZhY3Rvcjogb2xkUGFyYW1bIGkgXS5wYXJhbXMuZmFjdG9yLFxuICAgICAgICAgICAgICAgIHByZXNlcnZlOiB0cnVlXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCBvbGRQYXJhbVsgaSBdLm1vZGUgPT09IDQgKSB7IC8vIHNwcmluZ1xuICAgICAgICAgICAgbmV3UGFyYW0uZnhzLnB1c2goIHtcbiAgICAgICAgICAgICAgbmFtZTogJ0NyaXRpY2FsbHkgRGFtcGVkIFNwcmluZycsXG4gICAgICAgICAgICAgIGJ5cGFzczogZmFsc2UsXG4gICAgICAgICAgICAgIHJvdzogMCxcbiAgICAgICAgICAgICAgdGltZTogb2xkUGFyYW1bIGkgLSAxIF0udGltZSAtIDEuMCAvIGRhdGEucmVzb2x1dGlvbiwgLy8g8J+UpVxuICAgICAgICAgICAgICBsZW5ndGg6IG9sZFBhcmFtWyBpIF0udGltZSAtIG9sZFBhcmFtWyBpIC0gMSBdLnRpbWUsXG4gICAgICAgICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgICAgIGZhY3Rvcjogb2xkUGFyYW1bIGkgXS5wYXJhbXMucmF0ZSxcbiAgICAgICAgICAgICAgICByYXRpbzogb2xkUGFyYW1bIGkgXS5wYXJhbXMuZGFtcCxcbiAgICAgICAgICAgICAgICBwcmVzZXJ2ZTogdHJ1ZVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9ICk7XG4gICAgICAgICAgfSBlbHNlIGlmICggb2xkUGFyYW1bIGkgXS5tb2RlID09PSA1ICkgeyAvLyBncmF2aXR5XG4gICAgICAgICAgICBuZXdQYXJhbS5meHMucHVzaCgge1xuICAgICAgICAgICAgICBuYW1lOiAnR3Jhdml0eScsXG4gICAgICAgICAgICAgIGJ5cGFzczogZmFsc2UsXG4gICAgICAgICAgICAgIHJvdzogMCxcbiAgICAgICAgICAgICAgdGltZTogb2xkUGFyYW1bIGkgLSAxIF0udGltZSAtIDEuMCAvIGRhdGEucmVzb2x1dGlvbiwgLy8g8J+UpVxuICAgICAgICAgICAgICBsZW5ndGg6IG9sZFBhcmFtWyBpIF0udGltZSAtIG9sZFBhcmFtWyBpIC0gMSBdLnRpbWUsXG4gICAgICAgICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgICAgIGE6IG9sZFBhcmFtWyBpIF0ucGFyYW1zLmdyYXZpdHksXG4gICAgICAgICAgICAgICAgZTogb2xkUGFyYW1bIGkgXS5wYXJhbXMuYm91bmNlLFxuICAgICAgICAgICAgICAgIHByZXNlcnZlOiB0cnVlXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIG9sZFBhcmFtWyBpIF0ubW9kc1sgMSBdICkge1xuICAgICAgICAgIG5ld1BhcmFtLmZ4cy5wdXNoKCB7XG4gICAgICAgICAgICBuYW1lOiAnU2luZXdhdmUnLFxuICAgICAgICAgICAgYnlwYXNzOiBmYWxzZSxcbiAgICAgICAgICAgIHJvdzogMSxcbiAgICAgICAgICAgIHRpbWU6IG9sZFBhcmFtWyBpIC0gMSBdLnRpbWUsXG4gICAgICAgICAgICBsZW5ndGg6IG9sZFBhcmFtWyBpIF0udGltZSAtIG9sZFBhcmFtWyBpIC0gMSBdLnRpbWUsXG4gICAgICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAgICAgZnJlcTogb2xkUGFyYW1bIGkgXS5tb2RzWyAxIF0uZnJlcSxcbiAgICAgICAgICAgICAgYW1wOiBvbGRQYXJhbVsgaSBdLm1vZHNbIDEgXS5hbXAsXG4gICAgICAgICAgICAgIHBoYXNlOiBvbGRQYXJhbVsgaSBdLm1vZHNbIDEgXS5waGFzZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggb2xkUGFyYW1bIGkgXS5tb2RzWyAyIF0gKSB7XG4gICAgICAgICAgbmV3UGFyYW0uZnhzLnB1c2goIHtcbiAgICAgICAgICAgIG5hbWU6ICdGcmFjdGFsIE5vaXNlJyxcbiAgICAgICAgICAgIGJ5cGFzczogZmFsc2UsXG4gICAgICAgICAgICByb3c6IDIsXG4gICAgICAgICAgICB0aW1lOiBvbGRQYXJhbVsgaSAtIDEgXS50aW1lLFxuICAgICAgICAgICAgbGVuZ3RoOiBvbGRQYXJhbVsgaSBdLnRpbWUgLSBvbGRQYXJhbVsgaSAtIDEgXS50aW1lLFxuICAgICAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICAgIGFtcDogb2xkUGFyYW1bIGkgXS5tb2RzWyAyIF0uYW1wLFxuICAgICAgICAgICAgICByZWN1cnNpb246IG9sZFBhcmFtWyBpIF0ubW9kc1sgMiBdLnJlY3Vyc2lvbixcbiAgICAgICAgICAgICAgZnJlcTogb2xkUGFyYW1bIGkgXS5tb2RzWyAyIF0uZnJlcSxcbiAgICAgICAgICAgICAgcmVzbzogb2xkUGFyYW1bIGkgXS5tb2RzWyAyIF0ucmVzbyxcbiAgICAgICAgICAgICAgc2VlZDogb2xkUGFyYW1bIGkgXS5tb2RzWyAyIF0uc2VlZFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggb2xkUGFyYW1bIGkgXS5tb2RzWyAzIF0gKSB7XG4gICAgICAgICAgbmV3UGFyYW0uZnhzLnB1c2goIHtcbiAgICAgICAgICAgIG5hbWU6ICdMby1GaScsXG4gICAgICAgICAgICBieXBhc3M6IGZhbHNlLFxuICAgICAgICAgICAgcm93OiAzLFxuICAgICAgICAgICAgdGltZTogb2xkUGFyYW1bIGkgLSAxIF0udGltZSxcbiAgICAgICAgICAgIGxlbmd0aDogb2xkUGFyYW1bIGkgXS50aW1lIC0gb2xkUGFyYW1bIGkgLSAxIF0udGltZSxcbiAgICAgICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgICByZXNvbHV0aW9uOiBvbGRQYXJhbVsgaSBdLm1vZHNbIDMgXS5mcmVxLFxuICAgICAgICAgICAgICByZWxhdGl2ZTogdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZGF0YS5wYXJhbXNbIG5hbWUgXSA9IG5ld1BhcmFtO1xuICAgIH1cblxuICAgIGRhdGEuZ3VpU2V0dGluZ3MgPSB7XG4gICAgICBzbmFwQWN0aXZlOiBmYWxzZSxcbiAgICAgIHNuYXBUaW1lOiAwLjEsXG4gICAgICBzbmFwVmFsdWU6IDAuMVxuICAgIH07XG4gIH1cblxuICBkYXRhLnYgPSBcIjIuMC4xXCI7XG4gIHJldHVybiBkYXRhO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgY29tcGF0OyIsIi8vIHJlZjogaHR0cHM6Ly9naXRodWIuY29tL2dyZS9iZXppZXItZWFzaW5nL2Jsb2IvbWFzdGVyL3NyYy9pbmRleC5qc1xuXG5jb25zdCBORVdUT05fSVRFUiA9IDQ7XG5jb25zdCBORVdUT05fRVBTSUxPTiA9IDAuMDAxO1xuY29uc3QgU1VCRElWX0lURVIgPSAxMDtcbmNvbnN0IFNVQkRJVl9FUFNJTE9OID0gMC4wMDAwMDE7XG5jb25zdCBUQUJMRV9TSVpFID0gMjE7XG5cbmxldCB0YWIgPSBbXTtcblxuY29uc3QgQSA9ICggYTEsIGEyICkgPT4gMS4wIC0gMy4wICogYTIgKyAzLjAgKiBhMTtcbmNvbnN0IEIgPSAoIGExLCBhMiApID0+IDMuMCAqIGEyIC0gNi4wICogYTE7XG5jb25zdCBDID0gKCBhMSApID0+IDMuMCAqIGExO1xuXG5jb25zdCBzYXR1cmF0ZSA9ICggeCApID0+IE1hdGgubWluKCBNYXRoLm1heCggeCwgMC4wICksIDEuMCApO1xuXG5jb25zdCBjYWxjID0gKCB0LCBhMSwgYTIgKSA9PlxuICAoICggQSggYTEsIGEyICkgKiB0ICsgQiggYTEsIGEyICkgKSAqIHQgKyBDKCBhMSApICkgKiB0O1xuXG5jb25zdCBkZWx0YSA9ICggdCwgYTEsIGEyICkgPT5cbiAgMy4wICogQSggYTEsIGEyICkgKiB0ICogdCArIDIuMCAqIEIoIGExLCBhMiApICogdCArIEMoIGExICk7XG5cbmNvbnN0IHN1YmRpdiA9ICggeCwgYSwgYiwgeDEsIHgyICkgPT4ge1xuICBsZXQgY3ggPSAwO1xuICBsZXQgY3QgPSAwO1xuXG4gIGZvciAoIGxldCBpID0gMDsgaSA8IFNVQkRJVl9JVEVSOyBpICsrICkge1xuICAgIGN0ID0gYSArICggYiAtIGEgKSAvIDIuMDtcbiAgICBjeCA9IGNhbGMoIGN0LCB4MSwgeDIgKSAtIHg7XG4gICAgKCAwLjAgPCBjeCApID8gKCBiID0gY3QgKSA6ICggYSA9IGN0ICk7XG4gICAgaWYgKCBTVUJESVZfRVBTSUxPTiA8IE1hdGguYWJzKCBjeCApICkgeyBicmVhazsgfVxuICB9XG5cbiAgcmV0dXJuIGN0O1xufTtcblxuY29uc3QgbmV3dG9uID0gKCB4LCBndCwgeDEsIHgyICkgPT4ge1xuICBmb3IgKCBsZXQgaSA9IDA7IGkgPCBORVdUT05fSVRFUjsgaSArKyApIHtcbiAgICBjb25zdCBkID0gZGVsdGEoIGd0LCB4MSwgeDIgKTtcbiAgICBpZiAoIGQgPT09IDAuMCApIHsgcmV0dXJuIGd0OyB9XG4gICAgY29uc3QgY3ggPSBjYWxjKCBndCwgeDEsIHgyICkgLSB4O1xuICAgIGd0ID0gZ3QgLSBjeCAvIGQ7XG4gIH1cblxuICByZXR1cm4gZ3Q7XG59O1xuXG5jb25zdCByYXdDdWJpY0JlemllciA9ICggeDEsIHkxLCB4MiwgeTIsIHggKSA9PiB7XG4gIGlmICggaXNOYU4oIHgxICkgfHwgaXNOYU4oIHkxICkgfHwgaXNOYU4oIHgyICkgfHwgaXNOYU4oIHkyICkgKSB7IHJldHVybiB4OyB9IC8vIGhlaFxuICBpZiAoIHgxID09PSB5MSAmJiB4MiA9PT0geTIgKSB7IHJldHVybiB4OyB9IC8vIGxpbmVhclxuICBpZiAoIHggPD0gMC4wICkgeyByZXR1cm4gMC4wOyB9XG4gIGlmICggMS4wIDw9IHggKSB7IHJldHVybiAxLjA7IH1cblxuICB4MSA9IHNhdHVyYXRlKCB4MSApO1xuICB4MiA9IHNhdHVyYXRlKCB4MiApO1xuXG4gIGZvciAoIGxldCBpID0gMDsgaSA8IFRBQkxFX1NJWkU7IGkgKysgKSB7XG4gICAgdGFiWyBpIF0gPSBjYWxjKCBpIC8gKCBUQUJMRV9TSVpFIC0gMS4wICksIHgxLCB4MiApO1xuICB9XG5cbiAgbGV0IHNhbXBsZSA9IDE7XG4gIGZvciAoIGxldCBpID0gMTsgaSA8IFRBQkxFX1NJWkU7IGkgKysgKSB7XG4gICAgc2FtcGxlID0gaSAtIDE7XG4gICAgaWYgKCB4IDwgdGFiWyBpIF0gKSB7IGJyZWFrOyB9XG4gIH1cblxuICBjb25zdCBkaXN0ID0gKCB4IC0gdGFiWyBzYW1wbGUgXSApIC8gKCB0YWJbIHNhbXBsZSArIDEgXSAtIHRhYlsgc2FtcGxlIF0gKTtcbiAgbGV0IHQgPSAoIHNhbXBsZSArIGRpc3QgKSAvICggVEFCTEVfU0laRSAtIDEgKTtcbiAgY29uc3QgZCA9IGRlbHRhKCB0LCB4MSwgeDIgKTtcbiAgaWYgKCBORVdUT05fRVBTSUxPTiA8PSBkICkge1xuICAgIHQgPSBuZXd0b24oIHgsIHQsIHgxLCB4MiApO1xuICB9IGVsc2UgaWYgKCBkICE9PSAwLjAgKSB7XG4gICAgdCA9IHN1YmRpdiggeCwgKCBzYW1wbGUgKSAvICggVEFCTEVfU0laRSAtIDEgKSwgKCBzYW1wbGUgKyAxLjAgKSAvICggVEFCTEVfU0laRSAtIDEgKSwgeDEsIHgyICk7XG4gIH1cblxuICByZXR1cm4gY2FsYyggdCwgeTEsIHkyICk7XG59O1xuXG5jb25zdCBjdWJpY0JlemllciA9ICggbm9kZTAsIG5vZGUxLCB0aW1lICkgPT4ge1xuICBjb25zdCB0TCA9IG5vZGUxLnRpbWUgLSBub2RlMC50aW1lO1xuICBjb25zdCB2TCA9IG5vZGUxLnZhbHVlIC0gbm9kZTAudmFsdWU7XG4gIGNvbnN0IHgxID0gbm9kZTAub3V0LnRpbWUgLyB0TDtcbiAgY29uc3QgeTEgPSBub2RlMC5vdXQudmFsdWUgLyB2TDtcbiAgY29uc3QgeDIgPSAoIG5vZGUxLnRpbWUgKyBub2RlMS5pbi50aW1lIC0gbm9kZTAudGltZSApIC8gdEw7XG4gIGNvbnN0IHkyID0gKCBub2RlMS52YWx1ZSArIG5vZGUxLmluLnZhbHVlIC0gbm9kZTAudmFsdWUgKSAvIHZMO1xuICBjb25zdCB4ID0gKCB0aW1lIC0gbm9kZTAudGltZSApIC8gdEw7XG4gIHJldHVybiBub2RlMC52YWx1ZSArIHJhd0N1YmljQmV6aWVyKCB4MSwgeTEsIHgyLCB5MiwgeCApICogdkw7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBjdWJpY0JlemllcjsiLCJleHBvcnQgZGVmYXVsdCBbXG4gIHJlcXVpcmUoICcuL2Z4cy9hZGQnICkuZGVmYXVsdCxcbiAgcmVxdWlyZSggJy4vZnhzL2NkcycgKS5kZWZhdWx0LFxuICByZXF1aXJlKCAnLi9meHMvY2xhbXAnICkuZGVmYXVsdCxcbiAgcmVxdWlyZSggJy4vZnhzL2V4cCcgKS5kZWZhdWx0LFxuICByZXF1aXJlKCAnLi9meHMvZ3Jhdml0eScgKS5kZWZhdWx0LFxuICByZXF1aXJlKCAnLi9meHMvbG9maScgKS5kZWZhdWx0LFxuICByZXF1aXJlKCAnLi9meHMvbm9pc2UnICkuZGVmYXVsdCxcbiAgcmVxdWlyZSggJy4vZnhzL3BvdycgKS5kZWZhdWx0LFxuICByZXF1aXJlKCAnLi9meHMvc2luZScgKS5kZWZhdWx0XG5dOyIsImV4cG9ydCBkZWZhdWx0IFsgJ2FkZCcsIHtcbiAgbmFtZTogJ0FkZCcsXG4gIGRlc2NyaXB0aW9uOiAnVGhlIHNpbXBsZXN0IGZ4IGV2ZXIuIEp1c3QgYWRkIGEgY29uc3RhbnQgdmFsdWUgdG8gdGhlIGN1cnZlLicsXG4gIHBhcmFtczoge1xuICAgIHZhbHVlOiB7IG5hbWU6ICdWYWx1ZScsIHR5cGU6ICdmbG9hdCcsIGRlZmF1bHQ6IDEuMCB9XG4gIH0sXG4gIGZ1bmMoIGNvbnRleHQgKSB7XG4gICAgcmV0dXJuIGNvbnRleHQudiArIGNvbnRleHQucGFyYW1zLnZhbHVlO1xuICB9XG59IF07IiwiZXhwb3J0IGRlZmF1bHQgWyAnY2RzJywge1xuICBuYW1lOiAnQ3JpdGljYWxseSBEYW1wZWQgU3ByaW5nJyxcbiAgZGVzY3JpcHRpb246ICdCYXNpY2FsbHkgdGhlIGJlc3Qgc21vb3RoaW5nIG1ldGhvZC4gU2hvdXRvdXRzIHRvIEtlaWppcm8gVGFrYWhhc2hpJyxcbiAgcGFyYW1zOiB7XG4gICAgZmFjdG9yOiB7IG5hbWU6ICdGYWN0b3InLCB0eXBlOiAnZmxvYXQnLCBkZWZhdWx0OiAxMDAuMCwgbWluOiAwLjAgfSxcbiAgICByYXRpbzogeyBuYW1lOiAnRGFtcCBSYXRpbycsIHR5cGU6ICdmbG9hdCcsIGRlZmF1bHQ6IDEuMCB9LFxuICAgIHByZXNlcnZlOiB7IG5hbWU6ICdQcmVzZXJ2ZSBWZWxvY2l0eScsIHR5cGU6ICdib29sZWFuJywgZGVmYXVsdDogZmFsc2UgfVxuICB9LFxuICBmdW5jKCBjb250ZXh0ICkge1xuICAgIGNvbnN0IGR0ID0gY29udGV4dC5kdDtcbiAgICBjb25zdCB2ID0gY29udGV4dC52O1xuICAgIGNvbnN0IGsgPSBjb250ZXh0LnBhcmFtcy5mYWN0b3I7XG5cbiAgICBpZiAoIGNvbnRleHQuaW5pdCApIHtcbiAgICAgIGNvbnRleHQucG9zID0gY29udGV4dC52O1xuICAgICAgaWYgKCBjb250ZXh0LnBhcmFtcy5wcmVzZXJ2ZSApIHtcbiAgICAgICAgY29uc3QgZHYgPSB2IC0gY29udGV4dC5nZXRWYWx1ZSggY29udGV4dC50IC0gZHQgKTtcbiAgICAgICAgY29udGV4dC52ZWwgPSBkdiAvIGR0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGV4dC52ZWwgPSAwLjA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29udGV4dC52ZWwgKz0gKCAtayAqICggY29udGV4dC5wb3MgLSB2ICkgLSAyLjAgKiBjb250ZXh0LnZlbCAqIE1hdGguc3FydCggayApICogY29udGV4dC5wYXJhbXMucmF0aW8gKSAqIGR0O1xuICAgIGNvbnRleHQucG9zICs9IGNvbnRleHQudmVsICogZHQ7XG4gICAgcmV0dXJuIGNvbnRleHQucG9zO1xuICB9XG59IF07IiwiY29uc3QgY2xhbXAgPSAoIHgsIGEsIGIgKSA9PiBNYXRoLm1pbiggTWF0aC5tYXgoIHgsIGEgKSwgYiApO1xuXG5jb25zdCBzbWluID0gKCBhLCBiLCBrICkgPT4ge1xuICBjb25zdCBoID0gTWF0aC5tYXgoIGsgLSBNYXRoLmFicyggYSAtIGIgKSwgMC4wICk7XG4gIHJldHVybiBNYXRoLm1pbiggYSwgYiApIC0gaCAqIGggKiBoIC8gKCA2LjAgKiBrICogayApO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgWyAnY2xhbXAnLCB7XG4gIG5hbWU6ICdDbGFtcCcsXG4gIGRlc2NyaXB0aW9uOiAnQ29uc3RyYWluIHRoZSBjdXJ2ZSBiZXR3ZWVuIHR3byB2YWx1ZXMsIGZlYXR1cmluZyBzbW9vdGggbWluaW11bS4nLFxuICBwYXJhbXM6IHtcbiAgICBtaW46IHsgbmFtZTogJ01pbicsIHR5cGU6ICdmbG9hdCcsIGRlZmF1bHQ6IDAuMCB9LFxuICAgIG1heDogeyBuYW1lOiAnTWF4JywgdHlwZTogJ2Zsb2F0JywgZGVmYXVsdDogMS4wIH0sXG4gICAgc21vb3RoOiB7IG5hbWU6ICdTbW9vdGgnLCB0eXBlOiAnZmxvYXQnLCBkZWZhdWx0OiAwLjAsIG1pbjogMC4wIH1cbiAgfSxcbiAgZnVuYyggY29udGV4dCApIHtcbiAgICBpZiAoIGNvbnRleHQucGFyYW1zLnNtb290aCA9PT0gMC4wICkge1xuICAgICAgcmV0dXJuIGNsYW1wKCBjb250ZXh0LnYsIGNvbnRleHQucGFyYW1zLm1pbiwgY29udGV4dC5wYXJhbXMubWF4ICk7XG4gICAgfVxuXG4gICAgbGV0IHYgPSAtc21pbiggLWNvbnRleHQucGFyYW1zLm1pbiwgLWNvbnRleHQudiwgY29udGV4dC5wYXJhbXMuc21vb3RoICk7XG4gICAgcmV0dXJuIHNtaW4oIGNvbnRleHQucGFyYW1zLm1heCwgdiwgY29udGV4dC5wYXJhbXMuc21vb3RoICk7XG4gIH1cbn0gXTsiLCJleHBvcnQgZGVmYXVsdCBbICdleHAnLCB7XG4gIG5hbWU6ICdFeHBvbmVudGlhbCBTbW9vdGhpbmcnLFxuICBkZXNjcmlwdGlvbjogJ1Ntb290aCB0aGUgY3VydmUuIFNpbXBsZSBidXQgZ29vZC4nLFxuICBwYXJhbXM6IHtcbiAgICBmYWN0b3I6IHsgbmFtZTogJ0ZhY3RvcicsIHR5cGU6ICdmbG9hdCcsIGRlZmF1bHQ6IDEwLjAsIG1pbjogMC4wIH1cbiAgfSxcbiAgZnVuYyggY29udGV4dCApIHtcbiAgICBjb25zdCB2ID0gY29udGV4dC52O1xuXG4gICAgaWYgKCBjb250ZXh0LmluaXQgKSB7XG4gICAgICBjb250ZXh0LnBvcyA9IHY7XG4gICAgfVxuXG4gICAgY29uc3QgayA9IE1hdGguZXhwKCAtY29udGV4dC5kdCAqIGNvbnRleHQucGFyYW1zLmZhY3RvciApO1xuICAgIGNvbnRleHQucG9zID0gY29udGV4dC5wb3MgKiBrICsgdiAqICggMS4wIC0gayApO1xuICAgIHJldHVybiBjb250ZXh0LnBvcztcbiAgfVxufSBdOyIsImV4cG9ydCBkZWZhdWx0IFsgJ2dyYXZpdHknLCB7XG4gIG5hbWU6ICdHcmF2aXR5JyxcbiAgZGVzY3JpcHRpb246ICdBY2NlbGVyYXRlIGFuZCBib3VuY2UgdGhlIGN1cnZlLicsXG4gIHBhcmFtczoge1xuICAgIGE6IHsgbmFtZTogJ0FjY2VsZXJhdGlvbicsIHR5cGU6ICdmbG9hdCcsIGRlZmF1bHQ6IDkuOCB9LFxuICAgIGU6IHsgbmFtZTogJ1Jlc3RpdHV0aW9uJywgdHlwZTogJ2Zsb2F0JywgZGVmYXVsdDogMC41LCBtaW46IDAuMCB9LFxuICAgIHByZXNlcnZlOiB7IG5hbWU6ICdQcmVzZXJ2ZSBWZWxvY2l0eScsIHR5cGU6ICdib29sZWFuJywgZGVmYXVsdDogZmFsc2UgfVxuICB9LFxuICBmdW5jKCBjb250ZXh0ICkge1xuICAgIGNvbnN0IGR0ID0gY29udGV4dC5kdDtcbiAgICBjb25zdCB2ID0gY29udGV4dC52O1xuXG4gICAgaWYgKCBjb250ZXh0LmluaXQgKSB7XG4gICAgICBjb250ZXh0LnBvcyA9IHY7XG4gICAgICBpZiAoIGNvbnRleHQucGFyYW1zLnByZXNlcnZlICkge1xuICAgICAgICBjb25zdCBkdiA9IHYgLSBjb250ZXh0LmdldFZhbHVlKCBjb250ZXh0LnQgLSBkdCApO1xuICAgICAgICBjb250ZXh0LnZlbCA9IGR2IC8gZHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250ZXh0LnZlbCA9IDAuMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBhID0gTWF0aC5zaWduKCB2IC0gY29udGV4dC5wb3MgKSAqIGNvbnRleHQucGFyYW1zLmE7XG4gICAgY29udGV4dC52ZWwgKz0gYSAqIGR0O1xuICAgIGNvbnRleHQucG9zICs9IGNvbnRleHQudmVsICogZHQ7XG5cbiAgICBpZiAoIE1hdGguc2lnbiggYSApICE9PSBNYXRoLnNpZ24oIHYgLSBjb250ZXh0LnBvcyApICkge1xuICAgICAgY29udGV4dC52ZWwgKj0gLWNvbnRleHQucGFyYW1zLmU7XG4gICAgICBjb250ZXh0LnBvcyA9IHYgKyBjb250ZXh0LnBhcmFtcy5lICogKCB2IC0gY29udGV4dC5wb3MgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY29udGV4dC5wb3M7XG4gIH1cbn0gXTsiLCJleHBvcnQgZGVmYXVsdCBbICdsb2ZpJywge1xuICBuYW1lOiAnTG8tRmknLFxuICBkZXNjcmlwdGlvbjogJ01ha2UgY3VydmUgbW9yZSBjcnVuY2h5LicsXG4gIHBhcmFtczoge1xuICAgIHJhdGU6IHsgbmFtZTogJ0ZyYW1lIFJhdGUnLCB0eXBlOiAnZmxvYXQnLCBkZWZhdWx0OiAxMC4wLCBtaW46IDAuMCwgbWF4OiAxMDAwLjAgfSxcbiAgICByZWxhdGl2ZTogeyBuYW1lOiAnUmVsYXRpdmUnLCB0eXBlOiAnYm9vbGVhbicsIGRlZmF1bHQ6IGZhbHNlIH0sXG4gICAgcmVzbzogeyBuYW1lOiAnUmVzbyBQZXIgVW5pdCcsIHR5cGU6ICdmbG9hdCcsIGRlZmF1bHQ6IDAuMSwgbWluOiAwLjAsIG1heDogMTAwMC4wIH0sXG4gICAgcm91bmQ6IHsgbmFtZTogJ1JvdW5kJywgdHlwZTogJ2Jvb2xlYW4nLCBkZWZhdWx0OiBmYWxzZSB9XG4gIH0sXG4gIGZ1bmMoIGNvbnRleHQgKSB7XG4gICAgbGV0IHQ7XG4gICAgaWYgKCBjb250ZXh0LnBhcmFtcy5yYXRlID09PSAwLjAgKSB7XG4gICAgICB0ID0gY29udGV4dC50O1xuICAgIH0gZWxzZSBpZiAoIGNvbnRleHQucGFyYW1zLnJlbGF0aXZlICkge1xuICAgICAgdCA9IGNvbnRleHQudDAgKyBNYXRoLmZsb29yKCAoIGNvbnRleHQudCAtIGNvbnRleHQudDAgKSAqIGNvbnRleHQucGFyYW1zLnJhdGUgKSAvIGNvbnRleHQucGFyYW1zLnJhdGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHQgPSBNYXRoLmZsb29yKCAoIGNvbnRleHQudCApICogY29udGV4dC5wYXJhbXMucmF0ZSApIC8gY29udGV4dC5wYXJhbXMucmF0ZTtcbiAgICB9XG5cbiAgICBsZXQgdiA9IGNvbnRleHQuZ2V0VmFsdWUoIHQgKTtcbiAgICBpZiAoIGNvbnRleHQucGFyYW1zLnJlc28gIT09IDAuMCApIHtcbiAgICAgIHYgPSBNYXRoLmZsb29yKCB2ICogY29udGV4dC5wYXJhbXMucmVzbyArICggY29udGV4dC5wYXJhbXMucm91bmQgPyAwLjUgOiAwLjAgKSApIC8gY29udGV4dC5wYXJhbXMucmVzbztcbiAgICB9XG4gICAgcmV0dXJuIHY7XG4gIH1cbn0gXTsiLCJsZXQgWG9yc2hpZnQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCBfc2VlZCApIHtcbiAgICB0aGlzLnNldCggX3NlZWQgKTtcbiAgfVxuXG4gIGdlbiggX3NlZWQgKSB7XG4gICAgaWYgKCBfc2VlZCApIHsgdGhpcy5zZXQoIF9zZWVkICk7IH1cbiAgICB0aGlzLnNlZWQgPSB0aGlzLnNlZWQgXiAoIHRoaXMuc2VlZCA8PCAxMyApO1xuICAgIHRoaXMuc2VlZCA9IHRoaXMuc2VlZCBeICggdGhpcy5zZWVkID4+PiAxNyApO1xuICAgIHRoaXMuc2VlZCA9IHRoaXMuc2VlZCBeICggdGhpcy5zZWVkIDw8IDUgKTtcbiAgICByZXR1cm4gdGhpcy5zZWVkIC8gTWF0aC5wb3coIDIsIDMyICkgKyAwLjU7XG4gIH1cblxuICBzZXQoIF9zZWVkICkge1xuICAgIHRoaXMuc2VlZCA9IF9zZWVkIHx8IHRoaXMuc2VlZCB8fCAxO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFhvcnNoaWZ0O1xuIiwiaW1wb3J0IFhvcnNoaWZ0IGZyb20gJy4vbW9kdWxlcy94b3JzaGlmdCc7XG5cbmNvbnN0IHhvcnNoaWZ0ID0gbmV3IFhvcnNoaWZ0KCk7XG5cbmNvbnN0IHNtb290aHN0ZXAgPSAoIF9hLCBfYiwgX2sgKSA9PiB7XG4gIGNvbnN0IHNtb290aCA9IF9rICogX2sgKiAoIDMuMCAtIDIuMCAqIF9rICk7XG4gIHJldHVybiBfYSArICggX2IgLSBfYSApICogc21vb3RoO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgWyAnbm9pc2UnLCB7XG4gIG5hbWU6ICdGcmFjdGFsIE5vaXNlJyxcbiAgZGVzY3JpcHRpb246ICd3aWdnbGUoKScsXG4gIHBhcmFtczoge1xuICAgIHJlY3Vyc2lvbjogeyBuYW1lOiAnUmVjdXJzaW9uJywgdHlwZTogJ2ludCcsIGRlZmF1bHQ6IDQsIG1pbjogMSwgbWF4OiA5OSB9LFxuICAgIGZyZXE6IHsgbmFtZTogJ0ZyZXF1ZW5jeScsIHR5cGU6ICdmbG9hdCcsIGRlZmF1bHQ6IDEuMCwgbWluOiAwLjAgfSxcbiAgICByZXNvOiB7IG5hbWU6ICdSZXNvbHV0aW9uJywgdHlwZTogJ2Zsb2F0JywgZGVmYXVsdDogOC4wLCBtaW46IDEuMCB9LFxuICAgIHNlZWQ6IHsgbmFtZTogJ1NlZWQnLCB0eXBlOiAnaW50JywgZGVmYXVsdDogMSwgbWluOiAwIH0sXG4gICAgYW1wOiB7IG5hbWU6ICdBbXAnLCB0eXBlOiAnZmxvYXQnLCBkZWZhdWx0OiAwLjIgfVxuICB9LFxuICBmdW5jKCBjb250ZXh0ICkge1xuICAgIGlmICggY29udGV4dC5pbml0ICkge1xuICAgICAgeG9yc2hpZnQuZ2VuKCBjb250ZXh0LnBhcmFtcy5zZWVkICk7XG5cbiAgICAgIGNvbnRleHQudGFibGUgPSBuZXcgRmxvYXQzMkFycmF5KCBNYXRoLmZsb29yKCBjb250ZXh0LnBhcmFtcy5yZXNvICkgKyAyICk7XG4gICAgICBmb3IgKCBsZXQgaSA9IDE7IGkgPCBjb250ZXh0LnBhcmFtcy5yZXNvOyBpICsrICkge1xuICAgICAgICBjb250ZXh0LnRhYmxlWyBpIF0gPSB4b3JzaGlmdC5nZW4oKSAqIDIuMCAtIDEuMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgdiA9IGNvbnRleHQudjtcbiAgICBjb25zdCBwID0gY29udGV4dC5wcm9ncmVzcztcblxuICAgIGZvciAoIGxldCBpID0gMDsgaSA8IGNvbnRleHQucGFyYW1zLnJlY3Vyc2lvbjsgaSArKyApIHtcbiAgICAgIGNvbnN0IGluZGV4ID0gKCBwICogY29udGV4dC5wYXJhbXMuZnJlcSAqIGNvbnRleHQucGFyYW1zLnJlc28gKiBNYXRoLnBvdyggMi4wLCBpICkgKSAlIGNvbnRleHQucGFyYW1zLnJlc287XG4gICAgICBjb25zdCBpbmRleGkgPSBNYXRoLmZsb29yKCBpbmRleCApO1xuICAgICAgY29uc3QgaW5kZXhmID0gaW5kZXggLSBpbmRleGk7XG4gICAgICBjb25zdCBmYWN0b3IgPSBNYXRoLnBvdyggMC41LCBpICsgMS4wICk7XG5cbiAgICAgIHYgKz0gY29udGV4dC5wYXJhbXMuYW1wICogZmFjdG9yICogc21vb3Roc3RlcChcbiAgICAgICAgY29udGV4dC50YWJsZVsgaW5kZXhpIF0sXG4gICAgICAgIGNvbnRleHQudGFibGVbIGluZGV4aSArIDEgXSxcbiAgICAgICAgaW5kZXhmXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gdjtcbiAgfVxufSBdOyIsImV4cG9ydCBkZWZhdWx0IFsgJ3BvdycsIHtcbiAgbmFtZTogJ1Bvd2VyJyxcbiAgZGVzY3JpcHRpb246ICdZb3UgZ290IGJvb3N0IHBvd2VyIScsXG4gIHBhcmFtczoge1xuICAgIHBvdzogeyBuYW1lOiAnUG93ZXInLCB0eXBlOiAnZmxvYXQnLCBkZWZhdWx0OiAyLjAgfSxcbiAgICBiaWFzOiB7IG5hbWU6ICdCaWFzJywgdHlwZTogJ2Zsb2F0JywgZGVmYXVsdDogMC4wIH0sXG4gICAgcG9zaXRpdmU6IHsgbmFtZTogJ0ZvcmNlIFBvc2l0aXZlJywgdHlwZTogJ2Jvb2xlYW4nLCBkZWZhdWx0OiBmYWxzZSB9XG4gIH0sXG4gIGZ1bmMoIGNvbnRleHQgKSB7XG4gICAgY29uc3QgdiA9IGNvbnRleHQudiAtIGNvbnRleHQucGFyYW1zLmJpYXM7XG4gICAgY29uc3Qgc2lnbiA9IGNvbnRleHQucGFyYW1zLnBvc2l0aXZlID8gMS4wIDogTWF0aC5zaWduKCB2ICk7XG4gICAgcmV0dXJuIE1hdGgucG93KFxuICAgICAgTWF0aC5hYnMoIHYgKSxcbiAgICAgIGNvbnRleHQucGFyYW1zLnBvd1xuICAgICkgKiBzaWduICsgY29udGV4dC5wYXJhbXMuYmlhcztcbiAgfVxufSBdOyIsImNvbnN0IFRBVSA9IE1hdGguUEkgKiAyLjA7XG5cbmV4cG9ydCBkZWZhdWx0IFsgJ3NpbmUnLCB7XG4gIG5hbWU6ICdTaW5ld2F2ZScsXG4gIGRlc2NyaXB0aW9uOiAnT3ZlcmxheSBhIHNpbmV3YXZlIHRvIHRoZSBjdXJ2ZS4nLFxuICBwYXJhbXM6IHtcbiAgICBhbXA6IHsgbmFtZTogJ0FtcCcsIHR5cGU6ICdmbG9hdCcsIGRlZmF1bHQ6IDAuMSB9LFxuICAgIGZyZXE6IHsgbmFtZTogJ0ZyZXF1ZW5jeScsIHR5cGU6ICdmbG9hdCcsIGRlZmF1bHQ6IDUuMCB9LFxuICAgIHBoYXNlOiB7IG5hbWU6ICdQaGFzZScsIHR5cGU6ICdmbG9hdCcsIGRlZmF1bHQ6IDAuMCwgbWluOiAwLjAsIG1heDogMS4wIH1cbiAgfSxcbiAgZnVuYyggY29udGV4dCApIHtcbiAgICBjb25zdCB2ID0gY29udGV4dC52O1xuICAgIGNvbnN0IHAgPSBjb250ZXh0LnByb2dyZXNzICogY29udGV4dC5wYXJhbXMuZnJlcSArIGNvbnRleHQucGFyYW1zLnBoYXNlO1xuICAgIHJldHVybiB2ICsgY29udGV4dC5wYXJhbXMuYW1wICogTWF0aC5zaW4oIHAgKiBUQVUgKTtcbiAgfVxufSBdOyIsImV4cG9ydCBkZWZhdWx0ICgpID0+IHtcbiAgbGV0IHJldCA9ICcnO1xuICBmb3IgKCBsZXQgaSA9IDA7IGkgPCAxNjsgaSArKyApIHtcbiAgICByZXQgKz0gTWF0aC5mbG9vciggMTYuMCAqIE1hdGgucmFuZG9tKCkgKS50b1N0cmluZyggMTYgKTtcbiAgfVxuICByZXR1cm4gcmV0O1xufTsiLCJjb25zdCBoYXNPdmVyd3JhcCA9ICggdDEsIGwxLCB0MiwgbDIgKSA9PiB7XG4gIGlmICggbDIgPCBsMSApIHsgcmV0dXJuIGhhc092ZXJ3cmFwKCB0MiwgbDIsIHQxLCBsMSApOyB9XG4gIHJldHVybiAoXG4gICAgdDIgPCB0MSAmJiB0MSA8IHQyICsgbDIgfHxcbiAgICB0MiA8IHQxICsgbDEgJiYgdDEgKyBsMSA8IHQyICsgbDJcbiAgKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGhhc092ZXJ3cmFwOyIsIm1vZHVsZS5leHBvcnRzID0gXCJkYXRhOmltYWdlL3N2Zyt4bWwsJTNDJTNGeG1sIHZlcnNpb249JzEuMCcgZW5jb2Rpbmc9J1VURi04JyBzdGFuZGFsb25lPSdubyclM0YlM0UgJTNDIURPQ1RZUEUgc3ZnIFBVQkxJQyAnLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4nICdodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQnJTNFICUzQ3N2ZyB3aWR0aD0nMTAwJTI1JyBoZWlnaHQ9JzEwMCUyNScgdmlld0JveD0nMCAwIDEyOCAxMjgnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgeG1sOnNwYWNlPSdwcmVzZXJ2ZScgeG1sbnM6c2VyaWY9J2h0dHA6Ly93d3cuc2VyaWYuY29tLycgc3R5bGU9J2ZpbGwtcnVsZTpldmVub2RkJTNCY2xpcC1ydWxlOmV2ZW5vZGQlM0JzdHJva2UtbGluZWpvaW46cm91bmQlM0JzdHJva2UtbWl0ZXJsaW1pdDoxLjQxNDIxJTNCJyUzRSAgICAgJTNDcGF0aCBkPSdNNjQlMkM1NS41MzdMMTA1LjAyMyUyQzE0LjUxM0wxMTMuNDg3JTJDMjIuOTc3TDcyLjQ2MyUyQzY0TDExMy40ODclMkMxMDUuMDIzTDEwNS4wMjMlMkMxMTMuNDg3TDY0JTJDNzIuNDYzTDIyLjk3NyUyQzExMy40ODdMMTQuNTEzJTJDMTA1LjAyM0w1NS41MzclMkM2NEwxNC41MTMlMkMyMi45NzdMMjIuOTc3JTJDMTQuNTEzTDY0JTJDNTUuNTM3Wicgc3R5bGU9J2ZpbGw6cmdiKDIwMSUyQzIyNiUyQzI1NSklM0InLyUzRSAlM0Mvc3ZnJTNFXCIiLCJleHBvcnQgZGVmYXVsdCAoIGRhdGEgKSA9PiBKU09OLnBhcnNlKCBKU09OLnN0cmluZ2lmeSggZGF0YSApICk7IiwiaW1wb3J0IGFzcyBmcm9tICcuL2Fzcyc7XG5pbXBvcnQgY29tcGF0IGZyb20gJy4vY29tcGF0JztcbmltcG9ydCBqc29uQ29weSBmcm9tICcuL2pzb24tY29weSc7XG5cbmltcG9ydCBQYXJhbSBmcm9tICcuL3BhcmFtLWd1aSc7XG5cbmltcG9ydCBBdXRvbWF0b24gZnJvbSAnLi9tYWluJztcbmltcG9ydCBmeERlZmluaXRpb25zIGZyb20gJy4vZngtZGVmaW5pdGlvbnMnO1xuXG5pbXBvcnQgVnVlIGZyb20gJ3Z1ZSc7XG5pbXBvcnQgR1VJIGZyb20gJy4vdnVlL21haW4udnVlJztcblxuLyoqXG4gKiBJVCdTIEFVVE9NQVRPTiFcbiAqIEl0J3MgYGF1dG9tYXRvbi5qc2AgYW5kIGBhdXRvbWF0b24ubWluLmpzYCB2ZXJzaW9uLlxuICogU2luY2UgR1VJIHN0dWZmIGlzIHByZXR0eSBiaWcgZm9yIGludHJvIGhlaFxuICogQGV4dGVuZHMgQXV0b21hdG9uXG4gKiBAcGFyYW0ge09iamVjdH0gW19wcm9wc11cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW19wcm9wcy5sb29wXSBXaGV0aGVyIGxldCB0aGUgdGltZSBsb29wIG9yIG5vdFxuICogQHBhcmFtIHtudW1iZXJ9IFtfcHJvcHMuZnBzXSBJZiB0aGlzIGlzIHNldCwgdGhlIGNsb2NrIHdpbGwgYmVjb21lIGZyYW1lIG1vZGVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW19wcm9wcy5yZWFsdGltZV0gSWYgdGhpcyBpcyB0cnVlLCB0aGUgY2xvY2sgd2lsbCBiZWNvbWUgcmVhbHRpbWUgbW9kZVxuICogQHBhcmFtIHtET019IFtfcHJvcHMuZ3VpXSBET00gZWxlbWVudCB3aGVyZSB5b3Ugd2FudCB0byBhdHRhY2ggdGhlIEF1dG9tYXRvbiBHVUlcbiAqIEBwYXJhbSB7c3RyaW5nfE9iamVjdH0gW19wcm9wcy5kYXRhXSBEYXRhIG9mIHRoZSBhdXRvbWF0b24uIERvbid0IHdvcnJ5LCBJIGNhbiBnZW5lcmF0ZSBhbiBpbml0aWFsIGRhdGEgZm9yIHlvdSFcbiAqL1xuY29uc3QgQXV0b21hdG9uV2l0aEdVSSA9IGNsYXNzIGV4dGVuZHMgQXV0b21hdG9uIHtcbiAgY29uc3RydWN0b3IoIF9wcm9wcyApIHtcbiAgICBjb25zdCBwcm9wcyA9IE9iamVjdC5hc3NpZ24oIHt9LCBfcHJvcHMgKTtcblxuICAgIGFzcyggIV9wcm9wcy5vbnNlZWssICdUaGUgaGFuZGxlciBcIm9uc2Vla1wiIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQuIFVzZSBBdXRvbWF0b24ub24oIFwic2Vla1wiLCAuLi4gKSBpbnN0ZWFkLicgKTtcbiAgICBhc3MoICFfcHJvcHMub25wbGF5LCAnVGhlIGhhbmRsZXIgXCJvbnBsYXlcIiBpcyBubyBsb25nZXIgc3VwcG9ydGVkLiBVc2UgQXV0b21hdG9uLm9uKCBcInBsYXlcIiwgLi4uICkgaW5zdGVhZC4nICk7XG4gICAgYXNzKCAhX3Byb3BzLm9ucGF1c2UsICdUaGUgaGFuZGxlciBcIm9ucGF1c2VcIiBpcyBubyBsb25nZXIgc3VwcG9ydGVkLiBVc2UgQXV0b21hdG9uLm9uKCBcInBhdXNlXCIsIC4uLiApIGluc3RlYWQuJyApO1xuXG4gICAgc3VwZXIoIHByb3BzICk7XG5cbiAgICAvKipcbiAgICAgKiBIaXN0b3J5IHN0YWNrLlxuICAgICAqIFdpbGwgYmUgbWFuYWdlZCBmcm9tIHtAbGluayBBdXRvbWF0b25XaXRoR1VJI3B1c2hIaXN0b3J5fHB1c2hIaXN0b3J5KCl9LCBuYXZpZ2F0ZWQgZnJvbSB7QGxpbmsgQXV0b21hdG9uV2l0aEdVSSN1bmRvfHVuZG8oKX0gYW5kIHtAbGluayBBdXRvbWF0b25XaXRoR1VJI3JlZG98cmVkbygpfS5cbiAgICAgKiBAdHlwZSB7T2JqZWN0W119XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHRoaXMuX19oaXN0b3J5ID0gW107XG5cbiAgICAvKipcbiAgICAgKiBDdXJyZW50IHBvc2l0aW9uIG9mIGhpc3Rvcnkgc3RhY2suXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgdGhpcy5fX2hpc3RvcnlJbmRleCA9IDA7XG5cbiAgICBmeERlZmluaXRpb25zLm1hcCggKCBmeERlZiApID0+IHtcbiAgICAgIHRoaXMuYWRkRnhEZWZpbml0aW9uKCAuLi5meERlZiApO1xuICAgIH0gKTtcblxuICAgIGlmICggX3Byb3BzLmd1aSApIHsgdGhpcy5fX3ByZXBhcmVHVUkoIF9wcm9wcy5ndWkgKTsgfVxuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoICdiZWZvcmV1bmxvYWQnLCAoIGV2ZW50ICkgPT4ge1xuICAgICAgaWYgKCB0aGlzLl9faGlzdG9yeUluZGV4ICE9PSAwICkge1xuICAgICAgICB2YXIgY29uZmlybWF0aW9uTWVzc2FnZSA9ICdBdXRvbWF0b246IERpZCB5b3Ugc2F2ZWQgeW91ciBwcm9ncmVzcz8nO1xuXG4gICAgICAgIGV2ZW50LnJldHVyblZhbHVlID0gY29uZmlybWF0aW9uTWVzc2FnZTtcbiAgICAgICAgcmV0dXJuIGNvbmZpcm1hdGlvbk1lc3NhZ2U7XG4gICAgICB9XG4gICAgfSApO1xuICB9XG5cbiAgLyoqXG4gICAqIFByZXBhcmUgR1VJLlxuICAgKiBAcGFyYW0ge0RPTX0gX3RhcmdldCBET00gZWxlbWVudCB3aGVyZSB5b3Ugd2FudCB0byBhdHRhY2ggdGhlIEF1dG9tYXRvbiBHVUlcbiAgICogQHJldHVybnMge3ZvaWR9IHZvaWRcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgX19wcmVwYXJlR1VJKCBfdGFyZ2V0ICkge1xuICAgIGNvbnN0IGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2RpdicgKTtcbiAgICBfdGFyZ2V0LmFwcGVuZENoaWxkKCBlbCApO1xuXG4gICAgLyoqXG4gICAgICogVnVlIGluc3RhbmNlIHRoYXQgbWFuYWdlcyBhdXRvbWF0b24gZ3VpLlxuICAgICAqIEB0eXBlIHtWdWV9XG4gICAgICovXG4gICAgdGhpcy5fX3Z1ZSA9IG5ldyBWdWUoIHtcbiAgICAgIGVsOiBlbCxcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgYXV0b21hdG9uOiB0aGlzXG4gICAgICB9LFxuICAgICAgcmVuZGVyOiBmdW5jdGlvbiggY3JlYXRlRWxlbWVudCApIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgR1VJLFxuICAgICAgICAgIHsgcHJvcHM6IHsgYXV0b21hdG9uOiB0aGlzLmF1dG9tYXRvbiB9IH1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9ICk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgZGVmYXVsdCBmeCBwYXJhbXMgb2JqZWN0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gX2lkIElkIG9mIHRoZSBmeFxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBEZWZhdWx0IGZ4IHBhcmFtcyBvYmplY3RcbiAgICovXG4gIGdlbmVyYXRlRGVmYXVsdEZ4UGFyYW1zKCBfaWQgKSB7XG4gICAgY29uc3QgZnhEZWYgPSB0aGlzLl9fcGFyYW1GeERlZnNbIF9pZCBdO1xuICAgIGlmICggIWZ4RGVmICkgeyB0aHJvdyBuZXcgRXJyb3IoIGBGeCBkZWZpbml0aW9uIGNhbGxlZCAke19pZH0gaXMgbm90IGRlZmluZWRgICk7IH1cblxuICAgIGNvbnN0IHJldCA9IHt9O1xuICAgIGZvciAoIGxldCBrZXkgaW4gZnhEZWYucGFyYW1zICkge1xuICAgICAgcmV0WyBrZXkgXSA9IGZ4RGVmLnBhcmFtc1sga2V5IF0uZGVmYXVsdDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgLyoqXG4gICAqIFRvZ2dsZSBwbGF5IC8gcGF1c2UuXG4gICAqIEByZXR1cm5zIHt2b2lkfSB2b2lkXG4gICAqL1xuICB0b2dnbGVQbGF5KCkge1xuICAgIGlmICggdGhpcy5pc1BsYXlpbmcgKSB7IHRoaXMucGF1c2UoKTsgfVxuICAgIGVsc2UgeyB0aGlzLnBsYXkoKTsgfVxuICB9XG5cbiAgLyoqXG4gICAqIFB1dCBzb21lIG9wZXJhdGlvbiBpbnRvIHRoZSBoaXN0b3J5IHN0YWNrLlxuICAgKiBTaW5jZSBpdCBzaG91bGQgYWNjZXNzaWJsZSBmcm9tIEdVSSB0aGlzIGZ1bmN0aW9uIGlzIHB1YmxpYywgYmFzaWNhbGx5IGAtLSBET04nVCBUT1VDSCBJVCBLSURETyAtLWBcbiAgICogQHBhcmFtIHtzdHJpbmd9IF9kZXNjIERlc2NyaXB0aW9uIG9mIHRoZSBvcGVyYXRpb25cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gX2RvIE9wZXJhdGlvblxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBfdW5kbyBPcGVyYXRpb24gdGhhdCB1bmRvZXMgdGhlIGBfZG9gXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW19leGVjdXRlPWZhbHNlXSBfZG8gd2lsbCBiZSBleGVjdXRlZCBpbnN0YW50bHkgaWYgdHJ1ZVxuICAgKiBAcmV0dXJucyB7YW55fSBhbnkgaWYgYF9leGVjdXRlYCBpcyB0cnVlLCB2b2lkIG90aGVyd2lzZVxuICAgKi9cbiAgcHVzaEhpc3RvcnkoIF9kZXNjLCBfZG8sIF91bmRvLCBfZXhlY3V0ZSApIHtcbiAgICB0aGlzLl9faGlzdG9yeS5zcGxpY2UoIHRoaXMuX19oaXN0b3J5SW5kZXggKTtcbiAgICB0aGlzLl9faGlzdG9yeS5wdXNoKCB7IGRlc2M6IF9kZXNjLCBkbzogX2RvLCB1bmRvOiBfdW5kbyB9ICk7XG4gICAgdGhpcy5fX2hpc3RvcnlJbmRleCArKztcblxuICAgIGlmICggX2V4ZWN1dGUgfHwgZmFsc2UgKSB7XG4gICAgICByZXR1cm4gX2RvKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFVuZG8gdGhlIG9wZXJhdGlvbiBiYXNlZCBvbiBoaXN0b3J5IHN0YWNrLlxuICAgKiBDYW4gYmUgcGVyZm9ybWVkIHZpYSBHVUkuXG4gICAqIEByZXR1cm5zIHthbnl9IFJlc3VsdCBvZiBfdW5kb1xuICAgKi9cbiAgdW5kbygpIHtcbiAgICBpZiAoIHRoaXMuX19oaXN0b3J5SW5kZXggPD0gMCApIHsgcmV0dXJuOyB9XG4gICAgdGhpcy5fX2hpc3RvcnlJbmRleCAtLTtcbiAgICByZXR1cm4gdGhpcy5fX2hpc3RvcnlbIHRoaXMuX19oaXN0b3J5SW5kZXggXS51bmRvKCk7XG4gIH1cblxuICAvKipcbiAgICogUmVkbyB0aGUgb3BlcmF0aW9uIGJhc2VkIG9uIGhpc3Rvcnkgc3RhY2suXG4gICAqIENhbiBiZSBwZXJmb3JtZWQgdmlhIEdVSS5cbiAgICogQHJldHVybnMge2FueX0gUmVzdWx0IG9mIF9kb1xuICAgKi9cbiAgcmVkbygpIHtcbiAgICBpZiAoIHRoaXMuX19oaXN0b3J5Lmxlbmd0aCA8PSB0aGlzLl9faGlzdG9yeUluZGV4ICkgeyByZXR1cm47IH1cbiAgICB0aGlzLl9faGlzdG9yeUluZGV4ICsrO1xuICAgIHJldHVybiB0aGlzLl9faGlzdG9yeVsgdGhpcy5fX2hpc3RvcnlJbmRleCAtIDEgXS5kbygpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBkZXNjcmlwdGlvbiBvZiBsYXRlc3Qgb3BlcmF0aW9uLlxuICAgKiBJZiB0aGVyZSBhcmUgbm8gb3BlcmF0aW9uIGJlZm9yZSB0aGUgY3VycmVudCBzdGF0ZSwgaXQgd2lsbCByZXR1cm4gZW1wdHkgc3RyaW5nIGluc3RlYWQuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IERlc2NyaXB0aW9uIG9mIG9wZXJhdGlvblxuICAgKi9cbiAgZ2V0VW5kb0Rlc2MoKSB7XG4gICAgcmV0dXJuIHRoaXMuX19oaXN0b3J5WyB0aGlzLl9faGlzdG9yeUluZGV4IC0gMSBdID8gdGhpcy5fX2hpc3RvcnlbIHRoaXMuX19oaXN0b3J5SW5kZXggLSAxIF0uZGVzYyA6ICcnO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBkZXNjcmlwdGlvbiBvZiByZWNlbnRseSB1bmRvLWVkIG9wZXJhdGlvbi5cbiAgICogSWYgdGhlcmUgYXJlIG5vIG9wZXJhdGlvbiBhZnRlciB0aGUgY3VycmVudCBzdGF0ZSwgaXQgd2lsbCByZXR1cm4gZW1wdHkgc3RyaW5nIGluc3RlYWQuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IERlc2NyaXB0aW9uIG9mIG9wZXJhdGlvblxuICAgKi9cbiAgZ2V0UmVkb0Rlc2MoKSB7XG4gICAgcmV0dXJuIHRoaXMuX19oaXN0b3J5WyB0aGlzLl9faGlzdG9yeUluZGV4IF0gPyB0aGlzLl9faGlzdG9yeVsgdGhpcy5fX2hpc3RvcnlJbmRleCBdLmRlc2MgOiAnJztcbiAgfVxuXG4gIC8qKlxuICAgKiBEcm9wIGFsbCB0aGUgaGlzdG9yeS4gWUFCQUkuXG4gICAqL1xuICBkcm9wSGlzdG9yeSgpIHtcbiAgICB0aGlzLl9faGlzdG9yeS5zcGxpY2UoIDAgKTtcbiAgICB0aGlzLl9faGlzdG9yeUluZGV4ID0gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgbmV3IGxlbmd0aCBmb3IgdGhpcyBhdXRvbWF0b24gaW5zdGFuY2UuXG4gICAqICoqU29tZSBub2RlcyAvIGZ4cyBtaWdodCBiZSBhdXRvbWF0aWNhbGx5IHJlbW92ZWQgLyBjaGFuZ2VkLioqXG4gICAqIENhbiBiZSBwZXJmb3JtZWQgdmlhIEdVSS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IF9sZW5ndGggTmV3IGxlbmd0aCBmb3IgdGhlIGF1dG9tYXRvblxuICAgKiBAcmV0dXJucyB7dm9pZH0gdm9pZFxuICAgKi9cbiAgc2V0TGVuZ3RoKCBfbGVuZ3RoICkge1xuICAgIC8vIGlmIGxlbmd0aCBpcyBpbnZhbGlkIHRoZW4gdGhyb3cgZXJyb3JcbiAgICBpZiAoIGlzTmFOKCBfbGVuZ3RoICkgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoICdBdXRvbWF0b24uc2V0TGVuZ3RoOiBfbGVuZ3RoIGlzIGludmFsaWQnICk7XG4gICAgfVxuXG4gICAgLy8gaWYgbGVuZ3RoIGlzIG5vdCBjaGFuZ2VkIHRoZW4gZG8gZmFzdC1yZXR1cm5cbiAgICBpZiAoIF9sZW5ndGggPT09IHRoaXMubGVuZ3RoICkgeyByZXR1cm47IH1cblxuICAgIC8vIGNoYW5nZUxlbmd0aCBpcyBhIGdvb2QgbWV0aG9kXG4gICAgZm9yICggbGV0IHBhcmFtTmFtZSBpbiB0aGlzLl9fcGFyYW1zICkge1xuICAgICAgY29uc3QgcGFyYW0gPSB0aGlzLl9fcGFyYW1zWyBwYXJhbU5hbWUgXTtcbiAgICAgIHBhcmFtLmNoYW5nZUxlbmd0aCggX2xlbmd0aCApO1xuICAgIH1cblxuICAgIC8vIGZpbmFsbHkgc2V0IHRoZSBsZW5ndGhcbiAgICB0aGlzLl9fbGVuZ3RoID0gX2xlbmd0aDtcblxuICAgIC8vIEl0J3MgaXJyZXZlcnNpYmxlIG9wZXJhdGlvbiwgc29ycnkuXG4gICAgdGhpcy5kcm9wSGlzdG9yeSgpO1xuXG4gICAgLy8gUG9rZSB2dWVcbiAgICB0aGlzLl9fdnVlLiRlbWl0KCAnY2hhbmdlZExlbmd0aCcgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgbmV3IHJlc29sdXRpb24gZm9yIHRoaXMgYXV0b21hdG9uIGluc3RhbmNlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gX3Jlc29sdWx0aW9uIE5ldyByZXNvbHV0aW9uIGZvciB0aGUgYXV0b21hdG9uIGx1bFxuICAgKiBAcmV0dXJucyB7dm9pZH0gdm9pZFxuICAgKi9cbiAgc2V0UmVzb2x1dGlvbiggX3Jlc29sdWx0aW9uICkgeyAvLyBsdWxcbiAgICB0aGlzLl9fcmVzb2x1dGlvbiA9IF9yZXNvbHVsdGlvbjsgLy8gbHVsXG4gICAgdGhpcy5wcmVjYWxjQWxsKCk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IHBhcmFtLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gX25hbWUgTmFtZSBvZiBwYXJhbVxuICAgKiBAcmV0dXJucyB7UGFyYW19IENyZWF0ZWQgcGFyYW1cbiAgICovXG4gIGNyZWF0ZVBhcmFtKCBfbmFtZSwgX2RhdGEgKSB7XG4gICAgY29uc3QgcGFyYW0gPSBuZXcgUGFyYW0oIHtcbiAgICAgIGF1dG9tYXRvbjogdGhpcyxcbiAgICAgIGRhdGE6IF9kYXRhXG4gICAgfSApO1xuICAgIFZ1ZS5zZXQoIHRoaXMuX19wYXJhbXMsIF9uYW1lLCBwYXJhbSApO1xuICAgIHJldHVybiBwYXJhbTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYSBwYXJhbS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IF9uYW1lIE5hbWUgb2YgcGFyYW1cbiAgICogQHJldHVybnMge3ZvaWR9IHZvaWRcbiAgICovXG4gIHJlbW92ZVBhcmFtKCBfbmFtZSApIHtcbiAgICBWdWUuZGVsZXRlKCB0aGlzLl9fcGFyYW1zLCBfbmFtZSApO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhIHBhcmFtLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gX25hbWUgTmFtZSBvZiB0aGUgcGFyYW1cbiAgICogQHJldHVybnMge1BhcmFtfSBQYXJhbSBvYmplY3RcbiAgICovXG4gIGdldFBhcmFtKCBfbmFtZSApIHtcbiAgICByZXR1cm4gdGhpcy5fX3BhcmFtc1sgX25hbWUgXSB8fCBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBsaXN0IG9mIG5hbWUgb2YgcGFyYW1zLiBTb3J0ZWQuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gTGlzdCBvZiBuYW1lIG9mIHBhcmFtc1xuICAgKi9cbiAgZ2V0UGFyYW1OYW1lcygpIHtcbiAgICBsZXQgYXJyID0gW107XG4gICAgZm9yICggY29uc3QgbmFtZSBpbiB0aGlzLl9fcGFyYW1zICkgeyBhcnIucHVzaCggbmFtZSApOyB9XG4gICAgYXJyID0gYXJyLnNvcnQoKTtcbiAgICByZXR1cm4gYXJyO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBsaXN0IG9mIGlkIG9mIGZ4IGRlZmluaXRpb25zLiBTb3J0ZWQuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gTGlzdCBvZiBpZCBvZiBmeCBkZWZpbml0aW9uc1xuICAgKi9cbiAgZ2V0RnhEZWZpbml0aW9uSWRzKCkge1xuICAgIGxldCBhcnIgPSBbXTtcbiAgICBmb3IgKCBjb25zdCBpZCBpbiB0aGlzLl9fcGFyYW1GeERlZnMgKSB7IGFyci5wdXNoKCBpZCApOyB9XG4gICAgYXJyID0gYXJyLnNvcnQoKTtcbiAgICByZXR1cm4gYXJyO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBkaXNwbGF5IG5hbWUgb2YgYSBmeCBkZWZpbml0aW9uLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gX2lkIElkIG9mIHRoZSBmeCBkZWZpbml0aW9uIHlvdSB3YW50IHRvIGdyYWJcbiAgICogQHJldHVybnMge3N0cmluZ30gTmFtZSBvZiB0aGUgZnggZGVmaW5pdGlvblxuICAgKi9cbiAgZ2V0RnhEZWZpbml0aW9uTmFtZSggX2lkICkge1xuICAgIGlmICggdGhpcy5fX3BhcmFtRnhEZWZzWyBfaWQgXSApIHtcbiAgICAgIHJldHVybiB0aGlzLl9fcGFyYW1GeERlZnNbIF9pZCBdLm5hbWUgfHwgX2lkO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gZGVzY3JpcHRpb24gb2YgYSBmeCBkZWZpbml0aW9uLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gX2lkIElkIG9mIHRoZSBmeCBkZWZpbml0aW9uIHlvdSB3YW50IHRvIGdyYWJcbiAgICogQHJldHVybnMge3N0cmluZ30gRGVzY3JpcHRpb24gb2YgdGhlIGZ4IGRlZmluaXRpb25cbiAgICovXG4gIGdldEZ4RGVmaW5pdGlvbkRlc2NyaXB0aW9uKCBfaWQgKSB7XG4gICAgaWYgKCB0aGlzLl9fcGFyYW1GeERlZnNbIF9pZCBdICkge1xuICAgICAgcmV0dXJuIHRoaXMuX19wYXJhbUZ4RGVmc1sgX2lkIF0uZGVzY3JpcHRpb24gfHwgJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBwYXJhbXMgc2VjdGlvbiBvZiBhIGZ4IGRlZmluaXRpb24uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBfaWQgSWQgb2YgdGhlIGZ4IGRlZmluaXRpb24geW91IHdhbnQgdG8gZ3JhYlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBQYXJhbXMgc2VjdGlvblxuICAgKi9cbiAgZ2V0RnhEZWZpbml0aW9uUGFyYW1zKCBfaWQgKSB7XG4gICAgaWYgKCB0aGlzLl9fcGFyYW1GeERlZnNbIF9pZCBdICkge1xuICAgICAgcmV0dXJuIGpzb25Db3B5KCB0aGlzLl9fcGFyYW1GeERlZnNbIF9pZCBdLnBhcmFtcyB8fCB7fSApO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gY291bnQgb2YgcGFyYW1zLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBDb3VudCBvZiBwYXJhbXNcbiAgICovXG4gIGNvdW50UGFyYW1zKCkge1xuICAgIGxldCBzdW0gPSAwO1xuICAgIGZvciAoIGNvbnN0IG5hbWUgaW4gdGhpcy5fX3BhcmFtcyApIHsgc3VtICsrOyB9XG4gICAgcmV0dXJuIHN1bTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBc3NpZ25lZCB0byBgQXV0b21hdG9uLmF1dG9gIGF0IGNvbnN0cnVjdG9yLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gX25hbWUgbmFtZSBvZiB0aGUgcGFyYW1cbiAgICogQHJldHVybnMge251bWJlcn0gQ3VycmVudCB2YWx1ZSBvZiB0aGUgcGFyYW1cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgX19hdXRvKCBfbmFtZSApIHtcbiAgICBsZXQgcGFyYW0gPSB0aGlzLl9fcGFyYW1zWyBfbmFtZSBdO1xuICAgIGlmICggIXBhcmFtICkgeyBwYXJhbSA9IHRoaXMuY3JlYXRlUGFyYW0oIF9uYW1lICk7IH1cbiAgICBwYXJhbS5tYXJrQXNVc2VkKCk7XG4gICAgcmV0dXJuIHBhcmFtLmdldFZhbHVlKCk7XG4gIH1cblxuICAvKipcbiAgICogTG9hZCBhdXRvbWF0b24gc3RhdGUgZGF0YS5cbiAgICogQHBhcmFtIHtPYmplY3R9IF9kYXRhIE9iamVjdCBjb250YWlucyBhdXRvbWF0b24gZGF0YS5cbiAgICogQHJldHVybnMge3ZvaWR9IHZvaWRcbiAgICovXG4gIGxvYWQoIF9kYXRhICkge1xuICAgIGxldCBkYXRhID0gY29tcGF0KCBfZGF0YSApO1xuICAgIHN1cGVyLmxvYWQoIGRhdGEgKTtcblxuICAgIC8qKlxuICAgICAqIEdVSSBzZXR0aW5ncy5cbiAgICAgKiBGZWVsIGZyZWUgdG8gZ2V0IC8gc2V0IHRoZXNlIHZhbHVlcy5cbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuICAgIHRoaXMuZ3VpU2V0dGluZ3MgPSBkYXRhLmd1aVNldHRpbmdzO1xuXG4gICAgLy8gUG9rZSB2dWVcbiAgICBpZiAoIHRoaXMuX192dWUgKSB7XG4gICAgICB0aGlzLl9fdnVlLiRlbWl0KCAnbG9hZGVkJyApO1xuICAgIH1cblxuICAgIC8vIEJ5ZSBoaXN0b3J5XG4gICAgaWYgKCB0aGlzLl9faGlzdG9yeSApIHtcbiAgICAgIHRoaXMuZHJvcEhpc3RvcnkoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRXhwb3J0IGN1cnJlbnQgc3RhdGUgYXMgSlNPTi5cbiAgICogQHJldHVybnMge3N0cmluZ30gU2F2ZWQgb2JqZWN0IGFzIEpTT05cbiAgICogQGV4YW1wbGVcbiAgICog44GC44Go44Gn44KE44KLXG4gICAqIEB0b2RvIOOBr+OBhFxuICAgKi9cbiAgc2F2ZSgpIHtcbiAgICBjb25zdCByZXQgPSB7XG4gICAgICB2OiB0aGlzLnZlcnNpb24sXG4gICAgICBsZW5ndGg6IHRoaXMubGVuZ3RoLFxuICAgICAgcmVzb2x1dGlvbjogdGhpcy5yZXNvbHV0aW9uLFxuICAgICAgcGFyYW1zOiB7fSwgLy8gd2lsbCBiZSBmaWxsZWQgbGF0ZXJcbiAgICAgIGd1aVNldHRpbmdzOiB0aGlzLmd1aVNldHRpbmdzXG4gICAgfTtcblxuICAgIHJldC5wYXJhbXMgPSB7fTtcbiAgICBmb3IgKCBsZXQgbmFtZSBpbiB0aGlzLl9fcGFyYW1zICkge1xuICAgICAgY29uc3QgcGFyYW0gPSB0aGlzLl9fcGFyYW1zWyBuYW1lIF07XG4gICAgICByZXQucGFyYW1zWyBuYW1lIF0gPSB7XG4gICAgICAgIG5vZGVzOiBwYXJhbS5kdW1wTm9kZXNXaXRob3V0SWQoKSxcbiAgICAgICAgZnhzOiBwYXJhbS5kdW1wRnhzV2l0aG91dElkKClcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KCByZXQgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQb2tlIHRoZSB2dWUgcmVuZGVyZXIuXG4gICAqIEByZXR1cm5zIHt2b2lkfSB2b2lkXG4gICAqL1xuICBwb2tlUmVuZGVyZXIoKSB7XG4gICAgaWYgKCB0aGlzLl9fdnVlICkge1xuICAgICAgdGhpcy5fX3Z1ZS4kZW1pdCggJ3Bva2UnICk7XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEF1dG9tYXRvbldpdGhHVUk7XG5BdXRvbWF0b25XaXRoR1VJLmRlZmF1bHQgPSBBdXRvbWF0b25XaXRoR1VJOyIsImltcG9ydCBDbG9jayBmcm9tICcuL2Nsb2NrJztcbmltcG9ydCBDbG9ja0ZyYW1lIGZyb20gJy4vY2xvY2stZnJhbWUnO1xuaW1wb3J0IENsb2NrUmVhbHRpbWUgZnJvbSAnLi9jbG9jay1yZWFsdGltZSc7XG5cbmltcG9ydCBQYXJhbSBmcm9tICcuL3BhcmFtJztcblxuLyoqXG4gKiBJVCdTIEFVVE9NQVRPTiFcbiAqIEl0J3MgYGF1dG9tYXRvbi5ub2d1aS5qc2AgdmVyc2lvbiBhbmQgYWxzbyBiYXNlIGNsYXNzIGZvciB7QGxpbmsgQXV0b21hdG9uV2l0aEdVSX0uXG4gKiBAcGFyYW0ge09iamVjdH0gX3Byb3BzXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtfcHJvcHMubG9vcF0gV2hldGhlciBsZXQgdGhlIHRpbWUgbG9vcCBvciBub3RcbiAqIEBwYXJhbSB7bnVtYmVyfSBbX3Byb3BzLmZwc10gSWYgdGhpcyBpcyBzZXQsIHRoZSBjbG9jayB3aWxsIGJlY29tZSBmcmFtZSBtb2RlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtfcHJvcHMucmVhbHRpbWVdIElmIHRoaXMgaXMgdHJ1ZSwgdGhlIGNsb2NrIHdpbGwgYmVjb21lIHJlYWx0aW1lIG1vZGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBfcHJvcHMuZGF0YSBEYXRhIG9mIHRoZSBhdXRvbWF0b24uICoqUmVxdWlyZWQgaW4gbm9HVUkgbW9kZSoqXG4gKi9cbmNvbnN0IEF1dG9tYXRvbiA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoIF9wcm9wcyApIHtcbiAgICAvKipcbiAgICAgKiBWZXJzaW9uIG9mIHRoZSBhdXRvbWF0b24uXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgdGhpcy5fX3ZlcnNpb24gPSBcIjIuMC4xXCI7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSBhbmltYXRpb24gd2lsbCBiZSBsb29wZWQgb3Igbm90LlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMubG9vcCA9IF9wcm9wcy5sb29wIHx8IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQ2xvY2sgb2YgdGhlIGF1dG9tYXRvbi5cbiAgICAgKiBAdHlwZSB7Q2xvY2t9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHRoaXMuX19jbG9jayA9IChcbiAgICAgIF9wcm9wcy5mcHMgPyBuZXcgQ2xvY2tGcmFtZSggdGhpcywgX3Byb3BzLmZwcyApIDpcbiAgICAgIF9wcm9wcy5yZWFsdGltZSA/IG5ldyBDbG9ja1JlYWx0aW1lKCB0aGlzICkgOlxuICAgICAgbmV3IENsb2NrKCB0aGlzIClcbiAgICApO1xuXG4gICAgLyoqXG4gICAgICogTGlzdCBvZiBldmVudCBsaXN0ZW5lcnMuXG4gICAgICogQHR5cGUge09iamVjdC48c3RyaW5nLCBmdW5jdGlvbltdPn1cbiAgICAgKi9cbiAgICB0aGlzLl9fbGlzdGVuZXJzID0ge307XG5cbiAgICAvKipcbiAgICAgKiBBIGxpc3Qgb2YgcGFyYW0gZnggZGVmaW5pdGlvbnMuXG4gICAgICogQHR5cGUge09iamVjdC48c3RyaW5nLCBGeD59XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHRoaXMuX19wYXJhbUZ4RGVmcyA9IHt9O1xuXG4gICAgY29uc3QgZGF0YSA9IF9wcm9wcy5kYXRhO1xuICAgIHRoaXMubG9hZCggZGF0YSApO1xuXG4gICAgLyoqXG4gICAgICogKipUSEUgTUlHSFRZIGBhdXRvKClgIEZVTkNUSU9OISEgR1JBQiBJVCoqXG4gICAgICogSXQgY3JlYXRlcyBhIG5ldyBwYXJhbSBhdXRvbWF0aWNhbGx5IGlmIHRoZXJlIGFyZSBubyBwYXJhbSBjYWxsZWQgYF9uYW1lYCAoR1VJIG1vZGUgb25seSkuXG4gICAgICogT3RoZXJ3aXNlIGl0IHJldHVybnMgY3VycmVudCB2YWx1ZSBvZiB0aGUgcGFyYW0gY2FsbGVkIGBfbmFtZWAuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IF9uYW1lIG5hbWUgb2YgdGhlIHBhcmFtXG4gICAgICogQHJldHVybnMge251bWJlcn0gQ3VycmVudCB2YWx1ZSBvZiB0aGUgcGFyYW1cbiAgICAgKi9cbiAgICB0aGlzLmF1dG8gPSAoIF9uYW1lICkgPT4gdGhpcy5fX2F1dG8oIF9uYW1lICk7XG4gIH1cblxuICAvKipcbiAgICogVmVyc2lvbiBvZiB0aGUgYXV0b21hdG9uLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCB2ZXJzaW9uKCkgeyByZXR1cm4gdGhpcy5fX3ZlcnNpb247IH1cblxuICAvKipcbiAgICogQ3VycmVudCB0aW1lLiBTYW1lIGFzIGBhdXRvbWF0b24uX19jbG9jay50aW1lYC5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgdGltZSgpIHsgcmV0dXJuIHRoaXMuX19jbG9jay50aW1lOyB9XG5cbiAgLyoqXG4gICAqIFRvdGFsIGxlbmd0aCBvZiBhbmltYXRpb24gaW4gc2Vjb25kcy5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgbGVuZ3RoKCkgeyByZXR1cm4gdGhpcy5fX2xlbmd0aDsgfVxuXG4gIC8qKlxuICAgKiBSZXNvbHV0aW9uID0gU2FtcGxpbmcgcG9pbnQgcGVyIHNlY29uZC5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgcmVzb2x1dGlvbigpIHsgcmV0dXJuIHRoaXMuX19yZXNvbHV0aW9uOyB9XG5cbiAgLyoqXG4gICAqIERlbHRhIG9mIHRpbWUgYmV0d2VlbiBub3cgYW5kIHByZXZpb3VzIHVwZGF0ZSBjYWxsLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBkZWx0YVRpbWUoKSB7IHJldHVybiB0aGlzLl9fY2xvY2suZGVsdGFUaW1lOyB9XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgaXQncyBwbGF5aW5nIG9yIG5vdC5cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IGlzUGxheWluZygpIHsgcmV0dXJuIHRoaXMuX19jbG9jay5pc1BsYXlpbmc7IH1cblxuICAvKipcbiAgICogQ3VycmVudCBwcm9ncmVzcyBieSB3aG9sZSBsZW5ndGguIE1pZ2h0IE5PVCBiZSBbMC0xXSB1bmxlc3MgYF9wcm9wcy5sb29wYCAoc2VlIGNvbnN0cnVjdG9yKSBpcyB0cnVlLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBwcm9ncmVzcygpIHsgcmV0dXJuIHRoaXMudGltZSAvIHRoaXMubGVuZ3RoOyB9XG5cbiAgLyoqXG4gICAqIEZyYW1lIHBlciBzZWNvbmQuIElmIHRoZSBjbG9jayB0eXBlIGlzIG5vdCBmcHMsIGl0IHdpbGwgcmV0dXJuIGAwYCBpbnN0ZWFkLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBmcHMoKSB7IHJldHVybiB0aGlzLl9fY2xvY2suZnBzID8gdGhpcy5fX2Nsb2NrLmZwcyA6IDA7IH1cblxuICAvKipcbiAgICogQm9vbGVhbiB0aGF0IHJlcHJlc2VudHMgd2hldGhlciB0aGUgY2xvY2sgaXMgYmFzZWQgb24gcmVhbHRpbWUgb3Igbm90LlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgcmVhbHRpbWUoKSB7IHJldHVybiBCb29sZWFuKCB0aGlzLl9fY2xvY2sucmVhbHRpbWUgKTsgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgcGFyYW0uXG4gICAqIEBwYXJhbSBfbmFtZSBOYW1lIG9mIHRoZSBwYXJhbVxuICAgKiBAcGFyYW0gX2RhdGEgRGF0YSBmb3IgdGhlIHBhcmFtXG4gICAqIEByZXR1cm5zIHt2b2lkfSB2b2lkXG4gICAqL1xuICBjcmVhdGVQYXJhbSggX25hbWUsIF9kYXRhICkge1xuICAgIHRoaXMuX19wYXJhbXNbIG5hbWUgXSA9IG5ldyBQYXJhbSgge1xuICAgICAgYXV0b21hdG9uOiB0aGlzLFxuICAgICAgZGF0YTogX2RhdGFcbiAgICB9ICk7XG4gIH1cblxuICAvKipcbiAgICogTG9hZCBhdXRvbWF0b24gc3RhdGUgZGF0YS5cbiAgICogQHBhcmFtIHtPYmplY3R9IF9kYXRhIE9iamVjdCBjb250YWlucyBhdXRvbWF0b24gZGF0YS5cbiAgICogQHJldHVybnMge3ZvaWR9IHZvaWRcbiAgICovXG4gIGxvYWQoIF9kYXRhICkge1xuICAgIC8qKlxuICAgICAqIFRvdGFsIGxlbmd0aCBvZiBhbmltYXRpb24gaW4gc2Vjb25kcy5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICB0aGlzLl9fbGVuZ3RoID0gX2RhdGEubGVuZ3RoO1xuXG4gICAgLyoqXG4gICAgICogUmVzb2x1dGlvbiA9IFNhbXBsaW5nIHBvaW50IHBlciBzZWNvbmQuXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgdGhpcy5fX3Jlc29sdXRpb24gPSBfZGF0YS5yZXNvbHV0aW9uO1xuXG4gICAgLyoqXG4gICAgICogTGlzdCBvZiBQYXJhbS5cbiAgICAgKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsIFBhcmFtPn1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgdGhpcy5fX3BhcmFtcyA9IHt9O1xuICAgIGZvciAoIGNvbnN0IG5hbWUgaW4gX2RhdGEucGFyYW1zICkge1xuICAgICAgdGhpcy5jcmVhdGVQYXJhbSggbmFtZSwgX2RhdGEucGFyYW1zWyBuYW1lIF0gKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2VlayB0aGUgdGltZWxpbmUuXG4gICAqIENhbiBiZSBwZXJmb3JtZWQgdmlhIEdVSS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IF90aW1lIFRpbWVcbiAgICogQHJldHVybnMge3ZvaWR9IHZvaWRcbiAgICovXG4gIHNlZWsoIF90aW1lICkge1xuICAgIHRoaXMuX19jbG9jay5zZXRUaW1lKCBfdGltZSApO1xuICAgIHRoaXMuX19lbWl0KCAnc2VlaycgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQbGF5IHRoZSB0aW1lbGluZS5cbiAgICogQHJldHVybnMge3ZvaWR9IHZvaWRcbiAgICogQHRvZG8gU0hPVUxEIGJlIHBlcmZvcm1lZCB2aWEgR1VJLlxuICAgKi9cbiAgcGxheSgpIHtcbiAgICB0aGlzLl9fY2xvY2sucGxheSgpO1xuICAgIHRoaXMuX19lbWl0KCAncGxheScgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXVzZSB0aGUgdGltZWxpbmUuXG4gICAqIEByZXR1cm5zIHt2b2lkfSB2b2lkXG4gICAqIEB0b2RvIFNIT1VMRCBiZSBwZXJmb3JtZWQgdmlhIEdVSS5cbiAgICovXG4gIHBhdXNlKCkge1xuICAgIHRoaXMuX19jbG9jay5wYXVzZSgpO1xuICAgIHRoaXMuX19lbWl0KCAncGF1c2UnICk7XG4gIH1cblxuICAvKipcbiAgICogQWRkIGEgZnggZGVmaW5pdGlvbi5cbiAgICogQHBhcmFtIHtzdHJpbmd9IF9pZCBVbmlxdWUgaWQgZm9yIHRoZSBGeCBkZWZpbml0aW9uXG4gICAqIEBwYXJhbSB7RnhEZWZpbml0aW9ufSBfZnhEZWYgRnggZGVmaW5pdGlvbiBvYmplY3RcbiAgICogQHJldHVybnMge3ZvaWR9IHZvaWRcbiAgICovXG4gIGFkZEZ4RGVmaW5pdGlvbiggX2lkLCBfZnhEZWYgKSB7XG4gICAgdGhpcy5fX3BhcmFtRnhEZWZzWyBfaWQgXSA9IF9meERlZjtcblxuICAgIHRoaXMucHJlY2FsY0FsbCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEVtaXQgYW4gZXZlbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBfZXZlbnQgRXZlbnQgbmFtZVxuICAgKiBAcGFyYW0gey4uLmFueX0gX2FyZyBBcmd1bWVudHMgcGFzc2VkIHRvIGxpc3RlbmVyc1xuICAgKiBAcmV0dXJucyB7dm9pZH0gdm9pZFxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBfX2VtaXQoIF9ldmVudCwgLi4uX2FyZyApIHtcbiAgICBpZiAoICF0aGlzLl9fbGlzdGVuZXJzWyBfZXZlbnQgXSApIHsgcmV0dXJuOyB9XG4gICAgdGhpcy5fX2xpc3RlbmVyc1sgX2V2ZW50IF0ubWFwKCAoIGxpc3RlbmVyICkgPT4gbGlzdGVuZXIoIC4uLl9hcmcgKSApO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGEgbGlzdGVuZXIgZnVuY3Rpb24uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBfZXZlbnQgRXZlbnQgbmFtZVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBfZnVuYyBMaXN0ZW5lciBmdW5jdGlvblxuICAgKiBAcmV0dXJucyB7dm9pZH0gdm9pZFxuICAgKi9cbiAgb24oIF9ldmVudCwgX2Z1bmMgKSB7XG4gICAgaWYgKCAhdGhpcy5fX2xpc3RlbmVyc1sgX2V2ZW50IF0gKSB7XG4gICAgICB0aGlzLl9fbGlzdGVuZXJzWyBfZXZlbnQgXSA9IFtdO1xuICAgIH1cbiAgICB0aGlzLl9fbGlzdGVuZXJzWyBfZXZlbnQgXS5wdXNoKCBfZnVuYyApO1xuICB9XG5cbiAgLyoqXG4gICAqIFByZWNhbGN1bGF0ZSBhbGwgcGFyYW1zLlxuICAgKiBAcmV0dXJucyB7dm9pZH0gdm9pZFxuICAgKi9cbiAgcHJlY2FsY0FsbCgpIHtcbiAgICBmb3IgKCBjb25zdCBuYW1lIGluIHRoaXMuX19wYXJhbXMgKSB7XG4gICAgICB0aGlzLl9fcGFyYW1zWyBuYW1lIF0ucHJlY2FsYygpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIGVudGlyZSBhdXRvbWF0b24uXG4gICAqICoqWW91IG1heSB3YW50IHRvIGNhbGwgdGhpcyBpbiB5b3VyIHVwZGF0ZSBsb29wLioqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbX3RpbWVdIEN1cnJlbnQgdGltZSwgKipSZXF1aXJlZCBpZiB0aGUgY2xvY2sgbW9kZSBpcyBtYW51YWwqKlxuICAgKiBAcmV0dXJucyB7dm9pZH0gdm9pZFxuICAgKi9cbiAgdXBkYXRlKCBfdGltZSApIHtcbiAgICAvLyB1cGRhdGUgdGhlIGNsb2NrXG4gICAgdGhpcy5fX2Nsb2NrLnVwZGF0ZSggX3RpbWUgKTtcblxuICAgIC8vIGlmIGxvb3AgaXMgZW5hYmxlZCwgbG9vcCB0aGUgdGltZVxuICAgIGlmICggdGhpcy5sb29wICYmICggdGhpcy50aW1lIDwgMCB8fCB0aGlzLmxlbmd0aCA8IHRoaXMudGltZSApICkge1xuICAgICAgdGhpcy5fX2Nsb2NrLnNldFRpbWUoIHRoaXMudGltZSAtIE1hdGguZmxvb3IoIHRoaXMudGltZSAvIHRoaXMubGVuZ3RoICkgKiB0aGlzLmxlbmd0aCApO1xuICAgIH1cblxuICAgIC8vIGdyYWIgY3VycmVudCB2YWx1ZSBmb3IgZWFjaCBwYXJhbVxuICAgIGZvciAoIGxldCBuYW1lIGluIHRoaXMuX19wYXJhbXMgKSB7XG4gICAgICB0aGlzLl9fcGFyYW1zWyBuYW1lIF0uZ2V0VmFsdWUoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQXNzaWduZWQgdG8gQXV0b21hdG9uLmF1dG8gYXQgY29uc3RydWN0b3IuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBfbmFtZSBuYW1lIG9mIHRoZSBwYXJhbVxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBDdXJyZW50IHZhbHVlIG9mIHRoZSBwYXJhbVxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBfX2F1dG8oIF9uYW1lICkge1xuICAgIHJldHVybiB0aGlzLnBhcmFtc1sgX25hbWUgXS5fX2N1cnJlbnRWYWx1ZTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBBdXRvbWF0b247XG5BdXRvbWF0b24uZGVmYXVsdCA9IEF1dG9tYXRvbjsiLCJpbXBvcnQganNvbkNvcHkgZnJvbSAnLi9qc29uLWNvcHknO1xuaW1wb3J0IGFzcyBmcm9tICcuL2Fzcyc7XG5pbXBvcnQgZ2VuSWQgZnJvbSAnLi9nZW4taWQnO1xuaW1wb3J0IGhhc092ZXJ3cmFwIGZyb20gJy4vaGFzLW92ZXJ3cmFwJztcblxuaW1wb3J0IEF1dG9tYXRvbiBmcm9tICcuL21haW4tZ3VpJztcbmltcG9ydCBQYXJhbSBmcm9tICcuL3BhcmFtJztcblxuaW1wb3J0IFZ1ZSBmcm9tICd2dWUnO1xuXG4vKipcbiAqIEl0IHJlcHJlc2VudHMgYSBwYXJhbSBvZiBBdXRvbWF0b24uXG4gKiBJdCdzIGBhdXRvbWF0b24uanNgIGFuZCBgYXV0b21hdG9uLm1pbi5qc2AgdmVyc2lvbi5cbiAqIEl0IGhhcyBldmVuIG1vcmUgcHJldHR5IEFQSXMgeWF5XG4gKiBAcGFyYW0ge09iamVjdH0gX3Byb3BzXG4gKiBAcGFyYW0ge0F1dG9tYXRvbn0gX3Byb3BzLmF1dG9tYXRvbiBQYXJlbnQgYXV0b21hdG9uXG4gKiBAcGFyYW0ge09iamVjdH0gW19wcm9wcy5kYXRhXSBEYXRhIG9mIHRoZSBwYXJhbS4gRG9uJ3Qgd29ycnksIEkgY2FuIGdlbmVyYXRlIGFuIGluaXRpYWwgZGF0YSBmb3IgeW91IVxuICovXG5jb25zdCBQYXJhbVdpdGhHVUkgPSBjbGFzcyBleHRlbmRzIFBhcmFtIHtcbiAgY29uc3RydWN0b3IoIF9wcm9wcyApIHtcbiAgICBjb25zdCBwcm9wcyA9IE9iamVjdC5hc3NpZ24oIHt9LCBfcHJvcHMgKTtcbiAgICBjb25zdCBsZW4gPSBfcHJvcHMuYXV0b21hdG9uLmxlbmd0aDtcbiAgICBwcm9wcy5kYXRhID0gcHJvcHMuZGF0YSA/IHByb3BzLmRhdGEgOiB7XG4gICAgICBub2RlczogW1xuICAgICAgICB7XG4gICAgICAgICAgdGltZTogMC4wLFxuICAgICAgICAgIHZhbHVlOiAwLjAsXG4gICAgICAgICAgb3V0OiB7IHRpbWU6IFBhcmFtV2l0aEdVSS5ERUZBVUxUX0hBTkRMRV9MRU5HVEgsIHZhbHVlOiAwLjAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgdGltZTogbGVuLFxuICAgICAgICAgIHZhbHVlOiAwLjAsXG4gICAgICAgICAgaW46IHsgdGltZTogLVBhcmFtV2l0aEdVSS5ERUZBVUxUX0hBTkRMRV9MRU5HVEgsIHZhbHVlOiAwLjAgfVxuICAgICAgICB9XG4gICAgICBdLFxuICAgICAgZnhzOiBbXVxuICAgIH07XG5cbiAgICBzdXBlciggcHJvcHMgKTtcblxuICAgIC8qKlxuICAgICAqIFRydWUgaWYgdGhlIHBhcmFtIGlzIHVzZWQgb25jZSBhdCBsZWFzdCBpbiBjdXJyZW50IHNlc3Npb24uXG4gICAgICogQ2FuIGJlIG9wZXJhdGVkIGJ5IHtAbGluayBQYXJhbVdpdGhHVUkjbWFya0FzVXNlZH0uXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHRoaXMuX19pc1VzZWQgPSBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2FkIGEgcGFyYW0gZGF0YS5cbiAgICogQHBhcmFtIHtvYmplY3R9IF9kYXRhIERhdGEgb2YgcGFyYW1cbiAgICogQHJldHVybnMge3ZvaWR9IHZvaWRcbiAgICovXG4gIGxvYWQoIF9kYXRhICkge1xuICAgIGNvbnN0IGRhdGEgPSBqc29uQ29weSggX2RhdGEgKTtcbiAgICBzdXBlci5sb2FkKCBkYXRhICk7XG5cbiAgICB0aGlzLl9fbm9kZXMuZm9yRWFjaCggKCBub2RlICkgPT4gbm9kZS4kaWQgPSBnZW5JZCgpICk7XG4gICAgdGhpcy5fX2Z4cy5mb3JFYWNoKCAoIGZ4ICkgPT4gZnguJGlkID0gZ2VuSWQoKSApO1xuICB9XG5cbiAgLyoqXG4gICAqIFByZWNhbGN1bGF0ZSB2YWx1ZXMuXG4gICAqIEByZXR1cm5zIHt2b2lkfSB2b2lkXG4gICAqL1xuICBwcmVjYWxjKCkge1xuICAgIHN1cGVyLnByZWNhbGMoKTtcbiAgICB0aGlzLl9fYXV0b21hdG9uLnBva2VSZW5kZXJlcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1hcmsgdGhpcyBwYXJhbSBhcyB1c2VkLlxuICAgKiBAcmV0dXJucyB7dm9pZH0gdm9pZFxuICAgKi9cbiAgbWFya0FzVXNlZCgpIHtcbiAgICB0aGlzLl9faXNVc2VkID0gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gd2hldGhlciB0aGlzIGlzIHVzZWQgcGFyYW0gb3Igbm90LlxuICAgKiBAcmV0dXJucyB7Ym9vbH0gVHJ1ZSBpZiB0aGUgcGFyYW0gaXMgdXNlZCBhdCBsZWFzdCBvbmNlIGluIGN1cnJlbnQgc2Vzc2lvblxuICAgKi9cbiAgaXNVc2VkKCkge1xuICAgIHJldHVybiB0aGlzLl9faXNVc2VkO1xuICB9XG5cbiAgLyoqXG4gICAqIFNvcnQgbm9kZXMgYnkgdGltZS5cbiAgICogQHJldHVybnMge3ZvaWR9IHZvaWRcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgX19zb3J0Tm9kZXMoKSB7XG4gICAgdGhpcy5fX25vZGVzID0gdGhpcy5fX25vZGVzLnNvcnQoICggYSwgYiApID0+IGEudGltZSAtIGIudGltZSApO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlYXJjaCBmb3Igbm9kZSB0aGF0IGhhcyBnaXZlbiBpZCB0aGVuIHJldHVybiBpbmRleCBvZiBpdC5cbiAgICogSWYgaXQgY291bGRuJ3QgZmluZCB0aGUgbm9kZSwgaXQgd2lsbCB0aHJvdyBhbiBlcnJvciBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge251bWJlcn0gX2lkIElkIG9mIG5vZGUgeW91IHdhbnQgdG8gZ3JhYlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBfX2dldE5vZGVJbmRleEJ5SWQoIF9pZCApIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuX19ub2Rlcy5maW5kSW5kZXgoICggbm9kZSApID0+IG5vZGUuJGlkID09PSBfaWQgKTtcbiAgICBpZiAoIGluZGV4ID09PSAtMSApIHsgdGhyb3cgbmV3IEVycm9yKCBgU2VhcmNoZWQgZm9yIG5vZGUgaWQ6ICR7X2lkfSBidXQgbm90IGZvdW5kYCApOyB9XG4gICAgcmV0dXJuIGluZGV4O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBob3cgbWFueSBub2RlIHRoZSBwYXJhbSBjdXJyZW50bHkgaGF2ZS5cbiAgICogQHJldHVybnMge251bWJlcn0gTm9kZXMgY291bnRcbiAgICovXG4gIGdldE51bU5vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX19ub2Rlcy5sZW5ndGg7XG4gIH1cblxuICAvKipcbiAgICogRHVtcCBkYXRhIG9mIGEgbm9kZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IF9pZCBJZCBvZiB0aGUgbm9kZSB5b3Ugd2FudCB0byBkdW1wXG4gICAqIEByZXR1cm5zIHtvYmplY3R9IERhdGEgb2YgdGhlIG5vZGVcbiAgICovXG4gIGR1bXBOb2RlKCBfaWQgKSB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLl9fZ2V0Tm9kZUluZGV4QnlJZCggX2lkICk7XG4gICAgcmV0dXJuIGpzb25Db3B5KCB0aGlzLl9fbm9kZXNbIGluZGV4IF0gKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEdW1wIGRhdGEgb2Ygbm9kZXMuXG4gICAqIEByZXR1cm5zIHtvYmplY3RbXX0gRGF0YSBvZiBub2Rlc1xuICAgKi9cbiAgZHVtcE5vZGVzKCkge1xuICAgIHJldHVybiBqc29uQ29weSggdGhpcy5fX25vZGVzICk7XG4gIH1cblxuICAvKipcbiAgICogRHVtcCBkYXRhIG9mIG5vZGVzLCB3aXRob3V0IGAkaWRgLlxuICAgKiBAcmV0dXJucyB7b2JqZWN0W119IERhdGEgb2Ygbm9kZXNcbiAgICovXG4gIGR1bXBOb2Rlc1dpdGhvdXRJZCgpIHtcbiAgICBsZXQgbm9kZXMgPSB0aGlzLmR1bXBOb2RlcygpO1xuICAgIHJldHVybiBub2Rlcy5tYXAoICggbm9kZSApID0+IHtcbiAgICAgIGRlbGV0ZSBub2RlLiRpZDtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH0gKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBub2RlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gX3RpbWUgVGltZSBvZiBuZXcgbm9kZVxuICAgKiBAcGFyYW0ge251bWJlcn0gX3ZhbHVlIFZhbHVlIG9mIG5ldyBub2RlXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IElkIG9mIHRoZSBuZXcgbm9kZVxuICAgKi9cbiAgY3JlYXRlTm9kZSggX3RpbWUsIF92YWx1ZSApIHtcbiAgICBjb25zdCBkYXRhID0ge1xuICAgICAgJGlkOiBnZW5JZCgpLFxuICAgICAgdGltZTogX3RpbWUsXG4gICAgICB2YWx1ZTogX3ZhbHVlLFxuICAgICAgaW46IHsgdGltZTogLVBhcmFtV2l0aEdVSS5ERUZBVUxUX0hBTkRMRV9MRU5HVEgsIHZhbHVlOiAwLjAgfSxcbiAgICAgIG91dDogeyB0aW1lOiBQYXJhbVdpdGhHVUkuREVGQVVMVF9IQU5ETEVfTEVOR1RILCB2YWx1ZTogMC4wIH1cbiAgICB9O1xuICAgIHRoaXMuX19ub2Rlcy5wdXNoKCBkYXRhICk7XG4gICAgdGhpcy5fX3NvcnROb2RlcygpO1xuXG4gICAgdGhpcy5wcmVjYWxjKCk7XG5cbiAgICByZXR1cm4gZGF0YS4kaWQ7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbm9kZSBmcm9tIGR1bXBlZCBkYXRhLlxuICAgKiBAcGFyYW0ge29iamVjdH0gX29iaiBEdW1wZWQgbm9kZSBkYXRhXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IElkIG9mIHRoZSBuZXcgbm9kZVxuICAgKi9cbiAgY3JlYXRlTm9kZUZyb21EYXRhKCBfb2JqICkge1xuICAgIGNvbnN0IGRhdGEgPSBqc29uQ29weSggX29iaiApO1xuICAgIHRoaXMuX19ub2Rlcy5wdXNoKCBkYXRhICk7XG4gICAgdGhpcy5fX3NvcnROb2RlcygpO1xuXG4gICAgdGhpcy5wcmVjYWxjKCk7XG5cbiAgICByZXR1cm4gZGF0YS4kaWQ7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGEgbm9kZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IF9pZCBJZCBvZiB0aGUgbm9kZSB5b3Ugd2FudCB0byByZW1vdmVcbiAgICogQHJldHVybnMge3ZvaWR9IHZvaWRcbiAgICovXG4gIHJlbW92ZU5vZGUoIF9pZCApIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuX19nZXROb2RlSW5kZXhCeUlkKCBfaWQgKTtcblxuICAgIHRoaXMuX19ub2Rlcy5zcGxpY2UoIGluZGV4LCAxICk7XG5cbiAgICB0aGlzLnByZWNhbGMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNb3ZlIGEgbm9kZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IF9pZCBJZCBvZiB0aGUgbm9kZSB5b3Ugd2FudCB0byBtb3ZlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBfdGltZSBUaW1lXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBfdmFsdWUgVmFsdWVcbiAgICogQHJldHVybnMge3ZvaWR9IHZvaWRcbiAgICovXG4gIG1vdmVOb2RlKCBfaWQsIF90aW1lLCBfdmFsdWUgKSB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLl9fZ2V0Tm9kZUluZGV4QnlJZCggX2lkICk7XG5cbiAgICBjb25zdCBub2RlID0gdGhpcy5fX25vZGVzWyBpbmRleCBdO1xuXG4gICAgbGV0IHRpbWUgPSB0eXBlb2YgX3RpbWUgPT09ICdudW1iZXInID8gX3RpbWUgOiBub2RlLnRpbWU7XG4gICAgaWYgKCBpbmRleCA9PT0gMCApIHtcbiAgICAgIHRpbWUgPSAwO1xuICAgIH0gZWxzZSBpZiAoIGluZGV4ID09PSB0aGlzLl9fbm9kZXMubGVuZ3RoIC0gMSApIHtcbiAgICAgIHRpbWUgPSB0aGlzLl9fYXV0b21hdG9uLmxlbmd0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGltZSA9IE1hdGgubWluKCBNYXRoLm1heCggdGltZSwgdGhpcy5fX25vZGVzWyBpbmRleCAtIDEgXS50aW1lICksIHRoaXMuX19ub2Rlc1sgaW5kZXggKyAxIF0udGltZSApO1xuICAgIH1cbiAgICBub2RlLnRpbWUgPSB0aW1lO1xuXG4gICAgbm9kZS52YWx1ZSA9IHR5cGVvZiBfdmFsdWUgPT09ICdudW1iZXInID8gX3ZhbHVlIDogbm9kZS52YWx1ZTtcblxuICAgIHRoaXMucHJlY2FsYygpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1vdmUgYSBoYW5kbGUgb2YgYSBub2RlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gX2lkIElkIG9mIHRoZSBub2RlIHlvdSB3YW50IHRvIG9wZXJhdGVcbiAgICogQHBhcmFtIHtib29sZWFufSBfaXNPdXQgSW5wdXQgaGFuZGxlIGlmIGZhbHNlLCBvdXRwdXQgaGFuZGxlIGlmIHRydWVcbiAgICogQHBhcmFtIHtudW1iZXJ9IF90aW1lIFRpbWVcbiAgICogQHBhcmFtIHtudW1iZXJ9IF92YWx1ZSBWYWx1ZVxuICAgKiBAcmV0dXJucyB7dm9pZH0gdm9pZFxuICAgKi9cbiAgbW92ZUhhbmRsZSggX2lkLCBfaXNPdXQsIF90aW1lLCBfdmFsdWUgKSB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLl9fZ2V0Tm9kZUluZGV4QnlJZCggX2lkICk7XG5cbiAgICBpZiAoXG4gICAgICAoIGluZGV4ID09PSAwICYmICggIV9pc091dCApICkgfHxcbiAgICAgICggaW5kZXggPT09ICggdGhpcy5nZXROdW1Ob2RlKCkgLSAxICkgJiYgX2lzT3V0IClcbiAgICApIHsgcmV0dXJuOyB9XG5cbiAgICBjb25zdCBub2RlID0gdGhpcy5fX25vZGVzWyBpbmRleCBdO1xuICAgIGNvbnN0IGhhbmRsZSA9IF9pc091dCA/IG5vZGUub3V0IDogbm9kZS5pbjtcblxuICAgIGxldCB0aW1lID0gdHlwZW9mIF90aW1lID09PSAnbnVtYmVyJyA/IF90aW1lIDogaGFuZGxlLnRpbWU7XG4gICAgaWYgKCBfaXNPdXQgKSB7XG4gICAgICB0aW1lID0gTWF0aC5tYXgoIDAuMCwgdGltZSApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aW1lID0gTWF0aC5taW4oIDAuMCwgdGltZSApO1xuICAgIH1cbiAgICBoYW5kbGUudGltZSA9IHRpbWU7XG5cbiAgICBoYW5kbGUudmFsdWUgPSB0eXBlb2YgX3ZhbHVlID09PSAnbnVtYmVyJyA/IF92YWx1ZSA6IGhhbmRsZS52YWx1ZTtcblxuICAgIHRoaXMucHJlY2FsYygpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc2V0IGEgaGFuZGxlIG9mIGEgbm9kZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IF9pZCBJZCBvZiB0aGUgbm9kZSB5b3Ugd2FudCB0byBvcGVyYXRlXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gX2lzT3V0IElucHV0IGhhbmRsZSBpZiBmYWxzZSwgb3V0cHV0IGhhbmRsZSBpZiB0cnVlXG4gICAqIEByZXR1cm5zIHt2b2lkfSB2b2lkXG4gICAqL1xuICByZXNldEhhbmRsZSggX2lkLCBfaXNPdXQgKSB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLl9fZ2V0Tm9kZUluZGV4QnlJZCggX2lkICk7XG5cbiAgICBpZiAoXG4gICAgICAoIGluZGV4ID09PSAwICYmICggIV9pc091dCApICkgfHxcbiAgICAgICggaW5kZXggPT09ICggdGhpcy5nZXROdW1Ob2RlKCkgLSAxICkgJiYgX2lzT3V0IClcbiAgICApIHsgcmV0dXJuOyB9XG5cbiAgICBjb25zdCBub2RlID0gdGhpcy5fX25vZGVzWyBpbmRleCBdO1xuICAgIGNvbnN0IGhhbmRsZSA9IF9pc091dCA/IG5vZGUub3V0IDogbm9kZS5pbjtcblxuICAgIGhhbmRsZS50aW1lID0gKCBfaXNPdXQgPyAxLjAgOiAtMS4wICkgKiBQYXJhbVdpdGhHVUkuREVGQVVMVF9IQU5ETEVfTEVOR1RIO1xuICAgIGhhbmRsZS52YWx1ZSA9IDAuMDtcblxuICAgIHRoaXMucHJlY2FsYygpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNvcnQgZnhzIGJ5IHRpbWUuXG4gICAqIEByZXR1cm5zIHt2b2lkfSB2b2lkXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIF9fc29ydEZ4cygpIHtcbiAgICB0aGlzLl9fZnhzID0gdGhpcy5fX2Z4cy5zb3J0KCAoIGEsIGIgKSA9PiBhLnRpbWUgLSBiLnRpbWUgKS5zb3J0KCAoIGEsIGIgKSA9PiBhLnJvdyAtIGIucm93ICk7XG4gIH1cblxuICAvKipcbiAgICogU2VhcmNoIGZvciBmeCB0aGF0IGhhcyBnaXZlbiBpZCB0aGVuIHJldHVybiBpbmRleCBvZiBpdC5cbiAgICogSWYgaXQgY291bGRuJ3QgZmluZCB0aGUgZngsIGl0IHdpbGwgdGhyb3cgYW4gZXJyb3IgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IF9pZCBJZCBvZiBmeCB5b3Ugd2FudCB0byBncmFiXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIF9fZ2V0RnhJbmRleEJ5SWQoIF9pZCApIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuX19meHMuZmluZEluZGV4KCAoIGZ4ICkgPT4gZnguJGlkID09PSBfaWQgKTtcbiAgICBpZiAoIGluZGV4ID09PSAtMSApIHsgdGhyb3cgbmV3IEVycm9yKCBgU2VhcmNoZWQgZm9yIGZ4IGlkOiAke19pZH0gYnV0IG5vdCBmb3VuZGAgKTsgfVxuICAgIHJldHVybiBpbmRleDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZWFyY2ggZm9yIHZhY2FuY2UgZnggcm93IGZvciBnaXZlbiB0aW1lIGFuZCBsZW5ndGguXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBfdGltZSBCZWdpbm5pbmcgdGltZSBvZiBmeFxuICAgKiBAcGFyYW0ge251bWJlcn0gX2xlbmd0aCBMZW5ndGggb2YgZnhcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtfcm93PTBdIElmIGdpdmVuLCByb3dzIGxvd2VyIHRoYW4gdGhpcyB2YWx1ZSB3aWxsIG5vdCBiZSBzZWFyY2hlZC5cbiAgICogQHJldHVybnMge251bWJlcn0gTWluaW1hbCBmcmVlIGZ4IHJvd1xuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBfX2dldEZyZWVSb3coIF90aW1lLCBfbGVuZ3RoLCBfcm93ICkge1xuICAgIGxldCByb3cgPSBfcm93IHx8IDA7XG4gICAgZm9yICggbGV0IGlGeCA9IDA7IGlGeCA8IHRoaXMuX19meHMubGVuZ3RoOyBpRnggKysgKSB7XG4gICAgICBjb25zdCBmeCA9IHRoaXMuX19meHNbIGlGeCBdO1xuICAgICAgaWYgKCBmeC5yb3cgPCByb3cgKSB7IGNvbnRpbnVlOyB9XG4gICAgICBpZiAoIHJvdyA8IGZ4LnJvdyApIHsgYnJlYWs7IH1cbiAgICAgIGlmICggaGFzT3ZlcndyYXAoIF90aW1lLCBfbGVuZ3RoLCBmeC50aW1lLCBmeC5sZW5ndGggKSApIHtcbiAgICAgICAgcm93ICsrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcm93O1xuICB9XG5cbiAgLyoqXG4gICAqIER1bXAgZGF0YSBvZiBhIGZ4LlxuICAgKiBAcGFyYW0ge251bWJlcn0gX2lkIElkIG9mIGEgZnggeW91IHdhbnQgdG8gZHVtcFxuICAgKiBAcmV0dXJucyB7b2JqZWN0fSBEYXRhIG9mIHRoZSBmeFxuICAgKi9cbiAgZHVtcEZ4KCBfaWQgKSB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLl9fZ2V0RnhJbmRleEJ5SWQoIF9pZCApO1xuICAgIHJldHVybiBqc29uQ29weSggdGhpcy5fX2Z4c1sgaW5kZXggXSApO1xuICB9XG5cbiAgLyoqXG4gICAqIER1bXAgZGF0YSBvZiBmeHMuXG4gICAqIEByZXR1cm5zIHtvYmplY3RbXX0gRGF0YSBvZiBmeHNcbiAgICovXG4gIGR1bXBGeHMoKSB7XG4gICAgcmV0dXJuIGpzb25Db3B5KCB0aGlzLl9fZnhzICk7XG4gIH1cblxuICAvKipcbiAgICogRHVtcCBkYXRhIG9mIGZ4cywgd2l0aG91dCBgJGlkYC5cbiAgICogQHJldHVybnMge29iamVjdFtdfSBEYXRhIG9mIGZ4c1xuICAgKi9cbiAgZHVtcEZ4c1dpdGhvdXRJZCgpIHtcbiAgICBsZXQgZnhzID0gdGhpcy5kdW1wRnhzKCk7XG4gICAgcmV0dXJuIGZ4cy5tYXAoICggZnggKSA9PiB7XG4gICAgICBkZWxldGUgZnguJGlkO1xuICAgICAgcmV0dXJuIGZ4O1xuICAgIH0gKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBmeC5cbiAgICogSWYgaXQgY291bGRuJ3QgY3JlYXRlIHBhcmFtLCBpdCB3aWxsIHJldHVybiBlbXB0eSBzdHJpbmcgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IF90aW1lIEJlZ2lubmluZyB0aW1lIG9mIG5ldyBmeFxuICAgKiBAcGFyYW0ge251bWJlcn0gX2xlbmd0aCBMZW5ndGggb2YgbmV3IGZ4XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBfZGVmIERlZmluaXRpb24gaWQgKGtpbmQpIG9mIG5ldyBmeFxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBJZCBvZiB0aGUgbmV3IGZ4XG4gICAqL1xuICBjcmVhdGVGeCggX3RpbWUsIF9sZW5ndGgsIF9kZWYgKSB7XG4gICAgbGV0IHJvdyA9IHRoaXMuX19nZXRGcmVlUm93KCBfdGltZSwgX2xlbmd0aCApO1xuICAgIGlmICggUGFyYW1XaXRoR1VJLkZYX1JPV19NQVggPCByb3cgKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCAnVG9vIG1hbnkgZnggc3RhY2tzIGF0IGhlcmUhJyApO1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICAkaWQ6IGdlbklkKCksXG4gICAgICB0aW1lOiBfdGltZSxcbiAgICAgIGxlbmd0aDogX2xlbmd0aCxcbiAgICAgIHJvdzogcm93LFxuICAgICAgZGVmOiBfZGVmLFxuICAgICAgcGFyYW1zOiB0aGlzLl9fYXV0b21hdG9uLmdlbmVyYXRlRGVmYXVsdEZ4UGFyYW1zKCBfZGVmIClcbiAgICB9O1xuICAgIHRoaXMuX19meHMucHVzaCggZGF0YSApO1xuICAgIHRoaXMuX19zb3J0RnhzKCk7XG5cbiAgICB0aGlzLnByZWNhbGMoKTtcblxuICAgIHJldHVybiBkYXRhLiRpZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBmeCBmcm9tIGR1bXBlZCBkYXRhLlxuICAgKiBJZiBpdCBjb3VsZG4ndCBjcmVhdGUgcGFyYW0sIGl0IHdpbGwgcmV0dXJuIGVtcHR5IHN0cmluZyBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge29iamVjdH0gX29iaiBEdW1wZWQgZnggZGF0YVxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBJZCBvZiB0aGUgbmV3IGZ4XG4gICAqL1xuICBjcmVhdGVGeEZyb21EYXRhKCBfb2JqICkge1xuICAgIGxldCByb3cgPSB0aGlzLl9fZ2V0RnJlZVJvdyggX29iai50aW1lLCBfb2JqLmxlbmd0aCwgX29iai5yb3cgKTtcbiAgICBpZiAoIFBhcmFtV2l0aEdVSS5GWF9ST1dfTUFYIDwgcm93ICkge1xuICAgICAgY29uc29sZS5lcnJvciggJ1RvbyBtYW55IGZ4IHN0YWNrcyBhdCBoZXJlIScgKTtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICBsZXQgZGF0YSA9IGpzb25Db3B5KCBfb2JqICk7XG4gICAgZGF0YS5yb3cgPSByb3c7XG4gICAgdGhpcy5fX2Z4cy5wdXNoKCBkYXRhICk7XG4gICAgdGhpcy5fX3NvcnRGeHMoKTtcblxuICAgIHRoaXMucHJlY2FsYygpO1xuXG4gICAgcmV0dXJuIGRhdGEuJGlkO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhIGZ4LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gX2lkIElkIG9mIHRoZSBmeCB5b3Ugd2FudCB0byByZW1vdmVcbiAgICogQHJldHVybnMge3ZvaWR9IHZvaWRcbiAgICovXG4gIHJlbW92ZUZ4KCBfaWQgKSB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLl9fZ2V0RnhJbmRleEJ5SWQoIF9pZCApO1xuXG4gICAgdGhpcy5fX2Z4cy5zcGxpY2UoIGluZGV4LCAxICk7XG5cbiAgICB0aGlzLnByZWNhbGMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNb3ZlIGEgZnguXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBfaWQgSWQgb2YgdGhlIGZ4IHlvdSB3YW50IHRvIG1vdmVcbiAgICogQHBhcmFtIHtudW1iZXJ9IF90aW1lIEJlZ2lubmluZyB0aW1lXG4gICAqIEByZXR1cm5zIHt2b2lkfSB2b2lkXG4gICAqL1xuICBtb3ZlRngoIF9pZCwgX3RpbWUgKSB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLl9fZ2V0RnhJbmRleEJ5SWQoIF9pZCApO1xuXG4gICAgY29uc3QgZnggPSB0aGlzLl9fZnhzWyBpbmRleCBdO1xuXG4gICAgY29uc3Qgc2FtZVJvdyA9IHRoaXMuX19meHMuZmlsdGVyKCAoIGZ4T3AgKSA9PiBmeE9wLnJvdyA9PT0gZngucm93ICk7XG4gICAgY29uc3QgaW5kZXhJblJvdyA9IHNhbWVSb3cuaW5kZXhPZiggZnggKTtcbiAgICBjb25zdCBwcmV2ID0gc2FtZVJvd1sgaW5kZXhJblJvdyAtIDEgXTtcbiAgICBjb25zdCBuZXh0ID0gc2FtZVJvd1sgaW5kZXhJblJvdyArIDEgXTtcblxuICAgIGNvbnN0IGxlZnQgPSBwcmV2ID8gKCBwcmV2LnRpbWUgKyBwcmV2Lmxlbmd0aCApIDogMC4wO1xuICAgIGNvbnN0IHJpZ2h0ID0gbmV4dCA/IG5leHQudGltZSA6IHRoaXMuX19hdXRvbWF0b24ubGVuZ3RoO1xuICAgIGZ4LnRpbWUgPSBNYXRoLm1pbiggTWF0aC5tYXgoIF90aW1lLCBsZWZ0ICksIHJpZ2h0IC0gZngubGVuZ3RoICk7XG5cbiAgICB0aGlzLnByZWNhbGMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGFuZ2Ugcm93IG9mIGEgZnguXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBfaWQgSWQgb2YgdGhlIGZ4IHlvdSB3YW50IHRvIG1vdmVcbiAgICogQHBhcmFtIHtudW1iZXJ9IF9yb3cgUm93XG4gICAqIEByZXR1cm5zIHt2b2lkfSB2b2lkXG4gICAqL1xuICBjaGFuZ2VGeFJvdyggX2lkLCBfcm93ICkge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5fX2dldEZ4SW5kZXhCeUlkKCBfaWQgKTtcblxuICAgIGlmICggX3JvdyA8IDAgfHwgUGFyYW1XaXRoR1VJLkZYX1JPV19NQVggPCBfcm93ICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCBgUm93IG51bWJlciAke19yb3d9IGlzIGludmFsaWRgICk7XG4gICAgfVxuXG4gICAgY29uc3QgZnggPSB0aGlzLl9fZnhzWyBpbmRleCBdO1xuICAgIGlmICggZngucm93ID09PSBfcm93ICkgeyByZXR1cm47IH1cblxuICAgIGNvbnN0IHNhbWVSb3cgPSB0aGlzLl9fZnhzLmZpbHRlciggKCBmeE9wICkgPT4gZnhPcC5yb3cgPT09IF9yb3cgKTtcbiAgICBjb25zdCBpc1ZhbGlkID0gc2FtZVJvdy5ldmVyeSggKCBmeE9wICkgPT4gKFxuICAgICAgISggZnhPcC50aW1lIDwgZngudGltZSAmJiBmeC50aW1lIDwgKCBmeE9wLnRpbWUgKyBmeE9wLmxlbmd0aCApICkgJiZcbiAgICAgICEoIGZ4T3AudGltZSA8ICggZngudGltZSArIGZ4Lmxlbmd0aCApICYmICggZngudGltZSArIGZ4Lmxlbmd0aCApIDwgKCBmeE9wLnRpbWUgKyBmeE9wLmxlbmd0aCApICkgJiZcbiAgICAgICEoIGZ4LnRpbWUgPCBmeE9wLnRpbWUgJiYgZnhPcC50aW1lIDwgKCBmeC50aW1lICsgZngubGVuZ3RoICkgKSAmJlxuICAgICAgISggZngudGltZSA8ICggZnhPcC50aW1lICsgZnhPcC5sZW5ndGggKSAmJiAoIGZ4T3AudGltZSArIGZ4T3AubGVuZ3RoICkgPCAoIGZ4LnRpbWUgKyBmeC5sZW5ndGggKSApXG4gICAgKSApO1xuXG4gICAgaWYgKCAhaXNWYWxpZCApIHsgcmV0dXJuOyB9XG5cbiAgICBmeC5yb3cgPSBfcm93O1xuICAgIHRoaXMuX19zb3J0RnhzKCk7XG5cbiAgICB0aGlzLnByZWNhbGMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCeXBhc3Mgb3IgdW5ieXBhc3MgYSBmeC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IF9pZCBJZCBvZiB0aGUgZnggeW91IHdhbnQgdG8gY2hhbmdlXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gX2J5cGFzcyBJZiB0cnVlLCBmeCB3aWxsIGJlIGJ5cGFzc2VkXG4gICAqIEByZXR1cm5zIHt2b2lkfSB2b2lkXG4gICAqL1xuICBieXBhc3NGeCggX2lkLCBfYnlwYXNzICkge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5fX2dldEZ4SW5kZXhCeUlkKCBfaWQgKTtcblxuICAgIGNvbnN0IGZ4ID0gdGhpcy5fX2Z4c1sgaW5kZXggXTtcbiAgICBWdWUuc2V0KCBmeCwgJ2J5cGFzcycsICEhX2J5cGFzcyApO1xuXG4gICAgdGhpcy5wcmVjYWxjKCk7XG4gIH1cblxuICAvKipcbiAgICogQ2hhbmdlIGEgcGFyYW0gb2YgYSBmeC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IF9pZCBJZCBvZiB0aGUgZnggeW91IHdhbnQgdG8gY2hhbmdlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBfbmFtZSBOYW1lIG9mIHRoZSBwYXJhbSB5b3Ugd2FudCB0byBjaGFuZ2VcbiAgICogQHBhcmFtIHthbnl9IF92YWx1ZSBZb3VyIGRlc2lyZWQgdmFsdWVcbiAgICogQHJldHVybnMge3ZvaWR9IHZvaWRcbiAgICovXG4gIGNoYW5nZUZ4UGFyYW0oIF9pZCwgX25hbWUsIF92YWx1ZSApIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuX19nZXRGeEluZGV4QnlJZCggX2lkICk7XG5cbiAgICBjb25zdCBmeCA9IHRoaXMuX19meHNbIGluZGV4IF07XG4gICAgY29uc3QgcGFyYW1zID0gdGhpcy5fX2F1dG9tYXRvbi5nZXRGeERlZmluaXRpb25QYXJhbXMoIGZ4LmRlZiApO1xuXG4gICAgbGV0IHZhbHVlID0gX3ZhbHVlO1xuICAgIGlmICggdHlwZW9mIHBhcmFtc1sgX25hbWUgXS5taW4gPT09ICdudW1iZXInICkgeyB2YWx1ZSA9IE1hdGgubWF4KCBwYXJhbXNbIF9uYW1lIF0ubWluLCB2YWx1ZSApOyB9XG4gICAgaWYgKCB0eXBlb2YgcGFyYW1zWyBfbmFtZSBdLm1heCA9PT0gJ251bWJlcicgKSB7IHZhbHVlID0gTWF0aC5taW4oIHBhcmFtc1sgX25hbWUgXS5tYXgsIHZhbHVlICk7IH1cbiAgICBWdWUuc2V0KCBmeC5wYXJhbXMsIF9uYW1lLCB2YWx1ZSApO1xuXG4gICAgdGhpcy5wcmVjYWxjKCk7XG4gIH1cblxuICAvKipcbiAgICogTW92ZSBhIGZ4IC0tZm9yY2UuXG4gICAqIEJlc3QgZm9yIHVuZG8tcmVkbyBvcGVyYXRpb24uIHByb2JhYmx5LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gX2lkIElkIG9mIHRoZSBmeCB5b3Ugd2FudCB0byBtb3ZlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBfdGltZSBCZWdpbm5pbmcgdGltZVxuICAgKiBAcGFyYW0ge251bWJlcn0gX3JvdyBSb3dcbiAgICogQHJldHVybnMge3ZvaWR9IHZvaWRcbiAgICovXG4gIGZvcmNlTW92ZUZ4KCBfaWQsIF90aW1lLCBfcm93ICkge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5fX2dldEZ4SW5kZXhCeUlkKCBfaWQgKTtcblxuICAgIGNvbnN0IGZ4ID0gdGhpcy5fX2Z4c1sgaW5kZXggXTtcblxuICAgIGZ4LnRpbWUgPSBfdGltZTtcbiAgICBmeC5yb3cgPSBfcm93O1xuICAgIHRoaXMuX19zb3J0RnhzKCk7XG5cbiAgICB0aGlzLnByZWNhbGMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNpemUgYSBmeC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IF9pZCBJbmRleCBvZiB0aGUgZnggeW91IHdhbnQgdG8gcmVzaXplXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBfbGVuZ3RoIExlbmd0aFxuICAgKiBAcmV0dXJucyB7dm9pZH0gdm9pZFxuICAgKi9cbiAgcmVzaXplRngoIF9pZCwgX2xlbmd0aCApIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuX19nZXRGeEluZGV4QnlJZCggX2lkICk7XG5cbiAgICBjb25zdCBmeCA9IHRoaXMuX19meHNbIGluZGV4IF07XG5cbiAgICBjb25zdCBzYW1lUm93ID0gdGhpcy5fX2Z4cy5maWx0ZXIoICggZnhPcCApID0+IGZ4T3Aucm93ID09PSBmeC5yb3cgKTtcbiAgICBjb25zdCBpbmRleEluUm93ID0gc2FtZVJvdy5pbmRleE9mKCBmeCApO1xuICAgIGNvbnN0IG5leHQgPSBzYW1lUm93WyBpbmRleEluUm93ICsgMSBdO1xuXG4gICAgY29uc3QgcmlnaHQgPSBuZXh0ID8gbmV4dC50aW1lIDogdGhpcy5fX2F1dG9tYXRvbi5sZW5ndGg7XG5cbiAgICBmeC5sZW5ndGggPSBNYXRoLm1pbiggTWF0aC5tYXgoIF9sZW5ndGgsIDAuMCApLCByaWdodCAtIGZ4LnRpbWUgKTtcblxuICAgIHRoaXMucHJlY2FsYygpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc2l6ZSBhIGZ4IGJ5IGxlZnQgc2lkZSBvZiB0aGUgZW5kLlxuICAgKiBJdCdzIHZlcnkgR1VJIGRldiBmcmllbmRseSBtZXRob2QuIHllYWguXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBfaWQgSW5kZXggb2YgdGhlIGZ4IHlvdSB3YW50IHRvIHJlc2l6ZVxuICAgKiBAcGFyYW0ge251bWJlcn0gX2xlbmd0aCBMZW5ndGhcbiAgICogQHJldHVybnMge3ZvaWR9IHZvaWRcbiAgICovXG4gIHJlc2l6ZUZ4QnlMZWZ0KCBfaWQsIF9sZW5ndGggKSB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLl9fZ2V0RnhJbmRleEJ5SWQoIF9pZCApO1xuXG4gICAgY29uc3QgZnggPSB0aGlzLl9fZnhzWyBpbmRleCBdO1xuICAgIGNvbnN0IGVuZCA9IGZ4LnRpbWUgKyBmeC5sZW5ndGg7XG5cbiAgICBjb25zdCBzYW1lUm93ID0gdGhpcy5fX2Z4cy5maWx0ZXIoICggZnhPcCApID0+IGZ4T3Aucm93ID09PSBmeC5yb3cgKTtcbiAgICBjb25zdCBpbmRleEluUm93ID0gc2FtZVJvdy5pbmRleE9mKCBmeCApO1xuICAgIGNvbnN0IHByZXYgPSBzYW1lUm93WyBpbmRleEluUm93IC0gMSBdO1xuXG4gICAgY29uc3QgbGVmdCA9IHByZXYgPyAoIHByZXYudGltZSArIHByZXYubGVuZ3RoICkgOiAwLjA7XG5cbiAgICBmeC5sZW5ndGggPSBNYXRoLm1pbiggTWF0aC5tYXgoIF9sZW5ndGgsIDAuMCApLCBlbmQgLSBsZWZ0ICk7XG4gICAgZngudGltZSA9IGVuZCAtIGZ4Lmxlbmd0aDtcblxuICAgIHRoaXMucHJlY2FsYygpO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGwgd2hlbiB5b3UgbmVlZCB0byBjaGFuZ2UgYXV0b21hdG9uIGxlbmd0aC5cbiAgICogVGhpcyBpcyB2ZXJ5IGhhcmRjb3JlIG1ldGhvZC4gU2hvdWxkIG5vdCBiZSBjYWxsZWQgYnkgYW55d2hlcmUgZXhjZXB0IHtAbGluayBBdXRvbWF0b25XaXRoR1VJI3NldExlbmd0aH0uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBfbGVuZ3RoIERlc2lyZWQgbGVuZ3RoXG4gICAqIEByZXR1cm5zIHt2b2lkfSB2b2lkXG4gICAqL1xuICBjaGFuZ2VMZW5ndGgoIF9sZW5ndGggKSB7XG4gICAgZm9yICggbGV0IGkgPSB0aGlzLl9fbm9kZXMubGVuZ3RoIC0gMTsgMCA8PSBpOyBpIC0tICkge1xuICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuX19ub2Rlc1sgaSBdO1xuICAgICAgaWYgKCBfbGVuZ3RoIDwgbm9kZS50aW1lICkge1xuICAgICAgICB0aGlzLl9fbm9kZXMuc3BsaWNlKCBpLCAxICk7XG4gICAgICB9IGVsc2UgaWYgKCBub2RlLnRpbWUgPT09IF9sZW5ndGggKSB7XG4gICAgICAgIGRlbGV0ZSBub2RlLm91dDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBsYXN0Tm9kZSA9IHRoaXMuX19ub2Rlc1sgdGhpcy5fX25vZGVzLmxlbmd0aCAtIDEgXTtcbiAgICAgICAgaWYgKCBsYXN0Tm9kZSApIHtcbiAgICAgICAgICBsYXN0Tm9kZS5vdXQgPSB7IHRpbWU6IFBhcmFtV2l0aEdVSS5ERUZBVUxUX0hBTkRMRV9MRU5HVEgsIHZhbHVlOiAwLjAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX19ub2Rlcy5wdXNoKCB7XG4gICAgICAgICAgdGltZTogX2xlbmd0aCxcbiAgICAgICAgICB2YWx1ZTogMC4wLFxuICAgICAgICAgIGluOiB7IHRpbWU6IC1QYXJhbVdpdGhHVUkuREVGQVVMVF9IQU5ETEVfTEVOR1RILCB2YWx1ZTogMC4wIH1cbiAgICAgICAgfSApO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKCBsZXQgaSA9IHRoaXMuX19meHMubGVuZ3RoIC0gMTsgMCA8PSBpOyBpIC0tICkge1xuICAgICAgY29uc3QgZnggPSB0aGlzLl9fZnhzWyBpIF07XG4gICAgICBpZiAoIF9sZW5ndGggPCBmeC50aW1lICkge1xuICAgICAgICB0aGlzLl9fZnhzLnNwbGljZSggaSwgMSApO1xuICAgICAgfSBlbHNlIGlmICggX2xlbmd0aCA8IGZ4LnRpbWUgKyBmeC5sZW5ndGggKSB7XG4gICAgICAgIGZ4Lmxlbmd0aCA9IF9sZW5ndGggLSBmeC50aW1lO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX192YWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KCB0aGlzLl9fYXV0b21hdG9uLnJlc29sdXRpb24gKiBfbGVuZ3RoICsgMSApO1xuICAgIHRoaXMucHJlY2FsYygpO1xuICB9XG59O1xuXG4vKipcbiAqIEhhbmRsZXMgb2YgYSBuZXcgbm9kZSB3aWxsIGJlIGNyZWF0ZWQgaW4gdGhpcyBsZW5ndGguXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGNvbnN0YW50XG4gKi9cblBhcmFtV2l0aEdVSS5ERUZBVUxUX0hBTkRMRV9MRU5HVEggPSAwLjU7XG5QYXJhbVdpdGhHVUkuRlhfUk9XX01BWCA9IDQ7XG5cbmV4cG9ydCBkZWZhdWx0IFBhcmFtV2l0aEdVSTsiLCJpbXBvcnQgY3ViaWNCZXppZXIgZnJvbSAnLi9jdWJpYy1iZXppZXInO1xuXG5pbXBvcnQgQXV0b21hdG9uIGZyb20gJy4vbWFpbic7XG5cbi8qKlxuICogSXQgcmVwcmVzZW50cyBhIHBhcmFtIG9mIEF1dG9tYXRvbi5cbiAqIEl0J3MgYGF1dG9tYXRvbi5ub2d1aS5qc2AgdmVyc2lvbiBhbmQgYWxzbyBiYXNlIGNsYXNzIGZvciB7QGxpbmsgUGFyYW1XaXRoR1VJfVxuICogQHBhcmFtIHtPYmplY3R9IF9wcm9wc1xuICogQHBhcmFtIHtBdXRvbWF0b259IF9wcm9wcy5hdXRvbWF0b24gUGFyZW50IGF1dG9tYXRvblxuICogQHBhcmFtIHtPYmplY3R9IFtfcHJvcHMuZGF0YV0gRGF0YSBvZiB0aGUgcGFyYW0uICoqUmVxdWlyZWQgaW4gbm9HVUkgbW9kZSoqXG4gKi9cbmNvbnN0IFBhcmFtID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvciggX3Byb3BzICkge1xuICAgIC8qKlxuICAgICAqIFRoZSBwYXJlbnQgYXV0b21hdG9uLlxuICAgICAqIEB0eXBlIHtBdXRvbWF0b259XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHRoaXMuX19hdXRvbWF0b24gPSBfcHJvcHMuYXV0b21hdG9uO1xuXG4gICAgLyoqXG4gICAgICogQW4gYXJyYXkgb2YgcHJlY2FsY3VsYXRlZCB2YWx1ZS5cbiAgICAgKiBJdHMgbGVuZ3RoIGlzIHNhbWUgYXMgYHBhcmFtLl9fYXV0b21hdG9uLnJlc29sdXRpb24gKiBwYXJhbS5fX2F1dG9tYXRvbi5sZW5ndGggKyAxYC5cbiAgICAgKiBAdHlwZSB7bnVtYmVyW119XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHRoaXMuX192YWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KCB0aGlzLl9fYXV0b21hdG9uLnJlc29sdXRpb24gKiB0aGlzLl9fYXV0b21hdG9uLmxlbmd0aCArIDEgKTtcblxuICAgIHRoaXMubG9hZCggX3Byb3BzLmRhdGEgKTtcblxuICAgIC8qKlxuICAgICAqIEEgYnVmZmVyIG9mIGxhc3QgY2FsY3VsYXRlZCB2YWx1ZS5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICB0aGlzLl9fbGFzdFZhbHVlID0gMC4wO1xuXG4gICAgLyoqXG4gICAgICogV2lsbCBiZSB1c2VkIGZvciBjYWxjdWxhdGlvbiBvZiBgcGFyYW0uX19sYXN0VmFsdWVgLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHRoaXMuX19sYXN0VGltZSA9IDAuMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2FkIGEgcGFyYW0gZGF0YS5cbiAgICogQHBhcmFtIHtvYmplY3R9IF9kYXRhIERhdGEgb2YgcGFyYW1cbiAgICogQHJldHVybnMge3ZvaWR9IHZvaWRcbiAgICovXG4gIGxvYWQoIF9kYXRhICkge1xuICAgIC8qKlxuICAgICAqIExpc3Qgb2Ygbm9kZS5cbiAgICAgKiBAdHlwZSB7UGFyYW1Ob2RlW119XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHRoaXMuX19ub2RlcyA9IF9kYXRhLm5vZGVzO1xuXG4gICAgLyoqXG4gICAgICogTGlzdCBvZiBmeC5cbiAgICAgKiBAdHlwZSB7UGFyYW1GeFN0cmlwW119XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHRoaXMuX19meHMgPSBfZGF0YS5meHM7XG5cbiAgICB0aGlzLnByZWNhbGMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcmVjYWxjdWxhdGUgdmFsdWUgb2YgYSBzYW1wbGUuXG4gICAqIEByZXR1cm5zIHt2b2lkfSB2b2lkXG4gICAqL1xuICBwcmVjYWxjKCkge1xuICAgIGZvciAoIGxldCBpTm9kZSA9IDA7IGlOb2RlIDwgdGhpcy5fX25vZGVzLmxlbmd0aCAtIDE7IGlOb2RlICsrICkge1xuICAgICAgY29uc3Qgbm9kZTAgPSB0aGlzLl9fbm9kZXNbIGlOb2RlIF07XG4gICAgICBjb25zdCBub2RlMSA9IHRoaXMuX19ub2Rlc1sgaU5vZGUgKyAxIF07XG4gICAgICBjb25zdCBpMCA9IE1hdGguZmxvb3IoIG5vZGUwLnRpbWUgKiB0aGlzLl9fYXV0b21hdG9uLnJlc29sdXRpb24gKTtcbiAgICAgIGNvbnN0IGkxID0gTWF0aC5mbG9vciggbm9kZTEudGltZSAqIHRoaXMuX19hdXRvbWF0b24ucmVzb2x1dGlvbiApO1xuXG4gICAgICB0aGlzLl9fdmFsdWVzWyBpMCBdID0gbm9kZTAudmFsdWU7XG4gICAgICBmb3IgKCBsZXQgaSA9IGkwICsgMTsgaSA8PSBpMTsgaSArKyApIHtcbiAgICAgICAgY29uc3QgdGltZSA9IGkgLyB0aGlzLl9fYXV0b21hdG9uLnJlc29sdXRpb247XG4gICAgICAgIGNvbnN0IHZhbHVlID0gY3ViaWNCZXppZXIoIG5vZGUwLCBub2RlMSwgdGltZSApO1xuICAgICAgICB0aGlzLl9fdmFsdWVzWyBpIF0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKCBsZXQgaUZ4ID0gMDsgaUZ4IDwgdGhpcy5fX2Z4cy5sZW5ndGg7IGlGeCArKyApIHtcbiAgICAgIGNvbnN0IGZ4ID0gdGhpcy5fX2Z4c1sgaUZ4IF07XG4gICAgICBpZiAoIGZ4LmJ5cGFzcyApIHsgY29udGludWU7IH1cbiAgICAgIGNvbnN0IGZ4RGVmID0gdGhpcy5fX2F1dG9tYXRvbi5fX3BhcmFtRnhEZWZzWyBmeC5kZWYgXTtcbiAgICAgIGlmICggIWZ4RGVmICkgeyBjb250aW51ZTsgfVxuXG4gICAgICBjb25zdCBpMCA9IE1hdGguY2VpbCggdGhpcy5fX2F1dG9tYXRvbi5yZXNvbHV0aW9uICogZngudGltZSApO1xuICAgICAgY29uc3QgaTEgPSBNYXRoLmZsb29yKCB0aGlzLl9fYXV0b21hdG9uLnJlc29sdXRpb24gKiAoIGZ4LnRpbWUgKyBmeC5sZW5ndGggKSApO1xuXG4gICAgICBjb25zdCB0ZW1wVmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheSggaTEgLSBpMCApO1xuICAgICAgY29uc3QgdGVtcExlbmd0aCA9IHRlbXBWYWx1ZXMubGVuZ3RoO1xuXG4gICAgICBsZXQgY29udGV4dCA9IHtcbiAgICAgICAgaTA6IGkwLFxuICAgICAgICBpMTogaTEsXG4gICAgICAgIHQwOiBmeC50aW1lLFxuICAgICAgICB0MTogZngudGltZSArIGZ4Lmxlbmd0aCxcbiAgICAgICAgZHQ6IDEuMCAvIHRoaXMuX19hdXRvbWF0b24ucmVzb2x1dGlvbixcbiAgICAgICAgcmVzb2x1dGlvbjogdGhpcy5fX2F1dG9tYXRvbi5yZXNvbHV0aW9uLFxuICAgICAgICBsZW5ndGg6IGZ4Lmxlbmd0aCxcbiAgICAgICAgcGFyYW1zOiBmeC5wYXJhbXMsXG4gICAgICAgIGFycmF5OiB0aGlzLl9fdmFsdWVzLFxuICAgICAgICBnZXRWYWx1ZTogdGhpcy5nZXRWYWx1ZS5iaW5kKCB0aGlzICksXG4gICAgICAgIGluaXQ6IHRydWVcbiAgICAgIH07XG5cbiAgICAgIGZvciAoIGxldCBpID0gMDsgaSA8IHRlbXBMZW5ndGg7IGkgKysgKSB7XG4gICAgICAgIGNvbnRleHQuaSA9IGkgKyBpMDtcbiAgICAgICAgY29udGV4dC50ID0gY29udGV4dC5pIC8gdGhpcy5fX2F1dG9tYXRvbi5yZXNvbHV0aW9uO1xuICAgICAgICBjb250ZXh0LnYgPSB0aGlzLl9fdmFsdWVzWyBpICsgaTAgXTtcbiAgICAgICAgY29udGV4dC5wcm9ncmVzcyA9ICggY29udGV4dC50IC0gZngudGltZSApIC8gZngubGVuZ3RoO1xuICAgICAgICB0ZW1wVmFsdWVzWyBpIF0gPSBmeERlZi5mdW5jKCBjb250ZXh0ICk7XG5cbiAgICAgICAgY29udGV4dC5pbml0ID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX192YWx1ZXMuc2V0KCB0ZW1wVmFsdWVzLCBpMCApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIHZhbHVlIG9mIHNwZWNpZmllZCB0aW1lIHBvaW50LlxuICAgKiBAcGFyYW0ge251bWJlcn0ge190aW1lfSBUaW1lIGF0IHRoZSBwb2ludCB5b3Ugd2FudCB0byBncmFiIHRoZSB2YWx1ZS5cbiAgICogSWYgaXQgaXMgbm90IGdpdmVuLCB1c2UgY3VycmVudCB0aW1lIG9mIHBhcmVudCBhdXRvbWF0b24gaW5zdGVhZFxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXN1bHQgdmFsdWVcbiAgICovXG5cbiAgZ2V0VmFsdWUoIF90aW1lICkge1xuICAgIGxldCB0aW1lID0gX3RpbWU7XG4gICAgaWYgKCB0eXBlb2YgdGltZSAhPT0gJ251bWJlcicgKSB7IC8vIHVzZSBwYXJlbnQgYXV0b21hdG9uIHRpbWUgaW5zdGVhZFxuICAgICAgdGltZSA9IHRoaXMuX19hdXRvbWF0b24udGltZTtcbiAgICB9XG5cbiAgICBpZiAoIHRpbWUgPT09IHRoaXMuX19sYXN0VGltZSApIHsgLy8gdXNlIHRoZSBidWZmZXIhXG4gICAgICByZXR1cm4gdGhpcy5fX2xhc3RWYWx1ZTtcbiAgICB9XG5cbiAgICBpZiAoIHRoaXMuX19hdXRvbWF0b24ubG9vcCApIHtcbiAgICAgIHRpbWUgPSB0aW1lIC0gTWF0aC5mbG9vciggdGltZSAvIHRoaXMuX19hdXRvbWF0b24ubGVuZ3RoICkgKiB0aGlzLl9fYXV0b21hdG9uLmxlbmd0aDtcbiAgICB9XG5cbiAgICBpZiAoIHRpbWUgPD0gMC4wICkgeyAvLyBsZWZ0IGNsYW1wXG4gICAgICByZXR1cm4gdGhpcy5fX3ZhbHVlc1sgMCBdO1xuXG4gICAgfSBlbHNlIGlmICggdGhpcy5fX2F1dG9tYXRvbi5sZW5ndGggPD0gdGltZSApIHsgLy8gcmlnaHQgY2xhbXBcbiAgICAgIHJldHVybiB0aGlzLl9fdmFsdWVzWyB0aGlzLl9fdmFsdWVzLmxlbmd0aCAtIDEgXTtcblxuICAgIH0gZWxzZSB7IC8vIGZldGNoIHR3byB2YWx1ZSB0aGVuIGRvIGxpbmVhciBpbnRlcnBvbGF0aW9uXG4gICAgICBjb25zdCBpbmRleCA9IHRpbWUgKiB0aGlzLl9fYXV0b21hdG9uLnJlc29sdXRpb247XG4gICAgICBjb25zdCBpbmRleGkgPSBNYXRoLmZsb29yKCBpbmRleCApO1xuICAgICAgY29uc3QgaW5kZXhmID0gaW5kZXggJSAxLjA7XG5cbiAgICAgIGNvbnN0IHYwID0gdGhpcy5fX3ZhbHVlc1sgaW5kZXhpIF07XG4gICAgICBjb25zdCB2MSA9IHRoaXMuX192YWx1ZXNbIGluZGV4aSArIDEgXTtcblxuICAgICAgY29uc3QgdiA9IHYwICsgKCB2MSAtIHYwICkgKiBpbmRleGY7XG5cbiAgICAgIC8vIHN0b3JlIGxhc3RWYWx1ZVxuICAgICAgdGhpcy5fX2xhc3RUaW1lID0gdGltZTtcbiAgICAgIHRoaXMuX19sYXN0VmFsdWUgPSB2O1xuXG4gICAgICByZXR1cm4gdjtcbiAgICB9XG4gIH1cbn07XG5cbi8vIC0tLS0tLVxuXG5leHBvcnQgZGVmYXVsdCBQYXJhbTsiLCI8dGVtcGxhdGU+XG48ZGl2PlxuICA8ZGl2IGNsYXNzPVwiYmx1ci1sYXllclwiXG4gICAgQG1vdXNlZG93bj1cImJsdXJcIlxuICAvPlxuICA8ZGl2IGNsYXNzPVwicm9vdFwiPlxuICAgIDxpbWcgY2xhc3M9XCJsb2dvLWJnXCJcbiAgICAgIDpzcmM9XCJyZXF1aXJlKCAnLi4vaW1hZ2VzL2F1dG9tYXRvbi1hLnN2ZycgKVwiXG4gICAgLz5cblxuICAgIDxpbWcgY2xhc3M9XCJsb2dvXCJcbiAgICAgIDpzcmM9XCJyZXF1aXJlKCAnLi4vaW1hZ2VzL2F1dG9tYXRvbi5zdmcnIClcIlxuICAgIC8+XG4gICAgPGRpdiBjbGFzcz1cInZlcnNpb25cIj57eyBhdXRvbWF0b24udmVyc2lvbiB9fTwvZGl2PjxiciAvPlxuICAgIEFuaW1hdGlvbiBlbmdpbmUgd2l0aCBUaW1lbGluZSBHVUkgZm9yIGNyZWF0aXZlIGNvZGluZ1xuXG4gICAgPGRpdiBjbGFzcz1cImxvZ28taHJcIj48L2Rpdj5cblxuICAgIEF1dGhvcjogPGEgaHJlZj1cImh0dHBzOi8vZ2l0aHViLmNvbS9mbXMtY2F0L1wiIHRhcmdldD1cIl9ibGFua1wiPkBGTVNfQ2F0PC9hPjxiciAvPlxuICAgIFJlcG9zaXRvcnk6IDxhIGhyZWY9XCJodHRwczovL2dpdGh1Yi5jb20vZm1zLWNhdC9hdXRvbWF0b24vXCIgdGFyZ2V0PVwiX2JsYW5rXCI+aHR0cHM6Ly9naXRodWIuY29tL2Ztcy1jYXQvYXV0b21hdG9uLzwvYT48YnIgLz5cbiAgICBBdXRvbWF0b24gaXMgZGlzdHJpYnV0ZWQgdW5kZXIgcGVybWlzc2l2ZSA8YSBocmVmPVwiaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVRcIiB0YXJnZXQ9XCJfYmxhbmtcIj5NSVQgTGljZW5zZTwvYT4uPGJyIC8+XG4gICAgU2hvdXRvdXRzIHRvIDxhIGhyZWY9XCJodHRwczovL3d3dy5pbWFnZS1saW5lLmNvbS9mbHN0dWRpby9cIiB0YXJnZXQ9XCJfYmxhbmtcIj5JbWFnZSBMaW5lIFNvZnR3YXJlPC9hPiAmbHQ7M1xuXG4gICAgPGltZyBjbGFzcz1cImNsb3NlXCJcbiAgICAgIDpzcmM9XCJyZXF1aXJlKCAnLi4vaW1hZ2VzL2Fib3V0LWNsb3NlLnN2ZycgKVwiXG4gICAgICBAbW91c2Vkb3duPVwiYmx1clwiXG4gICAgLz5cbiAgPC9kaXY+XG48L2Rpdj5cbjwvdGVtcGxhdGU+XG5cblxuPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ2Fib3V0JyxcblxuICBwcm9wczogWyAnYXV0b21hdG9uJyBdLFxuXG4gIGRhdGEoKSB7XG4gICAgcmV0dXJuIHt9XG4gIH0sXG5cbiAgbWV0aG9kczoge1xuICAgIGJsdXIoKSB7XG4gICAgICB0aGlzLiRlbWl0KCAnYmx1cicgKTtcbiAgICB9XG4gIH1cbn1cbjwvc2NyaXB0PlxuXG48c3R5bGUgbGFuZz1cInNjc3NcIiBzY29wZWQ+XG5AaW1wb3J0IFwiLi9jb2xvcnMuc2Nzc1wiO1xuXG4uYmx1ci1sYXllciB7XG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgbGVmdDogMDtcbiAgdG9wOiAwO1xuICB3aWR0aDogMTAwJTtcbiAgaGVpZ2h0OiAxMDAlO1xuXG4gIGJhY2tncm91bmQ6ICMwMDAwMDA2Njtcbn1cblxuLnJvb3Qge1xuICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gIGxlZnQ6IGNhbGMoIDUwJSAtIDE3ZW0gKTtcbiAgdG9wOiAxZW07XG4gIHdpZHRoOiAzMGVtO1xuICBwYWRkaW5nOiAxZW07XG4gIG92ZXJmbG93OiBoaWRkZW47XG5cbiAgYmFja2dyb3VuZDogJGNvbG9yLWJhY2szO1xuICBib3JkZXItcmFkaXVzOiAwLjVlbTtcbiAgY29sb3I6ICRjb2xvci1mb3JlO1xuICBmb250LXNpemU6IDAuOGVtO1xuICBsaW5lLWhlaWdodDogMS4yO1xuXG4gIGZpbHRlcjogZHJvcC1zaGFkb3coIDAgMCAycHggIzAwMDAwMCApO1xuXG4gIGEge1xuICAgIGNvbG9yOiAkY29sb3ItYWNjZW50O1xuICAgIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcblxuICAgICY6aG92ZXIgeyBvcGFjaXR5OiAwLjc7IH1cbiAgfVxuXG4gIC5sb2dvLWJnIHtcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgcmlnaHQ6IC0xZW07XG4gICAgYm90dG9tOiAtMWVtO1xuICAgIHdpZHRoOiAxNGVtO1xuXG4gICAgb3BhY2l0eTogMC4wNztcbiAgfVxuXG4gIC5sb2dvIHtcbiAgICB3aWR0aDogMjBlbTtcbiAgICBtYXJnaW4tYm90dG9tOiAwLjNlbTtcbiAgfVxuXG4gIC52ZXJzaW9uIHtcbiAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XG4gICAgdmVydGljYWwtYWxpZ246IGJvdHRvbTtcbiAgICBtYXJnaW4tbGVmdDogNHB4O1xuICAgIG1hcmdpbi1ib3R0b206IDAuM2VtO1xuICB9XG5cbiAgLmxvZ28taHIge1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIGhlaWdodDogMXB4O1xuICAgIG1hcmdpbjogMC41ZW0gMDtcblxuICAgIGJhY2tncm91bmQ6ICRjb2xvci1mb3Jlc3ViO1xuICB9XG5cbiAgLmNsb3NlIHtcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgcmlnaHQ6IDAuNWVtO1xuICAgIHRvcDogMC41ZW07XG4gICAgd2lkdGg6IDFlbTtcblxuICAgIGN1cnNvcjogcG9pbnRlcjtcblxuICAgICY6aG92ZXIgeyBvcGFjaXR5OiAwLjc7IH1cbiAgfVxufVxuPC9zdHlsZT5cbiIsIjx0ZW1wbGF0ZT5cbjxkaXY+XG4gIDxkaXYgY2xhc3M9XCJibHVyLWxheWVyXCJcbiAgICB2LWlmPVwiYWN0aXZlXCJcbiAgICBAbW91c2Vkb3duPVwiYmx1clwiXG4gIC8+XG4gIDxkaXYgY2xhc3M9XCJyb290XCJcbiAgICB2LWlmPVwiYWN0aXZlXCJcbiAgICA6c3R5bGU9XCJ7XG4gICAgICBsZWZ0OiB0eXBlb2YgbGVmdCA9PT0gJ251bWJlcicgPyBgJHsgbGVmdCB9cHhgIDogdW5kZWZpbmVkLFxuICAgICAgcmlnaHQ6IHR5cGVvZiByaWdodCA9PT0gJ251bWJlcicgPyBgJHsgcmlnaHQgfXB4YCA6IHVuZGVmaW5lZCxcbiAgICAgIHRvcDogdHlwZW9mIHRvcCA9PT0gJ251bWJlcicgPyBgJHsgdG9wIH1weGAgOiB1bmRlZmluZWQsXG4gICAgICBib3R0b206IHR5cGVvZiBib3R0b20gPT09ICdudW1iZXInID8gYCR7IGJvdHRvbSB9cHhgIDogdW5kZWZpbmVkXG4gICAgfVwiXG4gID5cbiAgICA8ZGl2IGNsYXNzPVwiY29tbWFuZFwiXG4gICAgICB2LWZvcj1cIiggY29tbWFuZCwgaW5kZXggKSBpbiBjb21tYW5kc1wiXG4gICAgICA6a2V5PVwiJ2NvbW1hbmQnK2luZGV4XCJcbiAgICAgIEBtb3VzZXVwPVwic2VsZWN0Q29tbWFuZCggaW5kZXggKVwiXG4gICAgPnt7IGNvbW1hbmQudGV4dCB9fTwvZGl2PlxuICA8L2Rpdj5cbjwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ2NvbnRleHQtbWVudScsXG5cbiAgcHJvcHM6IFtcbiAgICAnYWN0aXZlJyxcbiAgICAneCcsXG4gICAgJ3knLFxuICAgICdjb21tYW5kcydcbiAgXSxcblxuICBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBsZWZ0OiAwLFxuICAgICAgcmlnaHQ6IDAsXG4gICAgICB0b3A6IDAsXG4gICAgICBib3R0b206IDBcbiAgICB9O1xuICB9LFxuXG4gIG1ldGhvZHM6IHtcbiAgICBibHVyKCkge1xuICAgICAgdGhpcy4kZW1pdCggJ2JsdXInICk7XG4gICAgfSxcblxuICAgIG1vdmVSb290KCkge1xuICAgICAgY29uc3QgeCA9IHRoaXMueDtcbiAgICAgIGNvbnN0IHkgPSB0aGlzLnk7XG4gICAgICBjb25zdCB3ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoO1xuICAgICAgY29uc3QgaCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQ7XG5cbiAgICAgIGNvbnN0IGJMZWZ0U2lkZSA9IHcgLSAyNDAgPCB4O1xuICAgICAgY29uc3QgYlVwU2lkZSA9IGggLSA0MCA8IHk7XG5cbiAgICAgIHRoaXMubGVmdCA9IGJMZWZ0U2lkZSA/IG51bGwgOiB4O1xuICAgICAgdGhpcy5yaWdodCA9IGJMZWZ0U2lkZSA/ICggdyAtIHggKSA6IG51bGw7XG4gICAgICB0aGlzLnRvcCA9IGJVcFNpZGUgPyBudWxsIDogeTtcbiAgICAgIHRoaXMuYm90dG9tID0gYlVwU2lkZSA/ICggaCAtIHkgKSA6IG51bGw7XG4gICAgfSxcblxuICAgIHNlbGVjdENvbW1hbmQoIGluZGV4ICkge1xuICAgICAgdGhpcy5jb21tYW5kc1sgaW5kZXggXS5mdW5jKCk7XG4gICAgICB0aGlzLiRlbWl0KCAnYmx1cicgKTtcbiAgICB9XG4gIH0sXG5cbiAgd2F0Y2g6IHtcbiAgICB4KCkgeyB0aGlzLm1vdmVSb290KCkgfSxcbiAgICB5KCkgeyB0aGlzLm1vdmVSb290KCkgfVxuICB9XG59O1xuPC9zY3JpcHQ+XG5cbjxzdHlsZSBsYW5nPVwic2Nzc1wiIHNjb3BlZD5cbkBpbXBvcnQgXCIuL2NvbG9ycy5zY3NzXCI7XG5cbi5ibHVyLWxheWVyIHtcbiAgcG9zaXRpb246IGZpeGVkO1xuICBsZWZ0OiAwO1xuICB0b3A6IDA7XG4gIHdpZHRoOiAxMDAlO1xuICBoZWlnaHQ6IDEwMCU7XG59XG5cbi5yb290IHtcbiAgcG9zaXRpb246IGZpeGVkO1xuICB3aGl0ZS1zcGFjZTogbm93cmFwO1xuICBwYWRkaW5nOiAwLjRlbTtcbiAgZm9udC1zaXplOiAwLjhlbTtcblxuICBiYWNrZ3JvdW5kOiByZ2JhKCAwLCAwLCAwLCAwLjUgKTtcbiAgYm9yZGVyOiBzb2xpZCAxcHggJGNvbG9yLWJhY2s0O1xuICBjb2xvcjogJGNvbG9yLWZvcmVzdWI7XG4gIGJvcmRlci1yYWRpdXM6IDAuMmVtO1xuXG4gIGZpbHRlcjogZHJvcC1zaGFkb3coIDAgMCAycHggIzAwMDAwMCApO1xuXG4gIC5jb21tYW5kIHtcbiAgICBwYWRkaW5nLWxlZnQ6IDAuMmVtO1xuICAgIHBhZGRpbmctcmlnaHQ6IDJlbTtcblxuICAgIGJvcmRlci1yYWRpdXM6IDAuMmVtO1xuXG4gICAgY3Vyc29yOiBwb2ludGVyO1xuXG4gICAgJjpob3ZlciB7XG4gICAgICBiYWNrZ3JvdW5kOiAkY29sb3ItYmFjazQ7XG4gICAgICBjb2xvcjogJGNvbG9yLWZvcmU7XG4gICAgfVxuICB9XG59XG48L3N0eWxlPlxuIiwiPHRlbXBsYXRlPlxuPGRpdj5cbiAgPGRpdiBjbGFzcz1cInJvb3RcIj5cbiAgICA8ZGl2IGNsYXNzPVwicm93IHJvdy1jZW50ZXJcIj5cbiAgICAgIDxkaXYgY2xhc3M9XCJsb2dvYm94XCJcbiAgICAgICAgQGNsaWNrLnN0b3A9XCIkZW1pdCggJ2xvZ29DbGlja2VkJyApXCJcbiAgICAgID5cbiAgICAgICAgPGltZyBjbGFzcz1cImxvZ29cIlxuICAgICAgICAgIDpzcmM9XCJyZXF1aXJlKCAnLi4vaW1hZ2VzL2F1dG9tYXRvbi5zdmcnIClcIlxuICAgICAgICAvPlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gICAgPGRpdiBjbGFzcz1cInJvdyByb3ctbGVmdFwiPlxuICAgICAgPGltZyBjbGFzcz1cImJ1dHRvblwiXG4gICAgICAgIDpzcmM9XCJhdXRvbWF0b24uaXNQbGF5aW5nID8gcmVxdWlyZSggJy4uL2ltYWdlcy9wYXVzZS5zdmcnICkgOiByZXF1aXJlKCAnLi4vaW1hZ2VzL3BsYXkuc3ZnJyApXCJcbiAgICAgICAgQGNsaWNrLnN0b3A9XCJhdXRvbWF0b24udG9nZ2xlUGxheSgpXCJcbiAgICAgIC8+XG4gICAgICA8ZGl2IGNsYXNzPVwidGltZVwiXG4gICAgICAgIDpjbGFzcz1cInsgc2Vla2luZzogc2Vla2luZyB9XCJcbiAgICAgICAgQG1vdXNlZG93bi5zdG9wPVwic2Vla1wiXG4gICAgICA+XG4gICAgICAgIDxzcGFuIGNsYXNzPVwiY3VycmVudFwiPnt7IGF1dG9tYXRvbi50aW1lLnRvRml4ZWQoIDMgKSB9fTwvc3Bhbj5cbiAgICAgICAgPHNwYW4gY2xhc3M9XCJsZW5ndGhcIj4gLyB7eyBhdXRvbWF0b24ubGVuZ3RoLnRvRml4ZWQoIDMgKSB9fTwvc3Bhbj5cbiAgICAgICAgPGRpdiBjbGFzcz1cImJhciBiYXItYmdcIlxuICAgICAgICAgIDpzdHlsZT1cInsgd2lkdGg6ICcxMDAlJyB9XCJcbiAgICAgICAgPjwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzPVwiYmFyIGJhci1mZ1wiXG4gICAgICAgICAgOnN0eWxlPVwieyB3aWR0aDogYCR7IGF1dG9tYXRvbi5wcm9ncmVzcyAqIDEwMCB9JWAgfVwiXG4gICAgICAgID48L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJyb3cgcm93LXJpZ2h0XCI+XG4gICAgICA8aW1nIGNsYXNzPVwiYnV0dG9uXCJcbiAgICAgICAgOnNyYz1cInJlcXVpcmUoICcuLi9pbWFnZXMvdW5kby5zdmcnIClcIlxuICAgICAgICA6c3RhbGtlci10ZXh0PVwiYXV0b21hdG9uLmdldFVuZG9EZXNjKCkgPyBgVW5kbzogJHthdXRvbWF0b24uZ2V0VW5kb0Rlc2MoKX1gIDogJ0NhblxcJ3QgdW5kbydcIlxuICAgICAgICBAY2xpY2suc3RvcD1cInVuZG8oKVwiXG4gICAgICAvPlxuICAgICAgPGltZyBjbGFzcz1cImJ1dHRvblwiXG4gICAgICAgIDpzcmM9XCJyZXF1aXJlKCAnLi4vaW1hZ2VzL3JlZG8uc3ZnJyApXCJcbiAgICAgICAgOnN0YWxrZXItdGV4dD1cImF1dG9tYXRvbi5nZXRSZWRvRGVzYygpID8gYFJlZG86ICR7YXV0b21hdG9uLmdldFJlZG9EZXNjKCl9YCA6ICdDYW5cXCd0IHJlZG8nXCJcbiAgICAgICAgQGNsaWNrLnN0b3A9XCJyZWRvKClcIlxuICAgICAgLz5cbiAgICAgIDxpbWcgY2xhc3M9XCJidXR0b25cIlxuICAgICAgICA6c3JjPVwicmVxdWlyZSggJy4uL2ltYWdlcy9zbmFwLnN2ZycgKVwiXG4gICAgICAgIHN0YWxrZXItdGV4dD1cIlNuYXAgU2V0dGluZ3NcIlxuICAgICAgICBAY2xpY2suc3RvcD1cIiRlbWl0KCAnY29uZmlnU2VsZWN0ZWQnLCAnc25hcCcgKVwiXG4gICAgICAvPlxuICAgICAgPGltZyBjbGFzcz1cImJ1dHRvblwiXG4gICAgICAgIDpzcmM9XCJyZXF1aXJlKCAnLi4vaW1hZ2VzL2NvZy5zdmcnIClcIlxuICAgICAgICBzdGFsa2VyLXRleHQ9XCJHZW5lcmFsIENvbmZpZ1wiXG4gICAgICAgIEBjbGljay5zdG9wPVwiJGVtaXQoICdjb25maWdTZWxlY3RlZCcsICdnZW5lcmFsJyApXCJcbiAgICAgIC8+XG4gICAgICA8aW1nIGNsYXNzPVwiYnV0dG9uXCJcbiAgICAgICAgOnNyYz1cInJlcXVpcmUoICcuLi9pbWFnZXMvc2F2ZS5zdmcnIClcIlxuICAgICAgICA6c3RhbGtlci10ZXh0PVwic2F2ZVRleHRcIlxuICAgICAgICBAY2xpY2suc3RvcD1cInNhdmVcIlxuICAgICAgLz5cbiAgICA8L2Rpdj5cbiAgPC9kaXY+XG48L2Rpdj5cbjwvdGVtcGxhdGU+XG5cblxuPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbW91bnRlZCgpIHt9LFxuXG4gIGJlZm9yZURlc3Ryb3koKSB7fSxcblxuICBwcm9wczogWyBcImF1dG9tYXRvblwiIF0sXG5cbiAgZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc2F2ZVRleHQ6ICdDb3B5IGN1cnJlbnQgc3RhdGUgYXMgSlNPTicsXG4gICAgICBzZWVraW5nOiBmYWxzZSxcbiAgICAgIGNhbnRVbmRvVGhpczogMFxuICAgIH1cbiAgfSxcblxuICBtZXRob2RzOiB7XG4gICAgc2VlayggZXZlbnQgKSB7XG4gICAgICBjb25zdCB3aWR0aCA9IGV2ZW50LnRhcmdldC5vZmZzZXRXaWR0aDtcbiAgICAgIGNvbnN0IHhPZmZzZXQwID0gZXZlbnQub2Zmc2V0WDtcbiAgICAgIGNvbnN0IHhDbGllbnQwID0gZXZlbnQuY2xpZW50WDtcblxuICAgICAgY29uc3QgaXNQbGF5aW5nMCA9IHRoaXMuYXV0b21hdG9uLmlzUGxheWluZztcblxuICAgICAgaWYgKCBpc1BsYXlpbmcwICkge1xuICAgICAgICB0aGlzLmF1dG9tYXRvbi5wYXVzZSgpO1xuICAgICAgfVxuICAgICAgdGhpcy5hdXRvbWF0b24uc2VlayggdGhpcy5hdXRvbWF0b24ubGVuZ3RoICogeE9mZnNldDAgLyB3aWR0aCApO1xuXG4gICAgICB0aGlzLnNlZWtpbmcgPSB0cnVlO1xuXG4gICAgICBjb25zdCBtb3ZlID0gKCBldmVudCApID0+IHtcbiAgICAgICAgY29uc3QgeCA9IHhPZmZzZXQwICsgZXZlbnQuY2xpZW50WCAtIHhDbGllbnQwO1xuICAgICAgICB0aGlzLmF1dG9tYXRvbi5zZWVrKCB0aGlzLmF1dG9tYXRvbi5sZW5ndGggKiB4IC8gd2lkdGggKTtcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHVwID0gKCBldmVudCApID0+IHtcbiAgICAgICAgaWYgKCBpc1BsYXlpbmcwICkge1xuICAgICAgICAgIHRoaXMuYXV0b21hdG9uLnBsYXkoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlZWtpbmcgPSBmYWxzZTtcblxuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ21vdXNlbW92ZScsIG1vdmUgKTtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoICdtb3VzZXVwJywgdXAgKTtcbiAgICAgIH07XG5cbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCAnbW91c2Vtb3ZlJywgbW92ZSApO1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoICdtb3VzZXVwJywgdXAgKTtcbiAgICB9LFxuXG4gICAgdW5kbygpIHtcbiAgICAgIGlmICggdGhpcy5hdXRvbWF0b24uZ2V0VW5kb0Rlc2MoKSApIHtcbiAgICAgICAgdGhpcy5hdXRvbWF0b24udW5kbygpO1xuICAgICAgICB0aGlzLmNhbnRVbmRvVGhpcyA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNhbnRVbmRvVGhpcyArKztcbiAgICAgICAgaWYgKCAxMCA9PT0gdGhpcy5jYW50VW5kb1RoaXMgKSB7XG4gICAgICAgICAgd2luZG93Lm9wZW4oICdodHRwczovL3lvdXR1LmJlL2J6WTdKMFhsZTA4JywgJ19ibGFuaycgKTtcbiAgICAgICAgICB0aGlzLmNhbnRVbmRvVGhpcyA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy4kZW1pdCggJ2hpc3RvcnlNb3ZlZCcgKTtcbiAgICB9LFxuXG4gICAgcmVkbygpIHtcbiAgICAgIHRoaXMuYXV0b21hdG9uLnJlZG8oKTtcblxuICAgICAgdGhpcy4kZW1pdCggJ2hpc3RvcnlNb3ZlZCcgKTtcbiAgICB9LFxuXG4gICAgc2F2ZSgpIHtcbiAgICAgIGNvbnN0IGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ3RleHRhcmVhJyApO1xuICAgICAgZWwudmFsdWUgPSB0aGlzLmF1dG9tYXRvbi5zYXZlKCk7XG4gICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKCBlbCApO1xuICAgICAgZWwuc2VsZWN0KCk7XG4gICAgICBkb2N1bWVudC5leGVjQ29tbWFuZCggJ2NvcHknICk7XG4gICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKCBlbCApO1xuXG4gICAgICB0aGlzLnNhdmVUZXh0ID0gJ0NvcGllZCEnO1xuICAgICAgc2V0VGltZW91dCggKCkgPT4ge1xuICAgICAgICB0aGlzLnNhdmVUZXh0ID0gJ0NvcHkgY3VycmVudCBzdGF0ZSBhcyBKU09OJztcbiAgICAgIH0sIDMwMDAgKTtcbiAgICB9XG4gIH1cbn1cbjwvc2NyaXB0PlxuXG48c3R5bGUgbGFuZz1cInNjc3NcIiBzY29wZWQ+XG5AaW1wb3J0IFwiLi9jb2xvcnMuc2Nzc1wiO1xuXG4ucm9vdCB7XG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgbGVmdDogMDtcbiAgdG9wOiAwO1xuICB3aWR0aDogMTAwJTtcbiAgaGVpZ2h0OiAxMDAlO1xuXG4gIGJhY2tncm91bmQ6ICRjb2xvci1iYWNrNDtcblxuICAucm93IHtcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgaGVpZ2h0OiBjYWxjKCAxMDAlIC0gMC4yNWVtICk7XG4gICAgbWFyZ2luOiAwLjEyNWVtO1xuXG4gICAgJi5yb3ctY2VudGVyIHtcbiAgICAgIHdpZHRoOiBjYWxjKCAxMDAlIC0gMC4yNWVtICk7XG4gICAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XG4gICAgfVxuICAgICYucm93LWxlZnQgeyBsZWZ0OiAwLjEyNWVtOyB9XG4gICAgJi5yb3ctcmlnaHQgeyByaWdodDogMC4xMjVlbTsgfVxuXG4gICAgJiA+ICoge1xuICAgICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xuICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgdmVydGljYWwtYWxpZ246IGJvdHRvbTtcbiAgICAgIG1hcmdpbjogMCAwLjEyNWVtO1xuICAgICAgaGVpZ2h0OiAxMDAlO1xuICAgIH1cblxuICAgIC5sb2dvYm94IHtcbiAgICAgIGNvbG9yOiAkY29sb3ItZm9yZTtcbiAgICAgIG9wYWNpdHk6IDAuNTtcblxuICAgICAgY3Vyc29yOiBwb2ludGVyO1xuXG4gICAgICAmOmhvdmVyIHsgb3BhY2l0eTogMC44OyB9XG5cbiAgICAgIC5sb2dvIHtcbiAgICAgICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgIGhlaWdodDogNjAlO1xuICAgICAgICB0b3A6IDIwJTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAuYnV0dG9uIHtcbiAgICAgIGhlaWdodDogMTAwJTtcblxuICAgICAgY3Vyc29yOiBwb2ludGVyO1xuXG4gICAgICAmOmhvdmVyIHsgb3BhY2l0eTogMC43OyB9XG4gICAgfVxuXG4gICAgLnRpbWUge1xuICAgICAgd2lkdGg6IDhlbTtcblxuICAgICAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcbiAgICAgIHRleHQtYWxpZ246IHJpZ2h0O1xuXG4gICAgICBjdXJzb3I6IHBvaW50ZXI7XG5cbiAgICAgICoge1xuICAgICAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcbiAgICAgIH1cblxuICAgICAgLmN1cnJlbnQge1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgIGZvbnQtc2l6ZTogMC44ZW07XG4gICAgICAgIG1hcmdpbi1yaWdodDogMDtcblxuICAgICAgICBjb2xvcjogJGNvbG9yLWZvcmU7XG5cbiAgICAgIH1cblxuICAgICAgLmxlbmd0aCB7XG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgZm9udC1zaXplOiAwLjZlbTtcbiAgICAgICAgbWFyZ2luLWxlZnQ6IDA7XG5cbiAgICAgICAgY29sb3I6ICRjb2xvci1mb3Jlc3ViO1xuICAgICAgfVxuXG4gICAgICAuYmFyIHtcbiAgICAgICAgZGlzcGxheTogYmxvY2s7XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgYm90dG9tOiAwLjI1ZW07XG4gICAgICAgIGxlZnQ6IDBweDtcbiAgICAgICAgaGVpZ2h0OiAycHg7XG4gICAgICAgIG1hcmdpbjogMDtcblxuICAgICAgICAmLmJhci1iZyB7IGJhY2tncm91bmQ6ICRjb2xvci1ibGFjazsgfVxuICAgICAgICAmLmJhci1mZyB7IGJhY2tncm91bmQ6ICRjb2xvci1mb3JlOyB9XG4gICAgICB9XG5cbiAgICAgICY6aG92ZXIge1xuICAgICAgICAuYmFyLWZnIHsgYmFja2dyb3VuZDogJGNvbG9yLWFjY2VudDsgfVxuICAgICAgfVxuXG4gICAgICAmLnNlZWtpbmcge1xuICAgICAgICAuYmFyLWZnIHsgYmFja2dyb3VuZDogJGNvbG9yLWFjY2VudDsgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuPC9zdHlsZT5cblxuIiwiPHRlbXBsYXRlPlxuPGRpdj5cbiAgPGRpdiBjbGFzcz1cInJvb3QgYXV0b21hdG9uIGNvbG9yLXRoZW1lLWRhcmtcIj5cbiAgICA8SGVhZGVyIGNsYXNzPVwiaGVhZGVyXCJcbiAgICAgIDphdXRvbWF0b249XCJhdXRvbWF0b25cIlxuICAgICAgQGhpc3RvcnlNb3ZlZD1cIm9uSGlzdG9yeU1vdmVkXCJcbiAgICAgIEBjb25maWdTZWxlY3RlZD1cIm9uQ29uZmlnU2VsZWN0ZWRcIlxuICAgICAgQGNvbnRleHQ9XCJvcGVuQ29udGV4dE1lbnVcIlxuICAgICAgQGxvZ29DbGlja2VkPVwiYWJvdXRBY3RpdmUgPSB0cnVlXCJcbiAgICAvPlxuICAgIDxQYXJhbUxpc3QgY2xhc3M9XCJwYXJhbWxpc3RcIlxuICAgICAgOmF1dG9tYXRvbj1cImF1dG9tYXRvblwiXG4gICAgICA6c2VsZWN0ZWRQYXJhbU5hbWU9XCJzZWxlY3RlZFBhcmFtTmFtZVwiXG4gICAgICBAc2VsZWN0ZWQ9XCJzZWxlY3RQYXJhbSggJGV2ZW50IClcIlxuICAgICAgQGNvbnRleHQ9XCJvcGVuQ29udGV4dE1lbnVcIlxuICAgIC8+XG4gICAgPFByb3BNZW51IGNsYXNzPVwicHJvcG1lbnVcIlxuICAgICAgOmF1dG9tYXRvbj1cImF1dG9tYXRvblwiXG4gICAgICA6c2VsZWN0ZWRQYXJhbU5hbWU9XCJzZWxlY3RlZFBhcmFtTmFtZVwiXG4gICAgICA6c2VsZWN0ZWROb2RlSWRzPVwic2VsZWN0ZWROb2RlSWRzXCJcbiAgICAgIDpzZWxlY3RlZEZ4SWRzPVwic2VsZWN0ZWRGeElkc1wiXG4gICAgICA6Y29uZmlnPVwiY29uZmlnXCJcbiAgICAgIEBjb250ZXh0PVwib3BlbkNvbnRleHRNZW51XCJcbiAgICAvPlxuICAgIDxUaW1lbGluZSBjbGFzcz1cInRpbWVsaW5lXCJcbiAgICAgIDphdXRvbWF0b249XCJhdXRvbWF0b25cIlxuICAgICAgOnNlbGVjdGVkUGFyYW1OYW1lPVwic2VsZWN0ZWRQYXJhbU5hbWVcIlxuICAgICAgOnNlbGVjdGVkTm9kZUlkcz1cInNlbGVjdGVkTm9kZUlkc1wiXG4gICAgICA6c2VsZWN0ZWRGeElkcz1cInNlbGVjdGVkRnhJZHNcIlxuICAgICAgQG5vZGVTZWxlY3RlZD1cInNlbGVjdE5vZGVzKCAkZXZlbnQgKVwiXG4gICAgICBAZnhTZWxlY3RlZD1cInNlbGVjdEZ4cyggJGV2ZW50IClcIlxuICAgICAgQGNvbnRleHQ9XCJvcGVuQ29udGV4dE1lbnVcIlxuICAgIC8+XG5cbiAgICA8QWJvdXQgY2xhc3M9XCJhYm91dFwiXG4gICAgICB2LWlmPVwiYWJvdXRBY3RpdmVcIlxuICAgICAgOmF1dG9tYXRvbj1cImF1dG9tYXRvblwiXG4gICAgICBAYmx1cj1cImFib3V0QWN0aXZlID0gZmFsc2VcIlxuICAgIC8+XG5cbiAgICA8Q29udGV4dE1lbnUgY2xhc3M9XCJjb250ZXh0LW1lbnVcIlxuICAgICAgOmFjdGl2ZT1cImNvbnRleHRNZW51QWN0aXZlXCJcbiAgICAgIDp4PVwiY29udGV4dE1lbnVYXCJcbiAgICAgIDp5PVwiY29udGV4dE1lbnVZXCJcbiAgICAgIDpjb21tYW5kcz1cImNvbnRleHRNZW51Q29tbWFuZHNcIlxuICAgICAgQGJsdXI9XCJjb250ZXh0TWVudUFjdGl2ZSA9IGZhbHNlXCJcbiAgICAvPlxuICAgIDxTdGFsa2VyIGNsYXNzPVwic3RhbGtlclwiIC8+XG4gIDwvZGl2PlxuPC9kaXY+XG48L3RlbXBsYXRlPlxuXG5cbjxzY3JpcHQ+XG5pbXBvcnQgQWJvdXQgZnJvbSAnLi9hYm91dC52dWUnO1xuaW1wb3J0IEhlYWRlciBmcm9tICcuL2hlYWRlci52dWUnO1xuaW1wb3J0IFBhcmFtTGlzdCBmcm9tICcuL3BhcmFtbGlzdC52dWUnO1xuaW1wb3J0IFByb3BNZW51IGZyb20gJy4vcHJvcG1lbnUudnVlJztcbmltcG9ydCBUaW1lbGluZSBmcm9tICcuL3RpbWVsaW5lLnZ1ZSc7XG5pbXBvcnQgQ29udGV4dE1lbnUgZnJvbSAnLi9jb250ZXh0LW1lbnUudnVlJztcbmltcG9ydCBTdGFsa2VyIGZyb20gJy4vc3RhbGtlci52dWUnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGNvbXBvbmVudHM6IHtcbiAgICBBYm91dCxcbiAgICBIZWFkZXIsXG4gICAgUGFyYW1MaXN0LFxuICAgIFByb3BNZW51LFxuICAgIFRpbWVsaW5lLFxuICAgIENvbnRleHRNZW51LFxuICAgIFN0YWxrZXJcbiAgfSxcblxuICBwcm9wczogWyAnYXV0b21hdG9uJyBdLFxuXG4gIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFib3V0QWN0aXZlOiBmYWxzZSxcbiAgICAgIHNlbGVjdGVkUGFyYW1OYW1lOiBudWxsLFxuICAgICAgc2VsZWN0ZWROb2RlSWRzOiBbXSxcbiAgICAgIHNlbGVjdGVkRnhJZHM6IFtdLFxuICAgICAgY29uZmlnOiAnJyxcbiAgICAgIGNvbnRleHRNZW51QWN0aXZlOiBmYWxzZSxcbiAgICAgIGNvbnRleHRNZW51WDogMCxcbiAgICAgIGNvbnRleHRNZW51WTogMCxcbiAgICAgIGNvbnRleHRNZW51Q29tbWFuZHM6IFtdXG4gICAgfVxuICB9LFxuXG4gIG1ldGhvZHM6IHtcbiAgICBzZWxlY3RQYXJhbSggbmFtZSApIHtcbiAgICAgIHRoaXMuc2VsZWN0ZWRQYXJhbU5hbWUgPSBuYW1lO1xuICAgICAgdGhpcy5zZWxlY3ROb2RlcyggW10gKTtcbiAgICAgIHRoaXMuc2VsZWN0RnhzKCBbXSApO1xuICAgIH0sXG5cbiAgICBzZWxlY3ROb2RlcyggYXJyICkge1xuICAgICAgdGhpcy5zZWxlY3RlZE5vZGVJZHMgPSBhcnI7XG4gICAgICB0aGlzLmNvbmZpZyA9ICcnO1xuICAgIH0sXG5cbiAgICBzZWxlY3RGeHMoIGFyciApIHtcbiAgICAgIHRoaXMuc2VsZWN0ZWRGeElkcyA9IGFycjtcbiAgICAgIHRoaXMuY29uZmlnID0gJyc7XG4gICAgfSxcblxuICAgIG9uSGlzdG9yeU1vdmVkKCkge1xuICAgICAgdGhpcy5zZWxlY3ROb2RlcyggW10gKTtcbiAgICAgIHRoaXMuc2VsZWN0RnhzKCBbXSApO1xuICAgIH0sXG5cbiAgICBvbkNvbmZpZ1NlbGVjdGVkKCBjb25maWcgKSB7XG4gICAgICB0aGlzLnNlbGVjdE5vZGVzKCBbXSApO1xuICAgICAgdGhpcy5zZWxlY3RGeHMoIFtdICk7XG4gICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICB9LFxuXG4gICAgb3BlbkNvbnRleHRNZW51KCBldmVudCApIHtcbiAgICAgIHRoaXMuY29udGV4dE1lbnVBY3RpdmUgPSB0cnVlO1xuICAgICAgdGhpcy5jb250ZXh0TWVudVggPSBldmVudC5jbGllbnRYO1xuICAgICAgdGhpcy5jb250ZXh0TWVudVkgPSBldmVudC5jbGllbnRZO1xuICAgICAgdGhpcy5jb250ZXh0TWVudUNvbW1hbmRzID0gZXZlbnQuY29tbWFuZHM7XG4gICAgfVxuICB9LFxuICBcbiAgbW91bnRlZCgpIHtcbiAgICB0aGlzLiRyb290LiRvbiggJ2xvYWRlZCcsICgpID0+IHtcbiAgICAgIHRoaXMuc2VsZWN0UGFyYW0oIG51bGwgKTtcbiAgICAgIHRoaXMuc2VsZWN0Tm9kZXMoIFtdICk7XG4gICAgICB0aGlzLnNlbGVjdEZ4cyggW10gKTtcbiAgICAgIHRoaXMuY29uZmlnID0gJyc7XG4gICAgfSApO1xuICB9LFxuXG4gIGJlZm9yZURlc3Ryb3koKSB7fVxufVxuPC9zY3JpcHQ+XG5cbjxzdHlsZSBsYW5nPVwic2Nzc1wiPlxuQGltcG9ydCB1cmwoJ2h0dHBzOi8vZm9udHMuZ29vZ2xlYXBpcy5jb20vY3NzP2ZhbWlseT1Sb2JvdG86MzAwLDQwMCw1MDAsNzAwLDkwMCcpO1xuXG4uYXV0b21hdG9uIHtcbiAgZm9udC1mYW1pbHk6ICdSb2JvdG8nLCBzYW5zLXNlcmlmO1xuICBmb250LXdlaWdodDogMzAwO1xuICBmb250LXNpemU6IDE2cHg7XG59XG48L3N0eWxlPlxuXG48c3R5bGUgbGFuZz1cInNjc3NcIiBzY29wZWQ+XG5AaW1wb3J0IFwiLi9jb2xvcnMuc2Nzc1wiO1xuXG4ucm9vdCB7XG4gIHVzZXItc2VsZWN0OiBub25lO1xuXG4gICRoZWFkZXItaGVpZ2h0OiAyZW07XG4gIC5oZWFkZXIge1xuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICBsZWZ0OiAwO1xuICAgIHRvcDogMDtcbiAgICB3aWR0aDogMTAwJTtcbiAgICBoZWlnaHQ6ICRoZWFkZXItaGVpZ2h0O1xuICB9XG5cbiAgJHBhcmFtbGlzdC13aWR0aDogOGVtO1xuICAucGFyYW1saXN0IHtcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgbGVmdDogMDtcbiAgICB0b3A6ICRoZWFkZXItaGVpZ2h0O1xuICAgIHdpZHRoOiAkcGFyYW1saXN0LXdpZHRoO1xuICAgIGhlaWdodDogY2FsYyggMTAwJSAtICN7JGhlYWRlci1oZWlnaHR9ICk7XG4gIH1cblxuICAkcHJvcG1lbnUtd2lkdGg6IDEyZW07XG4gIC5wcm9wbWVudSB7XG4gICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgIHJpZ2h0OiAwO1xuICAgIHRvcDogJGhlYWRlci1oZWlnaHQ7XG4gICAgd2lkdGg6ICRwcm9wbWVudS13aWR0aDtcbiAgICBoZWlnaHQ6IGNhbGMoIDEwMCUgLSAjeyRoZWFkZXItaGVpZ2h0fSApO1xuICB9XG5cbiAgLnRpbWVsaW5lIHtcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgbGVmdDogJHBhcmFtbGlzdC13aWR0aDtcbiAgICB0b3A6ICRoZWFkZXItaGVpZ2h0O1xuICAgIHdpZHRoOiBjYWxjKCAxMDAlIC0gI3skcGFyYW1saXN0LXdpZHRoICsgJHByb3BtZW51LXdpZHRofSApO1xuICAgIGhlaWdodDogY2FsYyggMTAwJSAtICN7JGhlYWRlci1oZWlnaHR9ICk7XG4gIH1cbn1cbjwvc3R5bGU+XG5cbiIsIjx0ZW1wbGF0ZT5cbjxkaXY+XG4gIDxTY3JvbGxhYmxlIGNsYXNzPVwicm9vdFwiXG4gICAgYmFyPVwibGVmdFwiXG4gID5cbiAgICA8ZGl2IGNsYXNzPVwicGFyYW1cIlxuICAgICAgdi1mb3I9XCJuYW1lIGluIGF1dG9tYXRvbi5nZXRQYXJhbU5hbWVzKClcIlxuICAgICAgOmtleT1cIidwYXJhbScgKyBuYW1lXCJcbiAgICAgIDpjbGFzcz1cInsgc2VsZWN0ZWQ6IG5hbWUgPT09IHNlbGVjdGVkUGFyYW1OYW1lIH1cIlxuICAgICAgOnN0YWxrZXItdGV4dD1cIm5hbWVcIlxuICAgICAgQGNsaWNrPVwiJGVtaXQoICdzZWxlY3RlZCcsIG5hbWUgKVwiXG4gICAgICBAY29udGV4dG1lbnUuc3RvcC5wcmV2ZW50PVwiY29udGV4dFBhcmFtKCAkZXZlbnQsIG5hbWUgKVwiXG4gICAgPlxuICAgICAgPGRpdiBjbGFzcz1cIm5hbWVcIlxuICAgICAgICA6c3RhbGtlci10ZXh0PVwibmFtZVwiXG4gICAgICA+e3sgbmFtZSB9fTwvZGl2PlxuICAgICAgPGRpdiBjbGFzcz1cInZhbHVlXCJcbiAgICAgICAgdi1pZj1cImF1dG9tYXRvbi5nZXRQYXJhbSggbmFtZSApLmlzVXNlZCgpXCJcbiAgICAgICAgOnN0YWxrZXItdGV4dD1cIm5hbWVcIlxuICAgICAgPnt7IGF1dG9tYXRvbi5hdXRvKCBuYW1lICkudG9GaXhlZCggMyApIH19PC9kaXY+XG4gICAgICA8aW1nIGNsYXNzPVwid2FybmluZ1wiXG4gICAgICAgIHYtaWY9XCIhYXV0b21hdG9uLmdldFBhcmFtKCBuYW1lICkuaXNVc2VkKClcIlxuICAgICAgICA6c3JjPVwicmVxdWlyZSggJy4uL2ltYWdlcy93YXJuaW5nLnN2ZycgKVwiXG4gICAgICAgIHN0YWxrZXItdGV4dD1cIlRoaXMgcGFyYW0gaGFzIG5vdCBiZWVuIHVzZWQgeWV0XCJcbiAgICAgIC8+XG4gICAgPC9kaXY+XG4gIDwvU2Nyb2xsYWJsZT5cbjwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCBTY3JvbGxhYmxlIGZyb20gJy4vc2Nyb2xsYWJsZS52dWUnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGNvbXBvbmVudHM6IHtcbiAgICBTY3JvbGxhYmxlXG4gIH0sXG5cbiAgcHJvcHM6IFsgXCJhdXRvbWF0b25cIiwgXCJzZWxlY3RlZFBhcmFtTmFtZVwiIF0sXG5cbiAgZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgIH1cbiAgfSxcblxuICBtZXRob2RzOiB7XG4gICAgY29udGV4dFBhcmFtKCBldmVudCwgbmFtZSApIHtcbiAgICAgIHRoaXMuJGVtaXQoICdjb250ZXh0Jywge1xuICAgICAgICBjbGllbnRYOiBldmVudC5jbGllbnRYLFxuICAgICAgICBjbGllbnRZOiBldmVudC5jbGllbnRZLFxuICAgICAgICBjb21tYW5kczogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRleHQ6ICdTZWxlY3QgUGFyYW0nLFxuICAgICAgICAgICAgZnVuYzogKCkgPT4ge1xuICAgICAgICAgICAgICB0aGlzLiRlbWl0KCAnc2VsZWN0ZWQnLCBuYW1lICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0ZXh0OiAnUmVtb3ZlIFBhcmFtJyxcbiAgICAgICAgICAgIGZ1bmM6ICgpID0+IHtcbiAgICAgICAgICAgICAgdGhpcy5hdXRvbWF0b24ucmVtb3ZlUGFyYW0oIG5hbWUgKTtcbiAgICAgICAgICAgICAgdGhpcy4kZW1pdCggJ3NlbGVjdGVkJywgbnVsbCApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgICAgfSApO1xuICAgIH1cbiAgfVxufVxuPC9zY3JpcHQ+XG5cbjxzdHlsZSBsYW5nPVwic2Nzc1wiIHNjb3BlZD5cbkBpbXBvcnQgXCIuL2NvbG9ycy5zY3NzXCI7XG5cbi5yb290IHtcbiAgcG9zaXRpb246IGFic29sdXRlO1xuICBsZWZ0OiAwO1xuICB0b3A6IDA7XG4gIHdpZHRoOiAxMDAlO1xuICBoZWlnaHQ6IDEwMCU7XG5cbiAgYmFja2dyb3VuZDogJGNvbG9yLWJhY2syO1xuICBjb2xvcjogJGNvbG9yLWZvcmU7XG5cbiAgLnBhcmFtIHtcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgd2lkdGg6IGNhbGMoIDEwMCUgLSA0cHggKTtcbiAgICBoZWlnaHQ6IDEuMjVlbTtcbiAgICBtYXJnaW46IDJweDtcblxuICAgIGJhY2tncm91bmQ6ICRjb2xvci1iYWNrMztcbiAgICBjb2xvcjogJGNvbG9yLWZvcmVzdWI7XG5cbiAgICBjdXJzb3I6IHBvaW50ZXI7XG5cbiAgICAmLnNlbGVjdGVkIHtcbiAgICAgIGJhY2tncm91bmQ6ICRjb2xvci1iYWNrNDtcbiAgICAgIGNvbG9yOiAkY29sb3ItZm9yZTtcbiAgICB9XG5cbiAgICAubmFtZSB7XG4gICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICBsZWZ0OiAwLjJlbTtcbiAgICAgIHRvcDogMDtcbiAgICAgIHdpZHRoOiBjYWxjKCAxMDAlIC0gMmVtICk7XG4gICAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgICAgdGV4dC1vdmVyZmxvdzogZWxsaXBzaXM7XG4gICAgICB3aGl0ZS1zcGFjZTogbm93cmFwO1xuXG4gICAgICB1c2VyLXNlbGVjdDogbm9uZTtcbiAgICB9XG5cbiAgICAudmFsdWUge1xuICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgcmlnaHQ6IDAuMmVtO1xuICAgICAgYm90dG9tOiAwLjFlbTtcblxuICAgICAgZm9udC1zaXplOiAwLjZlbTtcbiAgICAgIG9wYWNpdHk6IDAuNztcblxuICAgICAgdXNlci1zZWxlY3Q6IG5vbmU7XG4gICAgfVxuXG4gICAgLndhcm5pbmcge1xuICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgcmlnaHQ6IDAuMWVtO1xuICAgICAgYm90dG9tOiAwLjFlbTtcbiAgICAgIGhlaWdodDogY2FsYyggMTAwJSAtIDAuMmVtICk7XG4gICAgfVxuICB9XG59XG48L3N0eWxlPlxuXG4iLCI8dGVtcGxhdGU+XG48ZGl2PlxuICA8ZGl2IGNsYXNzPVwicHJvcGJveFwiPlxuICAgIDxkaXYgY2xhc3M9XCJuYW1lXCI+e3sgbmFtZSB9fTwvZGl2PlxuXG4gICAgPGRpdiBjbGFzcz1cInZhbHVlIG51bWJlclwiXG4gICAgICB2LWlmPVwidHlwZSA9PT0gJ2Zsb2F0JyB8fCB0eXBlID09PSAnaW50J1wiXG4gICAgICA6Y2xhc3M9XCJ7IHJlYWRvbmx5OiByZWFkb25seSB9XCJcbiAgICA+XG4gICAgICA8ZGl2IGNsYXNzPVwidmFsdWVUZXh0XCJcbiAgICAgICAgOmNsYXNzPVwieyByZWFkb25seTogcmVhZG9ubHkgfVwiXG4gICAgICAgIEBtb3VzZWRvd249XCJuTW91c2Vkb3duXCJcbiAgICAgID57eyB0eXBlID09PSAnaW50JyA/IHZhbHVlIDogdmFsdWUudG9GaXhlZCggMyApIH19PC9kaXY+XG4gICAgICA8aW5wdXQgY2xhc3M9XCJ2YWx1ZUlucHV0XCJcbiAgICAgICAgcmVmPVwidmFsdWVJbnB1dFwiXG4gICAgICAgIHYtc2hvdz1cImlucHV0XCJcbiAgICAgICAgQGtleWRvd24uZW50ZXI9XCJuRW50ZXJcIlxuICAgICAgICBAYmx1cj1cIm5CbHVyXCJcbiAgICAgIC8+XG4gICAgPC9kaXY+XG5cbiAgICA8ZGl2IGNsYXNzPVwidmFsdWUgYm9vbGVhblwiXG4gICAgICB2LWlmPVwidHlwZSA9PT0gJ2Jvb2xlYW4nXCJcbiAgICAgIDpjbGFzcz1cInsgcmVhZG9ubHk6IHJlYWRvbmx5IH1cIlxuICAgICAgQGNsaWNrPVwiYlRvZ2dsZVwiXG4gICAgPlxuICAgICAgPGRpdiBjbGFzcz1cImJvb2xlYW5DaGVja1wiXG4gICAgICAgIHYtc2hvdz1cInZhbHVlXCJcbiAgICAgID48L2Rpdj5cbiAgICA8L2Rpdj5cbiAgPC9kaXY+XG48L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5jb25zdCBtb3VzZUV2ZW50cyA9ICggbW92ZSwgdXAgKSA9PiB7XG4gIGNvbnN0IHUgPSAoIGV2ZW50ICkgPT4ge1xuICAgIGlmICggdHlwZW9mIHVwID09PSBcImZ1bmN0aW9uXCIgKSB7IHVwKCBldmVudCApOyB9IFxuXG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoIFwibW91c2Vtb3ZlXCIsIG1vdmUgKTtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lciggXCJtb3VzZXVwXCIsIHUgKTtcbiAgfTtcblxuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggXCJtb3VzZW1vdmVcIiwgbW92ZSApO1xuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggXCJtb3VzZXVwXCIsIHUgKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ3Byb3Bib3gnLFxuXG4gIHByb3BzOiBbXG4gICAgJ25hbWUnLFxuICAgICd2YWx1ZScsXG4gICAgJ3R5cGUnLFxuICAgICdtaW4nLFxuICAgICdtYXgnLFxuICAgICdyZWFkb25seSdcbiAgXSxcblxuICBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBpbnB1dDogZmFsc2UsXG4gICAgICBsYXN0Q2xpY2s6IDBcbiAgICB9O1xuICB9LFxuXG4gIG1ldGhvZHM6IHtcbiAgICBuTW91c2Vkb3duKCBldmVudCApIHtcbiAgICAgIGlmICggdGhpcy5yZWFkb25seSApIHsgcmV0dXJuOyB9XG5cbiAgICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgICBpZiAoIG5vdyAtIHRoaXMubGFzdENsaWNrIDwgNTAwICkgeyAvLyBkb3VibGVjbGlja1xuICAgICAgICB0aGlzLmlucHV0ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy4kcmVmcy52YWx1ZUlucHV0LnZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICAgICAgc2V0VGltZW91dCggKCkgPT4ge1xuICAgICAgICAgIHRoaXMuJHJlZnMudmFsdWVJbnB1dC5mb2N1cygpO1xuICAgICAgICAgIHRoaXMuJHJlZnMudmFsdWVJbnB1dC5zZWxlY3QoKTtcbiAgICAgICAgfSwgMTAgKTsgLy8g8J+UpVxuICAgICAgfVxuICAgICAgdGhpcy5sYXN0Q2xpY2sgPSBub3c7XG5cbiAgICAgIGNvbnN0IHkwID0gZXZlbnQuY2xpZW50WTtcbiAgICAgIGxldCBsYXN0WSA9IHkwO1xuICAgICAgY29uc3QgdjAgPSBOdW1iZXIoIHRoaXMudmFsdWUgKTtcblxuICAgICAgbW91c2VFdmVudHMoICggZXZlbnQgKSA9PiB7XG4gICAgICAgIGxldCB2ID0gTnVtYmVyKCB0aGlzLnZhbHVlICk7XG4gICAgICAgIGNvbnN0IHkgPSBldmVudC5jbGllbnRZO1xuICAgICAgICBjb25zdCBkeSA9IGxhc3RZIC0geTtcbiAgICAgICAgbGFzdFkgPSB5O1xuXG4gICAgICAgIGlmICggdGhpcy50eXBlID09PSAnaW50JyApIHtcbiAgICAgICAgICB2ID0gdjAgLSBNYXRoLmZsb29yKCAoIHkgLSB5MCApIC8gMTAuMCApO1xuICAgICAgICB9IGVsc2UgaWYgKCBldmVudC5zaGlmdEtleSApIHtcbiAgICAgICAgICBjb25zdCBkeUFicyA9IE1hdGguYWJzKCBkeSApO1xuICAgICAgICAgIGNvbnN0IGR5U2lnbiA9IE1hdGguc2lnbiggZHkgKTtcbiAgICAgICAgICBmb3IgKCBsZXQgaSA9IDA7IGkgPCBkeUFiczsgaSArKyApIHtcbiAgICAgICAgICAgIGNvbnN0IHZBYnMgPSBNYXRoLmFicyggdiApO1xuICAgICAgICAgICAgY29uc3QgdlNpZ24gPSBNYXRoLnNpZ24oIHYgKyAxRS00ICogZHlTaWduICk7XG4gICAgICAgICAgICBjb25zdCBvcmRlciA9IE1hdGguZmxvb3IoIE1hdGgubG9nMTAoIHZBYnMgKyAxRS00ICogZHlTaWduICogdlNpZ24gKSApIC0gMSAtICggZXZlbnQuYWx0S2V5ID8gMSA6IDAgKTtcbiAgICAgICAgICAgIHYgKz0gTWF0aC5tYXgoIDAuMDAxLCBNYXRoLnBvdyggMTAuMCwgb3JkZXIgKSApICogZHlTaWduO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2ICs9IGR5ICogKCBldmVudC5hbHRLZXkgPyAwLjAwMSA6IDAuMDEgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggdGhpcy5tYXggKSB7IHYgPSBNYXRoLm1pbiggdiwgcGFyc2VGbG9hdCggdGhpcy5tYXggKSApOyB9XG4gICAgICAgIGlmICggdGhpcy5taW4gKSB7IHYgPSBNYXRoLm1heCggdiwgcGFyc2VGbG9hdCggdGhpcy5taW4gKSApOyB9XG4gICAgICAgIHYgPSB0aGlzLnR5cGUgPT09ICdpbnQnID8gdiA6IE51bWJlciggdi50b0ZpeGVkKCAzICkgKTtcbiAgICAgICAgdGhpcy4kZW1pdCggJ2NoYW5nZWQnLCB2ICk7XG4gICAgICB9LCAoIGV2ZW50ICkgPT4ge1xuICAgICAgICBpZiAoIHYwID09PSBOdW1iZXIoIHRoaXMudmFsdWUgKSApIHsgcmV0dXJuOyB9XG4gICAgICAgIHRoaXMuJGVtaXQoICdmaW5pc2hlZCcsIFsgdjAsIE51bWJlciggdGhpcy52YWx1ZSApIF0gKTtcbiAgICAgIH0gKTtcbiAgICB9LFxuXG4gICAgbkVudGVyKCBldmVudCApIHtcbiAgICAgIGxldCB2ID0gcGFyc2VGbG9hdCggdGhpcy4kcmVmcy52YWx1ZUlucHV0LnZhbHVlICk7XG4gICAgICBpZiAoIHRoaXMudHlwZSA9PT0gJ2ludCcgKSB7IHYgPSBNYXRoLnJvdW5kKCB2ICk7IH1cbiBcbiAgICAgIHRoaXMuJGVtaXQoICdjaGFuZ2VkJywgdiApO1xuICAgICAgdGhpcy4kZW1pdCggJ2ZpbmlzaGVkJywgWyBOdW1iZXIoIHRoaXMudmFsdWUgKSwgdiBdICk7XG4gICAgICB0aGlzLmlucHV0ID0gZmFsc2U7XG4gICAgfSxcblxuICAgIG5CbHVyKCBldmVudCApIHtcbiAgICAgIHRoaXMuaW5wdXQgPSBmYWxzZTtcbiAgICB9LFxuXG4gICAgYlRvZ2dsZSggZXZlbnQgKSB7XG4gICAgICBpZiAoIHRoaXMucmVhZG9ubHkgKSB7IHJldHVybjsgfVxuXG4gICAgICBjb25zdCB2ID0gIXRoaXMudmFsdWU7XG4gICAgICB0aGlzLiRlbWl0KCAnY2hhbmdlZCcsIHYgKTtcbiAgICAgIHRoaXMuJGVtaXQoICdmaW5pc2hlZCcsIFsgIXYsIHYgXSApO1xuICAgIH1cbiAgfVxufVxuPC9zY3JpcHQ+XG5cbjxzdHlsZSBsYW5nPVwic2Nzc1wiPlxuQGltcG9ydCBcIi4vY29sb3JzLnNjc3NcIjtcblxuLnByb3Bib3gge1xuICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gIHdpZHRoOiAxMDAlO1xuICBoZWlnaHQ6IDEuMjVlbTtcbiAgbWFyZ2luLWJvdHRvbTogMC4yNWVtO1xuXG4gIC5uYW1lIHtcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgbGVmdDogMDtcbiAgICB0b3A6IDA7XG4gICAgaGVpZ2h0OiAxMDAlO1xuXG4gICAgbWFyZ2luLXRvcDogMC4xZW07XG4gIH1cblxuICAudmFsdWUge1xuICAgIGJhY2tncm91bmQ6ICRjb2xvci1iYWNrMztcblxuICAgICY6YWN0aXZlOm5vdCgucmVhZG9ubHkpIHtcbiAgICAgIGJhY2tncm91bmQ6ICRjb2xvci1iYWNrMTtcbiAgICB9XG5cbiAgICBjdXJzb3I6IHBvaW50ZXI7XG5cbiAgICAmLnJlYWRvbmx5IHtcbiAgICAgIGN1cnNvcjogbm90LWFsbG93ZWQ7XG4gICAgfVxuICB9XG5cbiAgLm51bWJlciB7XG4gICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgIHJpZ2h0OiAwO1xuICAgIHRvcDogMDtcbiAgICB3aWR0aDogNWVtO1xuICAgIGhlaWdodDogMTAwJTtcblxuICAgIC52YWx1ZVRleHQge1xuICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICBtYXJnaW4tdG9wOiAwLjFlbTtcblxuICAgICAgdGV4dC1hbGlnbjogY2VudGVyO1xuXG4gICAgICAmLnJlYWRvbmx5IHtcbiAgICAgICAgb3BhY2l0eTogMC41O1xuICAgICAgfVxuICAgIH1cblxuICAgIC52YWx1ZUlucHV0IHtcbiAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgIGxlZnQ6IDA7XG4gICAgICB0b3A6IDA7XG4gICAgICB3aWR0aDogMTAwJTtcbiAgICAgIGhlaWdodDogMTAwJTtcbiAgICAgIGJvcmRlcjogbm9uZTtcbiAgICAgIHBhZGRpbmc6IDA7XG5cbiAgICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgICAgIGJhY2tncm91bmQ6ICRjb2xvci1iYWNrNTtcbiAgICAgIGNvbG9yOiAkY29sb3ItZm9yZTtcbiAgICB9XG4gIH1cblxuICAuYm9vbGVhbiB7XG4gICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgIHJpZ2h0OiAxLjg3NWVtO1xuICAgIHRvcDogMDtcbiAgICB3aWR0aDogMS4yNWVtO1xuICAgIGhlaWdodDogMTAwJTtcblxuICAgIC5ib29sZWFuQ2hlY2sge1xuICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgbGVmdDogMjAlO1xuICAgICAgdG9wOiAyMCU7XG4gICAgICB3aWR0aDogNjAlO1xuICAgICAgaGVpZ2h0OiA2MCU7XG4gICAgICBcbiAgICAgIGJhY2tncm91bmQ6ICRjb2xvci1hY2NlbnQ7XG5cbiAgICAgICYucmVhZG9ubHkge1xuICAgICAgICBiYWNrZ3JvdW5kOiAkY29sb3ItZ3JheTtcbiAgICAgICAgb3BhY2l0eTogMC41O1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuPC9zdHlsZT4iLCI8dGVtcGxhdGU+XG48ZGl2PlxuICA8U2Nyb2xsYWJsZSBjbGFzcz1cInJvb3RcIlxuICAgIGJhcj1cInJpZ2h0XCJcbiAgPlxuICAgIDxkaXYgY2xhc3M9XCJwcm9wc1wiXG4gICAgICB2LWlmPVwic2VsZWN0ZWROb2RlXCJcbiAgICA+XG4gICAgICA8ZGl2IGNsYXNzPVwidGl0bGVcIj5Ob2RlPC9kaXY+XG4gICAgICA8aHIgLz5cbiAgICAgIDxQcm9wYm94IGNsYXNzPVwicHJvcFwiXG4gICAgICAgIHR5cGU9XCJmbG9hdFwiXG4gICAgICAgIG5hbWU9XCJUaW1lXCJcbiAgICAgICAgOnZhbHVlPVwic2VsZWN0ZWROb2RlLnRpbWVcIlxuICAgICAgICA6cmVhZG9ubHk9XCIhKCBzZWxlY3RlZE5vZGUuaW4gJiYgc2VsZWN0ZWROb2RlLm91dCApXCJcbiAgICAgICAgQGNoYW5nZWQ9XCJcbiAgICAgICAgICBzZWxlY3RlZFBhcmFtLm1vdmVOb2RlKCBzZWxlY3RlZE5vZGVJZCwgJGV2ZW50IClcbiAgICAgICAgXCJcbiAgICAgICAgQGZpbmlzaGVkPVwiXG4gICAgICAgICAgYXV0b21hdG9uLnB1c2hIaXN0b3J5KCAnQ2hhbmdlIE5vZGUgVGltZScsICgpID0+IHtcbiAgICAgICAgICAgIHNlbGVjdGVkUGFyYW0ubW92ZU5vZGUoIHNlbGVjdGVkTm9kZUlkLCAkZXZlbnRbIDEgXSApO1xuICAgICAgICAgIH0sICgpID0+IHtcbiAgICAgICAgICAgIHNlbGVjdGVkUGFyYW0ubW92ZU5vZGUoIHNlbGVjdGVkTm9kZUlkLCAkZXZlbnRbIDAgXSApO1xuICAgICAgICAgIH0gKTtcbiAgICAgICAgXCJcbiAgICAgIC8+XG4gICAgICA8UHJvcGJveCBjbGFzcz1cInByb3BcIlxuICAgICAgICB0eXBlPVwiZmxvYXRcIlxuICAgICAgICBuYW1lPVwiVmFsdWVcIlxuICAgICAgICA6dmFsdWU9XCJzZWxlY3RlZE5vZGUudmFsdWVcIlxuICAgICAgICBAY2hhbmdlZD1cIlxuICAgICAgICAgIHNlbGVjdGVkUGFyYW0ubW92ZU5vZGUoIHNlbGVjdGVkTm9kZUlkLCB1bmRlZmluZWQsICRldmVudCApXG4gICAgICAgIFwiXG4gICAgICAgIEBmaW5pc2hlZD1cIlxuICAgICAgICAgIGF1dG9tYXRvbi5wdXNoSGlzdG9yeSggJ0NoYW5nZSBOb2RlIFZhbHVlJywgKCkgPT4ge1xuICAgICAgICAgICAgc2VsZWN0ZWRQYXJhbS5tb3ZlTm9kZSggc2VsZWN0ZWROb2RlSWQsIHVuZGVmaW5lZCwgJGV2ZW50WyAxIF0gKTtcbiAgICAgICAgICB9LCAoKSA9PiB7XG4gICAgICAgICAgICBzZWxlY3RlZFBhcmFtLm1vdmVOb2RlKCBzZWxlY3RlZE5vZGVJZCwgdW5kZWZpbmVkLCAkZXZlbnRbIDAgXSApO1xuICAgICAgICAgIH0gKTtcbiAgICAgICAgXCJcbiAgICAgIC8+XG4gICAgICA8aHIgLz5cbiAgICAgIDxQcm9wYm94IGNsYXNzPVwicHJvcFwiXG4gICAgICAgIHR5cGU9XCJmbG9hdFwiXG4gICAgICAgIG5hbWU9XCJJbiBUaW1lXCJcbiAgICAgICAgOnZhbHVlPVwic2VsZWN0ZWROb2RlLmluID8gc2VsZWN0ZWROb2RlLmluLnRpbWUgOiAwXCJcbiAgICAgICAgOnJlYWRvbmx5PVwiIXNlbGVjdGVkTm9kZS5pblwiXG4gICAgICAgIEBjaGFuZ2VkPVwiXG4gICAgICAgICAgc2VsZWN0ZWRQYXJhbS5tb3ZlSGFuZGxlKCBzZWxlY3RlZE5vZGVJZCwgZmFsc2UsICRldmVudCApXG4gICAgICAgIFwiXG4gICAgICAgIEBmaW5pc2hlZD1cIlxuICAgICAgICAgIGF1dG9tYXRvbi5wdXNoSGlzdG9yeSggJ0NoYW5nZSBOb2RlIFRpbWUnLCAoKSA9PiB7XG4gICAgICAgICAgICBzZWxlY3RlZFBhcmFtLm1vdmVIYW5kbGUoIHNlbGVjdGVkTm9kZUlkLCBmYWxzZSwgJGV2ZW50WyAxIF0gKTtcbiAgICAgICAgICB9LCAoKSA9PiB7XG4gICAgICAgICAgICBzZWxlY3RlZFBhcmFtLm1vdmVIYW5kbGUoIHNlbGVjdGVkTm9kZUlkLCBmYWxzZSwgJGV2ZW50WyAwIF0gKTtcbiAgICAgICAgICB9ICk7XG4gICAgICAgIFwiXG4gICAgICAvPlxuICAgICAgPFByb3Bib3ggY2xhc3M9XCJwcm9wXCJcbiAgICAgICAgdHlwZT1cImZsb2F0XCJcbiAgICAgICAgbmFtZT1cIkluIFZhbHVlXCJcbiAgICAgICAgOnZhbHVlPVwic2VsZWN0ZWROb2RlLmluID8gc2VsZWN0ZWROb2RlLmluLnZhbHVlIDogMFwiXG4gICAgICAgIDpyZWFkb25seT1cIiFzZWxlY3RlZE5vZGUuaW5cIlxuICAgICAgICBAY2hhbmdlZD1cIlxuICAgICAgICAgIHNlbGVjdGVkUGFyYW0ubW92ZUhhbmRsZSggc2VsZWN0ZWROb2RlSWQsIGZhbHNlLCB1bmRlZmluZWQsICRldmVudCApXG4gICAgICAgIFwiXG4gICAgICAgIEBmaW5pc2hlZD1cIlxuICAgICAgICAgIGF1dG9tYXRvbi5wdXNoSGlzdG9yeSggJ0NoYW5nZSBOb2RlIFZhbHVlJywgKCkgPT4ge1xuICAgICAgICAgICAgc2VsZWN0ZWRQYXJhbS5tb3ZlSGFuZGxlKCBzZWxlY3RlZE5vZGVJZCwgZmFsc2UsIHVuZGVmaW5lZCwgJGV2ZW50WyAxIF0gKTtcbiAgICAgICAgICB9LCAoKSA9PiB7XG4gICAgICAgICAgICBzZWxlY3RlZFBhcmFtLm1vdmVIYW5kbGUoIHNlbGVjdGVkTm9kZUlkLCBmYWxzZSwgdW5kZWZpbmVkLCAkZXZlbnRbIDAgXSApO1xuICAgICAgICAgIH0gKTtcbiAgICAgICAgXCJcbiAgICAgIC8+XG4gICAgICA8aHIgLz5cbiAgICAgIDxQcm9wYm94IGNsYXNzPVwicHJvcFwiXG4gICAgICAgIHR5cGU9XCJmbG9hdFwiXG4gICAgICAgIG5hbWU9XCJPdXQgVGltZVwiXG4gICAgICAgIDp2YWx1ZT1cInNlbGVjdGVkTm9kZS5vdXQgPyBzZWxlY3RlZE5vZGUub3V0LnRpbWUgOiAwXCJcbiAgICAgICAgOnJlYWRvbmx5PVwiIXNlbGVjdGVkTm9kZS5vdXRcIlxuICAgICAgICBAY2hhbmdlZD1cIlxuICAgICAgICAgIHNlbGVjdGVkUGFyYW0ubW92ZUhhbmRsZSggc2VsZWN0ZWROb2RlSWQsIHRydWUsICRldmVudCApXG4gICAgICAgIFwiXG4gICAgICAgIEBmaW5pc2hlZD1cIlxuICAgICAgICAgIGF1dG9tYXRvbi5wdXNoSGlzdG9yeSggJ0NoYW5nZSBOb2RlIFRpbWUnLCAoKSA9PiB7XG4gICAgICAgICAgICBzZWxlY3RlZFBhcmFtLm1vdmVIYW5kbGUoIHNlbGVjdGVkTm9kZUlkLCB0cnVlLCAkZXZlbnRbIDEgXSApO1xuICAgICAgICAgIH0sICgpID0+IHtcbiAgICAgICAgICAgIHNlbGVjdGVkUGFyYW0ubW92ZUhhbmRsZSggc2VsZWN0ZWROb2RlSWQsIHRydWUsICRldmVudFsgMCBdICk7XG4gICAgICAgICAgfSApO1xuICAgICAgICBcIlxuICAgICAgLz5cbiAgICAgIDxQcm9wYm94IGNsYXNzPVwicHJvcFwiXG4gICAgICAgIHR5cGU9XCJmbG9hdFwiXG4gICAgICAgIG5hbWU9XCJPdXQgVmFsdWVcIlxuICAgICAgICA6dmFsdWU9XCJzZWxlY3RlZE5vZGUub3V0ID8gc2VsZWN0ZWROb2RlLm91dC52YWx1ZSA6IDBcIlxuICAgICAgICA6cmVhZG9ubHk9XCIhc2VsZWN0ZWROb2RlLm91dFwiXG4gICAgICAgIEBjaGFuZ2VkPVwiXG4gICAgICAgICAgc2VsZWN0ZWRQYXJhbS5tb3ZlSGFuZGxlKCBzZWxlY3RlZE5vZGVJZCwgdHJ1ZSwgdW5kZWZpbmVkLCAkZXZlbnQgKVxuICAgICAgICBcIlxuICAgICAgICBAZmluaXNoZWQ9XCJcbiAgICAgICAgICBhdXRvbWF0b24ucHVzaEhpc3RvcnkoICdDaGFuZ2UgTm9kZSBWYWx1ZScsICgpID0+IHtcbiAgICAgICAgICAgIHNlbGVjdGVkUGFyYW0ubW92ZUhhbmRsZSggc2VsZWN0ZWROb2RlSWQsIHRydWUsIHVuZGVmaW5lZCwgJGV2ZW50WyAxIF0gKTtcbiAgICAgICAgICB9LCAoKSA9PiB7XG4gICAgICAgICAgICBzZWxlY3RlZFBhcmFtLm1vdmVIYW5kbGUoIHNlbGVjdGVkTm9kZUlkLCB0cnVlLCB1bmRlZmluZWQsICRldmVudFsgMCBdICk7XG4gICAgICAgICAgfSApO1xuICAgICAgICBcIlxuICAgICAgLz5cbiAgICA8L2Rpdj5cblxuICAgIDxkaXYgY2xhc3M9XCJwcm9wc1wiXG4gICAgICB2LWlmPVwic2VsZWN0ZWRGeFwiXG4gICAgPlxuICAgICAgPGRpdiBjbGFzcz1cInRpdGxlXCI+Rng6IHt7IGF1dG9tYXRvbi5nZXRGeERlZmluaXRpb25OYW1lKCBzZWxlY3RlZEZ4LmRlZiApIH19PC9kaXY+XG4gICAgICA8aHIgLz5cbiAgICAgIDxQcm9wYm94IGNsYXNzPVwicHJvcFwiXG4gICAgICAgIHR5cGU9XCJmbG9hdFwiXG4gICAgICAgIG5hbWU9XCJUaW1lXCJcbiAgICAgICAgOnZhbHVlPVwic2VsZWN0ZWRGeC50aW1lXCJcbiAgICAgICAgQGNoYW5nZWQ9XCJcbiAgICAgICAgICBzZWxlY3RlZFBhcmFtLm1vdmVGeCggc2VsZWN0ZWRGeElkLCAkZXZlbnQgKVxuICAgICAgICBcIlxuICAgICAgICBAZmluaXNoZWQ9XCJcbiAgICAgICAgICBhdXRvbWF0b24ucHVzaEhpc3RvcnkoICdNb3ZlIEZ4JywgKCkgPT4ge1xuICAgICAgICAgICAgc2VsZWN0ZWRQYXJhbS5tb3ZlRngoIHNlbGVjdGVkRnhJZCwgJGV2ZW50WyAxIF0gKTtcbiAgICAgICAgICB9LCAoKSA9PiB7XG4gICAgICAgICAgICBzZWxlY3RlZFBhcmFtLm1vdmVGeCggc2VsZWN0ZWRGeElkLCAkZXZlbnRbIDAgXSApO1xuICAgICAgICAgIH0gKTtcbiAgICAgICAgXCJcbiAgICAgIC8+XG4gICAgICA8UHJvcGJveCBjbGFzcz1cInByb3BcIlxuICAgICAgICB0eXBlPVwiZmxvYXRcIlxuICAgICAgICBuYW1lPVwiTGVuZ3RoXCJcbiAgICAgICAgOnZhbHVlPVwic2VsZWN0ZWRGeC5sZW5ndGhcIlxuICAgICAgICBAY2hhbmdlZD1cIlxuICAgICAgICAgIHNlbGVjdGVkUGFyYW0ucmVzaXplRngoIHNlbGVjdGVkRnhJZCwgJGV2ZW50IClcbiAgICAgICAgXCJcbiAgICAgICAgQGZpbmlzaGVkPVwiXG4gICAgICAgICAgYXV0b21hdG9uLnB1c2hIaXN0b3J5KCAnTW92ZSBGeCcsICgpID0+IHtcbiAgICAgICAgICAgIHNlbGVjdGVkUGFyYW0ucmVzaXplRngoIHNlbGVjdGVkRnhJZCwgJGV2ZW50WyAxIF0gKTtcbiAgICAgICAgICB9LCAoKSA9PiB7XG4gICAgICAgICAgICBzZWxlY3RlZFBhcmFtLnJlc2l6ZUZ4KCBzZWxlY3RlZEZ4SWQsICRldmVudFsgMCBdICk7XG4gICAgICAgICAgfSApO1xuICAgICAgICBcIlxuICAgICAgLz5cbiAgICAgIDxQcm9wYm94IGNsYXNzPVwicHJvcFwiXG4gICAgICAgIHR5cGU9XCJib29sZWFuXCJcbiAgICAgICAgbmFtZT1cIkJ5cGFzc1wiXG4gICAgICAgIDp2YWx1ZT1cInNlbGVjdGVkRnguYnlwYXNzXCJcbiAgICAgICAgQGZpbmlzaGVkPVwiXG4gICAgICAgICAgYXV0b21hdG9uLnB1c2hIaXN0b3J5KCAnVG9nZ2xlIEJ5cGFzcyBGeCcsICgpID0+IHtcbiAgICAgICAgICAgIHNlbGVjdGVkUGFyYW0uYnlwYXNzRngoIHNlbGVjdGVkRnhJZCwgJGV2ZW50WyAxIF0gKTtcbiAgICAgICAgICB9LCAoKSA9PiB7XG4gICAgICAgICAgICBzZWxlY3RlZFBhcmFtLmJ5cGFzc0Z4KCBzZWxlY3RlZEZ4SWQsICRldmVudFsgMCBdICk7XG4gICAgICAgICAgfSwgdHJ1ZSApO1xuICAgICAgICBcIlxuICAgICAgLz5cbiAgICAgIDxociAvPlxuICAgICAgPFByb3Bib3ggY2xhc3M9XCJwcm9wXCJcbiAgICAgICAgdi1mb3I9XCIoIHBhcmFtLCBrZXkgKSBpbiBhdXRvbWF0b24uZ2V0RnhEZWZpbml0aW9uUGFyYW1zKCBzZWxlY3RlZEZ4LmRlZiApXCJcbiAgICAgICAgOmtleT1cIidmeFBhcmFtLScra2V5XCJcbiAgICAgICAgOnR5cGU9XCJwYXJhbS50eXBlXCJcbiAgICAgICAgOm5hbWU9XCJwYXJhbS5uYW1lIHx8IGtleVwiXG4gICAgICAgIDp2YWx1ZT1cInNlbGVjdGVkRngucGFyYW1zWyBrZXkgXVwiXG4gICAgICAgIEBjaGFuZ2VkPVwiXG4gICAgICAgICAgc2VsZWN0ZWRQYXJhbS5jaGFuZ2VGeFBhcmFtKCBzZWxlY3RlZEZ4SWQsIGtleSwgJGV2ZW50IClcbiAgICAgICAgXCJcbiAgICAgICAgQGZpbmlzaGVkPVwiXG4gICAgICAgICAgYXV0b21hdG9uLnB1c2hIaXN0b3J5KCAnQ2hhbmdlIEZ4IFBhcmFtJywgKCkgPT4ge1xuICAgICAgICAgICAgc2VsZWN0ZWRQYXJhbS5jaGFuZ2VGeFBhcmFtKCBzZWxlY3RlZEZ4SWQsIGtleSwgJGV2ZW50WyAxIF0gKTtcbiAgICAgICAgICB9LCAoKSA9PiB7XG4gICAgICAgICAgICBzZWxlY3RlZFBhcmFtLmNoYW5nZUZ4UGFyYW0oIHNlbGVjdGVkRnhJZCwga2V5LCAkZXZlbnRbIDAgXSApO1xuICAgICAgICAgIH0gKTtcbiAgICAgICAgXCJcbiAgICAgIC8+XG4gICAgPC9kaXY+XG5cbiAgICA8ZGl2IGNsYXNzPVwicHJvcHNcIlxuICAgICAgdi1pZj1cImNvbmZpZyA9PT0gJ3NuYXAnXCJcbiAgICA+XG4gICAgICA8ZGl2IGNsYXNzPVwidGl0bGVcIj5TbmFwIFNldHRpbmdzPC9kaXY+XG4gICAgICA8aHIgLz5cbiAgICAgIDxQcm9wYm94IGNsYXNzPVwicHJvcFwiXG4gICAgICAgIG5hbWU9XCJFbmFibGUgU25hcFwiXG4gICAgICAgIHR5cGU9XCJib29sZWFuXCJcbiAgICAgICAgOnZhbHVlPVwiYXV0b21hdG9uLmd1aVNldHRpbmdzLnNuYXBBY3RpdmVcIlxuICAgICAgICBAY2hhbmdlZD1cImF1dG9tYXRvbi5ndWlTZXR0aW5ncy5zbmFwQWN0aXZlID0gJGV2ZW50XCJcbiAgICAgIC8+XG4gICAgICA8UHJvcGJveCBjbGFzcz1cInByb3BcIlxuICAgICAgICBuYW1lPVwiSW50ZXJ2YWwgKFRpbWUpXCJcbiAgICAgICAgbWluPVwiMC4wXCJcbiAgICAgICAgdHlwZT1cImZsb2F0XCJcbiAgICAgICAgOnZhbHVlPVwiYXV0b21hdG9uLmd1aVNldHRpbmdzLnNuYXBUaW1lXCJcbiAgICAgICAgQGNoYW5nZWQ9XCJhdXRvbWF0b24uZ3VpU2V0dGluZ3Muc25hcFRpbWUgPSAkZXZlbnRcIlxuICAgICAgLz5cbiAgICAgIDxQcm9wYm94IGNsYXNzPVwicHJvcFwiXG4gICAgICAgIG5hbWU9XCJJbnRlcnZhbCAoVmFsdWUpXCJcbiAgICAgICAgbWluPVwiMC4wXCJcbiAgICAgICAgdHlwZT1cImZsb2F0XCJcbiAgICAgICAgOnZhbHVlPVwiYXV0b21hdG9uLmd1aVNldHRpbmdzLnNuYXBWYWx1ZVwiXG4gICAgICAgIEBjaGFuZ2VkPVwiYXV0b21hdG9uLmd1aVNldHRpbmdzLnNuYXBWYWx1ZSA9ICRldmVudFwiXG4gICAgICAvPlxuICAgIDwvZGl2PlxuXG4gICAgPGRpdiBjbGFzcz1cInByb3BzXCJcbiAgICAgIHYtaWY9XCJjb25maWcgPT09ICdnZW5lcmFsJ1wiXG4gICAgPlxuICAgICAgPGRpdiBjbGFzcz1cInRpdGxlXCI+R2VuZXJhbCBDb25maWc8L2Rpdj5cbiAgICAgIDxociAvPlxuICAgICAgPFByb3Bib3ggY2xhc3M9XCJwcm9wXCJcbiAgICAgICAgbmFtZT1cIkxlbmd0aFwiXG4gICAgICAgIHR5cGU9XCJmbG9hdFwiXG4gICAgICAgIG1pbj1cIjBcIlxuICAgICAgICA6dmFsdWU9XCJnZW5lcmFsQ29uZmlncy5sZW5ndGhcIlxuICAgICAgICBAY2hhbmdlZD1cImdlbmVyYWxDb25maWdzLmxlbmd0aCA9ICRldmVudFwiXG4gICAgICAvPlxuICAgICAgPFByb3Bib3ggY2xhc3M9XCJwcm9wXCJcbiAgICAgICAgbmFtZT1cIlJlc29sdXRpb25cIlxuICAgICAgICB0eXBlPVwiaW50XCJcbiAgICAgICAgbWluPVwiMVwiXG4gICAgICAgIDp2YWx1ZT1cImdlbmVyYWxDb25maWdzLnJlc29sdXRpb25cIlxuICAgICAgICBAY2hhbmdlZD1cImdlbmVyYWxDb25maWdzLnJlc29sdXRpb24gPSAkZXZlbnRcIlxuICAgICAgLz5cbiAgICAgIDxociAvPlxuICAgICAgPGRpdiBjbGFzcz1cImNlbnRlcmluZ1wiPlxuICAgICAgICBUaGlzIGNhbm5vdCBiZSB1bmRvbmUhXG4gICAgICAgIDxkaXYgY2xhc3M9XCJidXR0b24tY29uZmlybVwiXG4gICAgICAgICAgQGNsaWNrPVwiY29uZmlybUdlbmVyYWxDb25maWdzXCJcbiAgICAgICAgPkFwcGx5PC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgPC9TY3JvbGxhYmxlPlxuXG4gIDxkaXYgY2xhc3M9XCJsb2dvYm94XCJcbiAgICB2LWlmPVwiIXNlbGVjdGVkTm9kZSAmJiAhc2VsZWN0ZWRGeCAmJiAhY29uZmlnXCJcbiAgPlxuICAgIDxpbWcgY2xhc3M9XCJsb2dvXCJcbiAgICAgIDpzcmM9XCJyZXF1aXJlKCAnLi4vaW1hZ2VzL2F1dG9tYXRvbi1hLnN2ZycgKVwiXG4gICAgLz5cbiAgPC9kaXY+XG48L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgUHJvcGJveCBmcm9tICcuL3Byb3Bib3gudnVlJztcbmltcG9ydCBTY3JvbGxhYmxlIGZyb20gJy4vc2Nyb2xsYWJsZS52dWUnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdwcm9wbWVudScsXG5cbiAgcHJvcHM6IFtcbiAgICAnYXV0b21hdG9uJyxcbiAgICAnc2VsZWN0ZWRQYXJhbU5hbWUnLFxuICAgICdzZWxlY3RlZE5vZGVJZHMnLFxuICAgICdzZWxlY3RlZEZ4SWRzJyxcbiAgICAnY29uZmlnJ1xuICBdLFxuXG4gIGNvbXBvbmVudHM6IHtcbiAgICBQcm9wYm94LFxuICAgIFNjcm9sbGFibGVcbiAgfSxcblxuICBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBnZW5lcmFsQ29uZmlnczoge1xuICAgICAgICBsZW5ndGg6IDAsXG4gICAgICAgIHJlc29sdXRpb246IDBcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgbWV0aG9kczoge1xuICAgIGNvbmZpcm1HZW5lcmFsQ29uZmlncygpIHtcbiAgICAgIHRoaXMuYXV0b21hdG9uLnNldExlbmd0aCggdGhpcy5nZW5lcmFsQ29uZmlncy5sZW5ndGggKTtcbiAgICAgIHRoaXMuYXV0b21hdG9uLnNldFJlc29sdXRpb24oIHRoaXMuZ2VuZXJhbENvbmZpZ3MucmVzb2x1dGlvbiApO1xuICAgIH1cbiAgfSxcblxuICBjb21wdXRlZDoge1xuICAgIHNlbGVjdGVkUGFyYW0oKSB7XG4gICAgICByZXR1cm4gdGhpcy5hdXRvbWF0b24uZ2V0UGFyYW0oIHRoaXMuc2VsZWN0ZWRQYXJhbU5hbWUgKTtcbiAgICB9LFxuXG4gICAgc2VsZWN0ZWROb2RlSWQoKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICB0aGlzLnNlbGVjdGVkTm9kZUlkcy5sZW5ndGggPT09IDFcbiAgICAgICAgPyB0aGlzLnNlbGVjdGVkTm9kZUlkc1sgMCBdXG4gICAgICAgIDogbnVsbFxuICAgICAgKTtcbiAgICB9LFxuXG4gICAgc2VsZWN0ZWROb2RlKCkge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgdGhpcy5zZWxlY3RlZE5vZGVJZHMubGVuZ3RoID09PSAxXG4gICAgICAgID8gdGhpcy5zZWxlY3RlZFBhcmFtLmR1bXBOb2RlKCB0aGlzLnNlbGVjdGVkTm9kZUlkIClcbiAgICAgICAgOiBudWxsXG4gICAgICApO1xuICAgIH0sXG5cbiAgICBzZWxlY3RlZEZ4SWQoKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICB0aGlzLnNlbGVjdGVkRnhJZHMubGVuZ3RoID09PSAxXG4gICAgICAgID8gdGhpcy5zZWxlY3RlZEZ4SWRzWyAwIF1cbiAgICAgICAgOiBudWxsXG4gICAgICApO1xuICAgIH0sXG5cbiAgICBzZWxlY3RlZEZ4KCkge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgdGhpcy5zZWxlY3RlZEZ4SWRzLmxlbmd0aCA9PT0gMVxuICAgICAgICA/IHRoaXMuc2VsZWN0ZWRQYXJhbS5kdW1wRngoIHRoaXMuc2VsZWN0ZWRGeElkIClcbiAgICAgICAgOiBudWxsXG4gICAgICApO1xuICAgIH1cbiAgfSxcblxuICB3YXRjaDoge1xuICAgIGNvbmZpZygpIHtcbiAgICAgIGlmICggdGhpcy5jb25maWcgPT09ICdnZW5lcmFsJyApIHtcbiAgICAgICAgdGhpcy5nZW5lcmFsQ29uZmlncy5sZW5ndGggPSB0aGlzLmF1dG9tYXRvbi5sZW5ndGg7XG4gICAgICAgIHRoaXMuZ2VuZXJhbENvbmZpZ3MucmVzb2x1dGlvbiA9IHRoaXMuYXV0b21hdG9uLnJlc29sdXRpb247XG4gICAgICB9XG4gICAgfVxuICB9XG59XG48L3NjcmlwdD5cblxuPHN0eWxlIGxhbmc9XCJzY3NzXCIgc2NvcGVkPlxuQGltcG9ydCBcIi4vY29sb3JzLnNjc3NcIjtcblxuLnJvb3Qge1xuICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gIGxlZnQ6IDA7XG4gIHRvcDogMDtcbiAgd2lkdGg6IDEwMCU7XG4gIGhlaWdodDogMTAwJTtcblxuICBiYWNrZ3JvdW5kOiAkY29sb3ItYmFjazI7XG4gIGNvbG9yOiAkY29sb3ItZm9yZTtcblxuICAucHJvcHMge1xuICAgIHBhZGRpbmc6IDAuNzVlbSAxLjVlbTtcbiAgICBmb250LXNpemU6IDAuNzVlbTtcblxuICAgIC50aXRsZSB7XG4gICAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgICAgdGV4dC1vdmVyZmxvdzogZWxsaXBzaXM7XG4gICAgICB3aGl0ZS1zcGFjZTogbm93cmFwO1xuXG4gICAgICBmb250LXNpemU6IDEuNWVtO1xuICAgICAgY29sb3I6ICRjb2xvci1hY2NlbnQ7XG4gICAgfVxuXG4gICAgaHIge1xuICAgICAgYm9yZGVyOiBzb2xpZCAxcHggJGNvbG9yLWJhY2szO1xuICAgIH1cblxuICAgIC5jZW50ZXJpbmcge1xuICAgICAgdGV4dC1hbGlnbjogY2VudGVyO1xuXG4gICAgICAuYnV0dG9uLWNvbmZpcm0ge1xuICAgICAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XG4gICAgICAgIHdpZHRoOiA0ZW07XG4gICAgICAgIHBhZGRpbmc6IDAuMjVlbTtcblxuICAgICAgICBiYWNrZ3JvdW5kOiAkY29sb3ItYmFjazM7XG5cbiAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xuXG4gICAgICAgICY6aG92ZXIgeyBiYWNrZ3JvdW5kOiAkY29sb3ItYmFjazE7IH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAubG9nb2JveCB7XG4gICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgIGxlZnQ6IDA7XG4gICAgdG9wOiAwO1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIGhlaWdodDogMTAwJTtcbiAgICBvdmVyZmxvdzogaGlkZGVuO1xuXG4gICAgLmxvZ28ge1xuICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgd2lkdGg6IDhlbTtcbiAgICAgIGxlZnQ6IGNhbGMoIDUwJSAtIDRlbSApO1xuICAgICAgdG9wOiBjYWxjKCA1MCUgLSA0ZW0gKTtcblxuICAgICAgb3BhY2l0eTogMC4xO1xuICAgIH1cbiAgfVxufVxuPC9zdHlsZT5cblxuIiwiPHRlbXBsYXRlPlxuPGRpdj5cbiAgPGRpdiBjbGFzcz1cInJvb3RcIiByZWY9XCJyb290XCJcbiAgICBAd2hlZWwuc3RvcD1cIm9uV2hlZWxcIlxuICA+XG4gICAgPGRpdiBjbGFzcz1cImluc2lkZVwiIHJlZj1cImluc2lkZVwiXG4gICAgICA6c3R5bGU9XCJ7IHRvcDogdG9wICsgJ3B4JyB9XCJcbiAgICA+XG4gICAgICA8c2xvdCAvPlxuICAgIDwvZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJiYXJcIlxuICAgICAgOnN0eWxlPVwie1xuICAgICAgICB0b3A6IGJhclRvcCArICclJyxcbiAgICAgICAgaGVpZ2h0OiBiYXJIZWlnaHQgKyAnJScsXG4gICAgICAgIGxlZnQ6IGJhciA9PT0gJ2xlZnQnID8gMCA6IHVuZGVmaW5lZCxcbiAgICAgICAgcmlnaHQ6IGJhciA9PT0gJ3JpZ2h0JyA/IDAgOiB1bmRlZmluZWQsXG4gICAgICAgIG9wYWNpdHk6IGJhck9wYWNpdHlcbiAgICAgIH1cIlxuICAgIC8+XG4gIDwvZGl2PlxuPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuZXhwb3J0IGRlZmF1bHQge1xuICBwcm9wczogW1xuICAgICdiYXInXG4gIF0sXG5cbiAgZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdG9wOiAwLFxuICAgICAgYmFyT3BhY2l0eTogMC4wXG4gICAgfVxuICB9LFxuXG4gIG1ldGhvZHM6IHtcbiAgICBvbldoZWVsKCBldmVudCApIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgIHRoaXMudG9wID0gdGhpcy50b3AgLSBldmVudC5kZWx0YVk7XG5cbiAgICAgIGNvbnN0IHNjcm9sbE1heCA9IHRoaXMuJHJlZnMuaW5zaWRlLmNsaWVudEhlaWdodCAtIHRoaXMuJHJlZnMucm9vdC5jbGllbnRIZWlnaHQ7XG4gICAgICBpZiAoIHRoaXMudG9wIDwgLXNjcm9sbE1heCApIHtcbiAgICAgICAgY29uc3Qgb3ZlcnJ1biA9IC1zY3JvbGxNYXggLSB0aGlzLnRvcDtcbiAgICAgICAgdGhpcy50b3AgPSAtc2Nyb2xsTWF4O1xuICAgICAgfVxuXG4gICAgICBpZiAoIDAgPCB0aGlzLnRvcCApIHtcbiAgICAgICAgY29uc3Qgb3ZlcnJ1biA9IHRoaXMudG9wO1xuICAgICAgICB0aGlzLnRvcCA9IDA7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYmFySGVpZ2h0ID0gMTAwLjAgKiB0aGlzLiRyZWZzLnJvb3QuY2xpZW50SGVpZ2h0IC8gdGhpcy4kcmVmcy5pbnNpZGUuY2xpZW50SGVpZ2h0O1xuICAgICAgdGhpcy5iYXJUb3AgPSAtMTAwLjAgKiB0aGlzLnRvcCAvIHRoaXMuJHJlZnMuaW5zaWRlLmNsaWVudEhlaWdodDtcbiAgICAgIHRoaXMuYmFyT3BhY2l0eSArPSBNYXRoLm1pbiggdGhpcy5iYXJPcGFjaXR5ICsgMC4xICogTWF0aC5hYnMoIGV2ZW50LmRlbHRhWSApLCAxLjAgKTtcbiAgICB9LFxuXG4gICAgdXBkYXRlKCkge1xuICAgICAgdGhpcy5iYXJPcGFjaXR5ICo9IDAuOTtcbiAgICB9XG4gIH0sXG5cbiAgbW91bnRlZCgpIHtcbiAgICBjb25zdCB1cGRhdGUgPSAoKSA9PiB7XG4gICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCB1cGRhdGUgKTtcbiAgICB9XG4gICAgdXBkYXRlKCk7XG4gIH1cbn1cbjwvc2NyaXB0PlxuXG48c3R5bGUgbGFuZz1cInNjc3NcIiBzY29wZWQ+XG5AaW1wb3J0IFwiLi9jb2xvcnMuc2Nzc1wiO1xuXG4ucm9vdCB7XG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgd2lkdGg6IDEwMCU7XG4gIGhlaWdodDogMTAwJTtcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcblxuICAuaW5zaWRlIHtcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgbGVmdDogMDtcbiAgICB3aWR0aDogMTAwJTtcbiAgfVxuXG4gIC5iYXIge1xuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICB3aWR0aDogNHB4O1xuXG4gICAgYmFja2dyb3VuZDogJGNvbG9yLWFjY2VudDtcbiAgICBib3JkZXItcmFkaXVzOiAycHg7XG4gIH1cbn1cbjwvc3R5bGU+XG4iLCI8dGVtcGxhdGU+XG48ZGl2PlxuICA8ZGl2IGNsYXNzPVwicm9vdFwiXG4gICAgdi1pZj1cInRleHRcIlxuICAgIDpzdHlsZT1cIntcbiAgICAgIGxlZnQ6IHR5cGVvZiBsZWZ0ID09PSAnbnVtYmVyJyA/IGAkeyBsZWZ0IH1weGAgOiB1bmRlZmluZWQsXG4gICAgICByaWdodDogdHlwZW9mIHJpZ2h0ID09PSAnbnVtYmVyJyA/IGAkeyByaWdodCB9cHhgIDogdW5kZWZpbmVkLFxuICAgICAgdG9wOiB0eXBlb2YgdG9wID09PSAnbnVtYmVyJyA/IGAkeyB0b3AgfXB4YCA6IHVuZGVmaW5lZCxcbiAgICAgIGJvdHRvbTogdHlwZW9mIGJvdHRvbSA9PT0gJ251bWJlcicgPyBgJHsgYm90dG9tIH1weGAgOiB1bmRlZmluZWRcbiAgICB9XCJcbiAgPlxuICAgIHt7IHRleHQgfX1cbiAgPC9kaXY+XG48L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdzdGFsa2VyJyxcblxuICBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBsZWZ0OiAwLFxuICAgICAgcmlnaHQ6IDAsXG4gICAgICB0b3A6IDAsXG4gICAgICBib3R0b206IDAsXG4gICAgICB0ZXh0OiAnJ1xuICAgIH07XG4gIH0sXG5cbiAgbWV0aG9kczoge1xuICAgIGFwcGx5U3RhbGtlclRleHQoIGVsICkge1xuICAgICAgc2V0VGltZW91dCggKCkgPT4ge1xuICAgICAgICB0aGlzLnRleHQgPSBlbC5nZXRBdHRyaWJ1dGUoICdzdGFsa2VyLXRleHQnICk7XG4gICAgICB9LCAxMCApOyAvLyDwn5Sl8J+UpfCflKXwn5Sl8J+UpfCflKVcbiAgICB9XG4gIH0sXG5cbiAgbW91bnRlZCgpIHtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggJ21vdXNlbW92ZScsICggZXZlbnQgKSA9PiB7XG4gICAgICBjb25zdCB4ID0gZXZlbnQuY2xpZW50WDtcbiAgICAgIGNvbnN0IHkgPSBldmVudC5jbGllbnRZO1xuICAgICAgY29uc3QgdyA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aDtcbiAgICAgIGNvbnN0IGggPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0O1xuXG4gICAgICBjb25zdCBiTGVmdFNpZGUgPSB3IC0gMjQwIDwgeDtcbiAgICAgIGNvbnN0IGJVcFNpZGUgPSBoIC0gNDAgPCB5O1xuXG4gICAgICB0aGlzLmxlZnQgPSBiTGVmdFNpZGUgPyBudWxsIDogeDtcbiAgICAgIHRoaXMucmlnaHQgPSBiTGVmdFNpZGUgPyAoIHcgLSB4ICkgOiBudWxsO1xuICAgICAgdGhpcy50b3AgPSBiVXBTaWRlID8gbnVsbCA6IHk7XG4gICAgICB0aGlzLmJvdHRvbSA9IGJVcFNpZGUgPyAoIGggLSB5ICkgOiBudWxsO1xuXG4gICAgICB0aGlzLmFwcGx5U3RhbGtlclRleHQoIGV2ZW50LnRhcmdldCApO1xuICAgIH0gKTtcblxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCAnbW91c2Vkb3duJywgKCBldmVudCApID0+IHtcbiAgICAgIHRoaXMuYXBwbHlTdGFsa2VyVGV4dCggZXZlbnQudGFyZ2V0ICk7XG4gICAgfSApO1xuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoICdtb3VzZXVwJywgKCBldmVudCApID0+IHtcbiAgICAgIHRoaXMuYXBwbHlTdGFsa2VyVGV4dCggZXZlbnQudGFyZ2V0ICk7XG4gICAgfSApO1xuICB9LFxufTtcbjwvc2NyaXB0PlxuXG48c3R5bGUgbGFuZz1cInNjc3NcIiBzY29wZWQ+XG5AaW1wb3J0IFwiLi9jb2xvcnMuc2Nzc1wiO1xuXG4ucm9vdCB7XG4gIHBvc2l0aW9uOiBmaXhlZDtcbiAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG4gIHdoaXRlLXNwYWNlOiBub3dyYXA7XG4gIHBhZGRpbmc6IDAuMmVtIDAuNGVtO1xuICBtYXJnaW46IDEwcHg7XG4gIGZvbnQtc2l6ZTogMC44ZW07XG5cbiAgYmFja2dyb3VuZDogcmdiYSggMCwgMCwgMCwgMC44ICk7XG4gIGNvbG9yOiAkY29sb3ItZm9yZTtcbiAgYm9yZGVyLXJhZGl1czogMC4yZW07XG59XG48L3N0eWxlPlxuIiwiPHRlbXBsYXRlPlxuPGRpdj5cbiAgPGRpdiBjbGFzcz1cImJsdXItbGF5ZXJcIlxuICAgIHYtaWY9XCJhY3RpdmVcIlxuICAgIEBtb3VzZWRvd249XCJibHVyXCJcbiAgLz5cbiAgPGRpdiBjbGFzcz1cInJvb3RcIlxuICAgIHYtaWY9XCJhY3RpdmVcIlxuICA+XG4gICAgPGlucHV0IGNsYXNzPVwic2VhcmNoLWJveFwiXG4gICAgICByZWY9XCJzZWFyY2hCb3hcIlxuICAgICAgdHlwZT1cInRleHRcIlxuICAgICAgdi1tb2RlbD1cInNlYXJjaFRleHRcIlxuICAgICAgcGxhY2Vob2xkZXI9XCJBZGQgYSBmeC4uLlwiXG4gICAgICBAa2V5ZG93bj1cIm9uU2VhcmNoQm94S2V5ZG93blwiXG4gICAgLz5cbiAgICA8U2Nyb2xsYWJsZSBjbGFzcz1cImZ4LW5hbWVzXCJcbiAgICAgIGJhcj1cInJpZ2h0XCJcbiAgICA+XG4gICAgICA8ZGl2IGNsYXNzPVwiZngtbmFtZVwiXG4gICAgICAgIHYtZm9yPVwiKCBpZCwgaW5kZXggKSBpbiBmeERlZnNGaWx0ZXJlZFwiXG4gICAgICAgIDprZXk9XCJpZFwiXG4gICAgICAgIDpjbGFzcz1cInsgc2VsZWN0ZWQ6IGluZGV4ID09PSBzZWxlY3RlZEluZGV4IH1cIlxuICAgICAgICA6c3RhbGtlci10ZXh0PVwiYXV0b21hdG9uLmdldEZ4RGVmaW5pdGlvbkRlc2NyaXB0aW9uKCBpZCApIHx8ICcobm8gZGVzY3JpcHRpb24gcHJvdmlkZWQpJ1wiXG4gICAgICAgIEBtb3VzZWRvd249XCJzZWxlY3QoIGlkIClcIlxuICAgICAgPlxuICAgICAgICB7eyBpZCA/IGF1dG9tYXRvbi5nZXRGeERlZmluaXRpb25OYW1lKCBpZCApIDogJyhObyByZXN1bHQgZm91bmQpJyB9fVxuICAgICAgPC9kaXY+XG4gICAgPC9TY3JvbGxhYmxlPlxuICA8L2Rpdj5cbjwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCBTY3JvbGxhYmxlIGZyb20gJy4vc2Nyb2xsYWJsZS52dWUnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIHByb3BzOiBbXG4gICAgJ2F1dG9tYXRvbicsXG4gICAgJ2FjdGl2ZSdcbiAgXSxcblxuICBjb21wb25lbnRzOiB7XG4gICAgU2Nyb2xsYWJsZVxuICB9LFxuXG4gIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZ4RGVmczogW10sXG4gICAgICBzZWFyY2hUZXh0OiAnJyxcbiAgICAgIHNlbGVjdGVkSW5kZXg6IDBcbiAgICB9XG4gIH0sXG5cbiAgbWV0aG9kczoge1xuICAgIGZpbHRlckRlZiggaWQgKSB7XG4gICAgICBjb25zdCBxdWVyaWVzID0gdGhpcy5zZWFyY2hUZXh0LnNwbGl0KCAvXFxzKy8gKTtcbiAgICAgIGNvbnN0IG5hbWUgPSB0aGlzLmF1dG9tYXRvbi5nZXRGeERlZmluaXRpb25OYW1lKCBpZCApO1xuICAgICAgcmV0dXJuIHF1ZXJpZXMuZXZlcnkoICggcXVlcnkgKSA9PiAoXG4gICAgICAgIG5hbWUudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyggcXVlcnkudG9Mb3dlckNhc2UoKSApIHx8XG4gICAgICAgIGlkLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoIHF1ZXJ5LnRvTG93ZXJDYXNlKCkgKVxuICAgICAgKSApO1xuICAgIH0sXG5cbiAgICBzZWxlY3QoIGlkICkge1xuICAgICAgaWYgKCBpZCA9PT0gJycgKSB7IHRoaXMuYmx1cigpOyByZXR1cm47IH1cbiAgICAgIHRoaXMuJGVtaXQoICdzZWxlY3RlZCcsIGlkICk7XG4gICAgICB0aGlzLmZ4RGVmcy5zcGxpY2UoIHRoaXMuZnhEZWZzLmluZGV4T2YoIGlkICksIDEgKTtcbiAgICAgIHRoaXMuZnhEZWZzLnVuc2hpZnQoIGlkICk7XG4gICAgICB0aGlzLmJsdXIoKTtcbiAgICB9LFxuXG4gICAgYmx1cigpIHtcbiAgICAgIHRoaXMuJGVtaXQoICdibHVyJyApO1xuICAgICAgdGhpcy5zZWFyY2hUZXh0ID0gJyc7XG4gICAgICB0aGlzLnNlbGVjdGVkSW5kZXggPSAwO1xuICAgIH0sXG5cbiAgICBvblNlYXJjaEJveEtleWRvd24oIGV2ZW50ICkge1xuICAgICAgaWYgKCBldmVudC53aGljaCA9PT0gMTMgKSB7IC8vIEVudGVyXG4gICAgICAgIHRoaXMuc2VsZWN0KCB0aGlzLmZ4RGVmc0ZpbHRlcmVkWyB0aGlzLnNlbGVjdGVkSW5kZXggXSApO1xuICAgICAgfSBlbHNlIGlmICggZXZlbnQud2hpY2ggPT09IDI3ICkgeyAvLyBFc2NhcGVcbiAgICAgICAgdGhpcy5ibHVyKCk7XG4gICAgICB9IGVsc2UgaWYgKCBldmVudC53aGljaCA9PT0gMzggKSB7IC8vIFVwXG4gICAgICAgIHRoaXMuc2VsZWN0ZWRJbmRleCA9ICggdGhpcy5zZWxlY3RlZEluZGV4IC0gMSArIHRoaXMuZnhEZWZzRmlsdGVyZWQubGVuZ3RoICkgJSB0aGlzLmZ4RGVmc0ZpbHRlcmVkLmxlbmd0aDtcbiAgICAgIH0gZWxzZSBpZiAoIGV2ZW50LndoaWNoID09PSA0MCApIHsgLy8gRG93blxuICAgICAgICB0aGlzLnNlbGVjdGVkSW5kZXggPSAoIHRoaXMuc2VsZWN0ZWRJbmRleCArIDEgKSAlIHRoaXMuZnhEZWZzRmlsdGVyZWQubGVuZ3RoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zZWxlY3RlZEluZGV4ID0gMDtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgbW91bnRlZCgpIHtcbiAgICB0aGlzLmZ4RGVmcyA9IHRoaXMuYXV0b21hdG9uLmdldEZ4RGVmaW5pdGlvbklkcygpO1xuICB9LFxuXG4gIGNvbXB1dGVkOiB7XG4gICAgZnhEZWZzRmlsdGVyZWQoKSB7XG4gICAgICB0aGlzLmZ4RGVmcy5wdXNoKFxuICAgICAgICAuLi50aGlzLmF1dG9tYXRvbi5nZXRGeERlZmluaXRpb25JZHMoKS5maWx0ZXIoXG4gICAgICAgICAgKCBpZCApID0+IHRoaXMuZnhEZWZzLmluZGV4T2YoIGlkICkgPT09IC0xXG4gICAgICAgIClcbiAgICAgICk7XG5cbiAgICAgIGxldCBhcnIgPSB0aGlzLmZ4RGVmcy5maWx0ZXIoICggaWQgKSA9PiB0aGlzLmZpbHRlckRlZiggaWQgKSApO1xuICAgICAgcmV0dXJuIGFyci5sZW5ndGggPT09IDAgPyBbICcnIF0gOiBhcnI7XG4gICAgfVxuICB9LFxuXG4gIHdhdGNoOiB7XG4gICAgYWN0aXZlKCB2ICkge1xuICAgICAgaWYgKCAhdiApIHsgcmV0dXJuOyB9XG4gICAgICBzZXRUaW1lb3V0KCAoKSA9PiB7XG4gICAgICAgIHRoaXMuJHJlZnMuc2VhcmNoQm94LmZvY3VzKCk7XG4gICAgICB9LCAxMCApOyAvLyDwn5SlXG4gICAgfVxuICB9XG59XG48L3NjcmlwdD5cblxuPHN0eWxlIGxhbmc9XCJzY3NzXCIgc2NvcGVkPlxuQGltcG9ydCBcIi4vY29sb3JzLnNjc3NcIjtcblxuLmJsdXItbGF5ZXIge1xuICBwb3NpdGlvbjogZml4ZWQ7XG4gIGxlZnQ6IDA7XG4gIHRvcDogMDtcbiAgd2lkdGg6IDEwMCU7XG4gIGhlaWdodDogMTAwJTtcbn1cblxuLnJvb3Qge1xuICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gIGxlZnQ6IGNhbGMoIDUwJSAtIDEwZW0gKTtcbiAgdG9wOiAxZW07XG4gIHdpZHRoOiAyMGVtO1xuICBoZWlnaHQ6IGNhbGMoIDEwMCUgLSAyZW0gKTtcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcblxuICBiYWNrZ3JvdW5kOiAkY29sb3ItYmFjazE7XG4gIGZvbnQtc2l6ZTogMC44ZW07XG5cbiAgZmlsdGVyOiBkcm9wLXNoYWRvdyggMCAwIDJweCAjMDAwMDAwICk7XG5cbiAgLnNlYXJjaC1ib3gge1xuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICBmb250LXNpemU6IDFlbTtcbiAgICB3aWR0aDogY2FsYyggMTAwJSAtIDEycHggKTtcbiAgICBtYXJnaW46IDJweDtcbiAgICBwYWRkaW5nOiAycHggNHB4O1xuICAgIGJvcmRlcjogbm9uZTtcblxuICAgIGJhY2tncm91bmQ6ICRjb2xvci1iYWNrNDtcbiAgICBjb2xvcjogJGNvbG9yLWZvcmU7XG4gIH1cblxuICAuZngtbmFtZXMge1xuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICB3aWR0aDogMTAwJTtcbiAgICBoZWlnaHQ6IGNhbGMoIDEwMCUgLSAxZW0gLSAxMnB4ICk7XG5cbiAgICAuZngtbmFtZSB7XG4gICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICB3aWR0aDogY2FsYyggMTAwJSAtIDEycHggKTtcbiAgICAgIG1hcmdpbjogMnB4O1xuICAgICAgcGFkZGluZzogMnB4IDRweDtcbiAgICAgIHdoaXRlLXNwYWNlOiBub3dyYXA7XG4gICAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgICAgdGV4dC1vdmVyZmxvdzogZWxsaXBzaXM7XG5cbiAgICAgIGJhY2tncm91bmQ6ICRjb2xvci1iYWNrMjtcblxuICAgICAgY3Vyc29yOiBwb2ludGVyO1xuXG4gICAgICAmOmhvdmVyIHsgYmFja2dyb3VuZDogJGNvbG9yLWJhY2szOyB9XG4gICAgICAmLnNlbGVjdGVkIHsgYmFja2dyb3VuZDogJGNvbG9yLWJhY2szOyB9XG4gICAgfVxuICB9XG59XG48L3N0eWxlPlxuIiwiPHRlbXBsYXRlPlxuPGRpdj5cbiAgPGRpdiBjbGFzcz1cInJvb3RcIiByZWY9XCJyb290XCJcbiAgICBAd2hlZWwucHJldmVudD1cIm9uV2hlZWxcIlxuICAgIEBkcmFnc3RhcnQucHJldmVudFxuICAgIEBtb3VzZWRvd24ucHJldmVudC5zdG9wPVwiZHJhZ0JnXCJcbiAgICBAZGJsY2xpY2subGVmdC5zdG9wPVwiY3JlYXRlTm9kZSggeDJ0KCAkZXZlbnQub2Zmc2V0WCApLCB5MnYoICRldmVudC5vZmZzZXRZICkgKVwiXG4gICAgQGNvbnRleHRtZW51LnN0b3AucHJldmVudD1cImNvbnRleHRCZ1wiXG4gID5cbiAgICA8ZGl2IGNsYXNzPVwiaGJhclwiPlxuICAgICAgPGRpdiBjbGFzcz1cInZpc2lvblwiXG4gICAgICAgIDpzdHlsZT1cIntcbiAgICAgICAgICBsZWZ0OiBgJHsgdDAgLyBhdXRvbWF0b24ubGVuZ3RoICogd2lkdGggfXB4YCxcbiAgICAgICAgICB3aWR0aDogYCR7ICggdDEgLSB0MCApIC8gYXV0b21hdG9uLmxlbmd0aCAqIHdpZHRoIH1weGBcbiAgICAgICAgfVwiXG4gICAgICA+PC9kaXY+XG4gICAgPC9kaXY+XG5cbiAgICA8c3ZnIGNsYXNzPVwic3ZnXCJcbiAgICAgIDp3aWR0aD1cIndpZHRoXCJcbiAgICAgIDpoZWlnaHQ9XCJoZWlnaHRcIlxuICAgICAgOnZpZXdCb3g9XCJgMCAwICR7d2lkdGh9ICR7aGVpZ2h0fWBcIlxuICAgID5cbiAgICAgIDxsaW5lIGNsYXNzPVwiZ3JpZFwiXG4gICAgICAgIHYtZm9yPVwiKCBsaW5lLCBpbmRleCApIGluIGdyaWQueFwiXG4gICAgICAgIDprZXk9XCInZ3JpZC14JytpbmRleFwiXG4gICAgICAgIDp4MT1cImxpbmUucG9zXCJcbiAgICAgICAgOnkxPVwiMFwiXG4gICAgICAgIDp4Mj1cImxpbmUucG9zXCJcbiAgICAgICAgOnkyPVwiaGVpZ2h0XCJcbiAgICAgICAgOm9wYWNpdHk9XCJsaW5lLm9wXCJcbiAgICAgIC8+XG4gICAgICA8bGluZSBjbGFzcz1cImdyaWRcIlxuICAgICAgICB2LWZvcj1cIiggbGluZSwgaW5kZXggKSBpbiBncmlkLnlcIlxuICAgICAgICA6a2V5PVwiJ2dyaWQteScraW5kZXhcIlxuICAgICAgICA6eDE9XCIwXCJcbiAgICAgICAgOnkxPVwibGluZS5wb3NcIlxuICAgICAgICA6eDI9XCJ3aWR0aFwiXG4gICAgICAgIDp5Mj1cImxpbmUucG9zXCJcbiAgICAgICAgOm9wYWNpdHk9XCJsaW5lLm9wXCJcbiAgICAgIC8+XG4gICAgICA8dGV4dCBjbGFzcz1cImdyaWQtdGV4dFwiXG4gICAgICAgIHYtZm9yPVwiKCBsaW5lLCBpbmRleCApIGluIGdyaWQueFwiXG4gICAgICAgIDprZXk9XCInZ3JpZC10ZXh0LXgnK2luZGV4XCJcbiAgICAgICAgOng9XCJsaW5lLnBvcyArIDJcIlxuICAgICAgICA6eT1cImhlaWdodCAtIDJcIlxuICAgICAgICA6b3BhY2l0eT1cImxpbmUub3BcIlxuICAgICAgPnt7IGxpbmUudmFsLnRvRml4ZWQoIDMgKSB9fTwvdGV4dD5cbiAgICAgIDx0ZXh0IGNsYXNzPVwiZ3JpZC10ZXh0XCJcbiAgICAgICAgdi1mb3I9XCIoIGxpbmUsIGluZGV4ICkgaW4gZ3JpZC55XCJcbiAgICAgICAgOmtleT1cIidncmlkLXRleHQteScraW5kZXhcIlxuICAgICAgICB4PVwiMlwiXG4gICAgICAgIDp5PVwibGluZS5wb3MgLSAyXCJcbiAgICAgICAgOm9wYWNpdHk9XCJsaW5lLm9wXCJcbiAgICAgID57eyBsaW5lLnZhbC50b0ZpeGVkKCAzICkgfX08L3RleHQ+XG5cbiAgICAgIDxnIHYtaWY9XCJzZWxlY3RlZFBhcmFtXCI+XG4gICAgICAgIDxnIGNsYXNzPVwiZnhcIlxuICAgICAgICAgIHYtZm9yPVwiZnggaW4gc2VsZWN0ZWRQYXJhbS5kdW1wRnhzKClcIlxuICAgICAgICAgIDprZXk9XCJmeC4kaWRcIlxuICAgICAgICA+XG4gICAgICAgICAgPGxpbmUgY2xhc3M9XCJsaW5lXCJcbiAgICAgICAgICAgIDp4MT1cInQyeCggZngudGltZSApXCJcbiAgICAgICAgICAgIHkxPVwiNFwiXG4gICAgICAgICAgICA6eDI9XCJ0MngoIGZ4LnRpbWUgKVwiXG4gICAgICAgICAgICA6eTI9XCJoZWlnaHRcIlxuICAgICAgICAgIC8+XG4gICAgICAgICAgPGxpbmUgY2xhc3M9XCJsaW5lXCJcbiAgICAgICAgICAgIDp4MT1cInQyeCggZngudGltZSArIGZ4Lmxlbmd0aCApXCJcbiAgICAgICAgICAgIHkxPVwiNFwiXG4gICAgICAgICAgICA6eDI9XCJ0MngoIGZ4LnRpbWUgKyBmeC5sZW5ndGggKVwiXG4gICAgICAgICAgICA6eTI9XCJoZWlnaHRcIlxuICAgICAgICAgIC8+XG5cbiAgICAgICAgICA8cmVjdCBjbGFzcz1cImZpbGxcIlxuICAgICAgICAgICAgOng9XCJ0MngoIGZ4LnRpbWUgKVwiXG4gICAgICAgICAgICB5PVwiMFwiXG4gICAgICAgICAgICA6d2lkdGg9XCJ0MngoIGZ4LnRpbWUgKyBmeC5sZW5ndGggKSAtIHQyeCggZngudGltZSApXCJcbiAgICAgICAgICAgIDpoZWlnaHQ9XCJoZWlnaHRcIlxuICAgICAgICAgIC8+XG5cbiAgICAgICAgICA8ZyA6dHJhbnNmb3JtPVwiJ3RyYW5zbGF0ZSgwLCcgKyAoIDEgKyAxNiAqIGZ4LnJvdyApICsgJyknXCI+XG4gICAgICAgICAgICA8cmVjdCBjbGFzcz1cImJvZHlcIlxuICAgICAgICAgICAgICA6Y2xhc3M9XCJ7XG4gICAgICAgICAgICAgICAgc2VsZWN0ZWQ6IHNlbGVjdGVkRnhJZHMuc29tZSggKCBpZCApID0+IGlkID09PSBmeC4kaWQgKSxcbiAgICAgICAgICAgICAgICBieXBhc3M6IGZ4LmJ5cGFzc1xuICAgICAgICAgICAgICB9XCJcbiAgICAgICAgICAgICAgOng9XCJ0MngoIGZ4LnRpbWUgKVwiXG4gICAgICAgICAgICAgIDp3aWR0aD1cInQyeCggZngudGltZSArIGZ4Lmxlbmd0aCApIC0gdDJ4KCBmeC50aW1lIClcIlxuICAgICAgICAgICAgICBoZWlnaHQ9XCIxNlwiXG4gICAgICAgICAgICAgIHJ4PVwiNVwiXG4gICAgICAgICAgICAgIHJ5PVwiNVwiXG4gICAgICAgICAgICAgIEBtb3VzZWRvd24ubGVmdC5zdG9wPVwiZ3JhYkZ4Qm9keSggZnguJGlkLCAkZXZlbnQgKVwiXG4gICAgICAgICAgICAgIEBkYmxjbGljay5zdG9wPVwicmVtb3ZlRngoIGZ4LiRpZCApXCJcbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgICA8cmVjdCBjbGFzcz1cInNpZGVcIlxuICAgICAgICAgICAgICA6eD1cInQyeCggZngudGltZSApIC0gMVwiXG4gICAgICAgICAgICAgIHdpZHRoPVwiNlwiXG4gICAgICAgICAgICAgIGhlaWdodD1cIjE2XCJcbiAgICAgICAgICAgICAgQG1vdXNlZG93bi5sZWZ0LnN0b3A9XCJncmFiRnhMZWZ0KCBmeC4kaWQsICRldmVudCApXCJcbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgICA8cmVjdCBjbGFzcz1cInNpZGVcIlxuICAgICAgICAgICAgICA6eD1cInQyeCggZngudGltZSArIGZ4Lmxlbmd0aCApIC0gNVwiXG4gICAgICAgICAgICAgIHdpZHRoPVwiNlwiXG4gICAgICAgICAgICAgIGhlaWdodD1cIjE2XCJcbiAgICAgICAgICAgICAgQG1vdXNlZG93bi5sZWZ0LnN0b3A9XCJncmFiRnhSaWdodCggZnguJGlkLCAkZXZlbnQgKVwiXG4gICAgICAgICAgICAvPlxuICAgICAgICAgICAgXG4gICAgICAgICAgICA8Y2xpcFBhdGhcbiAgICAgICAgICAgICAgOmlkPVwiJ2Z4Y2xpcCcrZnguJGlkXCJcbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgPHJlY3RcbiAgICAgICAgICAgICAgICA6eD1cInQyeCggZngudGltZSApXCJcbiAgICAgICAgICAgICAgICA6d2lkdGg9XCJ0MngoIGZ4LnRpbWUgKyBmeC5sZW5ndGggKSAtIHQyeCggZngudGltZSApXCJcbiAgICAgICAgICAgICAgICBoZWlnaHQ9XCIxNlwiXG4gICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICA8L2NsaXBQYXRoPlxuICAgICAgICAgICAgPGdcbiAgICAgICAgICAgICAgOmNsaXAtcGF0aD1cIid1cmwoI2Z4Y2xpcCcgKyBmeC4kaWQgKyAnKSdcIlxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICA8dGV4dCBjbGFzcz1cInRleHRcIlxuICAgICAgICAgICAgICAgIDpjbGFzcz1cIntcbiAgICAgICAgICAgICAgICAgIHNlbGVjdGVkOiBzZWxlY3RlZEZ4SWRzLnNvbWUoICggaWQgKSA9PiBpZCA9PT0gZnguJGlkICksXG4gICAgICAgICAgICAgICAgICBieXBhc3M6IGZ4LmJ5cGFzc1xuICAgICAgICAgICAgICAgIH1cIlxuICAgICAgICAgICAgICAgIDp4PVwidDJ4KCBmeC50aW1lICkgKyA0XCJcbiAgICAgICAgICAgICAgICB5PVwiMTJcIlxuICAgICAgICAgICAgICA+e3sgYXV0b21hdG9uLmdldEZ4RGVmaW5pdGlvbk5hbWUoIGZ4LmRlZiApIH19PC90ZXh0PlxuICAgICAgICAgICAgPC9nPlxuICAgICAgICAgIDwvZz5cbiAgICAgICAgPC9nPlxuXG4gICAgICAgIDxwb2x5bGluZSBjbGFzcz1cImdyYXBoXCJcbiAgICAgICAgICB2LWlmPVwic2VsZWN0ZWRQYXJhbVwiXG4gICAgICAgICAgOnBvaW50cz1cImdyYXBoUG9pbnRzXCJcbiAgICAgICAgLz5cblxuICAgICAgICA8bGluZSBjbGFzcz1cImN1cnJlbnRMaW5lXCJcbiAgICAgICAgICA6eDE9XCJ0MngoIGF1dG9tYXRvbi50aW1lIClcIlxuICAgICAgICAgIHkxPVwiMFwiXG4gICAgICAgICAgOngyPVwidDJ4KCBhdXRvbWF0b24udGltZSApXCJcbiAgICAgICAgICA6eTI9XCJoZWlnaHRcIlxuICAgICAgICAvPlxuICAgICAgICA8dGV4dCBjbGFzcz1cImN1cnJlbnRUZXh0XCJcbiAgICAgICAgICA6eD1cInQyeCggYXV0b21hdG9uLnRpbWUgKSArIDJcIlxuICAgICAgICAgIDp5PVwiaGVpZ2h0IC0gMlwiXG4gICAgICAgID57eyBhdXRvbWF0b24udGltZS50b0ZpeGVkKCAzICkgfX08L3RleHQ+XG4gICAgICAgIDxnXG4gICAgICAgICAgdi1pZj1cInNlbGVjdGVkUGFyYW1cIlxuICAgICAgICA+XG4gICAgICAgICAgPGxpbmUgY2xhc3M9XCJjdXJyZW50TGluZVwiXG4gICAgICAgICAgICB4MT1cIjBcIlxuICAgICAgICAgICAgOnkxPVwidjJ5KCBzZWxlY3RlZFBhcmFtLmdldFZhbHVlKCkgKVwiXG4gICAgICAgICAgICA6eDI9XCJ3aWR0aFwiXG4gICAgICAgICAgICA6eTI9XCJ2MnkoIHNlbGVjdGVkUGFyYW0uZ2V0VmFsdWUoKSApXCJcbiAgICAgICAgICAvPlxuICAgICAgICAgIDx0ZXh0IGNsYXNzPVwiY3VycmVudFRleHRcIlxuICAgICAgICAgICAgeD1cIjJcIlxuICAgICAgICAgICAgOnk9XCJ2MnkoIHNlbGVjdGVkUGFyYW0uZ2V0VmFsdWUoKSApIC0gMlwiXG4gICAgICAgICAgPnt7IHNlbGVjdGVkUGFyYW0uZ2V0VmFsdWUoKS50b0ZpeGVkKCAzICkgfX08L3RleHQ+XG4gICAgICAgICAgPGNpcmNsZSBjbGFzcz1cImN1cnJlbnRQb2ludFwiXG4gICAgICAgICAgICByPVwiNVwiXG4gICAgICAgICAgICA6Y3g9XCJ0MngoIGF1dG9tYXRvbi50aW1lIClcIlxuICAgICAgICAgICAgOmN5PVwidjJ5KCBzZWxlY3RlZFBhcmFtLmdldFZhbHVlKCkgKVwiXG4gICAgICAgICAgLz5cbiAgICAgICAgPC9nPlxuICAgICAgPC9nPlxuXG4gICAgICA8ZyB2LWlmPVwic2VsZWN0ZWRQYXJhbVwiPlxuICAgICAgICA8ZyBjbGFzcz1cIm5vZGVcIlxuICAgICAgICAgIHYtZm9yPVwibm9kZSBpbiBzZWxlY3RlZFBhcmFtLmR1bXBOb2RlcygpXCJcbiAgICAgICAgICA6a2V5PVwibm9kZS4kaWRcIlxuICAgICAgICA+XG4gICAgICAgICAgPGcgY2xhc3M9XCJoYW5kbGVcIj5cbiAgICAgICAgICAgIDxsaW5lIGNsYXNzPVwibGluZVwiXG4gICAgICAgICAgICAgIHYtaWY9XCJub2RlLmluXCJcbiAgICAgICAgICAgICAgOngxPVwidDJ4KCBub2RlLnRpbWUgKVwiXG4gICAgICAgICAgICAgIDp5MT1cInYyeSggbm9kZS52YWx1ZSApXCJcbiAgICAgICAgICAgICAgOngyPVwidDJ4KCBub2RlLnRpbWUgKyBub2RlLmluLnRpbWUgKVwiXG4gICAgICAgICAgICAgIDp5Mj1cInYyeSggbm9kZS52YWx1ZSArIG5vZGUuaW4udmFsdWUgKVwiXG4gICAgICAgICAgICAvPlxuICAgICAgICAgICAgPGNpcmNsZSBjbGFzcz1cImNpcmNsZVwiXG4gICAgICAgICAgICAgIHYtaWY9XCJub2RlLmluXCJcbiAgICAgICAgICAgICAgcj1cIjRcIlxuICAgICAgICAgICAgICA6dHJhbnNmb3JtPVwiJ3RyYW5zbGF0ZSgnICsgdDJ4KCBub2RlLnRpbWUgKyBub2RlLmluLnRpbWUgKSArICcsJyArIHYyeSggbm9kZS52YWx1ZSArIG5vZGUuaW4udmFsdWUgKSArICcpJ1wiXG4gICAgICAgICAgICAgIEBtb3VzZWRvd24ubGVmdC5zdG9wPVwiZ3JhYkhhbmRsZSggbm9kZS4kaWQsIGZhbHNlLCAkZXZlbnQgKVwiXG4gICAgICAgICAgICAgIEBkYmxjbGljay5zdG9wPVwicmVtb3ZlSGFuZGxlKCBub2RlLiRpZCwgZmFsc2UgKVwiXG4gICAgICAgICAgICAvPlxuXG4gICAgICAgICAgICA8bGluZSBjbGFzcz1cImxpbmVcIlxuICAgICAgICAgICAgICB2LWlmPVwibm9kZS5vdXRcIlxuICAgICAgICAgICAgICA6eDE9XCJ0MngoIG5vZGUudGltZSApXCJcbiAgICAgICAgICAgICAgOnkxPVwidjJ5KCBub2RlLnZhbHVlIClcIlxuICAgICAgICAgICAgICA6eDI9XCJ0MngoIG5vZGUudGltZSArIG5vZGUub3V0LnRpbWUgKVwiXG4gICAgICAgICAgICAgIDp5Mj1cInYyeSggbm9kZS52YWx1ZSArIG5vZGUub3V0LnZhbHVlIClcIlxuICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIDxjaXJjbGUgY2xhc3M9XCJjaXJjbGVcIlxuICAgICAgICAgICAgICB2LWlmPVwibm9kZS5vdXRcIlxuICAgICAgICAgICAgICByPVwiNFwiXG4gICAgICAgICAgICAgIDp0cmFuc2Zvcm09XCIndHJhbnNsYXRlKCcgKyB0MngoIG5vZGUudGltZSArIG5vZGUub3V0LnRpbWUgKSArICcsJyArIHYyeSggbm9kZS52YWx1ZSArIG5vZGUub3V0LnZhbHVlICkgKyAnKSdcIlxuICAgICAgICAgICAgICBAbW91c2Vkb3duLmxlZnQuc3RvcD1cImdyYWJIYW5kbGUoIG5vZGUuJGlkLCB0cnVlLCAkZXZlbnQgKVwiXG4gICAgICAgICAgICAgIEBkYmxjbGljay5zdG9wPVwicmVtb3ZlSGFuZGxlKCBub2RlLiRpZCwgdHJ1ZSApXCJcbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgPC9nPlxuXG4gICAgICAgICAgPGcgY2xhc3M9XCJib2R5XCJcbiAgICAgICAgICAgIDpjbGFzcz1cInsgc2VsZWN0ZWQ6IHNlbGVjdGVkTm9kZUlkcy5zb21lKCAoIGlkICkgPT4gaWQgPT09IG5vZGUuJGlkICkgfVwiXG4gICAgICAgICAgICBAZGJsY2xpY2suc3RvcD1cInJlbW92ZU5vZGUoIG5vZGUuJGlkIClcIlxuICAgICAgICAgICAgQG1vdXNlZG93bi5sZWZ0LnNoaWZ0LnN0b3A9XCJyZXNldEhhbmRsZXMoIG5vZGUuJGlkIClcIlxuICAgICAgICAgICAgQG1vdXNlZG93bi5sZWZ0LnN0b3A9XCJncmFiTm9kZSggbm9kZS4kaWQsICRldmVudCApXCJcbiAgICAgICAgICA+XG4gICAgICAgICAgICA8Y2lyY2xlIGNsYXNzPVwiY2lyY2xlXCJcbiAgICAgICAgICAgICAgdi1pZj1cInYwIDw9IG5vZGUudmFsdWUgJiYgbm9kZS52YWx1ZSA8PSB2MVwiXG4gICAgICAgICAgICAgIDp0cmFuc2Zvcm09XCIndHJhbnNsYXRlKCcgKyB0MngoIG5vZGUudGltZSApICsgJywnICsgdjJ5KCBub2RlLnZhbHVlICkgKyAnKSdcIlxuICAgICAgICAgICAgICByPVwiNVwiXG4gICAgICAgICAgICAvPlxuICAgICAgICAgICAgPHBhdGggY2xhc3M9XCJ0cmlhbmdsZVwiXG4gICAgICAgICAgICAgIHYtaWY9XCJub2RlLnZhbHVlIDwgdjBcIlxuICAgICAgICAgICAgICA6dHJhbnNmb3JtPVwiJ3RyYW5zbGF0ZSgnICsgdDJ4KCBub2RlLnRpbWUgKSArICcsJyArIGhlaWdodCArICcpJ1wiXG4gICAgICAgICAgICAgIGQ9XCJNIDAgLTQgTCA1IC0xMiBMIC01IC0xMiB6XCJcbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgICA8cGF0aCBjbGFzcz1cInRyaWFuZ2xlXCJcbiAgICAgICAgICAgICAgdi1pZj1cInYxIDwgbm9kZS52YWx1ZVwiXG4gICAgICAgICAgICAgIDp0cmFuc2Zvcm09XCIndHJhbnNsYXRlKCcgKyB0MngoIG5vZGUudGltZSApICsgJywwKSdcIlxuICAgICAgICAgICAgICBkPVwiTSAwIDQgTCAtNSAxMiBMIDUgMTIgelwiXG4gICAgICAgICAgICAvPlxuICAgICAgICAgIDwvZz5cbiAgICAgICAgPC9nPlxuICAgICAgPC9nPlxuICAgIDwvc3ZnPlxuXG4gICAgPEZ4TWVudVxuICAgICAgOmF1dG9tYXRvbj1cImF1dG9tYXRvblwiXG4gICAgICA6YWN0aXZlPVwiZnhtZW51QWN0aXZlXCJcbiAgICAgIEBzZWxlY3RlZD1cImNyZWF0ZUZ4KCBmeG1lbnVUaW1lLCAkZXZlbnQgKVwiXG4gICAgICBAYmx1cj1cImZ4bWVudUFjdGl2ZSA9IGZhbHNlXCJcbiAgICAvPlxuICA8L2Rpdj5cbjwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCBQYXJhbVdpdGhHVUkgZnJvbSAnLi4vcGFyYW0tZ3VpJztcblxuaW1wb3J0IEZ4TWVudSBmcm9tICcuL3RpbWVsaW5lLWZ4bWVudS52dWUnO1xuXG5jb25zdCBtb3VzZUV2ZW50cyA9ICggbW92ZSwgdXAgKSA9PiB7XG4gIGNvbnN0IHUgPSAoIGV2ZW50ICkgPT4ge1xuICAgIGlmICggdXAgKSB7IHVwKCBldmVudCApOyB9IFxuXG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoIFwibW91c2Vtb3ZlXCIsIG1vdmUgKTtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lciggXCJtb3VzZXVwXCIsIHUgKTtcbiAgfTtcblxuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggXCJtb3VzZW1vdmVcIiwgbW92ZSApO1xuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggXCJtb3VzZXVwXCIsIHUgKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgY29tcG9uZW50czoge1xuICAgIEZ4TWVudVxuICB9LFxuXG4gIHByb3BzOiBbXG4gICAgXCJhdXRvbWF0b25cIixcbiAgICBcInNlbGVjdGVkUGFyYW1OYW1lXCIsXG4gICAgXCJzZWxlY3RlZE5vZGVJZHNcIixcbiAgICBcInNlbGVjdGVkRnhJZHNcIlxuICBdLFxuXG4gIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoOiAxMDAsXG4gICAgICBoZWlnaHQ6IDEwMCxcblxuICAgICAgdDA6IDAuMCxcbiAgICAgIHQxOiB0aGlzLmF1dG9tYXRvbi5sZW5ndGgsXG4gICAgICB2MDogLTAuMjUsXG4gICAgICB2MTogMS4yNSxcblxuICAgICAgZ3JpZDoge1xuICAgICAgICB4OiBbXSxcbiAgICAgICAgeTogW11cbiAgICAgIH0sXG5cbiAgICAgIGdyYXBoUG9pbnRzOiAnJyxcblxuICAgICAgZnhtZW51QWN0aXZlOiBmYWxzZSxcbiAgICAgIGZ4bWVudVRpbWU6IDBcbiAgICB9XG4gIH0sXG5cbiAgbWV0aG9kczoge1xuICAgIHVwZGF0ZUdyaWQoKSB7XG4gICAgICB0aGlzLmdyaWQgPSB7XG4gICAgICAgIHg6IFtdLFxuICAgICAgICB5OiBbXVxuICAgICAgfTtcblxuICAgICAge1xuICAgICAgICBjb25zdCBkZWx0YSA9ICggdGhpcy50MSAtIHRoaXMudDAgKTtcbiAgICAgICAgY29uc3QgbG9nRGVsdGEgPSBNYXRoLmxvZzEwKCBkZWx0YSApO1xuICAgICAgICBjb25zdCBzY2FsZSA9IE1hdGgucG93KCAxMC4wLCBNYXRoLmZsb29yKCBsb2dEZWx0YSApIC0gMS4wICk7XG4gICAgICAgIGNvbnN0IGludHJ2ID0gbG9nRGVsdGEgLSBNYXRoLmZsb29yKCBsb2dEZWx0YSApO1xuICAgICAgICBjb25zdCBudW0gPSBNYXRoLmZsb29yKCB0aGlzLnQwIC8gc2NhbGUgKTtcbiAgICAgICAgY29uc3QgYmVnaW4gPSBudW0gKiBzY2FsZTtcbiAgICAgICAgbGV0IGFjY2VudDEwID0gbnVtIC0gTWF0aC5mbG9vciggbnVtIC8gMTAgKSAqIDEwO1xuICAgICAgICBsZXQgYWNjZW50MTAwID0gbnVtIC0gTWF0aC5mbG9vciggbnVtIC8gMTAwICkgKiAxMDA7XG5cbiAgICAgICAgZm9yICggbGV0IHYgPSBiZWdpbjsgdiA8IHRoaXMudDE7IHYgKz0gc2NhbGUgKSB7XG4gICAgICAgICAgY29uc3Qgb3AgPSAoXG4gICAgICAgICAgICBhY2NlbnQxMDAgPT09IDAgPyAwLjQgOlxuICAgICAgICAgICAgYWNjZW50MTAgPT09IDAgPyAwLjQgLSBpbnRydiAqIDAuMyA6XG4gICAgICAgICAgICAwLjEgLSBpbnRydiAqIDAuM1xuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKCAwLjAgPCBvcCApIHtcbiAgICAgICAgICAgIHRoaXMuZ3JpZC54LnB1c2goIHtcbiAgICAgICAgICAgICAgdmFsOiB2ICsgMUUtOSwgLy8gdHJpY2s6IHRvIHByZXZlbnQgLTAuMDAwXG4gICAgICAgICAgICAgIHBvczogdGhpcy50MngoIHYgKSxcbiAgICAgICAgICAgICAgb3A6IG9wXG4gICAgICAgICAgICB9ICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGFjY2VudDEwID0gKCBhY2NlbnQxMCArIDEgKSAlIDEwO1xuICAgICAgICAgIGFjY2VudDEwMCA9ICggYWNjZW50MTAwICsgMSApICUgMTAwO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHtcbiAgICAgICAgY29uc3QgZGVsdGEgPSAoIHRoaXMudjEgLSB0aGlzLnYwICk7XG4gICAgICAgIGNvbnN0IGxvZ0RlbHRhID0gTWF0aC5sb2cxMCggZGVsdGEgKTtcbiAgICAgICAgY29uc3Qgc2NhbGUgPSBNYXRoLnBvdyggMTAuMCwgTWF0aC5mbG9vciggbG9nRGVsdGEgKSAtIDEuMCApO1xuICAgICAgICBjb25zdCBpbnRydiA9IGxvZ0RlbHRhIC0gTWF0aC5mbG9vciggbG9nRGVsdGEgKTtcbiAgICAgICAgY29uc3QgbnVtID0gTWF0aC5mbG9vciggdGhpcy52MCAvIHNjYWxlICk7XG4gICAgICAgIGNvbnN0IGJlZ2luID0gbnVtICogc2NhbGU7XG4gICAgICAgIGxldCBhY2NlbnQxMCA9IG51bSAtIE1hdGguZmxvb3IoIG51bSAvIDEwICkgKiAxMDtcbiAgICAgICAgbGV0IGFjY2VudDEwMCA9IG51bSAtIE1hdGguZmxvb3IoIG51bSAvIDEwMCApICogMTAwO1xuXG4gICAgICAgIGZvciAoIGxldCB2ID0gYmVnaW47IHYgPCB0aGlzLnYxOyB2ICs9IHNjYWxlICkge1xuICAgICAgICAgIGNvbnN0IG9wID0gKFxuICAgICAgICAgICAgYWNjZW50MTAwID09PSAwID8gMC40IDpcbiAgICAgICAgICAgIGFjY2VudDEwID09PSAwID8gMC40IC0gaW50cnYgKiAwLjMgOlxuICAgICAgICAgICAgMC4xIC0gaW50cnYgKiAwLjNcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmICggMC4wIDwgb3AgKSB7XG4gICAgICAgICAgICB0aGlzLmdyaWQueS5wdXNoKCB7XG4gICAgICAgICAgICAgIHZhbDogdiArIDFFLTksIC8vIHRyaWNrOiB0byBwcmV2ZW50IC0wLjAwMFxuICAgICAgICAgICAgICBwb3M6IHRoaXMudjJ5KCB2ICksXG4gICAgICAgICAgICAgIG9wOiBvcFxuICAgICAgICAgICAgfSApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhY2NlbnQxMCA9ICggYWNjZW50MTAgKyAxICkgJSAxMDtcbiAgICAgICAgICBhY2NlbnQxMDAgPSAoIGFjY2VudDEwMCArIDEgKSAlIDEwMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICB1cGRhdGVHcmFwaCgpIHtcbiAgICAgIGNvbnN0IHBhcmFtID0gdGhpcy5zZWxlY3RlZFBhcmFtO1xuICAgICAgaWYgKCAhcGFyYW0gKSB7IHJldHVybjsgfVxuXG4gICAgICBsZXQgcG9pbnRzID0gJyc7XG5cbiAgICAgIGZvciAoIGxldCB4ID0gMDsgeCA8PSB0aGlzLndpZHRoOyB4ICsrICkge1xuICAgICAgICBjb25zdCB0ID0gdGhpcy54MnQoIHggKTtcbiAgICAgICAgY29uc3QgdiA9IHBhcmFtLmdldFZhbHVlKCB0ICk7XG4gICAgICAgIGNvbnN0IHkgPSB0aGlzLnYyeSggdiApO1xuICAgICAgICBwb2ludHMgKz0geCArICcgJyArIHkgKyAnICc7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHRoaXMuZ3JhcGhQb2ludHMgPSBwb2ludHM7XG4gICAgfSxcbiAgICBcbiAgICB4MnQoIHggKSB7XG4gICAgICBjb25zdCB1ID0geCAvIHRoaXMud2lkdGg7XG4gICAgICByZXR1cm4gdSAqICggdGhpcy50MSAtIHRoaXMudDAgKSArIHRoaXMudDA7XG4gICAgfSxcbiAgICB0MngoIHQgKSB7XG4gICAgICBjb25zdCB1ID0gKCB0IC0gdGhpcy50MCApIC8gKCB0aGlzLnQxIC0gdGhpcy50MCApO1xuICAgICAgcmV0dXJuIHUgKiB0aGlzLndpZHRoO1xuICAgIH0sXG4gICAgeTJ2KCB5ICkge1xuICAgICAgY29uc3QgdSA9IDEuMCAtIHkgLyB0aGlzLmhlaWdodDtcbiAgICAgIHJldHVybiB1ICogKCB0aGlzLnYxIC0gdGhpcy52MCApICsgdGhpcy52MDtcbiAgICB9LFxuICAgIHYyeSggdiApIHtcbiAgICAgIGNvbnN0IHUgPSAxLjAgLSAoIHYgLSB0aGlzLnYwICkgLyAoIHRoaXMudjEgLSB0aGlzLnYwICk7XG4gICAgICByZXR1cm4gdSAqIHRoaXMuaGVpZ2h0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNb3ZlIHRoZSB0aW1lbGluZSB2aWV3LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkeCBEZWx0YSBvZiBYXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGR5IERlbHRhIG9mIFlcbiAgICAgKiBAcmV0dXJucyB7dm9pZH0gdm9pZFxuICAgICAqL1xuICAgIG1vdmVWaWV3KCBkeCwgZHkgKSB7XG4gICAgICBsZXQgZHQgPSB0aGlzLngydCggMC4wICkgLSB0aGlzLngydCggZHggKTtcbiAgICAgIGxldCBkdiA9IHRoaXMueTJ2KCAwLjAgKSAtIHRoaXMueTJ2KCBkeSApO1xuXG4gICAgICBkdCA9IE1hdGgubWluKCBNYXRoLm1heCggZHQsIC10aGlzLnQwICksIHRoaXMuYXV0b21hdG9uLmxlbmd0aCAtIHRoaXMudDEgKTtcblxuICAgICAgdGhpcy50MCArPSBkdDsgdGhpcy50MSArPSBkdDtcbiAgICAgIHRoaXMudjAgKz0gZHY7IHRoaXMudjEgKz0gZHY7XG5cbiAgICAgIHRoaXMudXBkYXRlR3JpZCgpO1xuICAgICAgdGhpcy51cGRhdGVHcmFwaCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBab29tIHRoZSB0aW1lbGluZSB2aWV3LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjdCBDZW50ZXIgb2YgVFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjdiBDZW50ZXIgb2YgVlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkeCBEZWx0YSBvZiBYXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGR5IERlbHRhIG9mIFlcbiAgICAgKiBAcmV0dXJucyB7dm9pZH0gdm9pZFxuICAgICAqL1xuICAgIHpvb21WaWV3KCBjdCwgY3YsIGR4LCBkeSApIHtcbiAgICAgIGNvbnN0IHJ0ID0gKCBjdCAtIHRoaXMudDAgKSAvICggdGhpcy50MSAtIHRoaXMudDAgKTtcbiAgICAgIGNvbnN0IHJ2ID0gKCBjdiAtIHRoaXMudjAgKSAvICggdGhpcy52MSAtIHRoaXMudjAgKTtcblxuICAgICAgbGV0IGR0ID0gdGhpcy50MSAtIHRoaXMudDA7XG4gICAgICBkdCAqPSBNYXRoLnBvdyggKCB0aGlzLndpZHRoICsgMS4wICkgLyB0aGlzLndpZHRoLCBkeCAqIDIuMCApO1xuICAgICAgZHQgPSBNYXRoLm1pbiggTWF0aC5tYXgoIGR0LCAwLjAxICksIDEwMDAuMCApO1xuXG4gICAgICBsZXQgZHYgPSB0aGlzLnYxIC0gdGhpcy52MDtcbiAgICAgIGR2ICo9IE1hdGgucG93KCAoIHRoaXMud2lkdGggKyAxLjAgKSAvIHRoaXMud2lkdGgsIGR5ICogMi4wICk7XG4gICAgICBkdiA9IE1hdGgubWluKCBNYXRoLm1heCggZHYsIDAuMDEgKSwgMTAwMC4wICk7XG5cbiAgICAgIHRoaXMudDAgPSBjdCAtIHJ0ICogZHQ7XG4gICAgICB0aGlzLnQxID0gY3QgKyAoIDEuMCAtIHJ0ICkgKiBkdDtcbiAgICAgIHRoaXMudjAgPSBjdiAtIHJ2ICogZHY7XG4gICAgICB0aGlzLnYxID0gY3YgKyAoIDEuMCAtIHJ2ICkgKiBkdjtcblxuICAgICAgaWYgKHRoaXMudDAgPCAwLjAgKSB7XG4gICAgICAgIHRoaXMudDEgPSBNYXRoLm1heCggdGhpcy50MSAtIHRoaXMudDAsIHRoaXMudDEgKTtcbiAgICAgIH1cbiAgICAgIGlmICggdGhpcy5hdXRvbWF0b24ubGVuZ3RoIDwgdGhpcy50MSApIHtcbiAgICAgICAgdGhpcy50MCArPSB0aGlzLmF1dG9tYXRvbi5sZW5ndGggLSB0aGlzLnQxO1xuICAgICAgfVxuICAgICAgaWYgKCB0aGlzLnQwIDwgMC4wICkge1xuICAgICAgICB0aGlzLnQwID0gMC4wO1xuICAgICAgfVxuICAgICAgaWYgKCB0aGlzLmF1dG9tYXRvbi5sZW5ndGggPCB0aGlzLnQxICkge1xuICAgICAgICB0aGlzLnQxID0gdGhpcy5hdXRvbWF0b24ubGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnVwZGF0ZUdyaWQoKTtcbiAgICAgIHRoaXMudXBkYXRlR3JhcGgoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbm9kZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdCBUaW1lIHBvaW50IHdoZXJlIHlvdSB3YW50IHRvIGNyZWF0ZSBhIG5vZGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdiBWYWx1ZSBwb2ludCB3aGVyZSB5b3Ugd2FudCB0byBjcmVhdGUgYSBub2RlXG4gICAgICogQHJldHVybnMge3ZvaWR9IHZvaWRcbiAgICAgKi9cbiAgICBjcmVhdGVOb2RlKCB0LCB2ICkge1xuICAgICAgY29uc3QgcGFyYW0gPSB0aGlzLnNlbGVjdGVkUGFyYW07XG4gICAgICBpZiAoICFwYXJhbSApIHsgcmV0dXJuOyB9XG5cbiAgICAgIGNvbnN0IGlkID0gcGFyYW0uY3JlYXRlTm9kZSggdCwgdiApO1xuICAgICAgY29uc3QgZGF0YSA9IHBhcmFtLmR1bXBOb2RlKCBpZCApO1xuXG4gICAgICB0aGlzLiRlbWl0KCAnbm9kZVNlbGVjdGVkJywgWyBpZCBdICk7XG4gICAgICB0aGlzLiRlbWl0KCAnZnhTZWxlY3RlZCcsIFtdICk7XG5cbiAgICAgIHRoaXMuYXV0b21hdG9uLnB1c2hIaXN0b3J5KFxuICAgICAgICAnQ3JlYXRlIE5vZGUnLFxuICAgICAgICAoKSA9PiBwYXJhbS5jcmVhdGVOb2RlRnJvbURhdGEoIGRhdGEgKSxcbiAgICAgICAgKCkgPT4gcGFyYW0ucmVtb3ZlTm9kZSggaWQgKVxuICAgICAgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGEgbm9kZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgSWQgb2Ygbm9kZVxuICAgICAqIEByZXR1cm5zIHt2b2lkfSB2b2lkXG4gICAgICovXG4gICAgcmVtb3ZlTm9kZSggaWQgKSB7XG4gICAgICBjb25zdCBwYXJhbSA9IHRoaXMuc2VsZWN0ZWRQYXJhbTtcbiAgICAgIGlmICggIXBhcmFtICkgeyByZXR1cm47IH1cblxuICAgICAgY29uc3Qgbm9kZSA9IHBhcmFtLmR1bXBOb2RlKCBpZCApO1xuICAgICAgaWYgKCAhKCBub2RlLmluICYmIG5vZGUub3V0ICkgKSB7IHJldHVybjsgfVxuXG4gICAgICB0aGlzLmF1dG9tYXRvbi5wdXNoSGlzdG9yeShcbiAgICAgICAgJ1JlbW92ZSBOb2RlJyxcbiAgICAgICAgKCkgPT4gcGFyYW0ucmVtb3ZlTm9kZSggaWQgKSxcbiAgICAgICAgKCkgPT4gcGFyYW0uY3JlYXRlTm9kZUZyb21EYXRhKCBub2RlICksXG4gICAgICAgIHRydWVcbiAgICAgICk7XG5cbiAgICAgIHRoaXMuJGVtaXQoICdub2RlU2VsZWN0ZWQnLCBbXSApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYSBoYW5kbGUgb2YgYSBub2RlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBJZCBvZiBub2RlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBpc091dCBJbnB1dCBoYW5kbGUgaWYgZmFsc2UsIG91dHB1dCBoYW5kbGUgaWYgdHJ1ZVxuICAgICAqIEByZXR1cm5zIHt2b2lkfSB2b2lkXG4gICAgICovXG4gICAgcmVtb3ZlSGFuZGxlKCBpZCwgaXNPdXQgKSB7XG4gICAgICBjb25zdCBwYXJhbSA9IHRoaXMuc2VsZWN0ZWRQYXJhbTtcbiAgICAgIGlmICggIXBhcmFtICkgeyByZXR1cm47IH1cblxuICAgICAgY29uc3Qgbm9kZSA9IHBhcmFtLmR1bXBOb2RlKCBpZCApO1xuXG4gICAgICBjb25zdCB0MCA9IGlzT3V0ID8gbm9kZS5vdXQudGltZSA6IG5vZGUuaW4udGltZTtcbiAgICAgIGNvbnN0IHYwID0gaXNPdXQgPyBub2RlLm91dC52YWx1ZSA6IG5vZGUuaW4udmFsdWU7XG5cbiAgICAgIHBhcmFtLm1vdmVIYW5kbGUoIGlkLCBpc091dCwgMC4wLCAwLjAgKTtcblxuICAgICAgdGhpcy5hdXRvbWF0b24ucHVzaEhpc3RvcnkoXG4gICAgICAgICdSZW1vdmUgSGFuZGxlJyxcbiAgICAgICAgKCkgPT4gcGFyYW0ubW92ZUhhbmRsZSggaWQsIGlzT3V0LCAwLjAsIDAuMCApLFxuICAgICAgICAoKSA9PiBwYXJhbS5tb3ZlSGFuZGxlKCBpZCwgaXNPdXQsIHQwLCB2MCApLFxuICAgICAgICB0cnVlXG4gICAgICApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXNldCBoYW5kbGVzIG9mIGEgbm9kZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgSWQgb2Ygbm9kZVxuICAgICAqIEByZXR1cm5zIHt2b2lkfSB2b2lkXG4gICAgICovXG4gICAgcmVzZXRIYW5kbGVzKCBpZCApIHtcbiAgICAgIGNvbnN0IHBhcmFtID0gdGhpcy5zZWxlY3RlZFBhcmFtO1xuICAgICAgaWYgKCAhcGFyYW0gKSB7IHJldHVybjsgfVxuXG4gICAgICBjb25zdCBub2RlID0gcGFyYW0uZHVtcE5vZGUoIGlkICk7XG5cbiAgICAgIHRoaXMuYXV0b21hdG9uLnB1c2hIaXN0b3J5KFxuICAgICAgICAnUmVzZXQgSGFuZGxlJyxcbiAgICAgICAgKCkgPT4ge1xuICAgICAgICAgIHBhcmFtLnJlc2V0SGFuZGxlKCBpZCwgZmFsc2UgKTtcbiAgICAgICAgICBwYXJhbS5yZXNldEhhbmRsZSggaWQsIHRydWUgKTtcbiAgICAgICAgfSxcbiAgICAgICAgKCkgPT4ge1xuICAgICAgICAgIHBhcmFtLm1vdmVIYW5kbGUoIGlkLCBmYWxzZSwgbm9kZS5pbi50aW1lLCBub2RlLmluLnZhbHVlICk7XG4gICAgICAgICAgcGFyYW0ubW92ZUhhbmRsZSggaWQsIHRydWUsIG5vZGUub3V0LnRpbWUsIG5vZGUub3V0LnZhbHVlICk7XG4gICAgICAgIH0sXG4gICAgICAgIHRydWVcbiAgICAgICk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1vdXNlIG9wZXJhdGlvbiBoZWxwZXIuXG4gICAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBldmVudCBNb3VzZSBldmVudCBmcm9tIG1vdXNlZG93blxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIEV2ZW50IGxpc3RlbmVyIGZvciBtb3VzZW1vdmUgLyBtb3VzZXVwXG4gICAgICogQHJldHVybnMge3ZvaWR9IHZvaWRcbiAgICAgKi9cbiAgICBncmFiSGVscGVyKCBldmVudCwgY2FsbGJhY2sgKSB7XG4gICAgICBjb25zdCB4MCA9IGV2ZW50LmNsaWVudFg7XG4gICAgICBjb25zdCB5MCA9IGV2ZW50LmNsaWVudFk7XG4gICAgICBjb25zdCB0MCA9IHRoaXMueDJ0KCB4MCApO1xuICAgICAgY29uc3QgdjAgPSB0aGlzLnkydiggeTAgKTtcblxuICAgICAgbGV0IG1vdmVkID0gZmFsc2U7XG5cbiAgICAgIGNvbnN0IG1vdmUgPSAoIGV2ZW50ICkgPT4ge1xuICAgICAgICBjb25zdCBkdCA9IHRoaXMueDJ0KCBldmVudC5jbGllbnRYICkgLSB0MDtcbiAgICAgICAgY29uc3QgZHYgPSB0aGlzLnkydiggZXZlbnQuY2xpZW50WSApIC0gdjA7XG5cbiAgICAgICAgbW92ZWQgPSB0cnVlO1xuXG4gICAgICAgIGNhbGxiYWNrKCBkdCwgZHYsIGV2ZW50ICk7XG4gICAgICB9O1xuXG4gICAgICBjb25zdCB1cCA9ICggZXZlbnQgKSA9PiB7XG4gICAgICAgIGlmICggbW92ZWQgKSB7XG4gICAgICAgICAgY29uc3QgZHQgPSB0aGlzLngydCggZXZlbnQuY2xpZW50WCApIC0gdDA7XG4gICAgICAgICAgY29uc3QgZHYgPSB0aGlzLnkydiggZXZlbnQuY2xpZW50WSApIC0gdjA7XG5cbiAgICAgICAgICBjYWxsYmFjayggZHQsIGR2LCBldmVudCwgdHJ1ZSApO1xuICAgICAgICB9XG5cbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoICdtb3VzZW1vdmUnLCBtb3ZlICk7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCAnbW91c2V1cCcsIHVwICk7XG4gICAgICB9O1xuXG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggJ21vdXNlbW92ZScsIG1vdmUgKTtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCAnbW91c2V1cCcsIHVwICk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNuYXAgZ2l2ZW4gdGltZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdGltZSBUaW1lXG4gICAgICogQHJldHVybnMge251bWJlcn0gU25hcHBlZCB0aW1lXG4gICAgICovXG4gICAgc25hcFRpbWUoIHRpbWUgKSB7XG4gICAgICBpZiAoICF0aGlzLmF1dG9tYXRvbi5ndWlTZXR0aW5ncy5zbmFwQWN0aXZlICkgeyByZXR1cm4gdGltZTsgfVxuXG4gICAgICBjb25zdCBpbnRlcnZhbCA9IHRoaXMuYXV0b21hdG9uLmd1aVNldHRpbmdzLnNuYXBUaW1lO1xuICAgICAgY29uc3Qgd2lkdGggPSA1LjAgLyB0aGlzLndpZHRoICogKCB0aGlzLnQxIC0gdGhpcy50MCApO1xuICAgICAgY29uc3QgbmVhcmVzdCA9IE1hdGgucm91bmQoIHRpbWUgLyBpbnRlcnZhbCApICogaW50ZXJ2YWw7XG4gICAgICByZXR1cm4gTWF0aC5hYnMoIHRpbWUgLSBuZWFyZXN0ICkgPCB3aWR0aCA/IG5lYXJlc3QgOiB0aW1lO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTbmFwIGdpdmVuIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFNuYXBwZWQgdmFsdWVcbiAgICAgKi9cbiAgICBzbmFwVmFsdWUoIHZhbHVlICkge1xuICAgICAgaWYgKCAhdGhpcy5hdXRvbWF0b24uZ3VpU2V0dGluZ3Muc25hcEFjdGl2ZSApIHsgcmV0dXJuIHZhbHVlOyB9XG5cbiAgICAgIGNvbnN0IGludGVydmFsID0gdGhpcy5hdXRvbWF0b24uZ3VpU2V0dGluZ3Muc25hcFZhbHVlO1xuICAgICAgY29uc3Qgd2lkdGggPSA1LjAgLyB0aGlzLmhlaWdodCAqICggdGhpcy52MSAtIHRoaXMudjAgKTtcbiAgICAgIGNvbnN0IG5lYXJlc3QgPSBNYXRoLnJvdW5kKCB2YWx1ZSAvIGludGVydmFsICkgKiBpbnRlcnZhbDtcbiAgICAgIHJldHVybiBNYXRoLmFicyggdmFsdWUgLSBuZWFyZXN0ICkgPCB3aWR0aCA/IG5lYXJlc3QgOiB2YWx1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR3JhYiBhIG5vZGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGlkIElkIG9mIGEgbm9kZVxuICAgICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZXZlbnQgTW91c2UgZXZlbnRcbiAgICAgKiBAcmV0dXJucyB7dm9pZH0gdm9pZFxuICAgICAqL1xuICAgIGdyYWJOb2RlKCBpZCwgZXZlbnQgKSB7XG4gICAgICBjb25zdCBwYXJhbSA9IHRoaXMuc2VsZWN0ZWRQYXJhbTtcbiAgICAgIGlmICggIXBhcmFtICkgeyByZXR1cm47IH1cblxuICAgICAgdGhpcy4kZW1pdCggJ25vZGVTZWxlY3RlZCcsIFsgaWQgXSApO1xuICAgICAgdGhpcy4kZW1pdCggJ2Z4U2VsZWN0ZWQnLCBbXSApO1xuXG4gICAgICBjb25zdCBub2RlID0gcGFyYW0uZHVtcE5vZGUoIGlkICk7XG4gICAgICBjb25zdCB0MCA9IG5vZGUudGltZTtcbiAgICAgIGNvbnN0IHYwID0gbm9kZS52YWx1ZTtcblxuICAgICAgdGhpcy5ncmFiSGVscGVyKCBldmVudCwgKCBkdCwgZHYsIGV2ZW50LCBpc1VwICkgPT4ge1xuICAgICAgICBsZXQgdCA9IHQwICsgZHQ7XG4gICAgICAgIGxldCB2ID0gdjAgKyBkdjtcbiAgICAgICAgaWYgKCAhZXZlbnQuYWx0S2V5ICkge1xuICAgICAgICAgIHQgPSB0aGlzLnNuYXBUaW1lKCB0ICk7XG4gICAgICAgICAgdiA9IHRoaXMuc25hcFZhbHVlKCB2ICk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIGV2ZW50LnNoaWZ0S2V5ICkgeyB2ID0gdjA7IH1cbiAgICAgICAgZWxzZSBpZiAoIGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQubWV0YUtleSApIHsgdCA9IHQwOyB9XG5cbiAgICAgICAgcGFyYW0ubW92ZU5vZGUoIGlkLCB0LCB2ICk7XG5cbiAgICAgICAgaWYgKCBpc1VwICkge1xuICAgICAgICAgIHRoaXMuYXV0b21hdG9uLnB1c2hIaXN0b3J5KFxuICAgICAgICAgICAgJ01vdmUgTm9kZScsXG4gICAgICAgICAgICAoKSA9PiBwYXJhbS5tb3ZlTm9kZSggaWQsIHQsIHYgKSxcbiAgICAgICAgICAgICgpID0+IHBhcmFtLm1vdmVOb2RlKCBpZCwgdDAsIHYwIClcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9ICk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdyYWIgYSBoYW5kbGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGlkIElkIG9mIGEgaGFuZGxlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBpc091dCBJbnB1dCBoYW5kbGUgaWYgZmFsc2UsIG91dHB1dCBoYW5kbGUgaWYgdHJ1ZVxuICAgICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZXZlbnQgTW91c2UgZXZlbnRcbiAgICAgKiBAcmV0dXJucyB7dm9pZH0gdm9pZFxuICAgICAqL1xuICAgIGdyYWJIYW5kbGUoIGlkLCBpc091dCwgZXZlbnQgKSB7XG4gICAgICBjb25zdCBwYXJhbSA9IHRoaXMuc2VsZWN0ZWRQYXJhbTtcbiAgICAgIGlmICggIXBhcmFtICkgeyByZXR1cm47IH1cblxuICAgICAgY29uc3Qgbm9kZSA9IHBhcmFtLmR1bXBOb2RlKCBpZCApO1xuICAgICAgY29uc3QgaGFuZGxlID0gaXNPdXQgPyBub2RlLm91dCA6IG5vZGUuaW47XG5cbiAgICAgIGNvbnN0IHQwID0gaGFuZGxlLnRpbWU7XG4gICAgICBjb25zdCB2MCA9IGhhbmRsZS52YWx1ZTtcblxuICAgICAgY29uc3QgbGVuMCA9IE1hdGguc3FydCggdDAgKiB0MCArIHYwICogdjAgKTtcbiAgICAgIGNvbnN0IG50MCA9IHQwIC8gbGVuMDtcbiAgICAgIGNvbnN0IG52MCA9IHYwIC8gbGVuMDtcblxuICAgICAgY29uc3QgaGFuZGxlT3AgPSBpc091dCA/IG5vZGUuaW4gOiBub2RlLm91dDtcbiAgICAgIGNvbnN0IHRPcDAgPSBoYW5kbGVPcCA/IGhhbmRsZU9wLnRpbWUgOiAwLjA7XG4gICAgICBjb25zdCB2T3AwID0gaGFuZGxlT3AgPyBoYW5kbGVPcC52YWx1ZSA6IDAuMDtcblxuICAgICAgdGhpcy5ncmFiSGVscGVyKCBldmVudCwgKCBkdCwgZHYsIGV2ZW50LCBpc1VwICkgPT4ge1xuICAgICAgICBsZXQgdCA9IHQwICsgZHQ7XG4gICAgICAgIGxldCB2ID0gdjAgKyBkdjtcbiAgICAgICAgbGV0IHRPcCA9IHRPcDA7XG4gICAgICAgIGxldCB2T3AgPSB2T3AwO1xuXG4gICAgICAgIGlmICggZXZlbnQuc2hpZnRLZXkgKSB7XG4gICAgICAgICAgY29uc3QgZG90ID0gdCAqIG50MCArIHYgKiBudjA7XG4gICAgICAgICAgdCA9IGRvdCAqIG50MDtcbiAgICAgICAgICB2ID0gZG90ICogbnYwO1xuICAgICAgICB9IGVsc2UgaWYgKCBldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXkgKSB7XG4gICAgICAgICAgdE9wID0gLXQ7XG4gICAgICAgICAgdk9wID0gLXY7XG4gICAgICAgIH1cblxuICAgICAgICBwYXJhbS5tb3ZlSGFuZGxlKCBpZCwgaXNPdXQsIHQsIHYgKTtcbiAgICAgICAgcGFyYW0ubW92ZUhhbmRsZSggaWQsICFpc091dCwgdE9wLCB2T3AgKTtcblxuICAgICAgICBpZiAoIGlzVXAgKSB7XG4gICAgICAgICAgdGhpcy5hdXRvbWF0b24ucHVzaEhpc3RvcnkoXG4gICAgICAgICAgICAnTW92ZSBIYW5kbGUnLFxuICAgICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgICBwYXJhbS5tb3ZlSGFuZGxlKCBpZCwgaXNPdXQsIHQsIHYgKTtcbiAgICAgICAgICAgICAgcGFyYW0ubW92ZUhhbmRsZSggaWQsICFpc091dCwgdE9wLCB2T3AgKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICAgIHBhcmFtLm1vdmVIYW5kbGUoIGlkLCBpc091dCwgdDAsIHYwICk7XG4gICAgICAgICAgICAgIHBhcmFtLm1vdmVIYW5kbGUoIGlkLCAhaXNPdXQsIHRPcDAsIHZPcDAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9ICk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE9wZW4gZnggbWVudS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdGltZSBGeCB3aWxsIGJlIGNyZWF0ZWQgb24gdGhpcyB0aW1lXG4gICAgICogQHJldHVybnMge3ZvaWR9IHZvaWRcbiAgICAgKi9cbiAgICBvcGVuRnhNZW51KCB0aW1lICkge1xuICAgICAgdGhpcy5meG1lbnVBY3RpdmUgPSB0cnVlO1xuICAgICAgdGhpcy5meG1lbnVUaW1lID0gdGltZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgZnguXG4gICAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBldmVudCBNb3VzZSBldmVudCBjb21lcyBmcm9tIGRibGNsaWNrIGV2ZW50XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgTmFtZSBvZiBmeCBkZWZpbml0aW9uXG4gICAgICogQHJldHVybnMge3ZvaWR9IHZvaWRcbiAgICAgKi9cbiAgICBjcmVhdGVGeCggZXZlbnQsIG5hbWUgKSB7XG4gICAgICBjb25zdCBwYXJhbSA9IHRoaXMuc2VsZWN0ZWRQYXJhbTtcbiAgICAgIGlmICggIXBhcmFtICkgeyByZXR1cm47IH1cblxuICAgICAgY29uc3QgdCA9IHRoaXMuZnhtZW51VGltZTtcbiAgICAgIGNvbnN0IGwgPSBNYXRoLm1pbiggMS4wLCB0aGlzLmF1dG9tYXRvbi5sZW5ndGggLSB0aGlzLmZ4bWVudVRpbWUgKTtcbiAgICAgIGNvbnN0IGlkID0gcGFyYW0uY3JlYXRlRngoIHQsIGwsIG5hbWUgKTtcbiAgICAgIGNvbnN0IGRhdGEgPSBwYXJhbS5kdW1wRngoIGlkICk7XG5cbiAgICAgIGlmICggIWlkICkgeyByZXR1cm47IH1cbiAgICAgIHRoaXMuJGVtaXQoICdub2RlU2VsZWN0ZWQnLCBbXSApO1xuICAgICAgdGhpcy4kZW1pdCggJ2Z4U2VsZWN0ZWQnLCBbIGlkIF0gKTtcblxuICAgICAgdGhpcy5hdXRvbWF0b24ucHVzaEhpc3RvcnkoXG4gICAgICAgICdDcmVhdGUgRngnLFxuICAgICAgICAoKSA9PiBwYXJhbS5jcmVhdGVGeEZyb21EYXRhKCBkYXRhICksXG4gICAgICAgICgpID0+IHBhcmFtLnJlbW92ZUZ4KCBpZCApXG4gICAgICApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYSBmeC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgSWQgb2YgZnhcbiAgICAgKiBAcmV0dXJucyB7dm9pZH0gdm9pZFxuICAgICAqL1xuICAgIHJlbW92ZUZ4KCBpZCApIHtcbiAgICAgIGNvbnN0IHBhcmFtID0gdGhpcy5zZWxlY3RlZFBhcmFtO1xuICAgICAgaWYgKCAhcGFyYW0gKSB7IHJldHVybjsgfVxuXG4gICAgICBjb25zdCBmeCA9IHBhcmFtLmR1bXBGeCggaWQgKTtcblxuICAgICAgdGhpcy5hdXRvbWF0b24ucHVzaEhpc3RvcnkoXG4gICAgICAgICdSZW1vdmUgRngnLFxuICAgICAgICAoKSA9PiBwYXJhbS5yZW1vdmVGeCggaWQgKSxcbiAgICAgICAgKCkgPT4gcGFyYW0uY3JlYXRlRnhGcm9tRGF0YSggZnggKSxcbiAgICAgICAgdHJ1ZVxuICAgICAgKTtcblxuICAgICAgdGhpcy4kZW1pdCggJ2Z4U2VsZWN0ZWQnLCBbXSApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHcmFiIGEgYm9keSBvZiBmeC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgSWQgb2YgZnhcbiAgICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGV2ZW50IE1vdXNlIGV2ZW50XG4gICAgICogQHJldHVybnMge3ZvaWR9IHZvaWRcbiAgICAgKi9cbiAgICBncmFiRnhCb2R5KCBpZCwgZXZlbnQgKSB7XG4gICAgICBjb25zdCBwYXJhbSA9IHRoaXMuc2VsZWN0ZWRQYXJhbTtcbiAgICAgIGlmICggIXBhcmFtICkgeyByZXR1cm47IH1cblxuICAgICAgdGhpcy4kZW1pdCggJ25vZGVTZWxlY3RlZCcsIFtdICk7XG4gICAgICB0aGlzLiRlbWl0KCAnZnhTZWxlY3RlZCcsIFsgaWQgXSApO1xuICAgICAgXG4gICAgICBjb25zdCBmeCA9IHBhcmFtLmR1bXBGeCggaWQgKTtcblxuICAgICAgY29uc3QgdDAgPSBmeC50aW1lO1xuICAgICAgY29uc3QgcjAgPSBmeC5yb3c7XG5cbiAgICAgIGNvbnN0IHkwID0gZXZlbnQuY2xpZW50WTtcblxuICAgICAgdGhpcy5ncmFiSGVscGVyKCBldmVudCwgKCBkdCwgZHYsIGV2ZW50LCBpc1VwICkgPT4ge1xuICAgICAgICBjb25zdCBkeSA9IGV2ZW50LmNsaWVudFkgLSB5MDtcbiAgICAgICAgY29uc3QgbmV3Um93ID0gTWF0aC5taW4oIE1hdGgubWF4KCByMCArIE1hdGgucm91bmQoIGR5IC8gMTYuMCApLCAwICksIFBhcmFtV2l0aEdVSS5GWF9ST1dfTUFYICk7XG5cbiAgICAgICAgbGV0IHQgPSB0MCArIGR0O1xuICAgICAgICBpZiAoICFldmVudC5hbHRLZXkgKSB7XG4gICAgICAgICAgdCA9IHRoaXMuc25hcFRpbWUoIHQgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhcmFtLm1vdmVGeCggaWQsIHQgKTtcbiAgICAgICAgcGFyYW0uY2hhbmdlRnhSb3coIGlkLCBuZXdSb3cgKTtcblxuICAgICAgICBpZiAoIGlzVXAgKSB7XG4gICAgICAgICAgdGhpcy5hdXRvbWF0b24ucHVzaEhpc3RvcnkoXG4gICAgICAgICAgICAnTW92ZSBGeCcsXG4gICAgICAgICAgICAoKSA9PiBwYXJhbS5mb3JjZU1vdmVGeCggaWQsIHQsIG5ld1JvdyApLFxuICAgICAgICAgICAgKCkgPT4gcGFyYW0uZm9yY2VNb3ZlRngoIGlkLCB0MCwgcjAgKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0gKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR3JhYiBhIGxlZnQgc2lkZSBvZiBmeC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgSWQgb2YgZnhcbiAgICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGV2ZW50IE1vdXNlIGV2ZW50XG4gICAgICogQHJldHVybnMge3ZvaWR9IHZvaWRcbiAgICAgKi9cbiAgICBncmFiRnhMZWZ0KCBpZCwgZXZlbnQgKSB7XG4gICAgICBjb25zdCBwYXJhbSA9IHRoaXMuc2VsZWN0ZWRQYXJhbTtcbiAgICAgIGlmICggIXBhcmFtICkgeyByZXR1cm47IH1cblxuICAgICAgdGhpcy4kZW1pdCggJ25vZGVTZWxlY3RlZCcsIFtdICk7XG4gICAgICB0aGlzLiRlbWl0KCAnZnhTZWxlY3RlZCcsIFsgaWQgXSApO1xuXG4gICAgICBjb25zdCBmeCA9IHBhcmFtLmR1bXBGeCggaWQgKTtcblxuICAgICAgY29uc3QgbDAgPSBmeC5sZW5ndGg7XG4gICAgICBjb25zdCBlbmQwID0gZngudGltZSArIGwwO1xuXG4gICAgICB0aGlzLmdyYWJIZWxwZXIoIGV2ZW50LCAoIGR0LCBkdiwgZXZlbnQsIGlzVXAgKSA9PiB7XG4gICAgICAgIGxldCBsID0gbDAgLSBkdDtcbiAgICAgICAgaWYgKCAhZXZlbnQuYWx0S2V5ICkge1xuICAgICAgICAgIGwgPSB0aGlzLnNuYXBUaW1lKCBsIC0gZW5kMCApICsgZW5kMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhcmFtLnJlc2l6ZUZ4QnlMZWZ0KCBpZCwgbCApO1xuXG4gICAgICAgIGlmICggaXNVcCApIHtcbiAgICAgICAgICB0aGlzLmF1dG9tYXRvbi5wdXNoSGlzdG9yeShcbiAgICAgICAgICAgICdSZXNpemUgRngnLFxuICAgICAgICAgICAgKCkgPT4gcGFyYW0ucmVzaXplRnhCeUxlZnQoIGlkLCBsICksXG4gICAgICAgICAgICAoKSA9PiBwYXJhbS5yZXNpemVGeEJ5TGVmdCggaWQsIGwwIClcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9ICk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdyYWIgYSByaWdodCBzaWRlIG9mIGZ4LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBJZCBvZiBmeFxuICAgICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZXZlbnQgTW91c2UgZXZlbnRcbiAgICAgKiBAcmV0dXJucyB7dm9pZH0gdm9pZFxuICAgICAqL1xuICAgIGdyYWJGeFJpZ2h0KCBpZCwgZXZlbnQgKSB7XG4gICAgICBjb25zdCBwYXJhbSA9IHRoaXMuc2VsZWN0ZWRQYXJhbTtcbiAgICAgIGlmICggIXBhcmFtICkgeyByZXR1cm47IH1cblxuICAgICAgdGhpcy4kZW1pdCggJ25vZGVTZWxlY3RlZCcsIFtdICk7XG4gICAgICB0aGlzLiRlbWl0KCAnZnhTZWxlY3RlZCcsIFsgaWQgXSApO1xuXG4gICAgICBjb25zdCBmeCA9IHBhcmFtLmR1bXBGeCggaWQgKTtcblxuICAgICAgY29uc3QgbDAgPSBmeC5sZW5ndGg7XG4gICAgICBjb25zdCB0MCA9IGZ4LnRpbWU7XG5cbiAgICAgIHRoaXMuZ3JhYkhlbHBlciggZXZlbnQsICggZHQsIGR2LCBldmVudCwgaXNVcCApID0+IHtcbiAgICAgICAgbGV0IGwgPSBsMCArIGR0O1xuICAgICAgICBpZiAoICFldmVudC5hbHRLZXkgKSB7XG4gICAgICAgICAgbCA9IHRoaXMuc25hcFRpbWUoIGwgKyB0MCApIC0gdDA7XG4gICAgICAgIH1cblxuICAgICAgICBwYXJhbS5yZXNpemVGeCggaWQsIGwgKTtcblxuICAgICAgICBpZiAoIGlzVXAgKSB7XG4gICAgICAgICAgdGhpcy5hdXRvbWF0b24ucHVzaEhpc3RvcnkoXG4gICAgICAgICAgICAnUmVzaXplIEZ4JyxcbiAgICAgICAgICAgICgpID0+IHBhcmFtLnJlc2l6ZUZ4KCBpZCwgbCApLFxuICAgICAgICAgICAgKCkgPT4gcGFyYW0ucmVzaXplRngoIGlkLCBsMCApXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSApO1xuICAgIH0sXG5cbiAgICBkcmFnQmcoIGV2ZW50ICkge1xuICAgICAgY29uc3QgdDAgPSB0aGlzLngydCggZXZlbnQub2Zmc2V0WCApO1xuICAgICAgY29uc3QgdjAgPSB0aGlzLnkydiggZXZlbnQub2Zmc2V0WSApO1xuICAgICAgY29uc3Qgd2hpY2ggPSBldmVudC53aGljaDtcbiAgICAgIGNvbnN0IHNoaWZ0S2V5ID0gZXZlbnQuc2hpZnRLZXk7XG4gICAgICBjb25zdCBhbHRLZXkgPSBldmVudC5hbHRLZXk7XG5cbiAgICAgIGNvbnN0IHgwID0gZXZlbnQuY2xpZW50WDtcbiAgICAgIGNvbnN0IHkwID0gZXZlbnQuY2xpZW50WTtcbiAgICAgIGxldCB4UHJldiA9IHgwO1xuICAgICAgbGV0IHlQcmV2ID0geTA7XG5cbiAgICAgIGNvbnN0IGlzUGxheWluZzAgPSB0aGlzLmF1dG9tYXRvbi5pc1BsYXlpbmc7XG4gICAgICBpZiAoIGFsdEtleSApIHtcbiAgICAgICAgdGhpcy5hdXRvbWF0b24uc2VlayggdDAgKTtcbiAgICAgICAgaWYgKCBpc1BsYXlpbmcwICkge1xuICAgICAgICAgIHRoaXMuYXV0b21hdG9uLnBhdXNlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgbW92ZSA9ICggZXZlbnQgKSA9PiB7XG4gICAgICAgIGNvbnN0IHggPSBldmVudC5jbGllbnRYO1xuICAgICAgICBjb25zdCB5ID0gZXZlbnQuY2xpZW50WTtcbiAgICAgICAgY29uc3QgZHggPSBldmVudC5jbGllbnRYIC0geFByZXY7XG4gICAgICAgIGNvbnN0IGR5ID0gZXZlbnQuY2xpZW50WSAtIHlQcmV2O1xuXG4gICAgICAgIGlmICggd2hpY2ggPT09IDEgKSB7XG4gICAgICAgICAgaWYgKCBhbHRLZXkgKSB7XG4gICAgICAgICAgICB0aGlzLmF1dG9tYXRvbi5zZWVrKCB0MCArIHRoaXMueDJ0KCB4IC0geDAgKSApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICggd2hpY2ggPT09IDIgKSB7XG4gICAgICAgICAgaWYgKCBzaGlmdEtleSApIHtcbiAgICAgICAgICAgIHRoaXMuem9vbVZpZXcoIHQwLCB2MCwgLWR4LCBkeSApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm1vdmVWaWV3KCBkeCwgZHkgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB4UHJldiA9IHg7XG4gICAgICAgIHlQcmV2ID0geTtcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHVwID0gKCBldmVudCApID0+IHtcbiAgICAgICAgaWYgKCBhbHRLZXkgJiYgaXNQbGF5aW5nMCApIHtcbiAgICAgICAgICB0aGlzLmF1dG9tYXRvbi5wbGF5KCk7XG4gICAgICAgIH1cblxuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ21vdXNlbW92ZScsIG1vdmUgKTtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoICdtb3VzZXVwJywgdXAgKTtcbiAgICAgIH07XG5cbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCAnbW91c2Vtb3ZlJywgbW92ZSApO1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoICdtb3VzZXVwJywgdXAgKTtcbiAgICB9LFxuXG4gICAgY29udGV4dEJnKCBldmVudCApIHtcbiAgICAgIGlmICggIXRoaXMuc2VsZWN0ZWRQYXJhbSApIHsgcmV0dXJuOyB9XG5cbiAgICAgIGNvbnN0IHQgPSB0aGlzLngydCggZXZlbnQub2Zmc2V0WCApO1xuICAgICAgY29uc3QgdiA9IHRoaXMueTJ2KCBldmVudC5vZmZzZXRZICk7XG5cbiAgICAgIHRoaXMuJGVtaXQoICdjb250ZXh0Jywge1xuICAgICAgICBjbGllbnRYOiBldmVudC5jbGllbnRYLFxuICAgICAgICBjbGllbnRZOiBldmVudC5jbGllbnRZLFxuICAgICAgICBjb21tYW5kczogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRleHQ6ICdBZGQgTm9kZScsXG4gICAgICAgICAgICBmdW5jOiAoKSA9PiB7XG4gICAgICAgICAgICAgIHRoaXMuY3JlYXRlTm9kZSggdCwgdiApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgdGV4dDogJ0FkZCBGeCcsXG4gICAgICAgICAgICBmdW5jOiAoKSA9PiB7XG4gICAgICAgICAgICAgIHRoaXMub3BlbkZ4TWVudSggdCApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgICAgfSApO1xuICAgIH0sXG5cbiAgICBvbldoZWVsKCBldmVudCApIHtcbiAgICAgIGNvbnN0IHQwID0gdGhpcy54MnQoIGV2ZW50Lm9mZnNldFggKTtcbiAgICAgIGNvbnN0IHYwID0gdGhpcy55MnYoIGV2ZW50Lm9mZnNldFkgKTtcblxuICAgICAgaWYgKCBldmVudC5zaGlmdEtleSApIHsgLy8gem9vbSBob3Jpem9udGFsbHlcbiAgICAgICAgdGhpcy56b29tVmlldyggdDAsIHYwLCAtZXZlbnQuZGVsdGFZLCAwICk7XG4gICAgICB9IGVsc2UgaWYgKCBldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXkgKSB7IC8vIHpvb20gdmVydGljYWxseVxuICAgICAgICB0aGlzLnpvb21WaWV3KCB0MCwgdjAsIDAsIC1ldmVudC5kZWx0YVkgKTtcbiAgICAgIH0gZWxzZSB7IC8vIG1vdmVcbiAgICAgICAgdGhpcy5tb3ZlVmlldyggZXZlbnQuZGVsdGFYLCAtZXZlbnQuZGVsdGFZICk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudXBkYXRlR3JpZCgpO1xuICAgICAgdGhpcy51cGRhdGVHcmFwaCgpO1xuICAgIH0sXG5cbiAgICBvblJlc2l6ZSgpIHtcbiAgICAgIGNvbnN0IGVsID0gdGhpcy4kcmVmcy5yb290O1xuICAgICAgdGhpcy53aWR0aCA9IGVsLmNsaWVudFdpZHRoO1xuICAgICAgdGhpcy5oZWlnaHQgPSBlbC5jbGllbnRIZWlnaHQgLSA0O1xuXG4gICAgICB0aGlzLiRuZXh0VGljayggKCkgPT4ge1xuICAgICAgICB0aGlzLnVwZGF0ZUdyaWQoKTtcbiAgICAgICAgdGhpcy51cGRhdGVHcmFwaCgpO1xuICAgICAgfSApO1xuICAgIH1cbiAgfSxcblxuICBjb21wdXRlZDoge1xuICAgIHNlbGVjdGVkUGFyYW0oKSB7XG4gICAgICByZXR1cm4gdGhpcy5hdXRvbWF0b24uZ2V0UGFyYW0oIHRoaXMuc2VsZWN0ZWRQYXJhbU5hbWUgKTtcbiAgICB9XG4gIH0sXG5cbiAgd2F0Y2g6IHtcbiAgICBzZWxlY3RlZFBhcmFtTmFtZSgpIHtcbiAgICAgIHRoaXMudXBkYXRlR3JhcGgoKTtcbiAgICB9XG4gIH0sXG5cbiAgbW91bnRlZCgpIHtcbiAgICB0aGlzLiRyb290LiRvbiggJ2xvYWRlZCcsICgpID0+IHtcbiAgICAgIHRoaXMudDAgPSAwLjA7XG4gICAgICB0aGlzLnQxID0gdGhpcy5hdXRvbWF0b24ubGVuZ3RoO1xuICAgIH0gKTtcblxuICAgIHRoaXMuJHJvb3QuJG9uKCAnY2hhbmdlZExlbmd0aCcsICgpID0+IHtcbiAgICAgIHRoaXMudDAgPSAwLjA7XG4gICAgICB0aGlzLnQxID0gdGhpcy5hdXRvbWF0b24ubGVuZ3RoO1xuXG4gICAgICB0aGlzLnVwZGF0ZUdyYXBoKCk7XG4gICAgfSApO1xuXG4gICAgdGhpcy4kcm9vdC4kb24oICdwb2tlJywgKCkgPT4ge1xuICAgICAgdGhpcy51cGRhdGVHcmFwaCgpO1xuICAgIH0gKTtcblxuICAgIHRoaXMuJG5leHRUaWNrKCAoKSA9PiB7XG4gICAgICB0aGlzLm9uUmVzaXplKCk7XG4gICAgfSApO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCAncmVzaXplJywgdGhpcy5vblJlc2l6ZSApO1xuICB9LFxuXG4gIGJlZm9yZURlc3Ryb3koKSB7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoICdyZXNpemUnLCB0aGlzLm9uUmVzaXplICk7XG4gIH0sXG59XG48L3NjcmlwdD5cblxuPHN0eWxlIGxhbmc9XCJzY3NzXCIgc2NvcGVkPlxuQGltcG9ydCBcIi4vY29sb3JzLnNjc3NcIjtcblxuLnJvb3Qge1xuICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gIGxlZnQ6IDA7XG4gIHRvcDogMDtcbiAgd2lkdGg6IDEwMCU7XG4gIGhlaWdodDogMTAwJTtcblxuICBjb2xvcjogJGNvbG9yLWZvcmU7XG5cbiAgLmhiYXIge1xuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICBsZWZ0OiAwO1xuICAgIGJvdHRvbTogMDtcbiAgICB3aWR0aDogMTAwJTtcbiAgICBoZWlnaHQ6IDRweDtcblxuICAgIGJhY2tncm91bmQ6ICRjb2xvci1ibGFjaztcbiAgICBcbiAgICAudmlzaW9uIHtcbiAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgIGJvdHRvbTogMDtcbiAgICAgIGhlaWdodDogMTAwJTtcblxuICAgICAgYm9yZGVyLXJhZGl1czogMnB4O1xuXG4gICAgICBiYWNrZ3JvdW5kOiAkY29sb3ItYWNjZW50O1xuICAgIH1cbiAgfVxuXG4gIC5zdmcge1xuICAgIGJhY2tncm91bmQ6ICRjb2xvci1iYWNrMTtcblxuICAgIGZvbnQtc2l6ZTogMTBweDtcblxuICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xuXG4gICAgLmdyaWQge1xuICAgICAgc3Ryb2tlOiAkY29sb3ItZm9yZTtcbiAgICAgIHN0cm9rZS13aWR0aDogMTtcbiAgICB9XG5cbiAgICAuZ3JpZC10ZXh0IHtcbiAgICAgIGZpbGw6ICRjb2xvci1mb3JlO1xuICAgIH1cblxuICAgIC5ncmFwaCB7XG4gICAgICBmaWxsOiBub25lO1xuICAgICAgc3Ryb2tlOiAkY29sb3ItZm9yZTtcbiAgICAgIHN0cm9rZS13aWR0aDogMjtcbiAgICB9XG5cbiAgICAuY3VycmVudExpbmUge1xuICAgICAgc3Ryb2tlOiAkY29sb3ItYWNjZW50O1xuICAgICAgc3Ryb2tlLXdpZHRoOiAyO1xuICAgIH1cblxuICAgIC5jdXJyZW50VGV4dCB7XG4gICAgICBmaWxsOiAkY29sb3ItYWNjZW50O1xuICAgIH1cblxuICAgIC5jdXJyZW50UG9pbnQge1xuICAgICAgZmlsbDogJGNvbG9yLWFjY2VudDtcbiAgICB9XG5cbiAgICAubm9kZSB7XG4gICAgICAuaGFuZGxlIHtcbiAgICAgICAgLmxpbmUge1xuICAgICAgICAgIHN0cm9rZTogJGNvbG9yLWFjY2VudDtcbiAgICAgICAgICBzdHJva2Utd2lkdGg6IDE7XG4gICAgICAgIH1cblxuICAgICAgICAuY2lyY2xlIHtcbiAgICAgICAgICBmaWxsOiAkY29sb3ItYWNjZW50O1xuXG4gICAgICAgICAgcG9pbnRlci1ldmVudHM6IGF1dG87XG4gICAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC5ib2R5IHtcbiAgICAgICAgZmlsbDogJGNvbG9yLWJhY2sxO1xuICAgICAgICBzdHJva2U6ICRjb2xvci1hY2NlbnQ7XG4gICAgICAgIHN0cm9rZS13aWR0aDogMjtcblxuICAgICAgICBwb2ludGVyLWV2ZW50czogYXV0bztcbiAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xuXG4gICAgICAgICYuc2VsZWN0ZWQge1xuICAgICAgICAgIGZpbGw6ICRjb2xvci1hY2NlbnQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAuZngge1xuICAgICAgLmxpbmUge1xuICAgICAgICBzdHJva2U6ICRjb2xvci1meDtcbiAgICAgICAgc3Ryb2tlLXdpZHRoOiAxO1xuICAgICAgICBzdHJva2UtZGFzaGFycmF5OiA0O1xuICAgICAgfVxuXG4gICAgICAuZmlsbCB7XG4gICAgICAgIGZpbGw6ICRjb2xvci1meDtcbiAgICAgICAgb3BhY2l0eTogMC4xO1xuICAgICAgfVxuXG4gICAgICAuYm9keSB7XG4gICAgICAgIGZpbGw6ICRjb2xvci1iYWNrMTtcbiAgICAgICAgc3Ryb2tlOiAkY29sb3ItZng7XG4gICAgICAgIHN0cm9rZS13aWR0aDogMjtcblxuICAgICAgICAmLmJ5cGFzcyB7XG4gICAgICAgICAgZmlsbDogJGNvbG9yLWJhY2sxO1xuICAgICAgICAgIHN0cm9rZTogJGNvbG9yLWdyYXk7XG4gICAgICAgIH1cblxuICAgICAgICAmLnNlbGVjdGVkIHtcbiAgICAgICAgICBmaWxsOiAkY29sb3ItZng7XG4gICAgICAgICAgc3Ryb2tlOiAkY29sb3ItYmFjazE7XG5cbiAgICAgICAgICAmLmJ5cGFzcyB7XG4gICAgICAgICAgICBmaWxsOiAkY29sb3ItZ3JheTtcbiAgICAgICAgICAgIHN0cm9rZTogJGNvbG9yLWJhY2sxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHBvaW50ZXItZXZlbnRzOiBhdXRvO1xuICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgICB9XG5cbiAgICAgIC50ZXh0IHtcbiAgICAgICAgZmlsbDogJGNvbG9yLWZ4O1xuICAgICAgICAmLmJ5cGFzcyB7IGZpbGw6ICRjb2xvci1ncmF5OyB9XG4gICAgICAgICYuc2VsZWN0ZWQgeyBmaWxsOiAkY29sb3ItYmFjazE7IH1cbiAgICAgIH1cblxuICAgICAgLnNpZGUge1xuICAgICAgICBmaWxsOiByZ2JhKCAwLCAwLCAwLCAwICk7XG5cbiAgICAgICAgcG9pbnRlci1ldmVudHM6IGF1dG87XG4gICAgICAgIGN1cnNvcjogZXctcmVzaXplO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuPC9zdHlsZT5cblxuIiwiJ3VzZSBzdHJpY3QnXG5cbmV4cG9ydHMuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcbmV4cG9ydHMudG9CeXRlQXJyYXkgPSB0b0J5dGVBcnJheVxuZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gZnJvbUJ5dGVBcnJheVxuXG52YXIgbG9va3VwID0gW11cbnZhciByZXZMb29rdXAgPSBbXVxudmFyIEFyciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyA/IFVpbnQ4QXJyYXkgOiBBcnJheVxuXG52YXIgY29kZSA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJ1xuZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvZGUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgbG9va3VwW2ldID0gY29kZVtpXVxuICByZXZMb29rdXBbY29kZS5jaGFyQ29kZUF0KGkpXSA9IGlcbn1cblxuLy8gU3VwcG9ydCBkZWNvZGluZyBVUkwtc2FmZSBiYXNlNjQgc3RyaW5ncywgYXMgTm9kZS5qcyBkb2VzLlxuLy8gU2VlOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CYXNlNjQjVVJMX2FwcGxpY2F0aW9uc1xucmV2TG9va3VwWyctJy5jaGFyQ29kZUF0KDApXSA9IDYyXG5yZXZMb29rdXBbJ18nLmNoYXJDb2RlQXQoMCldID0gNjNcblxuZnVuY3Rpb24gZ2V0TGVucyAoYjY0KSB7XG4gIHZhciBsZW4gPSBiNjQubGVuZ3RoXG5cbiAgaWYgKGxlbiAlIDQgPiAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0JylcbiAgfVxuXG4gIC8vIFRyaW0gb2ZmIGV4dHJhIGJ5dGVzIGFmdGVyIHBsYWNlaG9sZGVyIGJ5dGVzIGFyZSBmb3VuZFxuICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9iZWF0Z2FtbWl0L2Jhc2U2NC1qcy9pc3N1ZXMvNDJcbiAgdmFyIHZhbGlkTGVuID0gYjY0LmluZGV4T2YoJz0nKVxuICBpZiAodmFsaWRMZW4gPT09IC0xKSB2YWxpZExlbiA9IGxlblxuXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSB2YWxpZExlbiA9PT0gbGVuXG4gICAgPyAwXG4gICAgOiA0IC0gKHZhbGlkTGVuICUgNClcblxuICByZXR1cm4gW3ZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW5dXG59XG5cbi8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoYjY0KSB7XG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpXG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF1cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV1cbiAgcmV0dXJuICgodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzTGVuXG59XG5cbmZ1bmN0aW9uIF9ieXRlTGVuZ3RoIChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pIHtcbiAgcmV0dXJuICgodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzTGVuXG59XG5cbmZ1bmN0aW9uIHRvQnl0ZUFycmF5IChiNjQpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVucyA9IGdldExlbnMoYjY0KVxuICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdXG5cbiAgdmFyIGFyciA9IG5ldyBBcnIoX2J5dGVMZW5ndGgoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSlcblxuICB2YXIgY3VyQnl0ZSA9IDBcblxuICAvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG4gIHZhciBsZW4gPSBwbGFjZUhvbGRlcnNMZW4gPiAwXG4gICAgPyB2YWxpZExlbiAtIDRcbiAgICA6IHZhbGlkTGVuXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxOCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDEyKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPDwgNikgfFxuICAgICAgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAzKV1cbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gMTYpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDIpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMikgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldID4+IDQpXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAxKSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDEwKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgNCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildID4+IDIpXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuICByZXR1cm4gbG9va3VwW251bSA+PiAxOCAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtID4+IDEyICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gPj4gNiAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtICYgMHgzRl1cbn1cblxuZnVuY3Rpb24gZW5jb2RlQ2h1bmsgKHVpbnQ4LCBzdGFydCwgZW5kKSB7XG4gIHZhciB0bXBcbiAgdmFyIG91dHB1dCA9IFtdXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSAzKSB7XG4gICAgdG1wID1cbiAgICAgICgodWludDhbaV0gPDwgMTYpICYgMHhGRjAwMDApICtcbiAgICAgICgodWludDhbaSArIDFdIDw8IDgpICYgMHhGRjAwKSArXG4gICAgICAodWludDhbaSArIDJdICYgMHhGRilcbiAgICBvdXRwdXQucHVzaCh0cmlwbGV0VG9CYXNlNjQodG1wKSlcbiAgfVxuICByZXR1cm4gb3V0cHV0LmpvaW4oJycpXG59XG5cbmZ1bmN0aW9uIGZyb21CeXRlQXJyYXkgKHVpbnQ4KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbiA9IHVpbnQ4Lmxlbmd0aFxuICB2YXIgZXh0cmFCeXRlcyA9IGxlbiAlIDMgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcbiAgdmFyIHBhcnRzID0gW11cbiAgdmFyIG1heENodW5rTGVuZ3RoID0gMTYzODMgLy8gbXVzdCBiZSBtdWx0aXBsZSBvZiAzXG5cbiAgLy8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuICBmb3IgKHZhciBpID0gMCwgbGVuMiA9IGxlbiAtIGV4dHJhQnl0ZXM7IGkgPCBsZW4yOyBpICs9IG1heENodW5rTGVuZ3RoKSB7XG4gICAgcGFydHMucHVzaChlbmNvZGVDaHVuayhcbiAgICAgIHVpbnQ4LCBpLCAoaSArIG1heENodW5rTGVuZ3RoKSA+IGxlbjIgPyBsZW4yIDogKGkgKyBtYXhDaHVua0xlbmd0aClcbiAgICApKVxuICB9XG5cbiAgLy8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuICBpZiAoZXh0cmFCeXRlcyA9PT0gMSkge1xuICAgIHRtcCA9IHVpbnQ4W2xlbiAtIDFdXG4gICAgcGFydHMucHVzaChcbiAgICAgIGxvb2t1cFt0bXAgPj4gMl0gK1xuICAgICAgbG9va3VwWyh0bXAgPDwgNCkgJiAweDNGXSArXG4gICAgICAnPT0nXG4gICAgKVxuICB9IGVsc2UgaWYgKGV4dHJhQnl0ZXMgPT09IDIpIHtcbiAgICB0bXAgPSAodWludDhbbGVuIC0gMl0gPDwgOCkgKyB1aW50OFtsZW4gLSAxXVxuICAgIHBhcnRzLnB1c2goXG4gICAgICBsb29rdXBbdG1wID4+IDEwXSArXG4gICAgICBsb29rdXBbKHRtcCA+PiA0KSAmIDB4M0ZdICtcbiAgICAgIGxvb2t1cFsodG1wIDw8IDIpICYgMHgzRl0gK1xuICAgICAgJz0nXG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIHBhcnRzLmpvaW4oJycpXG59XG4iLCIvKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxmZXJvc3NAZmVyb3NzLm9yZz4gPGh0dHA6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuXG4ndXNlIHN0cmljdCdcblxudmFyIGJhc2U2NCA9IHJlcXVpcmUoJ2Jhc2U2NC1qcycpXG52YXIgaWVlZTc1NCA9IHJlcXVpcmUoJ2llZWU3NTQnKVxudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5JylcblxuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuU2xvd0J1ZmZlciA9IFNsb3dCdWZmZXJcbmV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MFxuXG4vKipcbiAqIElmIGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGA6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBVc2UgT2JqZWN0IGltcGxlbWVudGF0aW9uIChtb3N0IGNvbXBhdGlibGUsIGV2ZW4gSUU2KVxuICpcbiAqIEJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0eXBlZCBhcnJheXMgYXJlIElFIDEwKywgRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKyxcbiAqIE9wZXJhIDExLjYrLCBpT1MgNC4yKy5cbiAqXG4gKiBEdWUgdG8gdmFyaW91cyBicm93c2VyIGJ1Z3MsIHNvbWV0aW1lcyB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uIHdpbGwgYmUgdXNlZCBldmVuXG4gKiB3aGVuIHRoZSBicm93c2VyIHN1cHBvcnRzIHR5cGVkIGFycmF5cy5cbiAqXG4gKiBOb3RlOlxuICpcbiAqICAgLSBGaXJlZm94IDQtMjkgbGFja3Mgc3VwcG9ydCBmb3IgYWRkaW5nIG5ldyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YCBpbnN0YW5jZXMsXG4gKiAgICAgU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTU0MzguXG4gKlxuICogICAtIENocm9tZSA5LTEwIGlzIG1pc3NpbmcgdGhlIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24uXG4gKlxuICogICAtIElFMTAgaGFzIGEgYnJva2VuIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhcnJheXMgb2ZcbiAqICAgICBpbmNvcnJlY3QgbGVuZ3RoIGluIHNvbWUgc2l0dWF0aW9ucy5cblxuICogV2UgZGV0ZWN0IHRoZXNlIGJ1Z2d5IGJyb3dzZXJzIGFuZCBzZXQgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYCB0byBgZmFsc2VgIHNvIHRoZXlcbiAqIGdldCB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uLCB3aGljaCBpcyBzbG93ZXIgYnV0IGJlaGF2ZXMgY29ycmVjdGx5LlxuICovXG5CdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCA9IGdsb2JhbC5UWVBFRF9BUlJBWV9TVVBQT1JUICE9PSB1bmRlZmluZWRcbiAgPyBnbG9iYWwuVFlQRURfQVJSQVlfU1VQUE9SVFxuICA6IHR5cGVkQXJyYXlTdXBwb3J0KClcblxuLypcbiAqIEV4cG9ydCBrTWF4TGVuZ3RoIGFmdGVyIHR5cGVkIGFycmF5IHN1cHBvcnQgaXMgZGV0ZXJtaW5lZC5cbiAqL1xuZXhwb3J0cy5rTWF4TGVuZ3RoID0ga01heExlbmd0aCgpXG5cbmZ1bmN0aW9uIHR5cGVkQXJyYXlTdXBwb3J0ICgpIHtcbiAgdHJ5IHtcbiAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoMSlcbiAgICBhcnIuX19wcm90b19fID0ge19fcHJvdG9fXzogVWludDhBcnJheS5wcm90b3R5cGUsIGZvbzogZnVuY3Rpb24gKCkgeyByZXR1cm4gNDIgfX1cbiAgICByZXR1cm4gYXJyLmZvbygpID09PSA0MiAmJiAvLyB0eXBlZCBhcnJheSBpbnN0YW5jZXMgY2FuIGJlIGF1Z21lbnRlZFxuICAgICAgICB0eXBlb2YgYXJyLnN1YmFycmF5ID09PSAnZnVuY3Rpb24nICYmIC8vIGNocm9tZSA5LTEwIGxhY2sgYHN1YmFycmF5YFxuICAgICAgICBhcnIuc3ViYXJyYXkoMSwgMSkuYnl0ZUxlbmd0aCA9PT0gMCAvLyBpZTEwIGhhcyBicm9rZW4gYHN1YmFycmF5YFxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuZnVuY3Rpb24ga01heExlbmd0aCAoKSB7XG4gIHJldHVybiBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVFxuICAgID8gMHg3ZmZmZmZmZlxuICAgIDogMHgzZmZmZmZmZlxufVxuXG5mdW5jdGlvbiBjcmVhdGVCdWZmZXIgKHRoYXQsIGxlbmd0aCkge1xuICBpZiAoa01heExlbmd0aCgpIDwgbGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgdHlwZWQgYXJyYXkgbGVuZ3RoJylcbiAgfVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSwgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICB0aGF0ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKVxuICAgIHRoYXQuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3NcbiAgICBpZiAodGhhdCA9PT0gbnVsbCkge1xuICAgICAgdGhhdCA9IG5ldyBCdWZmZXIobGVuZ3RoKVxuICAgIH1cbiAgICB0aGF0Lmxlbmd0aCA9IGxlbmd0aFxuICB9XG5cbiAgcmV0dXJuIHRoYXRcbn1cblxuLyoqXG4gKiBUaGUgQnVmZmVyIGNvbnN0cnVjdG9yIHJldHVybnMgaW5zdGFuY2VzIG9mIGBVaW50OEFycmF5YCB0aGF0IGhhdmUgdGhlaXJcbiAqIHByb3RvdHlwZSBjaGFuZ2VkIHRvIGBCdWZmZXIucHJvdG90eXBlYC4gRnVydGhlcm1vcmUsIGBCdWZmZXJgIGlzIGEgc3ViY2xhc3Mgb2ZcbiAqIGBVaW50OEFycmF5YCwgc28gdGhlIHJldHVybmVkIGluc3RhbmNlcyB3aWxsIGhhdmUgYWxsIHRoZSBub2RlIGBCdWZmZXJgIG1ldGhvZHNcbiAqIGFuZCB0aGUgYFVpbnQ4QXJyYXlgIG1ldGhvZHMuIFNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0XG4gKiByZXR1cm5zIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIFRoZSBgVWludDhBcnJheWAgcHJvdG90eXBlIHJlbWFpbnMgdW5tb2RpZmllZC5cbiAqL1xuXG5mdW5jdGlvbiBCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgISh0aGlzIGluc3RhbmNlb2YgQnVmZmVyKSkge1xuICAgIHJldHVybiBuZXcgQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgLy8gQ29tbW9uIGNhc2UuXG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmdPck9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0lmIGVuY29kaW5nIGlzIHNwZWNpZmllZCB0aGVuIHRoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nJ1xuICAgICAgKVxuICAgIH1cbiAgICByZXR1cm4gYWxsb2NVbnNhZmUodGhpcywgYXJnKVxuICB9XG4gIHJldHVybiBmcm9tKHRoaXMsIGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyIC8vIG5vdCB1c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb25cblxuLy8gVE9ETzogTGVnYWN5LCBub3QgbmVlZGVkIGFueW1vcmUuIFJlbW92ZSBpbiBuZXh0IG1ham9yIHZlcnNpb24uXG5CdWZmZXIuX2F1Z21lbnQgPSBmdW5jdGlvbiAoYXJyKSB7XG4gIGFyci5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gZnJvbSAodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlcicpXG4gIH1cblxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyh0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldClcbiAgfVxuXG4gIHJldHVybiBmcm9tT2JqZWN0KHRoYXQsIHZhbHVlKVxufVxuXG4vKipcbiAqIEZ1bmN0aW9uYWxseSBlcXVpdmFsZW50IHRvIEJ1ZmZlcihhcmcsIGVuY29kaW5nKSBidXQgdGhyb3dzIGEgVHlwZUVycm9yXG4gKiBpZiB2YWx1ZSBpcyBhIG51bWJlci5cbiAqIEJ1ZmZlci5mcm9tKHN0clssIGVuY29kaW5nXSlcbiAqIEJ1ZmZlci5mcm9tKGFycmF5KVxuICogQnVmZmVyLmZyb20oYnVmZmVyKVxuICogQnVmZmVyLmZyb20oYXJyYXlCdWZmZXJbLCBieXRlT2Zmc2V0WywgbGVuZ3RoXV0pXG4gKiovXG5CdWZmZXIuZnJvbSA9IGZ1bmN0aW9uICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBmcm9tKG51bGwsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbmlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICBCdWZmZXIucHJvdG90eXBlLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXkucHJvdG90eXBlXG4gIEJ1ZmZlci5fX3Byb3RvX18gPSBVaW50OEFycmF5XG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wuc3BlY2llcyAmJlxuICAgICAgQnVmZmVyW1N5bWJvbC5zcGVjaWVzXSA9PT0gQnVmZmVyKSB7XG4gICAgLy8gRml4IHN1YmFycmF5KCkgaW4gRVMyMDE2LiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL3B1bGwvOTdcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLCBTeW1ib2wuc3BlY2llcywge1xuICAgICAgdmFsdWU6IG51bGwsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KVxuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2VydFNpemUgKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9IGVsc2UgaWYgKHNpemUgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIG5lZ2F0aXZlJylcbiAgfVxufVxuXG5mdW5jdGlvbiBhbGxvYyAodGhhdCwgc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICBpZiAoc2l6ZSA8PSAwKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKVxuICB9XG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPbmx5IHBheSBhdHRlbnRpb24gdG8gZW5jb2RpbmcgaWYgaXQncyBhIHN0cmluZy4gVGhpc1xuICAgIC8vIHByZXZlbnRzIGFjY2lkZW50YWxseSBzZW5kaW5nIGluIGEgbnVtYmVyIHRoYXQgd291bGRcbiAgICAvLyBiZSBpbnRlcnByZXR0ZWQgYXMgYSBzdGFydCBvZmZzZXQuXG4gICAgcmV0dXJuIHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZydcbiAgICAgID8gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgICA6IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKS5maWxsKGZpbGwpXG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqIGFsbG9jKHNpemVbLCBmaWxsWywgZW5jb2RpbmddXSlcbiAqKi9cbkJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICByZXR1cm4gYWxsb2MobnVsbCwgc2l6ZSwgZmlsbCwgZW5jb2RpbmcpXG59XG5cbmZ1bmN0aW9uIGFsbG9jVW5zYWZlICh0aGF0LCBzaXplKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplIDwgMCA/IDAgOiBjaGVja2VkKHNpemUpIHwgMClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgKytpKSB7XG4gICAgICB0aGF0W2ldID0gMFxuICAgIH1cbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gQnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKG51bGwsIHNpemUpXG59XG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gU2xvd0J1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICovXG5CdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKG51bGwsIHNpemUpXG59XG5cbmZ1bmN0aW9uIGZyb21TdHJpbmcgKHRoYXQsIHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycgfHwgZW5jb2RpbmcgPT09ICcnKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgfVxuXG4gIGlmICghQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJlbmNvZGluZ1wiIG11c3QgYmUgYSB2YWxpZCBzdHJpbmcgZW5jb2RpbmcnKVxuICB9XG5cbiAgdmFyIGxlbmd0aCA9IGJ5dGVMZW5ndGgoc3RyaW5nLCBlbmNvZGluZykgfCAwXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuZ3RoKVxuXG4gIHZhciBhY3R1YWwgPSB0aGF0LndyaXRlKHN0cmluZywgZW5jb2RpbmcpXG5cbiAgaWYgKGFjdHVhbCAhPT0gbGVuZ3RoKSB7XG4gICAgLy8gV3JpdGluZyBhIGhleCBzdHJpbmcsIGZvciBleGFtcGxlLCB0aGF0IGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVycyB3aWxsXG4gICAgLy8gY2F1c2UgZXZlcnl0aGluZyBhZnRlciB0aGUgZmlyc3QgaW52YWxpZCBjaGFyYWN0ZXIgdG8gYmUgaWdub3JlZC4gKGUuZy5cbiAgICAvLyAnYWJ4eGNkJyB3aWxsIGJlIHRyZWF0ZWQgYXMgJ2FiJylcbiAgICB0aGF0ID0gdGhhdC5zbGljZSgwLCBhY3R1YWwpXG4gIH1cblxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlMaWtlICh0aGF0LCBhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoIDwgMCA/IDAgOiBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuZ3RoKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgdGhhdFtpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5QnVmZmVyICh0aGF0LCBhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gIGFycmF5LmJ5dGVMZW5ndGggLy8gdGhpcyB0aHJvd3MgaWYgYGFycmF5YCBpcyBub3QgYSB2YWxpZCBBcnJheUJ1ZmZlclxuXG4gIGlmIChieXRlT2Zmc2V0IDwgMCB8fCBhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXCdvZmZzZXRcXCcgaXMgb3V0IG9mIGJvdW5kcycpXG4gIH1cblxuICBpZiAoYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQgKyAobGVuZ3RoIHx8IDApKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ2xlbmd0aFxcJyBpcyBvdXQgb2YgYm91bmRzJylcbiAgfVxuXG4gIGlmIChieXRlT2Zmc2V0ID09PSB1bmRlZmluZWQgJiYgbGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5KVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldClcbiAgfSBlbHNlIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSwgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICB0aGF0ID0gYXJyYXlcbiAgICB0aGF0Ll9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIGFuIG9iamVjdCBpbnN0YW5jZSBvZiB0aGUgQnVmZmVyIGNsYXNzXG4gICAgdGhhdCA9IGZyb21BcnJheUxpa2UodGhhdCwgYXJyYXkpXG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbU9iamVjdCAodGhhdCwgb2JqKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIob2JqKSkge1xuICAgIHZhciBsZW4gPSBjaGVja2VkKG9iai5sZW5ndGgpIHwgMFxuICAgIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuKVxuXG4gICAgaWYgKHRoYXQubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhhdFxuICAgIH1cblxuICAgIG9iai5jb3B5KHRoYXQsIDAsIDAsIGxlbilcbiAgICByZXR1cm4gdGhhdFxuICB9XG5cbiAgaWYgKG9iaikge1xuICAgIGlmICgodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICBvYmouYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHx8ICdsZW5ndGgnIGluIG9iaikge1xuICAgICAgaWYgKHR5cGVvZiBvYmoubGVuZ3RoICE9PSAnbnVtYmVyJyB8fCBpc25hbihvYmoubGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIDApXG4gICAgICB9XG4gICAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh0aGF0LCBvYmopXG4gICAgfVxuXG4gICAgaWYgKG9iai50eXBlID09PSAnQnVmZmVyJyAmJiBpc0FycmF5KG9iai5kYXRhKSkge1xuICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2UodGhhdCwgb2JqLmRhdGEpXG4gICAgfVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcignRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksIG9yIGFycmF5LWxpa2Ugb2JqZWN0LicpXG59XG5cbmZ1bmN0aW9uIGNoZWNrZWQgKGxlbmd0aCkge1xuICAvLyBOb3RlOiBjYW5ub3QgdXNlIGBsZW5ndGggPCBrTWF4TGVuZ3RoKClgIGhlcmUgYmVjYXVzZSB0aGF0IGZhaWxzIHdoZW5cbiAgLy8gbGVuZ3RoIGlzIE5hTiAod2hpY2ggaXMgb3RoZXJ3aXNlIGNvZXJjZWQgdG8gemVyby4pXG4gIGlmIChsZW5ndGggPj0ga01heExlbmd0aCgpKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgJ3NpemU6IDB4JyArIGtNYXhMZW5ndGgoKS50b1N0cmluZygxNikgKyAnIGJ5dGVzJylcbiAgfVxuICByZXR1cm4gbGVuZ3RoIHwgMFxufVxuXG5mdW5jdGlvbiBTbG93QnVmZmVyIChsZW5ndGgpIHtcbiAgaWYgKCtsZW5ndGggIT0gbGVuZ3RoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG4gICAgbGVuZ3RoID0gMFxuICB9XG4gIHJldHVybiBCdWZmZXIuYWxsb2MoK2xlbmd0aClcbn1cblxuQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIgKGIpIHtcbiAgcmV0dXJuICEhKGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlcilcbn1cblxuQnVmZmVyLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChhLCBiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGEpIHx8ICFCdWZmZXIuaXNCdWZmZXIoYikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgbXVzdCBiZSBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChhID09PSBiKSByZXR1cm4gMFxuXG4gIHZhciB4ID0gYS5sZW5ndGhcbiAgdmFyIHkgPSBiLmxlbmd0aFxuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHggPSBhW2ldXG4gICAgICB5ID0gYltpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gaXNFbmNvZGluZyAoZW5jb2RpbmcpIHtcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnbGF0aW4xJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQgKGxpc3QsIGxlbmd0aCkge1xuICBpZiAoIWlzQXJyYXkobGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbGVuZ3RoID0gMFxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICBsZW5ndGggKz0gbGlzdFtpXS5sZW5ndGhcbiAgICB9XG4gIH1cblxuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbmd0aClcbiAgdmFyIHBvcyA9IDBcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYnVmID0gbGlzdFtpXVxuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gICAgfVxuICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKVxuICAgIHBvcyArPSBidWYubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlclxufVxuXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoc3RyaW5nKSkge1xuICAgIHJldHVybiBzdHJpbmcubGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIEFycmF5QnVmZmVyLmlzVmlldyA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgKEFycmF5QnVmZmVyLmlzVmlldyhzdHJpbmcpIHx8IHN0cmluZyBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSkge1xuICAgIHJldHVybiBzdHJpbmcuYnl0ZUxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuICAgIHN0cmluZyA9ICcnICsgc3RyaW5nXG4gIH1cblxuICB2YXIgbGVuID0gc3RyaW5nLmxlbmd0aFxuICBpZiAobGVuID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIFVzZSBhIGZvciBsb29wIHRvIGF2b2lkIHJlY3Vyc2lvblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsZW5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIGxlbiAqIDJcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBsZW4gPj4+IDFcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aCAvLyBhc3N1bWUgdXRmOFxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuQnVmZmVyLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5cbmZ1bmN0aW9uIHNsb3dUb1N0cmluZyAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcblxuICAvLyBObyBuZWVkIHRvIHZlcmlmeSB0aGF0IFwidGhpcy5sZW5ndGggPD0gTUFYX1VJTlQzMlwiIHNpbmNlIGl0J3MgYSByZWFkLW9ubHlcbiAgLy8gcHJvcGVydHkgb2YgYSB0eXBlZCBhcnJheS5cblxuICAvLyBUaGlzIGJlaGF2ZXMgbmVpdGhlciBsaWtlIFN0cmluZyBub3IgVWludDhBcnJheSBpbiB0aGF0IHdlIHNldCBzdGFydC9lbmRcbiAgLy8gdG8gdGhlaXIgdXBwZXIvbG93ZXIgYm91bmRzIGlmIHRoZSB2YWx1ZSBwYXNzZWQgaXMgb3V0IG9mIHJhbmdlLlxuICAvLyB1bmRlZmluZWQgaXMgaGFuZGxlZCBzcGVjaWFsbHkgYXMgcGVyIEVDTUEtMjYyIDZ0aCBFZGl0aW9uLFxuICAvLyBTZWN0aW9uIDEzLjMuMy43IFJ1bnRpbWUgU2VtYW50aWNzOiBLZXllZEJpbmRpbmdJbml0aWFsaXphdGlvbi5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQgfHwgc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgLy8gUmV0dXJuIGVhcmx5IGlmIHN0YXJ0ID4gdGhpcy5sZW5ndGguIERvbmUgaGVyZSB0byBwcmV2ZW50IHBvdGVudGlhbCB1aW50MzJcbiAgLy8gY29lcmNpb24gZmFpbCBiZWxvdy5cbiAgaWYgKHN0YXJ0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoZW5kIDw9IDApIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIC8vIEZvcmNlIGNvZXJzaW9uIHRvIHVpbnQzMi4gVGhpcyB3aWxsIGFsc28gY29lcmNlIGZhbHNleS9OYU4gdmFsdWVzIHRvIDAuXG4gIGVuZCA+Pj49IDBcbiAgc3RhcnQgPj4+PSAwXG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1dGYxNmxlU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbi8vIFRoZSBwcm9wZXJ0eSBpcyB1c2VkIGJ5IGBCdWZmZXIuaXNCdWZmZXJgIGFuZCBgaXMtYnVmZmVyYCAoaW4gU2FmYXJpIDUtNykgdG8gZGV0ZWN0XG4vLyBCdWZmZXIgaW5zdGFuY2VzLlxuQnVmZmVyLnByb3RvdHlwZS5faXNCdWZmZXIgPSB0cnVlXG5cbmZ1bmN0aW9uIHN3YXAgKGIsIG4sIG0pIHtcbiAgdmFyIGkgPSBiW25dXG4gIGJbbl0gPSBiW21dXG4gIGJbbV0gPSBpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDE2ID0gZnVuY3Rpb24gc3dhcDE2ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSAyICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMSlcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAzMiA9IGZ1bmN0aW9uIHN3YXAzMiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgNCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDMpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDIpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwNjQgPSBmdW5jdGlvbiBzd2FwNjQgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDggIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDY0LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDgpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyA3KVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyA2KVxuICAgIHN3YXAodGhpcywgaSArIDIsIGkgKyA1KVxuICAgIHN3YXAodGhpcywgaSArIDMsIGkgKyA0KVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aCB8IDBcbiAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuICcnXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIDAsIGxlbmd0aClcbiAgcmV0dXJuIHNsb3dUb1N0cmluZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgdmFyIHN0ciA9ICcnXG4gIHZhciBtYXggPSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTXG4gIGlmICh0aGlzLmxlbmd0aCA+IDApIHtcbiAgICBzdHIgPSB0aGlzLnRvU3RyaW5nKCdoZXgnLCAwLCBtYXgpLm1hdGNoKC8uezJ9L2cpLmpvaW4oJyAnKVxuICAgIGlmICh0aGlzLmxlbmd0aCA+IG1heCkgc3RyICs9ICcgLi4uICdcbiAgfVxuICByZXR1cm4gJzxCdWZmZXIgJyArIHN0ciArICc+J1xufVxuXG5CdWZmZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlICh0YXJnZXQsIHN0YXJ0LCBlbmQsIHRoaXNTdGFydCwgdGhpc0VuZCkge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIH1cblxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuZCA9IHRhcmdldCA/IHRhcmdldC5sZW5ndGggOiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc1N0YXJ0ID0gMFxuICB9XG4gIGlmICh0aGlzRW5kID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzRW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChzdGFydCA8IDAgfHwgZW5kID4gdGFyZ2V0Lmxlbmd0aCB8fCB0aGlzU3RhcnQgPCAwIHx8IHRoaXNFbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kICYmIHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kKSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cbiAgaWYgKHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAxXG4gIH1cblxuICBzdGFydCA+Pj49IDBcbiAgZW5kID4+Pj0gMFxuICB0aGlzU3RhcnQgPj4+PSAwXG4gIHRoaXNFbmQgPj4+PSAwXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCkgcmV0dXJuIDBcblxuICB2YXIgeCA9IHRoaXNFbmQgLSB0aGlzU3RhcnRcbiAgdmFyIHkgPSBlbmQgLSBzdGFydFxuICB2YXIgbGVuID0gTWF0aC5taW4oeCwgeSlcblxuICB2YXIgdGhpc0NvcHkgPSB0aGlzLnNsaWNlKHRoaXNTdGFydCwgdGhpc0VuZClcbiAgdmFyIHRhcmdldENvcHkgPSB0YXJnZXQuc2xpY2Uoc3RhcnQsIGVuZClcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKHRoaXNDb3B5W2ldICE9PSB0YXJnZXRDb3B5W2ldKSB7XG4gICAgICB4ID0gdGhpc0NvcHlbaV1cbiAgICAgIHkgPSB0YXJnZXRDb3B5W2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuLy8gRmluZHMgZWl0aGVyIHRoZSBmaXJzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPj0gYGJ5dGVPZmZzZXRgLFxuLy8gT1IgdGhlIGxhc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0IDw9IGBieXRlT2Zmc2V0YC5cbi8vXG4vLyBBcmd1bWVudHM6XG4vLyAtIGJ1ZmZlciAtIGEgQnVmZmVyIHRvIHNlYXJjaFxuLy8gLSB2YWwgLSBhIHN0cmluZywgQnVmZmVyLCBvciBudW1iZXJcbi8vIC0gYnl0ZU9mZnNldCAtIGFuIGluZGV4IGludG8gYGJ1ZmZlcmA7IHdpbGwgYmUgY2xhbXBlZCB0byBhbiBpbnQzMlxuLy8gLSBlbmNvZGluZyAtIGFuIG9wdGlvbmFsIGVuY29kaW5nLCByZWxldmFudCBpcyB2YWwgaXMgYSBzdHJpbmdcbi8vIC0gZGlyIC0gdHJ1ZSBmb3IgaW5kZXhPZiwgZmFsc2UgZm9yIGxhc3RJbmRleE9mXG5mdW5jdGlvbiBiaWRpcmVjdGlvbmFsSW5kZXhPZiAoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgLy8gRW1wdHkgYnVmZmVyIG1lYW5zIG5vIG1hdGNoXG4gIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSByZXR1cm4gLTFcblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldFxuICBpZiAodHlwZW9mIGJ5dGVPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBieXRlT2Zmc2V0XG4gICAgYnl0ZU9mZnNldCA9IDBcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0ID4gMHg3ZmZmZmZmZikge1xuICAgIGJ5dGVPZmZzZXQgPSAweDdmZmZmZmZmXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IC0weDgwMDAwMDAwKSB7XG4gICAgYnl0ZU9mZnNldCA9IC0weDgwMDAwMDAwXG4gIH1cbiAgYnl0ZU9mZnNldCA9ICtieXRlT2Zmc2V0ICAvLyBDb2VyY2UgdG8gTnVtYmVyLlxuICBpZiAoaXNOYU4oYnl0ZU9mZnNldCkpIHtcbiAgICAvLyBieXRlT2Zmc2V0OiBpdCBpdCdzIHVuZGVmaW5lZCwgbnVsbCwgTmFOLCBcImZvb1wiLCBldGMsIHNlYXJjaCB3aG9sZSBidWZmZXJcbiAgICBieXRlT2Zmc2V0ID0gZGlyID8gMCA6IChidWZmZXIubGVuZ3RoIC0gMSlcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0OiBuZWdhdGl2ZSBvZmZzZXRzIHN0YXJ0IGZyb20gdGhlIGVuZCBvZiB0aGUgYnVmZmVyXG4gIGlmIChieXRlT2Zmc2V0IDwgMCkgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggKyBieXRlT2Zmc2V0XG4gIGlmIChieXRlT2Zmc2V0ID49IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICBpZiAoZGlyKSByZXR1cm4gLTFcbiAgICBlbHNlIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoIC0gMVxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAwKSB7XG4gICAgaWYgKGRpcikgYnl0ZU9mZnNldCA9IDBcbiAgICBlbHNlIHJldHVybiAtMVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIHZhbFxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YWwgPSBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKVxuICB9XG5cbiAgLy8gRmluYWxseSwgc2VhcmNoIGVpdGhlciBpbmRleE9mIChpZiBkaXIgaXMgdHJ1ZSkgb3IgbGFzdEluZGV4T2ZcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWwpKSB7XG4gICAgLy8gU3BlY2lhbCBjYXNlOiBsb29raW5nIGZvciBlbXB0eSBzdHJpbmcvYnVmZmVyIGFsd2F5cyBmYWlsc1xuICAgIGlmICh2YWwubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDB4RkYgLy8gU2VhcmNoIGZvciBhIGJ5dGUgdmFsdWUgWzAtMjU1XVxuICAgIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJlxuICAgICAgICB0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKGRpcikge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCBbIHZhbCBdLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyJylcbn1cblxuZnVuY3Rpb24gYXJyYXlJbmRleE9mIChhcnIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICB2YXIgaW5kZXhTaXplID0gMVxuICB2YXIgYXJyTGVuZ3RoID0gYXJyLmxlbmd0aFxuICB2YXIgdmFsTGVuZ3RoID0gdmFsLmxlbmd0aFxuXG4gIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICBpZiAoZW5jb2RpbmcgPT09ICd1Y3MyJyB8fCBlbmNvZGluZyA9PT0gJ3Vjcy0yJyB8fFxuICAgICAgICBlbmNvZGluZyA9PT0gJ3V0ZjE2bGUnIHx8IGVuY29kaW5nID09PSAndXRmLTE2bGUnKSB7XG4gICAgICBpZiAoYXJyLmxlbmd0aCA8IDIgfHwgdmFsLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIC0xXG4gICAgICB9XG4gICAgICBpbmRleFNpemUgPSAyXG4gICAgICBhcnJMZW5ndGggLz0gMlxuICAgICAgdmFsTGVuZ3RoIC89IDJcbiAgICAgIGJ5dGVPZmZzZXQgLz0gMlxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWQgKGJ1ZiwgaSkge1xuICAgIGlmIChpbmRleFNpemUgPT09IDEpIHtcbiAgICAgIHJldHVybiBidWZbaV1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGJ1Zi5yZWFkVUludDE2QkUoaSAqIGluZGV4U2l6ZSlcbiAgICB9XG4gIH1cblxuICB2YXIgaVxuICBpZiAoZGlyKSB7XG4gICAgdmFyIGZvdW5kSW5kZXggPSAtMVxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPCBhcnJMZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHJlYWQoYXJyLCBpKSA9PT0gcmVhZCh2YWwsIGZvdW5kSW5kZXggPT09IC0xID8gMCA6IGkgLSBmb3VuZEluZGV4KSkge1xuICAgICAgICBpZiAoZm91bmRJbmRleCA9PT0gLTEpIGZvdW5kSW5kZXggPSBpXG4gICAgICAgIGlmIChpIC0gZm91bmRJbmRleCArIDEgPT09IHZhbExlbmd0aCkgcmV0dXJuIGZvdW5kSW5kZXggKiBpbmRleFNpemVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ICE9PSAtMSkgaSAtPSBpIC0gZm91bmRJbmRleFxuICAgICAgICBmb3VuZEluZGV4ID0gLTFcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGJ5dGVPZmZzZXQgKyB2YWxMZW5ndGggPiBhcnJMZW5ndGgpIGJ5dGVPZmZzZXQgPSBhcnJMZW5ndGggLSB2YWxMZW5ndGhcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIGZvdW5kID0gdHJ1ZVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB2YWxMZW5ndGg7IGorKykge1xuICAgICAgICBpZiAocmVhZChhcnIsIGkgKyBqKSAhPT0gcmVhZCh2YWwsIGopKSB7XG4gICAgICAgICAgZm91bmQgPSBmYWxzZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmb3VuZCkgcmV0dXJuIGlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uIGluY2x1ZGVzICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiB0aGlzLmluZGV4T2YodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykgIT09IC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIHRydWUpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUubGFzdEluZGV4T2YgPSBmdW5jdGlvbiBsYXN0SW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZmFsc2UpXG59XG5cbmZ1bmN0aW9uIGhleFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICB2YXIgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG5cbiAgLy8gbXVzdCBiZSBhbiBldmVuIG51bWJlciBvZiBkaWdpdHNcbiAgdmFyIHN0ckxlbiA9IHN0cmluZy5sZW5ndGhcbiAgaWYgKHN0ckxlbiAlIDIgIT09IDApIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgaGV4IHN0cmluZycpXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIHZhciBwYXJzZWQgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpXG4gICAgaWYgKGlzTmFOKHBhcnNlZCkpIHJldHVybiBpXG4gICAgYnVmW29mZnNldCArIGldID0gcGFyc2VkXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYXNjaWlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBsYXRpbjFXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBhc2NpaVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIHVjczJXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiB3cml0ZSAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZylcbiAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IG9mZnNldFxuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBvZmZzZXRbLCBsZW5ndGhdWywgZW5jb2RpbmddKVxuICB9IGVsc2UgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gICAgaWYgKGlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgIGxlbmd0aCA9IGxlbmd0aCB8IDBcbiAgICAgIGlmIChlbmNvZGluZyA9PT0gdW5kZWZpbmVkKSBlbmNvZGluZyA9ICd1dGY4J1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aFxuICAgICAgbGVuZ3RoID0gdW5kZWZpbmVkXG4gICAgfVxuICAvLyBsZWdhY3kgd3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0LCBsZW5ndGgpIC0gcmVtb3ZlIGluIHYwLjEzXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0J1ZmZlci53cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXRbLCBsZW5ndGhdKSBpcyBubyBsb25nZXIgc3VwcG9ydGVkJ1xuICAgIClcbiAgfVxuXG4gIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldFxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgfHwgbGVuZ3RoID4gcmVtYWluaW5nKSBsZW5ndGggPSByZW1haW5pbmdcblxuICBpZiAoKHN0cmluZy5sZW5ndGggPiAwICYmIChsZW5ndGggPCAwIHx8IG9mZnNldCA8IDApKSB8fCBvZmZzZXQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIHdyaXRlIG91dHNpZGUgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIC8vIFdhcm5pbmc6IG1heExlbmd0aCBub3QgdGFrZW4gaW50byBhY2NvdW50IGluIGJhc2U2NFdyaXRlXG4gICAgICAgIHJldHVybiBiYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdWNzMldyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0J1ZmZlcicsXG4gICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApXG4gIH1cbn1cblxuZnVuY3Rpb24gYmFzZTY0U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1ZilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICB9XG59XG5cbmZ1bmN0aW9uIHV0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcbiAgdmFyIHJlcyA9IFtdXG5cbiAgdmFyIGkgPSBzdGFydFxuICB3aGlsZSAoaSA8IGVuZCkge1xuICAgIHZhciBmaXJzdEJ5dGUgPSBidWZbaV1cbiAgICB2YXIgY29kZVBvaW50ID0gbnVsbFxuICAgIHZhciBieXRlc1BlclNlcXVlbmNlID0gKGZpcnN0Qnl0ZSA+IDB4RUYpID8gNFxuICAgICAgOiAoZmlyc3RCeXRlID4gMHhERikgPyAzXG4gICAgICA6IChmaXJzdEJ5dGUgPiAweEJGKSA/IDJcbiAgICAgIDogMVxuXG4gICAgaWYgKGkgKyBieXRlc1BlclNlcXVlbmNlIDw9IGVuZCkge1xuICAgICAgdmFyIHNlY29uZEJ5dGUsIHRoaXJkQnl0ZSwgZm91cnRoQnl0ZSwgdGVtcENvZGVQb2ludFxuXG4gICAgICBzd2l0Y2ggKGJ5dGVzUGVyU2VxdWVuY2UpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGlmIChmaXJzdEJ5dGUgPCAweDgwKSB7XG4gICAgICAgICAgICBjb2RlUG9pbnQgPSBmaXJzdEJ5dGVcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHgxRikgPDwgMHg2IHwgKHNlY29uZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4QyB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKHRoaXJkQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0ZGICYmICh0ZW1wQ29kZVBvaW50IDwgMHhEODAwIHx8IHRlbXBDb2RlUG9pbnQgPiAweERGRkYpKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGZvdXJ0aEJ5dGUgPSBidWZbaSArIDNdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwICYmIChmb3VydGhCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweDEyIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweEMgfCAodGhpcmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKGZvdXJ0aEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweEZGRkYgJiYgdGVtcENvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvZGVQb2ludCA9PT0gbnVsbCkge1xuICAgICAgLy8gd2UgZGlkIG5vdCBnZW5lcmF0ZSBhIHZhbGlkIGNvZGVQb2ludCBzbyBpbnNlcnQgYVxuICAgICAgLy8gcmVwbGFjZW1lbnQgY2hhciAoVStGRkZEKSBhbmQgYWR2YW5jZSBvbmx5IDEgYnl0ZVxuICAgICAgY29kZVBvaW50ID0gMHhGRkZEXG4gICAgICBieXRlc1BlclNlcXVlbmNlID0gMVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50ID4gMHhGRkZGKSB7XG4gICAgICAvLyBlbmNvZGUgdG8gdXRmMTYgKHN1cnJvZ2F0ZSBwYWlyIGRhbmNlKVxuICAgICAgY29kZVBvaW50IC09IDB4MTAwMDBcbiAgICAgIHJlcy5wdXNoKGNvZGVQb2ludCA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMClcbiAgICAgIGNvZGVQb2ludCA9IDB4REMwMCB8IGNvZGVQb2ludCAmIDB4M0ZGXG4gICAgfVxuXG4gICAgcmVzLnB1c2goY29kZVBvaW50KVxuICAgIGkgKz0gYnl0ZXNQZXJTZXF1ZW5jZVxuICB9XG5cbiAgcmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShyZXMpXG59XG5cbi8vIEJhc2VkIG9uIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIyNzQ3MjcyLzY4MDc0MiwgdGhlIGJyb3dzZXIgd2l0aFxuLy8gdGhlIGxvd2VzdCBsaW1pdCBpcyBDaHJvbWUsIHdpdGggMHgxMDAwMCBhcmdzLlxuLy8gV2UgZ28gMSBtYWduaXR1ZGUgbGVzcywgZm9yIHNhZmV0eVxudmFyIE1BWF9BUkdVTUVOVFNfTEVOR1RIID0gMHgxMDAwXG5cbmZ1bmN0aW9uIGRlY29kZUNvZGVQb2ludHNBcnJheSAoY29kZVBvaW50cykge1xuICB2YXIgbGVuID0gY29kZVBvaW50cy5sZW5ndGhcbiAgaWYgKGxlbiA8PSBNQVhfQVJHVU1FTlRTX0xFTkdUSCkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY29kZVBvaW50cykgLy8gYXZvaWQgZXh0cmEgc2xpY2UoKVxuICB9XG5cbiAgLy8gRGVjb2RlIGluIGNodW5rcyB0byBhdm9pZCBcImNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFwiLlxuICB2YXIgcmVzID0gJydcbiAgdmFyIGkgPSAwXG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoXG4gICAgICBTdHJpbmcsXG4gICAgICBjb2RlUG9pbnRzLnNsaWNlKGksIGkgKz0gTUFYX0FSR1VNRU5UU19MRU5HVEgpXG4gICAgKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0gJiAweDdGKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gbGF0aW4xU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlblxuXG4gIHZhciBvdXQgPSAnJ1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIG91dCArPSB0b0hleChidWZbaV0pXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiB1dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZClcbiAgdmFyIHJlcyA9ICcnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIGJ5dGVzW2kgKyAxXSAqIDI1NilcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgc3RhcnQgPSB+fnN0YXJ0XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogfn5lbmRcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgKz0gbGVuXG4gICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIH0gZWxzZSBpZiAoc3RhcnQgPiBsZW4pIHtcbiAgICBzdGFydCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgKz0gbGVuXG4gICAgaWYgKGVuZCA8IDApIGVuZCA9IDBcbiAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHtcbiAgICBlbmQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICB2YXIgbmV3QnVmXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIG5ld0J1ZiA9IHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZClcbiAgICBuZXdCdWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIHZhciBzbGljZUxlbiA9IGVuZCAtIHN0YXJ0XG4gICAgbmV3QnVmID0gbmV3IEJ1ZmZlcihzbGljZUxlbiwgdW5kZWZpbmVkKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2xpY2VMZW47ICsraSkge1xuICAgICAgbmV3QnVmW2ldID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ld0J1ZlxufVxuXG4vKlxuICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0IChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7XG4gIGlmICgob2Zmc2V0ICUgMSkgIT09IDAgfHwgb2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29mZnNldCBpcyBub3QgdWludCcpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gcmVhZFVJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludEJFID0gZnVuY3Rpb24gcmVhZFVJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcbiAgfVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF1cbiAgdmFyIG11bCA9IDFcbiAgd2hpbGUgKGJ5dGVMZW5ndGggPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIHJlYWRVSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCA4KSB8IHRoaXNbb2Zmc2V0ICsgMV1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiByZWFkVUludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKCh0aGlzW29mZnNldF0pIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSkgK1xuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gKiAweDEwMDAwMDApXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gKiAweDEwMDAwMDApICtcbiAgICAoKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgdGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50TEUgPSBmdW5jdGlvbiByZWFkSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50QkUgPSBmdW5jdGlvbiByZWFkSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgaSA9IGJ5dGVMZW5ndGhcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1pXVxuICB3aGlsZSAoaSA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIGlmICghKHRoaXNbb2Zmc2V0XSAmIDB4ODApKSByZXR1cm4gKHRoaXNbb2Zmc2V0XSlcbiAgcmV0dXJuICgoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTEpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiByZWFkSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gcmVhZEludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCAodGhpc1tvZmZzZXRdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0pIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSA8PCAyNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgMjQpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdExFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gcmVhZERvdWJsZUxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiByZWFkRG91YmxlQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOClcbn1cblxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJ1ZmZlclwiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKVxuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgaXMgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlVUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlVUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVVSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweGZmLCAwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbmZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDE2IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZiArIHZhbHVlICsgMVxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDIpOyBpIDwgajsgKytpKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlICYgKDB4ZmYgPDwgKDggKiAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSkpKSA+Pj5cbiAgICAgIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpICogOFxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbmZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDMyIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCA0KTsgaSA8IGo7ICsraSkge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSA+Pj4gKGxpdHRsZUVuZGlhbiA/IGkgOiAzIC0gaSkgKiA4KSAmIDB4ZmZcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSAwXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSAtIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSArIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5mdW5jdGlvbiBjaGVja0lFRUU3NTQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuZnVuY3Rpb24gd3JpdGVGbG9hdCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA0LCAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4LCAtMy40MDI4MjM0NjYzODUyODg2ZSszOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiB3cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA4LCAxLjc5NzY5MzEzNDg2MjMxNTdFKzMwOCwgLTEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KVxuICByZXR1cm4gb2Zmc2V0ICsgOFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbi8vIGNvcHkodGFyZ2V0QnVmZmVyLCB0YXJnZXRTdGFydD0wLCBzb3VyY2VTdGFydD0wLCBzb3VyY2VFbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKHRhcmdldCwgdGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kICYmIGVuZCAhPT0gMCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldFN0YXJ0ID49IHRhcmdldC5sZW5ndGgpIHRhcmdldFN0YXJ0ID0gdGFyZ2V0Lmxlbmd0aFxuICBpZiAoIXRhcmdldFN0YXJ0KSB0YXJnZXRTdGFydCA9IDBcbiAgaWYgKGVuZCA+IDAgJiYgZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgLy8gQ29weSAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm4gMFxuICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMCB8fCB0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBGYXRhbCBlcnJvciBjb25kaXRpb25zXG4gIGlmICh0YXJnZXRTdGFydCA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIH1cbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZVN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICBpZiAoZW5kIDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJylcblxuICAvLyBBcmUgd2Ugb29iP1xuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgPCBlbmQgLSBzdGFydCkge1xuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCArIHN0YXJ0XG4gIH1cblxuICB2YXIgbGVuID0gZW5kIC0gc3RhcnRcbiAgdmFyIGlcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHN0YXJ0IDwgdGFyZ2V0U3RhcnQgJiYgdGFyZ2V0U3RhcnQgPCBlbmQpIHtcbiAgICAvLyBkZXNjZW5kaW5nIGNvcHkgZnJvbSBlbmRcbiAgICBmb3IgKGkgPSBsZW4gLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSBpZiAobGVuIDwgMTAwMCB8fCAhQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBhc2NlbmRpbmcgY29weSBmcm9tIHN0YXJ0XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChcbiAgICAgIHRhcmdldCxcbiAgICAgIHRoaXMuc3ViYXJyYXkoc3RhcnQsIHN0YXJ0ICsgbGVuKSxcbiAgICAgIHRhcmdldFN0YXJ0XG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIGxlblxufVxuXG4vLyBVc2FnZTpcbi8vICAgIGJ1ZmZlci5maWxsKG51bWJlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoYnVmZmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChzdHJpbmdbLCBvZmZzZXRbLCBlbmRdXVssIGVuY29kaW5nXSlcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIGZpbGwgKHZhbCwgc3RhcnQsIGVuZCwgZW5jb2RpbmcpIHtcbiAgLy8gSGFuZGxlIHN0cmluZyBjYXNlczpcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gc3RhcnRcbiAgICAgIHN0YXJ0ID0gMFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbmQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IGVuZFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9XG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZhciBjb2RlID0gdmFsLmNoYXJDb2RlQXQoMClcbiAgICAgIGlmIChjb2RlIDwgMjU2KSB7XG4gICAgICAgIHZhbCA9IGNvZGVcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZW5jb2RpbmcgbXVzdCBiZSBhIHN0cmluZycpXG4gICAgfVxuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnICYmICFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAyNTVcbiAgfVxuXG4gIC8vIEludmFsaWQgcmFuZ2VzIGFyZSBub3Qgc2V0IHRvIGEgZGVmYXVsdCwgc28gY2FuIHJhbmdlIGNoZWNrIGVhcmx5LlxuICBpZiAoc3RhcnQgPCAwIHx8IHRoaXMubGVuZ3RoIDwgc3RhcnQgfHwgdGhpcy5sZW5ndGggPCBlbmQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignT3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgc3RhcnQgPSBzdGFydCA+Pj4gMFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IHRoaXMubGVuZ3RoIDogZW5kID4+PiAwXG5cbiAgaWYgKCF2YWwpIHZhbCA9IDBcblxuICB2YXIgaVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICB0aGlzW2ldID0gdmFsXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBieXRlcyA9IEJ1ZmZlci5pc0J1ZmZlcih2YWwpXG4gICAgICA/IHZhbFxuICAgICAgOiB1dGY4VG9CeXRlcyhuZXcgQnVmZmVyKHZhbCwgZW5jb2RpbmcpLnRvU3RyaW5nKCkpXG4gICAgdmFyIGxlbiA9IGJ5dGVzLmxlbmd0aFxuICAgIGZvciAoaSA9IDA7IGkgPCBlbmQgLSBzdGFydDsgKytpKSB7XG4gICAgICB0aGlzW2kgKyBzdGFydF0gPSBieXRlc1tpICUgbGVuXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxudmFyIElOVkFMSURfQkFTRTY0X1JFID0gL1teK1xcLzAtOUEtWmEtei1fXS9nXG5cbmZ1bmN0aW9uIGJhc2U2NGNsZWFuIChzdHIpIHtcbiAgLy8gTm9kZSBzdHJpcHMgb3V0IGludmFsaWQgY2hhcmFjdGVycyBsaWtlIFxcbiBhbmQgXFx0IGZyb20gdGhlIHN0cmluZywgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHN0ciA9IHN0cmluZ3RyaW0oc3RyKS5yZXBsYWNlKElOVkFMSURfQkFTRTY0X1JFLCAnJylcbiAgLy8gTm9kZSBjb252ZXJ0cyBzdHJpbmdzIHdpdGggbGVuZ3RoIDwgMiB0byAnJ1xuICBpZiAoc3RyLmxlbmd0aCA8IDIpIHJldHVybiAnJ1xuICAvLyBOb2RlIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBiYXNlNjQgc3RyaW5ncyAobWlzc2luZyB0cmFpbGluZyA9PT0pLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgd2hpbGUgKHN0ci5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgc3RyID0gc3RyICsgJz0nXG4gIH1cbiAgcmV0dXJuIHN0clxufVxuXG5mdW5jdGlvbiBzdHJpbmd0cmltIChzdHIpIHtcbiAgaWYgKHN0ci50cmltKSByZXR1cm4gc3RyLnRyaW0oKVxuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKVxufVxuXG5mdW5jdGlvbiB0b0hleCAobikge1xuICBpZiAobiA8IDE2KSByZXR1cm4gJzAnICsgbi50b1N0cmluZygxNilcbiAgcmV0dXJuIG4udG9TdHJpbmcoMTYpXG59XG5cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzIChzdHJpbmcsIHVuaXRzKSB7XG4gIHVuaXRzID0gdW5pdHMgfHwgSW5maW5pdHlcbiAgdmFyIGNvZGVQb2ludFxuICB2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aFxuICB2YXIgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcbiAgdmFyIGJ5dGVzID0gW11cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgY29kZVBvaW50ID0gc3RyaW5nLmNoYXJDb2RlQXQoaSlcblxuICAgIC8vIGlzIHN1cnJvZ2F0ZSBjb21wb25lbnRcbiAgICBpZiAoY29kZVBvaW50ID4gMHhEN0ZGICYmIGNvZGVQb2ludCA8IDB4RTAwMCkge1xuICAgICAgLy8gbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICghbGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgICAvLyBubyBsZWFkIHlldFxuICAgICAgICBpZiAoY29kZVBvaW50ID4gMHhEQkZGKSB7XG4gICAgICAgICAgLy8gdW5leHBlY3RlZCB0cmFpbFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSBpZiAoaSArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgIC8vIHVucGFpcmVkIGxlYWRcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdmFsaWQgbGVhZFxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gMiBsZWFkcyBpbiBhIHJvd1xuICAgICAgaWYgKGNvZGVQb2ludCA8IDB4REMwMCkge1xuICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyB2YWxpZCBzdXJyb2dhdGUgcGFpclxuICAgICAgY29kZVBvaW50ID0gKGxlYWRTdXJyb2dhdGUgLSAweEQ4MDAgPDwgMTAgfCBjb2RlUG9pbnQgLSAweERDMDApICsgMHgxMDAwMFxuICAgIH0gZWxzZSBpZiAobGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgLy8gdmFsaWQgYm1wIGNoYXIsIGJ1dCBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgfVxuXG4gICAgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcblxuICAgIC8vIGVuY29kZSB1dGY4XG4gICAgaWYgKGNvZGVQb2ludCA8IDB4ODApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMSkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQpXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDgwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2IHwgMHhDMCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyB8IDB4RTAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDQpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDEyIHwgMHhGMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb2RlIHBvaW50JylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnl0ZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgLy8gTm9kZSdzIGNvZGUgc2VlbXMgdG8gYmUgZG9pbmcgdGhpcyBhbmQgbm90ICYgMHg3Ri4uXG4gICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGKVxuICB9XG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMgKHN0ciwgdW5pdHMpIHtcbiAgdmFyIGMsIGhpLCBsb1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcblxuICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKVxuICAgIGhpID0gYyA+PiA4XG4gICAgbG8gPSBjICUgMjU2XG4gICAgYnl0ZUFycmF5LnB1c2gobG8pXG4gICAgYnl0ZUFycmF5LnB1c2goaGkpXG4gIH1cblxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMgKHN0cikge1xuICByZXR1cm4gYmFzZTY0LnRvQnl0ZUFycmF5KGJhc2U2NGNsZWFuKHN0cikpXG59XG5cbmZ1bmN0aW9uIGJsaXRCdWZmZXIgKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgaWYgKChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKSBicmVha1xuICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXVxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIGlzbmFuICh2YWwpIHtcbiAgcmV0dXJuIHZhbCAhPT0gdmFsIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXG59XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gTk9URTogVGhlc2UgdHlwZSBjaGVja2luZyBmdW5jdGlvbnMgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgYGluc3RhbmNlb2ZgXG4vLyBiZWNhdXNlIGl0IGlzIGZyYWdpbGUgYW5kIGNhbiBiZSBlYXNpbHkgZmFrZWQgd2l0aCBgT2JqZWN0LmNyZWF0ZSgpYC5cblxuZnVuY3Rpb24gaXNBcnJheShhcmcpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShhcmcpO1xuICB9XG4gIHJldHVybiBvYmplY3RUb1N0cmluZyhhcmcpID09PSAnW29iamVjdCBBcnJheV0nO1xufVxuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcblxuZnVuY3Rpb24gaXNCb29sZWFuKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nO1xufVxuZXhwb3J0cy5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XG5cbmZ1bmN0aW9uIGlzTnVsbChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsID0gaXNOdWxsO1xuXG5mdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGxPclVuZGVmaW5lZCA9IGlzTnVsbE9yVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuZXhwb3J0cy5pc051bWJlciA9IGlzTnVtYmVyO1xuXG5mdW5jdGlvbiBpc1N0cmluZyhhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnO1xufVxuZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xuXG5mdW5jdGlvbiBpc1N5bWJvbChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnO1xufVxuZXhwb3J0cy5pc1N5bWJvbCA9IGlzU3ltYm9sO1xuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuZXhwb3J0cy5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc1JlZ0V4cChyZSkge1xuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcocmUpID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cbmV4cG9ydHMuaXNSZWdFeHAgPSBpc1JlZ0V4cDtcblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzRGF0ZShkKSB7XG4gIHJldHVybiBvYmplY3RUb1N0cmluZyhkKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuZXhwb3J0cy5pc0RhdGUgPSBpc0RhdGU7XG5cbmZ1bmN0aW9uIGlzRXJyb3IoZSkge1xuICByZXR1cm4gKG9iamVjdFRvU3RyaW5nKGUpID09PSAnW29iamVjdCBFcnJvcl0nIHx8IGUgaW5zdGFuY2VvZiBFcnJvcik7XG59XG5leHBvcnRzLmlzRXJyb3IgPSBpc0Vycm9yO1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnYm9vbGVhbicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdudW1iZXInIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCcgfHwgIC8vIEVTNiBzeW1ib2xcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnO1xufVxuZXhwb3J0cy5pc1ByaW1pdGl2ZSA9IGlzUHJpbWl0aXZlO1xuXG5leHBvcnRzLmlzQnVmZmVyID0gQnVmZmVyLmlzQnVmZmVyO1xuXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyhvKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk7XG59XG4iLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKGZhbHNlKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcImJvZHkge1xcbiAgd2lkdGg6IDEwMCU7XFxuICBoZWlnaHQ6IDEwMCU7XFxuICBvdmVyZmxvdzogaGlkZGVuO1xcbiAgZm9udDogNTAwIDEwcHggJ1d0LVBvc2l0aW9uJywgc2Fucy1zZXJpZjtcXG4gIGJhY2tncm91bmQ6ICMwMDA7XFxuICBjb2xvcjogI2ZmZjsgfVxcbiAgYm9keSAjZGl2QWN0aXZlIHtcXG4gICAgcG9zaXRpb246IGZpeGVkO1xcbiAgICBsZWZ0OiA4cHg7XFxuICAgIGJvdHRvbTogMjQ4cHg7IH1cXG4gIGJvZHkgI2Rpdk1pZGkge1xcbiAgICBwb3NpdGlvbjogZml4ZWQ7XFxuICAgIGxlZnQ6IDhweDtcXG4gICAgYm90dG9tOiAyNDhweDsgfVxcbiAgYm9keSAjZGl2UGF0aCB7XFxuICAgIHBvc2l0aW9uOiBmaXhlZDtcXG4gICAgcmlnaHQ6IDhweDtcXG4gICAgYm90dG9tOiAyNDhweDtcXG4gICAgdGV4dC1hbGlnbjogcmlnaHQ7IH1cXG4gIGJvZHkgI2RpdkF1dG9tYXRvbiB7XFxuICAgIHBvc2l0aW9uOiBmaXhlZDtcXG4gICAgbGVmdDogMDtcXG4gICAgYm90dG9tOiAwO1xcbiAgICB3aWR0aDogMTAwJTtcXG4gICAgaGVpZ2h0OiAyNDBweDsgfVxcbiAgYm9keSAjY2FudmFzIHtcXG4gICAgcG9zaXRpb246IGZpeGVkO1xcbiAgICBsZWZ0OiAwO1xcbiAgICB0b3A6IDA7IH1cXG5cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG4iLCIvKlxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xuLy8gY3NzIGJhc2UgY29kZSwgaW5qZWN0ZWQgYnkgdGhlIGNzcy1sb2FkZXJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odXNlU291cmNlTWFwKSB7XG5cdHZhciBsaXN0ID0gW107XG5cblx0Ly8gcmV0dXJuIHRoZSBsaXN0IG9mIG1vZHVsZXMgYXMgY3NzIHN0cmluZ1xuXHRsaXN0LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG5cdFx0cmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0XHR2YXIgY29udGVudCA9IGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKTtcblx0XHRcdGlmKGl0ZW1bMl0pIHtcblx0XHRcdFx0cmV0dXJuIFwiQG1lZGlhIFwiICsgaXRlbVsyXSArIFwie1wiICsgY29udGVudCArIFwifVwiO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIGNvbnRlbnQ7XG5cdFx0XHR9XG5cdFx0fSkuam9pbihcIlwiKTtcblx0fTtcblxuXHQvLyBpbXBvcnQgYSBsaXN0IG9mIG1vZHVsZXMgaW50byB0aGUgbGlzdFxuXHRsaXN0LmkgPSBmdW5jdGlvbihtb2R1bGVzLCBtZWRpYVF1ZXJ5KSB7XG5cdFx0aWYodHlwZW9mIG1vZHVsZXMgPT09IFwic3RyaW5nXCIpXG5cdFx0XHRtb2R1bGVzID0gW1tudWxsLCBtb2R1bGVzLCBcIlwiXV07XG5cdFx0dmFyIGFscmVhZHlJbXBvcnRlZE1vZHVsZXMgPSB7fTtcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGlkID0gdGhpc1tpXVswXTtcblx0XHRcdGlmKHR5cGVvZiBpZCA9PT0gXCJudW1iZXJcIilcblx0XHRcdFx0YWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpZF0gPSB0cnVlO1xuXHRcdH1cblx0XHRmb3IoaSA9IDA7IGkgPCBtb2R1bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgaXRlbSA9IG1vZHVsZXNbaV07XG5cdFx0XHQvLyBza2lwIGFscmVhZHkgaW1wb3J0ZWQgbW9kdWxlXG5cdFx0XHQvLyB0aGlzIGltcGxlbWVudGF0aW9uIGlzIG5vdCAxMDAlIHBlcmZlY3QgZm9yIHdlaXJkIG1lZGlhIHF1ZXJ5IGNvbWJpbmF0aW9uc1xuXHRcdFx0Ly8gIHdoZW4gYSBtb2R1bGUgaXMgaW1wb3J0ZWQgbXVsdGlwbGUgdGltZXMgd2l0aCBkaWZmZXJlbnQgbWVkaWEgcXVlcmllcy5cblx0XHRcdC8vICBJIGhvcGUgdGhpcyB3aWxsIG5ldmVyIG9jY3VyIChIZXkgdGhpcyB3YXkgd2UgaGF2ZSBzbWFsbGVyIGJ1bmRsZXMpXG5cdFx0XHRpZih0eXBlb2YgaXRlbVswXSAhPT0gXCJudW1iZXJcIiB8fCAhYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpdGVtWzBdXSkge1xuXHRcdFx0XHRpZihtZWRpYVF1ZXJ5ICYmICFpdGVtWzJdKSB7XG5cdFx0XHRcdFx0aXRlbVsyXSA9IG1lZGlhUXVlcnk7XG5cdFx0XHRcdH0gZWxzZSBpZihtZWRpYVF1ZXJ5KSB7XG5cdFx0XHRcdFx0aXRlbVsyXSA9IFwiKFwiICsgaXRlbVsyXSArIFwiKSBhbmQgKFwiICsgbWVkaWFRdWVyeSArIFwiKVwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGxpc3QucHVzaChpdGVtKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cdHJldHVybiBsaXN0O1xufTtcblxuZnVuY3Rpb24gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtLCB1c2VTb3VyY2VNYXApIHtcblx0dmFyIGNvbnRlbnQgPSBpdGVtWzFdIHx8ICcnO1xuXHR2YXIgY3NzTWFwcGluZyA9IGl0ZW1bM107XG5cdGlmICghY3NzTWFwcGluZykge1xuXHRcdHJldHVybiBjb250ZW50O1xuXHR9XG5cblx0aWYgKHVzZVNvdXJjZU1hcCAmJiB0eXBlb2YgYnRvYSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdHZhciBzb3VyY2VNYXBwaW5nID0gdG9Db21tZW50KGNzc01hcHBpbmcpO1xuXHRcdHZhciBzb3VyY2VVUkxzID0gY3NzTWFwcGluZy5zb3VyY2VzLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG5cdFx0XHRyZXR1cm4gJy8qIyBzb3VyY2VVUkw9JyArIGNzc01hcHBpbmcuc291cmNlUm9vdCArIHNvdXJjZSArICcgKi8nXG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gW2NvbnRlbnRdLmNvbmNhdChzb3VyY2VVUkxzKS5jb25jYXQoW3NvdXJjZU1hcHBpbmddKS5qb2luKCdcXG4nKTtcblx0fVxuXG5cdHJldHVybiBbY29udGVudF0uam9pbignXFxuJyk7XG59XG5cbi8vIEFkYXB0ZWQgZnJvbSBjb252ZXJ0LXNvdXJjZS1tYXAgKE1JVClcbmZ1bmN0aW9uIHRvQ29tbWVudChzb3VyY2VNYXApIHtcblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG5cdHZhciBiYXNlNjQgPSBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpO1xuXHR2YXIgZGF0YSA9ICdzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCwnICsgYmFzZTY0O1xuXG5cdHJldHVybiAnLyojICcgKyBkYXRhICsgJyAqLyc7XG59XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICB0aGlzLl9ldmVudHMgPSB0aGlzLl9ldmVudHMgfHwge307XG4gIHRoaXMuX21heExpc3RlbmVycyA9IHRoaXMuX21heExpc3RlbmVycyB8fCB1bmRlZmluZWQ7XG59XG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC4xMC54XG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHMgPSB1bmRlZmluZWQ7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9tYXhMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG5cbi8vIEJ5IGRlZmF1bHQgRXZlbnRFbWl0dGVycyB3aWxsIHByaW50IGEgd2FybmluZyBpZiBtb3JlIHRoYW4gMTAgbGlzdGVuZXJzIGFyZVxuLy8gYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaCBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy5cbkV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XG5cbi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xuLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uKG4pIHtcbiAgaWYgKCFpc051bWJlcihuKSB8fCBuIDwgMCB8fCBpc05hTihuKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ24gbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicpO1xuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIGVyLCBoYW5kbGVyLCBsZW4sIGFyZ3MsIGksIGxpc3RlbmVycztcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcblxuICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXG4gIGlmICh0eXBlID09PSAnZXJyb3InKSB7XG4gICAgaWYgKCF0aGlzLl9ldmVudHMuZXJyb3IgfHxcbiAgICAgICAgKGlzT2JqZWN0KHRoaXMuX2V2ZW50cy5lcnJvcikgJiYgIXRoaXMuX2V2ZW50cy5lcnJvci5sZW5ndGgpKSB7XG4gICAgICBlciA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQXQgbGVhc3QgZ2l2ZSBzb21lIGtpbmQgb2YgY29udGV4dCB0byB0aGUgdXNlclxuICAgICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdVbmNhdWdodCwgdW5zcGVjaWZpZWQgXCJlcnJvclwiIGV2ZW50LiAoJyArIGVyICsgJyknKTtcbiAgICAgICAgZXJyLmNvbnRleHQgPSBlcjtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGhhbmRsZXIgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgaWYgKGlzVW5kZWZpbmVkKGhhbmRsZXIpKVxuICAgIHJldHVybiBmYWxzZTtcblxuICBpZiAoaXNGdW5jdGlvbihoYW5kbGVyKSkge1xuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgLy8gZmFzdCBjYXNlc1xuICAgICAgY2FzZSAxOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8gc2xvd2VyXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgaGFuZGxlci5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QoaGFuZGxlcikpIHtcbiAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICBsaXN0ZW5lcnMgPSBoYW5kbGVyLnNsaWNlKCk7XG4gICAgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspXG4gICAgICBsaXN0ZW5lcnNbaV0uYXBwbHkodGhpcywgYXJncyk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgbTtcblxuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgdGhpcy5fZXZlbnRzID0ge307XG5cbiAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PT0gXCJuZXdMaXN0ZW5lclwiISBCZWZvcmVcbiAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXCJuZXdMaXN0ZW5lclwiLlxuICBpZiAodGhpcy5fZXZlbnRzLm5ld0xpc3RlbmVyKVxuICAgIHRoaXMuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLFxuICAgICAgICAgICAgICBpc0Z1bmN0aW9uKGxpc3RlbmVyLmxpc3RlbmVyKSA/XG4gICAgICAgICAgICAgIGxpc3RlbmVyLmxpc3RlbmVyIDogbGlzdGVuZXIpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xuICBlbHNlIGlmIChpc09iamVjdCh0aGlzLl9ldmVudHNbdHlwZV0pKVxuICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGFycmF5LCBqdXN0IGFwcGVuZC5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0ucHVzaChsaXN0ZW5lcik7XG4gIGVsc2VcbiAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBbdGhpcy5fZXZlbnRzW3R5cGVdLCBsaXN0ZW5lcl07XG5cbiAgLy8gQ2hlY2sgZm9yIGxpc3RlbmVyIGxlYWtcbiAgaWYgKGlzT2JqZWN0KHRoaXMuX2V2ZW50c1t0eXBlXSkgJiYgIXRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQpIHtcbiAgICBpZiAoIWlzVW5kZWZpbmVkKHRoaXMuX21heExpc3RlbmVycykpIHtcbiAgICAgIG0gPSB0aGlzLl9tYXhMaXN0ZW5lcnM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycztcbiAgICB9XG5cbiAgICBpZiAobSAmJiBtID4gMCAmJiB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoID4gbSkge1xuICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCA9IHRydWU7XG4gICAgICBjb25zb2xlLmVycm9yKCcobm9kZSkgd2FybmluZzogcG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2xlYWsgZGV0ZWN0ZWQuICVkIGxpc3RlbmVycyBhZGRlZC4gJyArXG4gICAgICAgICAgICAgICAgICAgICdVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byBpbmNyZWFzZSBsaW1pdC4nLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoKTtcbiAgICAgIGlmICh0eXBlb2YgY29uc29sZS50cmFjZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBub3Qgc3VwcG9ydGVkIGluIElFIDEwXG4gICAgICAgIGNvbnNvbGUudHJhY2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgdmFyIGZpcmVkID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gZygpIHtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGcpO1xuXG4gICAgaWYgKCFmaXJlZCkge1xuICAgICAgZmlyZWQgPSB0cnVlO1xuICAgICAgbGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cblxuICBnLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gIHRoaXMub24odHlwZSwgZyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBlbWl0cyBhICdyZW1vdmVMaXN0ZW5lcicgZXZlbnQgaWZmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZFxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBsaXN0LCBwb3NpdGlvbiwgbGVuZ3RoLCBpO1xuXG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIGxpc3QgPSB0aGlzLl9ldmVudHNbdHlwZV07XG4gIGxlbmd0aCA9IGxpc3QubGVuZ3RoO1xuICBwb3NpdGlvbiA9IC0xO1xuXG4gIGlmIChsaXN0ID09PSBsaXN0ZW5lciB8fFxuICAgICAgKGlzRnVuY3Rpb24obGlzdC5saXN0ZW5lcikgJiYgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7XG4gICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICBpZiAodGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyKTtcblxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGxpc3QpKSB7XG4gICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gPiAwOykge1xuICAgICAgaWYgKGxpc3RbaV0gPT09IGxpc3RlbmVyIHx8XG4gICAgICAgICAgKGxpc3RbaV0ubGlzdGVuZXIgJiYgbGlzdFtpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7XG4gICAgICAgIHBvc2l0aW9uID0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBvc2l0aW9uIDwgMClcbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKSB7XG4gICAgICBsaXN0Lmxlbmd0aCA9IDA7XG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaXN0LnNwbGljZShwb3NpdGlvbiwgMSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lcik7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIga2V5LCBsaXN0ZW5lcnM7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgLy8gbm90IGxpc3RlbmluZyBmb3IgcmVtb3ZlTGlzdGVuZXIsIG5vIG5lZWQgdG8gZW1pdFxuICBpZiAoIXRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcikge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKVxuICAgICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgZWxzZSBpZiAodGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIGVtaXQgcmVtb3ZlTGlzdGVuZXIgZm9yIGFsbCBsaXN0ZW5lcnMgb24gYWxsIGV2ZW50c1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIGZvciAoa2V5IGluIHRoaXMuX2V2ZW50cykge1xuICAgICAgaWYgKGtleSA9PT0gJ3JlbW92ZUxpc3RlbmVyJykgY29udGludWU7XG4gICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhrZXkpO1xuICAgIH1cbiAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygncmVtb3ZlTGlzdGVuZXInKTtcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICBpZiAoaXNGdW5jdGlvbihsaXN0ZW5lcnMpKSB7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnMpO1xuICB9IGVsc2UgaWYgKGxpc3RlbmVycykge1xuICAgIC8vIExJRk8gb3JkZXJcbiAgICB3aGlsZSAobGlzdGVuZXJzLmxlbmd0aClcbiAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2xpc3RlbmVycy5sZW5ndGggLSAxXSk7XG4gIH1cbiAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIgcmV0O1xuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIHJldCA9IFtdO1xuICBlbHNlIGlmIChpc0Z1bmN0aW9uKHRoaXMuX2V2ZW50c1t0eXBlXSkpXG4gICAgcmV0ID0gW3RoaXMuX2V2ZW50c1t0eXBlXV07XG4gIGVsc2VcbiAgICByZXQgPSB0aGlzLl9ldmVudHNbdHlwZV0uc2xpY2UoKTtcbiAgcmV0dXJuIHJldDtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgaWYgKHRoaXMuX2V2ZW50cykge1xuICAgIHZhciBldmxpc3RlbmVyID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gICAgaWYgKGlzRnVuY3Rpb24oZXZsaXN0ZW5lcikpXG4gICAgICByZXR1cm4gMTtcbiAgICBlbHNlIGlmIChldmxpc3RlbmVyKVxuICAgICAgcmV0dXJuIGV2bGlzdGVuZXIubGVuZ3RoO1xuICB9XG4gIHJldHVybiAwO1xufTtcblxuRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XG4gIHJldHVybiBlbWl0dGVyLmxpc3RlbmVyQ291bnQodHlwZSk7XG59O1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG4iLCJleHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbVxuICB2YXIgZUxlbiA9IChuQnl0ZXMgKiA4KSAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgbkJpdHMgPSAtN1xuICB2YXIgaSA9IGlzTEUgPyAobkJ5dGVzIC0gMSkgOiAwXG4gIHZhciBkID0gaXNMRSA/IC0xIDogMVxuICB2YXIgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXVxuXG4gIGkgKz0gZFxuXG4gIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIHMgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IGVMZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IChlICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIGUgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IG1MZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IChtICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhc1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSlcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pXG4gICAgZSA9IGUgLSBlQmlhc1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXG59XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGNcbiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKVxuICB2YXIgaSA9IGlzTEUgPyAwIDogKG5CeXRlcyAtIDEpXG4gIHZhciBkID0gaXNMRSA/IDEgOiAtMVxuICB2YXIgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMFxuXG4gIHZhbHVlID0gTWF0aC5hYnModmFsdWUpXG5cbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDBcbiAgICBlID0gZU1heFxuICB9IGVsc2Uge1xuICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKVxuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLVxuICAgICAgYyAqPSAyXG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgdmFsdWUgKz0gcnQgLyBjXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKVxuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrK1xuICAgICAgYyAvPSAyXG4gICAgfVxuXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMFxuICAgICAgZSA9IGVNYXhcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtID0gKCh2YWx1ZSAqIGMpIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IGUgKyBlQmlhc1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSAwXG4gICAgfVxuICB9XG5cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCkge31cblxuICBlID0gKGUgPDwgbUxlbikgfCBtXG4gIGVMZW4gKz0gbUxlblxuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpIHt9XG5cbiAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4XG59XG4iLCIndXNlIHN0cmljdCc7XG52YXIgTXV0YXRpb24gPSBnbG9iYWwuTXV0YXRpb25PYnNlcnZlciB8fCBnbG9iYWwuV2ViS2l0TXV0YXRpb25PYnNlcnZlcjtcblxudmFyIHNjaGVkdWxlRHJhaW47XG5cbntcbiAgaWYgKE11dGF0aW9uKSB7XG4gICAgdmFyIGNhbGxlZCA9IDA7XG4gICAgdmFyIG9ic2VydmVyID0gbmV3IE11dGF0aW9uKG5leHRUaWNrKTtcbiAgICB2YXIgZWxlbWVudCA9IGdsb2JhbC5kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyk7XG4gICAgb2JzZXJ2ZXIub2JzZXJ2ZShlbGVtZW50LCB7XG4gICAgICBjaGFyYWN0ZXJEYXRhOiB0cnVlXG4gICAgfSk7XG4gICAgc2NoZWR1bGVEcmFpbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGVsZW1lbnQuZGF0YSA9IChjYWxsZWQgPSArK2NhbGxlZCAlIDIpO1xuICAgIH07XG4gIH0gZWxzZSBpZiAoIWdsb2JhbC5zZXRJbW1lZGlhdGUgJiYgdHlwZW9mIGdsb2JhbC5NZXNzYWdlQ2hhbm5lbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB2YXIgY2hhbm5lbCA9IG5ldyBnbG9iYWwuTWVzc2FnZUNoYW5uZWwoKTtcbiAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IG5leHRUaWNrO1xuICAgIHNjaGVkdWxlRHJhaW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICBjaGFubmVsLnBvcnQyLnBvc3RNZXNzYWdlKDApO1xuICAgIH07XG4gIH0gZWxzZSBpZiAoJ2RvY3VtZW50JyBpbiBnbG9iYWwgJiYgJ29ucmVhZHlzdGF0ZWNoYW5nZScgaW4gZ2xvYmFsLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpKSB7XG4gICAgc2NoZWR1bGVEcmFpbiA9IGZ1bmN0aW9uICgpIHtcblxuICAgICAgLy8gQ3JlYXRlIGEgPHNjcmlwdD4gZWxlbWVudDsgaXRzIHJlYWR5c3RhdGVjaGFuZ2UgZXZlbnQgd2lsbCBiZSBmaXJlZCBhc3luY2hyb25vdXNseSBvbmNlIGl0IGlzIGluc2VydGVkXG4gICAgICAvLyBpbnRvIHRoZSBkb2N1bWVudC4gRG8gc28sIHRodXMgcXVldWluZyB1cCB0aGUgdGFzay4gUmVtZW1iZXIgdG8gY2xlYW4gdXAgb25jZSBpdCdzIGJlZW4gY2FsbGVkLlxuICAgICAgdmFyIHNjcmlwdEVsID0gZ2xvYmFsLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICAgICAgc2NyaXB0RWwub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBuZXh0VGljaygpO1xuXG4gICAgICAgIHNjcmlwdEVsLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG4gICAgICAgIHNjcmlwdEVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc2NyaXB0RWwpO1xuICAgICAgICBzY3JpcHRFbCA9IG51bGw7XG4gICAgICB9O1xuICAgICAgZ2xvYmFsLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hcHBlbmRDaGlsZChzY3JpcHRFbCk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBzY2hlZHVsZURyYWluID0gZnVuY3Rpb24gKCkge1xuICAgICAgc2V0VGltZW91dChuZXh0VGljaywgMCk7XG4gICAgfTtcbiAgfVxufVxuXG52YXIgZHJhaW5pbmc7XG52YXIgcXVldWUgPSBbXTtcbi8vbmFtZWQgbmV4dFRpY2sgZm9yIGxlc3MgY29uZnVzaW5nIHN0YWNrIHRyYWNlc1xuZnVuY3Rpb24gbmV4dFRpY2soKSB7XG4gIGRyYWluaW5nID0gdHJ1ZTtcbiAgdmFyIGksIG9sZFF1ZXVlO1xuICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICB3aGlsZSAobGVuKSB7XG4gICAgb2xkUXVldWUgPSBxdWV1ZTtcbiAgICBxdWV1ZSA9IFtdO1xuICAgIGkgPSAtMTtcbiAgICB3aGlsZSAoKytpIDwgbGVuKSB7XG4gICAgICBvbGRRdWV1ZVtpXSgpO1xuICAgIH1cbiAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gIH1cbiAgZHJhaW5pbmcgPSBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbW1lZGlhdGU7XG5mdW5jdGlvbiBpbW1lZGlhdGUodGFzaykge1xuICBpZiAocXVldWUucHVzaCh0YXNrKSA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICBzY2hlZHVsZURyYWluKCk7XG4gIH1cbn1cbiIsImlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAvLyBpbXBsZW1lbnRhdGlvbiBmcm9tIHN0YW5kYXJkIG5vZGUuanMgJ3V0aWwnIG1vZHVsZVxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ3Rvci5wcm90b3R5cGUsIHtcbiAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgIHZhbHVlOiBjdG9yLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICB9O1xufSBlbHNlIHtcbiAgLy8gb2xkIHNjaG9vbCBzaGltIGZvciBvbGQgYnJvd3NlcnNcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9XG4gICAgVGVtcEN0b3IucHJvdG90eXBlID0gc3VwZXJDdG9yLnByb3RvdHlwZVxuICAgIGN0b3IucHJvdG90eXBlID0gbmV3IFRlbXBDdG9yKClcbiAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3JcbiAgfVxufVxuIiwidmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGFycikgPT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgc3VwcG9ydCA9IHJlcXVpcmUoJy4vc3VwcG9ydCcpO1xuLy8gcHJpdmF0ZSBwcm9wZXJ0eVxudmFyIF9rZXlTdHIgPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89XCI7XG5cblxuLy8gcHVibGljIG1ldGhvZCBmb3IgZW5jb2RpbmdcbmV4cG9ydHMuZW5jb2RlID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgICB2YXIgb3V0cHV0ID0gW107XG4gICAgdmFyIGNocjEsIGNocjIsIGNocjMsIGVuYzEsIGVuYzIsIGVuYzMsIGVuYzQ7XG4gICAgdmFyIGkgPSAwLCBsZW4gPSBpbnB1dC5sZW5ndGgsIHJlbWFpbmluZ0J5dGVzID0gbGVuO1xuXG4gICAgdmFyIGlzQXJyYXkgPSB1dGlscy5nZXRUeXBlT2YoaW5wdXQpICE9PSBcInN0cmluZ1wiO1xuICAgIHdoaWxlIChpIDwgaW5wdXQubGVuZ3RoKSB7XG4gICAgICAgIHJlbWFpbmluZ0J5dGVzID0gbGVuIC0gaTtcblxuICAgICAgICBpZiAoIWlzQXJyYXkpIHtcbiAgICAgICAgICAgIGNocjEgPSBpbnB1dC5jaGFyQ29kZUF0KGkrKyk7XG4gICAgICAgICAgICBjaHIyID0gaSA8IGxlbiA/IGlucHV0LmNoYXJDb2RlQXQoaSsrKSA6IDA7XG4gICAgICAgICAgICBjaHIzID0gaSA8IGxlbiA/IGlucHV0LmNoYXJDb2RlQXQoaSsrKSA6IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjaHIxID0gaW5wdXRbaSsrXTtcbiAgICAgICAgICAgIGNocjIgPSBpIDwgbGVuID8gaW5wdXRbaSsrXSA6IDA7XG4gICAgICAgICAgICBjaHIzID0gaSA8IGxlbiA/IGlucHV0W2krK10gOiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgZW5jMSA9IGNocjEgPj4gMjtcbiAgICAgICAgZW5jMiA9ICgoY2hyMSAmIDMpIDw8IDQpIHwgKGNocjIgPj4gNCk7XG4gICAgICAgIGVuYzMgPSByZW1haW5pbmdCeXRlcyA+IDEgPyAoKChjaHIyICYgMTUpIDw8IDIpIHwgKGNocjMgPj4gNikpIDogNjQ7XG4gICAgICAgIGVuYzQgPSByZW1haW5pbmdCeXRlcyA+IDIgPyAoY2hyMyAmIDYzKSA6IDY0O1xuXG4gICAgICAgIG91dHB1dC5wdXNoKF9rZXlTdHIuY2hhckF0KGVuYzEpICsgX2tleVN0ci5jaGFyQXQoZW5jMikgKyBfa2V5U3RyLmNoYXJBdChlbmMzKSArIF9rZXlTdHIuY2hhckF0KGVuYzQpKTtcblxuICAgIH1cblxuICAgIHJldHVybiBvdXRwdXQuam9pbihcIlwiKTtcbn07XG5cbi8vIHB1YmxpYyBtZXRob2QgZm9yIGRlY29kaW5nXG5leHBvcnRzLmRlY29kZSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgdmFyIGNocjEsIGNocjIsIGNocjM7XG4gICAgdmFyIGVuYzEsIGVuYzIsIGVuYzMsIGVuYzQ7XG4gICAgdmFyIGkgPSAwLCByZXN1bHRJbmRleCA9IDA7XG5cbiAgICB2YXIgZGF0YVVybFByZWZpeCA9IFwiZGF0YTpcIjtcblxuICAgIGlmIChpbnB1dC5zdWJzdHIoMCwgZGF0YVVybFByZWZpeC5sZW5ndGgpID09PSBkYXRhVXJsUHJlZml4KSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYSBjb21tb24gZXJyb3I6IHBlb3BsZSBnaXZlIGEgZGF0YSB1cmxcbiAgICAgICAgLy8gKGRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUi4uLikgd2l0aCBhIHtiYXNlNjQ6IHRydWV9IGFuZFxuICAgICAgICAvLyB3b25kZXJzIHdoeSB0aGluZ3MgZG9uJ3Qgd29yay5cbiAgICAgICAgLy8gV2UgY2FuIGRldGVjdCB0aGF0IHRoZSBzdHJpbmcgaW5wdXQgbG9va3MgbGlrZSBhIGRhdGEgdXJsIGJ1dCB3ZVxuICAgICAgICAvLyAqY2FuJ3QqIGJlIHN1cmUgaXQgaXMgb25lOiByZW1vdmluZyBldmVyeXRoaW5nIHVwIHRvIHRoZSBjb21tYSB3b3VsZFxuICAgICAgICAvLyBiZSB0b28gZGFuZ2Vyb3VzLlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGJhc2U2NCBpbnB1dCwgaXQgbG9va3MgbGlrZSBhIGRhdGEgdXJsLlwiKTtcbiAgICB9XG5cbiAgICBpbnB1dCA9IGlucHV0LnJlcGxhY2UoL1teQS1aYS16MC05XFwrXFwvXFw9XS9nLCBcIlwiKTtcblxuICAgIHZhciB0b3RhbExlbmd0aCA9IGlucHV0Lmxlbmd0aCAqIDMgLyA0O1xuICAgIGlmKGlucHV0LmNoYXJBdChpbnB1dC5sZW5ndGggLSAxKSA9PT0gX2tleVN0ci5jaGFyQXQoNjQpKSB7XG4gICAgICAgIHRvdGFsTGVuZ3RoLS07XG4gICAgfVxuICAgIGlmKGlucHV0LmNoYXJBdChpbnB1dC5sZW5ndGggLSAyKSA9PT0gX2tleVN0ci5jaGFyQXQoNjQpKSB7XG4gICAgICAgIHRvdGFsTGVuZ3RoLS07XG4gICAgfVxuICAgIGlmICh0b3RhbExlbmd0aCAlIDEgIT09IDApIHtcbiAgICAgICAgLy8gdG90YWxMZW5ndGggaXMgbm90IGFuIGludGVnZXIsIHRoZSBsZW5ndGggZG9lcyBub3QgbWF0Y2ggYSB2YWxpZFxuICAgICAgICAvLyBiYXNlNjQgY29udGVudC4gVGhhdCBjYW4gaGFwcGVuIGlmOlxuICAgICAgICAvLyAtIHRoZSBpbnB1dCBpcyBub3QgYSBiYXNlNjQgY29udGVudFxuICAgICAgICAvLyAtIHRoZSBpbnB1dCBpcyAqYWxtb3N0KiBhIGJhc2U2NCBjb250ZW50LCB3aXRoIGEgZXh0cmEgY2hhcnMgYXQgdGhlXG4gICAgICAgIC8vICAgYmVnaW5uaW5nIG9yIGF0IHRoZSBlbmRcbiAgICAgICAgLy8gLSB0aGUgaW5wdXQgdXNlcyBhIGJhc2U2NCB2YXJpYW50IChiYXNlNjR1cmwgZm9yIGV4YW1wbGUpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYmFzZTY0IGlucHV0LCBiYWQgY29udGVudCBsZW5ndGguXCIpO1xuICAgIH1cbiAgICB2YXIgb3V0cHV0O1xuICAgIGlmIChzdXBwb3J0LnVpbnQ4YXJyYXkpIHtcbiAgICAgICAgb3V0cHV0ID0gbmV3IFVpbnQ4QXJyYXkodG90YWxMZW5ndGh8MCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgb3V0cHV0ID0gbmV3IEFycmF5KHRvdGFsTGVuZ3RofDApO1xuICAgIH1cblxuICAgIHdoaWxlIChpIDwgaW5wdXQubGVuZ3RoKSB7XG5cbiAgICAgICAgZW5jMSA9IF9rZXlTdHIuaW5kZXhPZihpbnB1dC5jaGFyQXQoaSsrKSk7XG4gICAgICAgIGVuYzIgPSBfa2V5U3RyLmluZGV4T2YoaW5wdXQuY2hhckF0KGkrKykpO1xuICAgICAgICBlbmMzID0gX2tleVN0ci5pbmRleE9mKGlucHV0LmNoYXJBdChpKyspKTtcbiAgICAgICAgZW5jNCA9IF9rZXlTdHIuaW5kZXhPZihpbnB1dC5jaGFyQXQoaSsrKSk7XG5cbiAgICAgICAgY2hyMSA9IChlbmMxIDw8IDIpIHwgKGVuYzIgPj4gNCk7XG4gICAgICAgIGNocjIgPSAoKGVuYzIgJiAxNSkgPDwgNCkgfCAoZW5jMyA+PiAyKTtcbiAgICAgICAgY2hyMyA9ICgoZW5jMyAmIDMpIDw8IDYpIHwgZW5jNDtcblxuICAgICAgICBvdXRwdXRbcmVzdWx0SW5kZXgrK10gPSBjaHIxO1xuXG4gICAgICAgIGlmIChlbmMzICE9PSA2NCkge1xuICAgICAgICAgICAgb3V0cHV0W3Jlc3VsdEluZGV4KytdID0gY2hyMjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5jNCAhPT0gNjQpIHtcbiAgICAgICAgICAgIG91dHB1dFtyZXN1bHRJbmRleCsrXSA9IGNocjM7XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIHJldHVybiBvdXRwdXQ7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZXh0ZXJuYWwgPSByZXF1aXJlKFwiLi9leHRlcm5hbFwiKTtcbnZhciBEYXRhV29ya2VyID0gcmVxdWlyZSgnLi9zdHJlYW0vRGF0YVdvcmtlcicpO1xudmFyIERhdGFMZW5ndGhQcm9iZSA9IHJlcXVpcmUoJy4vc3RyZWFtL0RhdGFMZW5ndGhQcm9iZScpO1xudmFyIENyYzMyUHJvYmUgPSByZXF1aXJlKCcuL3N0cmVhbS9DcmMzMlByb2JlJyk7XG52YXIgRGF0YUxlbmd0aFByb2JlID0gcmVxdWlyZSgnLi9zdHJlYW0vRGF0YUxlbmd0aFByb2JlJyk7XG5cbi8qKlxuICogUmVwcmVzZW50IGEgY29tcHJlc3NlZCBvYmplY3QsIHdpdGggZXZlcnl0aGluZyBuZWVkZWQgdG8gZGVjb21wcmVzcyBpdC5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtudW1iZXJ9IGNvbXByZXNzZWRTaXplIHRoZSBzaXplIG9mIHRoZSBkYXRhIGNvbXByZXNzZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gdW5jb21wcmVzc2VkU2l6ZSB0aGUgc2l6ZSBvZiB0aGUgZGF0YSBhZnRlciBkZWNvbXByZXNzaW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IGNyYzMyIHRoZSBjcmMzMiBvZiB0aGUgZGVjb21wcmVzc2VkIGZpbGUuXG4gKiBAcGFyYW0ge29iamVjdH0gY29tcHJlc3Npb24gdGhlIHR5cGUgb2YgY29tcHJlc3Npb24sIHNlZSBsaWIvY29tcHJlc3Npb25zLmpzLlxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXlCdWZmZXJ8VWludDhBcnJheXxCdWZmZXJ9IGRhdGEgdGhlIGNvbXByZXNzZWQgZGF0YS5cbiAqL1xuZnVuY3Rpb24gQ29tcHJlc3NlZE9iamVjdChjb21wcmVzc2VkU2l6ZSwgdW5jb21wcmVzc2VkU2l6ZSwgY3JjMzIsIGNvbXByZXNzaW9uLCBkYXRhKSB7XG4gICAgdGhpcy5jb21wcmVzc2VkU2l6ZSA9IGNvbXByZXNzZWRTaXplO1xuICAgIHRoaXMudW5jb21wcmVzc2VkU2l6ZSA9IHVuY29tcHJlc3NlZFNpemU7XG4gICAgdGhpcy5jcmMzMiA9IGNyYzMyO1xuICAgIHRoaXMuY29tcHJlc3Npb24gPSBjb21wcmVzc2lvbjtcbiAgICB0aGlzLmNvbXByZXNzZWRDb250ZW50ID0gZGF0YTtcbn1cblxuQ29tcHJlc3NlZE9iamVjdC5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgd29ya2VyIHRvIGdldCB0aGUgdW5jb21wcmVzc2VkIGNvbnRlbnQuXG4gICAgICogQHJldHVybiB7R2VuZXJpY1dvcmtlcn0gdGhlIHdvcmtlci5cbiAgICAgKi9cbiAgICBnZXRDb250ZW50V29ya2VyIDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgd29ya2VyID0gbmV3IERhdGFXb3JrZXIoZXh0ZXJuYWwuUHJvbWlzZS5yZXNvbHZlKHRoaXMuY29tcHJlc3NlZENvbnRlbnQpKVxuICAgICAgICAucGlwZSh0aGlzLmNvbXByZXNzaW9uLnVuY29tcHJlc3NXb3JrZXIoKSlcbiAgICAgICAgLnBpcGUobmV3IERhdGFMZW5ndGhQcm9iZShcImRhdGFfbGVuZ3RoXCIpKTtcblxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgIHdvcmtlci5vbihcImVuZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZih0aGlzLnN0cmVhbUluZm9bJ2RhdGFfbGVuZ3RoJ10gIT09IHRoYXQudW5jb21wcmVzc2VkU2l6ZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkJ1ZyA6IHVuY29tcHJlc3NlZCBkYXRhIHNpemUgbWlzbWF0Y2hcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gd29ya2VyO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgd29ya2VyIHRvIGdldCB0aGUgY29tcHJlc3NlZCBjb250ZW50LlxuICAgICAqIEByZXR1cm4ge0dlbmVyaWNXb3JrZXJ9IHRoZSB3b3JrZXIuXG4gICAgICovXG4gICAgZ2V0Q29tcHJlc3NlZFdvcmtlciA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRhV29ya2VyKGV4dGVybmFsLlByb21pc2UucmVzb2x2ZSh0aGlzLmNvbXByZXNzZWRDb250ZW50KSlcbiAgICAgICAgLndpdGhTdHJlYW1JbmZvKFwiY29tcHJlc3NlZFNpemVcIiwgdGhpcy5jb21wcmVzc2VkU2l6ZSlcbiAgICAgICAgLndpdGhTdHJlYW1JbmZvKFwidW5jb21wcmVzc2VkU2l6ZVwiLCB0aGlzLnVuY29tcHJlc3NlZFNpemUpXG4gICAgICAgIC53aXRoU3RyZWFtSW5mbyhcImNyYzMyXCIsIHRoaXMuY3JjMzIpXG4gICAgICAgIC53aXRoU3RyZWFtSW5mbyhcImNvbXByZXNzaW9uXCIsIHRoaXMuY29tcHJlc3Npb24pXG4gICAgICAgIDtcbiAgICB9XG59O1xuXG4vKipcbiAqIENoYWluIHRoZSBnaXZlbiB3b3JrZXIgd2l0aCBvdGhlciB3b3JrZXJzIHRvIGNvbXByZXNzIHRoZSBjb250ZW50IHdpdGggdGhlXG4gKiBnaXZlbiBjb21wcmVzaW9uLlxuICogQHBhcmFtIHtHZW5lcmljV29ya2VyfSB1bmNvbXByZXNzZWRXb3JrZXIgdGhlIHdvcmtlciB0byBwaXBlLlxuICogQHBhcmFtIHtPYmplY3R9IGNvbXByZXNzaW9uIHRoZSBjb21wcmVzc2lvbiBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gY29tcHJlc3Npb25PcHRpb25zIHRoZSBvcHRpb25zIHRvIHVzZSB3aGVuIGNvbXByZXNzaW5nLlxuICogQHJldHVybiB7R2VuZXJpY1dvcmtlcn0gdGhlIG5ldyB3b3JrZXIgY29tcHJlc3NpbmcgdGhlIGNvbnRlbnQuXG4gKi9cbkNvbXByZXNzZWRPYmplY3QuY3JlYXRlV29ya2VyRnJvbSA9IGZ1bmN0aW9uICh1bmNvbXByZXNzZWRXb3JrZXIsIGNvbXByZXNzaW9uLCBjb21wcmVzc2lvbk9wdGlvbnMpIHtcbiAgICByZXR1cm4gdW5jb21wcmVzc2VkV29ya2VyXG4gICAgLnBpcGUobmV3IENyYzMyUHJvYmUoKSlcbiAgICAucGlwZShuZXcgRGF0YUxlbmd0aFByb2JlKFwidW5jb21wcmVzc2VkU2l6ZVwiKSlcbiAgICAucGlwZShjb21wcmVzc2lvbi5jb21wcmVzc1dvcmtlcihjb21wcmVzc2lvbk9wdGlvbnMpKVxuICAgIC5waXBlKG5ldyBEYXRhTGVuZ3RoUHJvYmUoXCJjb21wcmVzc2VkU2l6ZVwiKSlcbiAgICAud2l0aFN0cmVhbUluZm8oXCJjb21wcmVzc2lvblwiLCBjb21wcmVzc2lvbik7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbXByZXNzZWRPYmplY3Q7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBHZW5lcmljV29ya2VyID0gcmVxdWlyZShcIi4vc3RyZWFtL0dlbmVyaWNXb3JrZXJcIik7XG5cbmV4cG9ydHMuU1RPUkUgPSB7XG4gICAgbWFnaWM6IFwiXFx4MDBcXHgwMFwiLFxuICAgIGNvbXByZXNzV29ya2VyIDogZnVuY3Rpb24gKGNvbXByZXNzaW9uT3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IEdlbmVyaWNXb3JrZXIoXCJTVE9SRSBjb21wcmVzc2lvblwiKTtcbiAgICB9LFxuICAgIHVuY29tcHJlc3NXb3JrZXIgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgR2VuZXJpY1dvcmtlcihcIlNUT1JFIGRlY29tcHJlc3Npb25cIik7XG4gICAgfVxufTtcbmV4cG9ydHMuREVGTEFURSA9IHJlcXVpcmUoJy4vZmxhdGUnKTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuXG4vKipcbiAqIFRoZSBmb2xsb3dpbmcgZnVuY3Rpb25zIGNvbWUgZnJvbSBwYWtvLCBmcm9tIHBha28vbGliL3psaWIvY3JjMzIuanNcbiAqIHJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSwgc2VlIHBha28gaHR0cHM6Ly9naXRodWIuY29tL25vZGVjYS9wYWtvL1xuICovXG5cbi8vIFVzZSBvcmRpbmFyeSBhcnJheSwgc2luY2UgdW50eXBlZCBtYWtlcyBubyBib29zdCBoZXJlXG5mdW5jdGlvbiBtYWtlVGFibGUoKSB7XG4gICAgdmFyIGMsIHRhYmxlID0gW107XG5cbiAgICBmb3IodmFyIG4gPTA7IG4gPCAyNTY7IG4rKyl7XG4gICAgICAgIGMgPSBuO1xuICAgICAgICBmb3IodmFyIGsgPTA7IGsgPCA4OyBrKyspe1xuICAgICAgICAgICAgYyA9ICgoYyYxKSA/ICgweEVEQjg4MzIwIF4gKGMgPj4+IDEpKSA6IChjID4+PiAxKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGFibGVbbl0gPSBjO1xuICAgIH1cblxuICAgIHJldHVybiB0YWJsZTtcbn1cblxuLy8gQ3JlYXRlIHRhYmxlIG9uIGxvYWQuIEp1c3QgMjU1IHNpZ25lZCBsb25ncy4gTm90IGEgcHJvYmxlbS5cbnZhciBjcmNUYWJsZSA9IG1ha2VUYWJsZSgpO1xuXG5cbmZ1bmN0aW9uIGNyYzMyKGNyYywgYnVmLCBsZW4sIHBvcykge1xuICAgIHZhciB0ID0gY3JjVGFibGUsIGVuZCA9IHBvcyArIGxlbjtcblxuICAgIGNyYyA9IGNyYyBeICgtMSk7XG5cbiAgICBmb3IgKHZhciBpID0gcG9zOyBpIDwgZW5kOyBpKysgKSB7XG4gICAgICAgIGNyYyA9IChjcmMgPj4+IDgpIF4gdFsoY3JjIF4gYnVmW2ldKSAmIDB4RkZdO1xuICAgIH1cblxuICAgIHJldHVybiAoY3JjIF4gKC0xKSk7IC8vID4+PiAwO1xufVxuXG4vLyBUaGF0J3MgYWxsIGZvciB0aGUgcGFrbyBmdW5jdGlvbnMuXG5cbi8qKlxuICogQ29tcHV0ZSB0aGUgY3JjMzIgb2YgYSBzdHJpbmcuXG4gKiBUaGlzIGlzIGFsbW9zdCB0aGUgc2FtZSBhcyB0aGUgZnVuY3Rpb24gY3JjMzIsIGJ1dCBmb3Igc3RyaW5ncy4gVXNpbmcgdGhlXG4gKiBzYW1lIGZ1bmN0aW9uIGZvciB0aGUgdHdvIHVzZSBjYXNlcyBsZWFkcyB0byBob3JyaWJsZSBwZXJmb3JtYW5jZXMuXG4gKiBAcGFyYW0ge051bWJlcn0gY3JjIHRoZSBzdGFydGluZyB2YWx1ZSBvZiB0aGUgY3JjLlxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciB0aGUgc3RyaW5nIHRvIHVzZS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBsZW4gdGhlIGxlbmd0aCBvZiB0aGUgc3RyaW5nLlxuICogQHBhcmFtIHtOdW1iZXJ9IHBvcyB0aGUgc3RhcnRpbmcgcG9zaXRpb24gZm9yIHRoZSBjcmMzMiBjb21wdXRhdGlvbi5cbiAqIEByZXR1cm4ge051bWJlcn0gdGhlIGNvbXB1dGVkIGNyYzMyLlxuICovXG5mdW5jdGlvbiBjcmMzMnN0cihjcmMsIHN0ciwgbGVuLCBwb3MpIHtcbiAgICB2YXIgdCA9IGNyY1RhYmxlLCBlbmQgPSBwb3MgKyBsZW47XG5cbiAgICBjcmMgPSBjcmMgXiAoLTEpO1xuXG4gICAgZm9yICh2YXIgaSA9IHBvczsgaSA8IGVuZDsgaSsrICkge1xuICAgICAgICBjcmMgPSAoY3JjID4+PiA4KSBeIHRbKGNyYyBeIHN0ci5jaGFyQ29kZUF0KGkpKSAmIDB4RkZdO1xuICAgIH1cblxuICAgIHJldHVybiAoY3JjIF4gKC0xKSk7IC8vID4+PiAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNyYzMyd3JhcHBlcihpbnB1dCwgY3JjKSB7XG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhaW5wdXQubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIHZhciBpc0FycmF5ID0gdXRpbHMuZ2V0VHlwZU9mKGlucHV0KSAhPT0gXCJzdHJpbmdcIjtcblxuICAgIGlmKGlzQXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIGNyYzMyKGNyY3wwLCBpbnB1dCwgaW5wdXQubGVuZ3RoLCAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gY3JjMzJzdHIoY3JjfDAsIGlucHV0LCBpbnB1dC5sZW5ndGgsIDApO1xuICAgIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5leHBvcnRzLmJhc2U2NCA9IGZhbHNlO1xuZXhwb3J0cy5iaW5hcnkgPSBmYWxzZTtcbmV4cG9ydHMuZGlyID0gZmFsc2U7XG5leHBvcnRzLmNyZWF0ZUZvbGRlcnMgPSB0cnVlO1xuZXhwb3J0cy5kYXRlID0gbnVsbDtcbmV4cG9ydHMuY29tcHJlc3Npb24gPSBudWxsO1xuZXhwb3J0cy5jb21wcmVzc2lvbk9wdGlvbnMgPSBudWxsO1xuZXhwb3J0cy5jb21tZW50ID0gbnVsbDtcbmV4cG9ydHMudW5peFBlcm1pc3Npb25zID0gbnVsbDtcbmV4cG9ydHMuZG9zUGVybWlzc2lvbnMgPSBudWxsO1xuIiwiLyogZ2xvYmFsIFByb21pc2UgKi9cbid1c2Ugc3RyaWN0JztcblxuLy8gbG9hZCB0aGUgZ2xvYmFsIG9iamVjdCBmaXJzdDpcbi8vIC0gaXQgc2hvdWxkIGJlIGJldHRlciBpbnRlZ3JhdGVkIGluIHRoZSBzeXN0ZW0gKHVuaGFuZGxlZFJlamVjdGlvbiBpbiBub2RlKVxuLy8gLSB0aGUgZW52aXJvbm1lbnQgbWF5IGhhdmUgYSBjdXN0b20gUHJvbWlzZSBpbXBsZW1lbnRhdGlvbiAoc2VlIHpvbmUuanMpXG52YXIgRVM2UHJvbWlzZSA9IG51bGw7XG5pZiAodHlwZW9mIFByb21pc2UgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBFUzZQcm9taXNlID0gUHJvbWlzZTtcbn0gZWxzZSB7XG4gICAgRVM2UHJvbWlzZSA9IHJlcXVpcmUoXCJsaWVcIik7XG59XG5cbi8qKlxuICogTGV0IHRoZSB1c2VyIHVzZS9jaGFuZ2Ugc29tZSBpbXBsZW1lbnRhdGlvbnMuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIFByb21pc2U6IEVTNlByb21pc2Vcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgVVNFX1RZUEVEQVJSQVkgPSAodHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnKSAmJiAodHlwZW9mIFVpbnQxNkFycmF5ICE9PSAndW5kZWZpbmVkJykgJiYgKHR5cGVvZiBVaW50MzJBcnJheSAhPT0gJ3VuZGVmaW5lZCcpO1xuXG52YXIgcGFrbyA9IHJlcXVpcmUoXCJwYWtvXCIpO1xudmFyIHV0aWxzID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG52YXIgR2VuZXJpY1dvcmtlciA9IHJlcXVpcmUoXCIuL3N0cmVhbS9HZW5lcmljV29ya2VyXCIpO1xuXG52YXIgQVJSQVlfVFlQRSA9IFVTRV9UWVBFREFSUkFZID8gXCJ1aW50OGFycmF5XCIgOiBcImFycmF5XCI7XG5cbmV4cG9ydHMubWFnaWMgPSBcIlxceDA4XFx4MDBcIjtcblxuLyoqXG4gKiBDcmVhdGUgYSB3b3JrZXIgdGhhdCB1c2VzIHBha28gdG8gaW5mbGF0ZS9kZWZsYXRlLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1N0cmluZ30gYWN0aW9uIHRoZSBuYW1lIG9mIHRoZSBwYWtvIGZ1bmN0aW9uIHRvIGNhbGwgOiBlaXRoZXIgXCJEZWZsYXRlXCIgb3IgXCJJbmZsYXRlXCIuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyB0aGUgb3B0aW9ucyB0byB1c2Ugd2hlbiAoZGUpY29tcHJlc3NpbmcuXG4gKi9cbmZ1bmN0aW9uIEZsYXRlV29ya2VyKGFjdGlvbiwgb3B0aW9ucykge1xuICAgIEdlbmVyaWNXb3JrZXIuY2FsbCh0aGlzLCBcIkZsYXRlV29ya2VyL1wiICsgYWN0aW9uKTtcblxuICAgIHRoaXMuX3Bha28gPSBudWxsO1xuICAgIHRoaXMuX3Bha29BY3Rpb24gPSBhY3Rpb247XG4gICAgdGhpcy5fcGFrb09wdGlvbnMgPSBvcHRpb25zO1xuICAgIC8vIHRoZSBgbWV0YWAgb2JqZWN0IGZyb20gdGhlIGxhc3QgY2h1bmsgcmVjZWl2ZWRcbiAgICAvLyB0aGlzIGFsbG93IHRoaXMgd29ya2VyIHRvIHBhc3MgYXJvdW5kIG1ldGFkYXRhXG4gICAgdGhpcy5tZXRhID0ge307XG59XG5cbnV0aWxzLmluaGVyaXRzKEZsYXRlV29ya2VyLCBHZW5lcmljV29ya2VyKTtcblxuLyoqXG4gKiBAc2VlIEdlbmVyaWNXb3JrZXIucHJvY2Vzc0NodW5rXG4gKi9cbkZsYXRlV29ya2VyLnByb3RvdHlwZS5wcm9jZXNzQ2h1bmsgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICB0aGlzLm1ldGEgPSBjaHVuay5tZXRhO1xuICAgIGlmICh0aGlzLl9wYWtvID09PSBudWxsKSB7XG4gICAgICAgIHRoaXMuX2NyZWF0ZVBha28oKTtcbiAgICB9XG4gICAgdGhpcy5fcGFrby5wdXNoKHV0aWxzLnRyYW5zZm9ybVRvKEFSUkFZX1RZUEUsIGNodW5rLmRhdGEpLCBmYWxzZSk7XG59O1xuXG4vKipcbiAqIEBzZWUgR2VuZXJpY1dvcmtlci5mbHVzaFxuICovXG5GbGF0ZVdvcmtlci5wcm90b3R5cGUuZmx1c2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgR2VuZXJpY1dvcmtlci5wcm90b3R5cGUuZmx1c2guY2FsbCh0aGlzKTtcbiAgICBpZiAodGhpcy5fcGFrbyA9PT0gbnVsbCkge1xuICAgICAgICB0aGlzLl9jcmVhdGVQYWtvKCk7XG4gICAgfVxuICAgIHRoaXMuX3Bha28ucHVzaChbXSwgdHJ1ZSk7XG59O1xuLyoqXG4gKiBAc2VlIEdlbmVyaWNXb3JrZXIuY2xlYW5VcFxuICovXG5GbGF0ZVdvcmtlci5wcm90b3R5cGUuY2xlYW5VcCA9IGZ1bmN0aW9uICgpIHtcbiAgICBHZW5lcmljV29ya2VyLnByb3RvdHlwZS5jbGVhblVwLmNhbGwodGhpcyk7XG4gICAgdGhpcy5fcGFrbyA9IG51bGw7XG59O1xuXG4vKipcbiAqIENyZWF0ZSB0aGUgX3Bha28gb2JqZWN0LlxuICogVE9ETzogbGF6eS1sb2FkaW5nIHRoaXMgb2JqZWN0IGlzbid0IHRoZSBiZXN0IHNvbHV0aW9uIGJ1dCBpdCdzIHRoZVxuICogcXVpY2tlc3QuIFRoZSBiZXN0IHNvbHV0aW9uIGlzIHRvIGxhenktbG9hZCB0aGUgd29ya2VyIGxpc3QuIFNlZSBhbHNvIHRoZVxuICogaXNzdWUgIzQ0Ni5cbiAqL1xuRmxhdGVXb3JrZXIucHJvdG90eXBlLl9jcmVhdGVQYWtvID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX3Bha28gPSBuZXcgcGFrb1t0aGlzLl9wYWtvQWN0aW9uXSh7XG4gICAgICAgIHJhdzogdHJ1ZSxcbiAgICAgICAgbGV2ZWw6IHRoaXMuX3Bha29PcHRpb25zLmxldmVsIHx8IC0xIC8vIGRlZmF1bHQgY29tcHJlc3Npb25cbiAgICB9KTtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5fcGFrby5vbkRhdGEgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHNlbGYucHVzaCh7XG4gICAgICAgICAgICBkYXRhIDogZGF0YSxcbiAgICAgICAgICAgIG1ldGEgOiBzZWxmLm1ldGFcbiAgICAgICAgfSk7XG4gICAgfTtcbn07XG5cbmV4cG9ydHMuY29tcHJlc3NXb3JrZXIgPSBmdW5jdGlvbiAoY29tcHJlc3Npb25PcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBGbGF0ZVdvcmtlcihcIkRlZmxhdGVcIiwgY29tcHJlc3Npb25PcHRpb25zKTtcbn07XG5leHBvcnRzLnVuY29tcHJlc3NXb3JrZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5ldyBGbGF0ZVdvcmtlcihcIkluZmxhdGVcIiwge30pO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcbnZhciBHZW5lcmljV29ya2VyID0gcmVxdWlyZSgnLi4vc3RyZWFtL0dlbmVyaWNXb3JrZXInKTtcbnZhciB1dGY4ID0gcmVxdWlyZSgnLi4vdXRmOCcpO1xudmFyIGNyYzMyID0gcmVxdWlyZSgnLi4vY3JjMzInKTtcbnZhciBzaWduYXR1cmUgPSByZXF1aXJlKCcuLi9zaWduYXR1cmUnKTtcblxuLyoqXG4gKiBUcmFuc2Zvcm0gYW4gaW50ZWdlciBpbnRvIGEgc3RyaW5nIGluIGhleGFkZWNpbWFsLlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBkZWMgdGhlIG51bWJlciB0byBjb252ZXJ0LlxuICogQHBhcmFtIHtudW1iZXJ9IGJ5dGVzIHRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gZ2VuZXJhdGUuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSB0aGUgcmVzdWx0LlxuICovXG52YXIgZGVjVG9IZXggPSBmdW5jdGlvbihkZWMsIGJ5dGVzKSB7XG4gICAgdmFyIGhleCA9IFwiXCIsIGk7XG4gICAgZm9yIChpID0gMDsgaSA8IGJ5dGVzOyBpKyspIHtcbiAgICAgICAgaGV4ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoZGVjICYgMHhmZik7XG4gICAgICAgIGRlYyA9IGRlYyA+Pj4gODtcbiAgICB9XG4gICAgcmV0dXJuIGhleDtcbn07XG5cbi8qKlxuICogR2VuZXJhdGUgdGhlIFVOSVggcGFydCBvZiB0aGUgZXh0ZXJuYWwgZmlsZSBhdHRyaWJ1dGVzLlxuICogQHBhcmFtIHtPYmplY3R9IHVuaXhQZXJtaXNzaW9ucyB0aGUgdW5peCBwZXJtaXNzaW9ucyBvciBudWxsLlxuICogQHBhcmFtIHtCb29sZWFufSBpc0RpciB0cnVlIGlmIHRoZSBlbnRyeSBpcyBhIGRpcmVjdG9yeSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICogQHJldHVybiB7TnVtYmVyfSBhIDMyIGJpdCBpbnRlZ2VyLlxuICpcbiAqIGFkYXB0ZWQgZnJvbSBodHRwOi8vdW5peC5zdGFja2V4Y2hhbmdlLmNvbS9xdWVzdGlvbnMvMTQ3MDUvdGhlLXppcC1mb3JtYXRzLWV4dGVybmFsLWZpbGUtYXR0cmlidXRlIDpcbiAqXG4gKiBUVFRUc3N0cnd4cnd4cnd4MDAwMDAwMDAwMEFEVlNIUlxuICogXl5eXl9fX19fX19fX19fX19fX19fX19fX19fX19fX18gZmlsZSB0eXBlLCBzZWUgemlwaW5mby5jIChVTlhfKilcbiAqICAgICBeXl5fX19fX19fX19fX19fX19fX19fX19fX19fIHNldHVpZCwgc2V0Z2lkLCBzdGlja3lcbiAqICAgICAgICBeXl5eXl5eXl5fX19fX19fX19fX19fX19fIHBlcm1pc3Npb25zXG4gKiAgICAgICAgICAgICAgICAgXl5eXl5eXl5eXl9fX19fXyBub3QgdXNlZCA/XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIF5eXl5eXiBET1MgYXR0cmlidXRlIGJpdHMgOiBBcmNoaXZlLCBEaXJlY3RvcnksIFZvbHVtZSBsYWJlbCwgU3lzdGVtIGZpbGUsIEhpZGRlbiwgUmVhZCBvbmx5XG4gKi9cbnZhciBnZW5lcmF0ZVVuaXhFeHRlcm5hbEZpbGVBdHRyID0gZnVuY3Rpb24gKHVuaXhQZXJtaXNzaW9ucywgaXNEaXIpIHtcblxuICAgIHZhciByZXN1bHQgPSB1bml4UGVybWlzc2lvbnM7XG4gICAgaWYgKCF1bml4UGVybWlzc2lvbnMpIHtcbiAgICAgICAgLy8gSSBjYW4ndCB1c2Ugb2N0YWwgdmFsdWVzIGluIHN0cmljdCBtb2RlLCBoZW5jZSB0aGUgaGV4YS5cbiAgICAgICAgLy8gIDA0MDc3NSA9PiAweDQxZmRcbiAgICAgICAgLy8gMDEwMDY2NCA9PiAweDgxYjRcbiAgICAgICAgcmVzdWx0ID0gaXNEaXIgPyAweDQxZmQgOiAweDgxYjQ7XG4gICAgfVxuICAgIHJldHVybiAocmVzdWx0ICYgMHhGRkZGKSA8PCAxNjtcbn07XG5cbi8qKlxuICogR2VuZXJhdGUgdGhlIERPUyBwYXJ0IG9mIHRoZSBleHRlcm5hbCBmaWxlIGF0dHJpYnV0ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gZG9zUGVybWlzc2lvbnMgdGhlIGRvcyBwZXJtaXNzaW9ucyBvciBudWxsLlxuICogQHBhcmFtIHtCb29sZWFufSBpc0RpciB0cnVlIGlmIHRoZSBlbnRyeSBpcyBhIGRpcmVjdG9yeSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICogQHJldHVybiB7TnVtYmVyfSBhIDMyIGJpdCBpbnRlZ2VyLlxuICpcbiAqIEJpdCAwICAgICBSZWFkLU9ubHlcbiAqIEJpdCAxICAgICBIaWRkZW5cbiAqIEJpdCAyICAgICBTeXN0ZW1cbiAqIEJpdCAzICAgICBWb2x1bWUgTGFiZWxcbiAqIEJpdCA0ICAgICBEaXJlY3RvcnlcbiAqIEJpdCA1ICAgICBBcmNoaXZlXG4gKi9cbnZhciBnZW5lcmF0ZURvc0V4dGVybmFsRmlsZUF0dHIgPSBmdW5jdGlvbiAoZG9zUGVybWlzc2lvbnMsIGlzRGlyKSB7XG5cbiAgICAvLyB0aGUgZGlyIGZsYWcgaXMgYWxyZWFkeSBzZXQgZm9yIGNvbXBhdGliaWxpdHlcbiAgICByZXR1cm4gKGRvc1Blcm1pc3Npb25zIHx8IDApICAmIDB4M0Y7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlIHRoZSB2YXJpb3VzIHBhcnRzIHVzZWQgaW4gdGhlIGNvbnN0cnVjdGlvbiBvZiB0aGUgZmluYWwgemlwIGZpbGUuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RyZWFtSW5mbyB0aGUgaGFzaCB3aXRoIGluZm9ybWF0aW9ucyBhYm91dCB0aGUgY29tcHJlc3NlZCBmaWxlLlxuICogQHBhcmFtIHtCb29sZWFufSBzdHJlYW1lZENvbnRlbnQgaXMgdGhlIGNvbnRlbnQgc3RyZWFtZWQgP1xuICogQHBhcmFtIHtCb29sZWFufSBzdHJlYW1pbmdFbmRlZCBpcyB0aGUgc3RyZWFtIGZpbmlzaGVkID9cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgdGhlIGN1cnJlbnQgb2Zmc2V0IGZyb20gdGhlIHN0YXJ0IG9mIHRoZSB6aXAgZmlsZS5cbiAqIEBwYXJhbSB7U3RyaW5nfSBwbGF0Zm9ybSBsZXQncyBwcmV0ZW5kIHdlIGFyZSB0aGlzIHBsYXRmb3JtIChjaGFuZ2UgcGxhdGZvcm0gZGVwZW5kZW50cyBmaWVsZHMpXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlbmNvZGVGaWxlTmFtZSB0aGUgZnVuY3Rpb24gdG8gZW5jb2RlIHRoZSBmaWxlIG5hbWUgLyBjb21tZW50LlxuICogQHJldHVybiB7T2JqZWN0fSB0aGUgemlwIHBhcnRzLlxuICovXG52YXIgZ2VuZXJhdGVaaXBQYXJ0cyA9IGZ1bmN0aW9uKHN0cmVhbUluZm8sIHN0cmVhbWVkQ29udGVudCwgc3RyZWFtaW5nRW5kZWQsIG9mZnNldCwgcGxhdGZvcm0sIGVuY29kZUZpbGVOYW1lKSB7XG4gICAgdmFyIGZpbGUgPSBzdHJlYW1JbmZvWydmaWxlJ10sXG4gICAgY29tcHJlc3Npb24gPSBzdHJlYW1JbmZvWydjb21wcmVzc2lvbiddLFxuICAgIHVzZUN1c3RvbUVuY29kaW5nID0gZW5jb2RlRmlsZU5hbWUgIT09IHV0ZjgudXRmOGVuY29kZSxcbiAgICBlbmNvZGVkRmlsZU5hbWUgPSB1dGlscy50cmFuc2Zvcm1UbyhcInN0cmluZ1wiLCBlbmNvZGVGaWxlTmFtZShmaWxlLm5hbWUpKSxcbiAgICB1dGZFbmNvZGVkRmlsZU5hbWUgPSB1dGlscy50cmFuc2Zvcm1UbyhcInN0cmluZ1wiLCB1dGY4LnV0ZjhlbmNvZGUoZmlsZS5uYW1lKSksXG4gICAgY29tbWVudCA9IGZpbGUuY29tbWVudCxcbiAgICBlbmNvZGVkQ29tbWVudCA9IHV0aWxzLnRyYW5zZm9ybVRvKFwic3RyaW5nXCIsIGVuY29kZUZpbGVOYW1lKGNvbW1lbnQpKSxcbiAgICB1dGZFbmNvZGVkQ29tbWVudCA9IHV0aWxzLnRyYW5zZm9ybVRvKFwic3RyaW5nXCIsIHV0ZjgudXRmOGVuY29kZShjb21tZW50KSksXG4gICAgdXNlVVRGOEZvckZpbGVOYW1lID0gdXRmRW5jb2RlZEZpbGVOYW1lLmxlbmd0aCAhPT0gZmlsZS5uYW1lLmxlbmd0aCxcbiAgICB1c2VVVEY4Rm9yQ29tbWVudCA9IHV0ZkVuY29kZWRDb21tZW50Lmxlbmd0aCAhPT0gY29tbWVudC5sZW5ndGgsXG4gICAgZG9zVGltZSxcbiAgICBkb3NEYXRlLFxuICAgIGV4dHJhRmllbGRzID0gXCJcIixcbiAgICB1bmljb2RlUGF0aEV4dHJhRmllbGQgPSBcIlwiLFxuICAgIHVuaWNvZGVDb21tZW50RXh0cmFGaWVsZCA9IFwiXCIsXG4gICAgZGlyID0gZmlsZS5kaXIsXG4gICAgZGF0ZSA9IGZpbGUuZGF0ZTtcblxuXG4gICAgdmFyIGRhdGFJbmZvID0ge1xuICAgICAgICBjcmMzMiA6IDAsXG4gICAgICAgIGNvbXByZXNzZWRTaXplIDogMCxcbiAgICAgICAgdW5jb21wcmVzc2VkU2l6ZSA6IDBcbiAgICB9O1xuXG4gICAgLy8gaWYgdGhlIGNvbnRlbnQgaXMgc3RyZWFtZWQsIHRoZSBzaXplcy9jcmMzMiBhcmUgb25seSBhdmFpbGFibGUgQUZURVJcbiAgICAvLyB0aGUgZW5kIG9mIHRoZSBzdHJlYW0uXG4gICAgaWYgKCFzdHJlYW1lZENvbnRlbnQgfHwgc3RyZWFtaW5nRW5kZWQpIHtcbiAgICAgICAgZGF0YUluZm8uY3JjMzIgPSBzdHJlYW1JbmZvWydjcmMzMiddO1xuICAgICAgICBkYXRhSW5mby5jb21wcmVzc2VkU2l6ZSA9IHN0cmVhbUluZm9bJ2NvbXByZXNzZWRTaXplJ107XG4gICAgICAgIGRhdGFJbmZvLnVuY29tcHJlc3NlZFNpemUgPSBzdHJlYW1JbmZvWyd1bmNvbXByZXNzZWRTaXplJ107XG4gICAgfVxuXG4gICAgdmFyIGJpdGZsYWcgPSAwO1xuICAgIGlmIChzdHJlYW1lZENvbnRlbnQpIHtcbiAgICAgICAgLy8gQml0IDM6IHRoZSBzaXplcy9jcmMzMiBhcmUgc2V0IHRvIHplcm8gaW4gdGhlIGxvY2FsIGhlYWRlci5cbiAgICAgICAgLy8gVGhlIGNvcnJlY3QgdmFsdWVzIGFyZSBwdXQgaW4gdGhlIGRhdGEgZGVzY3JpcHRvciBpbW1lZGlhdGVseVxuICAgICAgICAvLyBmb2xsb3dpbmcgdGhlIGNvbXByZXNzZWQgZGF0YS5cbiAgICAgICAgYml0ZmxhZyB8PSAweDAwMDg7XG4gICAgfVxuICAgIGlmICghdXNlQ3VzdG9tRW5jb2RpbmcgJiYgKHVzZVVURjhGb3JGaWxlTmFtZSB8fCB1c2VVVEY4Rm9yQ29tbWVudCkpIHtcbiAgICAgICAgLy8gQml0IDExOiBMYW5ndWFnZSBlbmNvZGluZyBmbGFnIChFRlMpLlxuICAgICAgICBiaXRmbGFnIHw9IDB4MDgwMDtcbiAgICB9XG5cblxuICAgIHZhciBleHRGaWxlQXR0ciA9IDA7XG4gICAgdmFyIHZlcnNpb25NYWRlQnkgPSAwO1xuICAgIGlmIChkaXIpIHtcbiAgICAgICAgLy8gZG9zIG9yIHVuaXgsIHdlIHNldCB0aGUgZG9zIGRpciBmbGFnXG4gICAgICAgIGV4dEZpbGVBdHRyIHw9IDB4MDAwMTA7XG4gICAgfVxuICAgIGlmKHBsYXRmb3JtID09PSBcIlVOSVhcIikge1xuICAgICAgICB2ZXJzaW9uTWFkZUJ5ID0gMHgwMzFFOyAvLyBVTklYLCB2ZXJzaW9uIDMuMFxuICAgICAgICBleHRGaWxlQXR0ciB8PSBnZW5lcmF0ZVVuaXhFeHRlcm5hbEZpbGVBdHRyKGZpbGUudW5peFBlcm1pc3Npb25zLCBkaXIpO1xuICAgIH0gZWxzZSB7IC8vIERPUyBvciBvdGhlciwgZmFsbGJhY2sgdG8gRE9TXG4gICAgICAgIHZlcnNpb25NYWRlQnkgPSAweDAwMTQ7IC8vIERPUywgdmVyc2lvbiAyLjBcbiAgICAgICAgZXh0RmlsZUF0dHIgfD0gZ2VuZXJhdGVEb3NFeHRlcm5hbEZpbGVBdHRyKGZpbGUuZG9zUGVybWlzc2lvbnMsIGRpcik7XG4gICAgfVxuXG4gICAgLy8gZGF0ZVxuICAgIC8vIEBzZWUgaHR0cDovL3d3dy5kZWxvcmllLmNvbS9kamdwcC9kb2MvcmJpbnRlci9pdC81Mi8xMy5odG1sXG4gICAgLy8gQHNlZSBodHRwOi8vd3d3LmRlbG9yaWUuY29tL2RqZ3BwL2RvYy9yYmludGVyL2l0LzY1LzE2Lmh0bWxcbiAgICAvLyBAc2VlIGh0dHA6Ly93d3cuZGVsb3JpZS5jb20vZGpncHAvZG9jL3JiaW50ZXIvaXQvNjYvMTYuaHRtbFxuXG4gICAgZG9zVGltZSA9IGRhdGUuZ2V0VVRDSG91cnMoKTtcbiAgICBkb3NUaW1lID0gZG9zVGltZSA8PCA2O1xuICAgIGRvc1RpbWUgPSBkb3NUaW1lIHwgZGF0ZS5nZXRVVENNaW51dGVzKCk7XG4gICAgZG9zVGltZSA9IGRvc1RpbWUgPDwgNTtcbiAgICBkb3NUaW1lID0gZG9zVGltZSB8IGRhdGUuZ2V0VVRDU2Vjb25kcygpIC8gMjtcblxuICAgIGRvc0RhdGUgPSBkYXRlLmdldFVUQ0Z1bGxZZWFyKCkgLSAxOTgwO1xuICAgIGRvc0RhdGUgPSBkb3NEYXRlIDw8IDQ7XG4gICAgZG9zRGF0ZSA9IGRvc0RhdGUgfCAoZGF0ZS5nZXRVVENNb250aCgpICsgMSk7XG4gICAgZG9zRGF0ZSA9IGRvc0RhdGUgPDwgNTtcbiAgICBkb3NEYXRlID0gZG9zRGF0ZSB8IGRhdGUuZ2V0VVRDRGF0ZSgpO1xuXG4gICAgaWYgKHVzZVVURjhGb3JGaWxlTmFtZSkge1xuICAgICAgICAvLyBzZXQgdGhlIHVuaWNvZGUgcGF0aCBleHRyYSBmaWVsZC4gdW56aXAgbmVlZHMgYXQgbGVhc3Qgb25lIGV4dHJhXG4gICAgICAgIC8vIGZpZWxkIHRvIGNvcnJlY3RseSBoYW5kbGUgdW5pY29kZSBwYXRoLCBzbyB1c2luZyB0aGUgcGF0aCBpcyBhcyBnb29kXG4gICAgICAgIC8vIGFzIGFueSBvdGhlciBpbmZvcm1hdGlvbi4gVGhpcyBjb3VsZCBpbXByb3ZlIHRoZSBzaXR1YXRpb24gd2l0aFxuICAgICAgICAvLyBvdGhlciBhcmNoaXZlIG1hbmFnZXJzIHRvby5cbiAgICAgICAgLy8gVGhpcyBmaWVsZCBpcyB1c3VhbGx5IHVzZWQgd2l0aG91dCB0aGUgdXRmOCBmbGFnLCB3aXRoIGEgbm9uXG4gICAgICAgIC8vIHVuaWNvZGUgcGF0aCBpbiB0aGUgaGVhZGVyICh3aW5yYXIsIHdpbnppcCkuIFRoaXMgaGVscHMgKGEgYml0KVxuICAgICAgICAvLyB3aXRoIHRoZSBtZXNzeSBXaW5kb3dzJyBkZWZhdWx0IGNvbXByZXNzZWQgZm9sZGVycyBmZWF0dXJlIGJ1dFxuICAgICAgICAvLyBicmVha3Mgb24gcDd6aXAgd2hpY2ggZG9lc24ndCBzZWVrIHRoZSB1bmljb2RlIHBhdGggZXh0cmEgZmllbGQuXG4gICAgICAgIC8vIFNvIGZvciBub3csIFVURi04IGV2ZXJ5d2hlcmUgIVxuICAgICAgICB1bmljb2RlUGF0aEV4dHJhRmllbGQgPVxuICAgICAgICAgICAgLy8gVmVyc2lvblxuICAgICAgICAgICAgZGVjVG9IZXgoMSwgMSkgK1xuICAgICAgICAgICAgLy8gTmFtZUNSQzMyXG4gICAgICAgICAgICBkZWNUb0hleChjcmMzMihlbmNvZGVkRmlsZU5hbWUpLCA0KSArXG4gICAgICAgICAgICAvLyBVbmljb2RlTmFtZVxuICAgICAgICAgICAgdXRmRW5jb2RlZEZpbGVOYW1lO1xuXG4gICAgICAgIGV4dHJhRmllbGRzICs9XG4gICAgICAgICAgICAvLyBJbmZvLVpJUCBVbmljb2RlIFBhdGggRXh0cmEgRmllbGRcbiAgICAgICAgICAgIFwiXFx4NzVcXHg3MFwiICtcbiAgICAgICAgICAgIC8vIHNpemVcbiAgICAgICAgICAgIGRlY1RvSGV4KHVuaWNvZGVQYXRoRXh0cmFGaWVsZC5sZW5ndGgsIDIpICtcbiAgICAgICAgICAgIC8vIGNvbnRlbnRcbiAgICAgICAgICAgIHVuaWNvZGVQYXRoRXh0cmFGaWVsZDtcbiAgICB9XG5cbiAgICBpZih1c2VVVEY4Rm9yQ29tbWVudCkge1xuXG4gICAgICAgIHVuaWNvZGVDb21tZW50RXh0cmFGaWVsZCA9XG4gICAgICAgICAgICAvLyBWZXJzaW9uXG4gICAgICAgICAgICBkZWNUb0hleCgxLCAxKSArXG4gICAgICAgICAgICAvLyBDb21tZW50Q1JDMzJcbiAgICAgICAgICAgIGRlY1RvSGV4KGNyYzMyKGVuY29kZWRDb21tZW50KSwgNCkgK1xuICAgICAgICAgICAgLy8gVW5pY29kZU5hbWVcbiAgICAgICAgICAgIHV0ZkVuY29kZWRDb21tZW50O1xuXG4gICAgICAgIGV4dHJhRmllbGRzICs9XG4gICAgICAgICAgICAvLyBJbmZvLVpJUCBVbmljb2RlIFBhdGggRXh0cmEgRmllbGRcbiAgICAgICAgICAgIFwiXFx4NzVcXHg2M1wiICtcbiAgICAgICAgICAgIC8vIHNpemVcbiAgICAgICAgICAgIGRlY1RvSGV4KHVuaWNvZGVDb21tZW50RXh0cmFGaWVsZC5sZW5ndGgsIDIpICtcbiAgICAgICAgICAgIC8vIGNvbnRlbnRcbiAgICAgICAgICAgIHVuaWNvZGVDb21tZW50RXh0cmFGaWVsZDtcbiAgICB9XG5cbiAgICB2YXIgaGVhZGVyID0gXCJcIjtcblxuICAgIC8vIHZlcnNpb24gbmVlZGVkIHRvIGV4dHJhY3RcbiAgICBoZWFkZXIgKz0gXCJcXHgwQVxceDAwXCI7XG4gICAgLy8gZ2VuZXJhbCBwdXJwb3NlIGJpdCBmbGFnXG4gICAgaGVhZGVyICs9IGRlY1RvSGV4KGJpdGZsYWcsIDIpO1xuICAgIC8vIGNvbXByZXNzaW9uIG1ldGhvZFxuICAgIGhlYWRlciArPSBjb21wcmVzc2lvbi5tYWdpYztcbiAgICAvLyBsYXN0IG1vZCBmaWxlIHRpbWVcbiAgICBoZWFkZXIgKz0gZGVjVG9IZXgoZG9zVGltZSwgMik7XG4gICAgLy8gbGFzdCBtb2QgZmlsZSBkYXRlXG4gICAgaGVhZGVyICs9IGRlY1RvSGV4KGRvc0RhdGUsIDIpO1xuICAgIC8vIGNyYy0zMlxuICAgIGhlYWRlciArPSBkZWNUb0hleChkYXRhSW5mby5jcmMzMiwgNCk7XG4gICAgLy8gY29tcHJlc3NlZCBzaXplXG4gICAgaGVhZGVyICs9IGRlY1RvSGV4KGRhdGFJbmZvLmNvbXByZXNzZWRTaXplLCA0KTtcbiAgICAvLyB1bmNvbXByZXNzZWQgc2l6ZVxuICAgIGhlYWRlciArPSBkZWNUb0hleChkYXRhSW5mby51bmNvbXByZXNzZWRTaXplLCA0KTtcbiAgICAvLyBmaWxlIG5hbWUgbGVuZ3RoXG4gICAgaGVhZGVyICs9IGRlY1RvSGV4KGVuY29kZWRGaWxlTmFtZS5sZW5ndGgsIDIpO1xuICAgIC8vIGV4dHJhIGZpZWxkIGxlbmd0aFxuICAgIGhlYWRlciArPSBkZWNUb0hleChleHRyYUZpZWxkcy5sZW5ndGgsIDIpO1xuXG5cbiAgICB2YXIgZmlsZVJlY29yZCA9IHNpZ25hdHVyZS5MT0NBTF9GSUxFX0hFQURFUiArIGhlYWRlciArIGVuY29kZWRGaWxlTmFtZSArIGV4dHJhRmllbGRzO1xuXG4gICAgdmFyIGRpclJlY29yZCA9IHNpZ25hdHVyZS5DRU5UUkFMX0ZJTEVfSEVBREVSICtcbiAgICAgICAgLy8gdmVyc2lvbiBtYWRlIGJ5ICgwMDogRE9TKVxuICAgICAgICBkZWNUb0hleCh2ZXJzaW9uTWFkZUJ5LCAyKSArXG4gICAgICAgIC8vIGZpbGUgaGVhZGVyIChjb21tb24gdG8gZmlsZSBhbmQgY2VudHJhbCBkaXJlY3RvcnkpXG4gICAgICAgIGhlYWRlciArXG4gICAgICAgIC8vIGZpbGUgY29tbWVudCBsZW5ndGhcbiAgICAgICAgZGVjVG9IZXgoZW5jb2RlZENvbW1lbnQubGVuZ3RoLCAyKSArXG4gICAgICAgIC8vIGRpc2sgbnVtYmVyIHN0YXJ0XG4gICAgICAgIFwiXFx4MDBcXHgwMFwiICtcbiAgICAgICAgLy8gaW50ZXJuYWwgZmlsZSBhdHRyaWJ1dGVzIFRPRE9cbiAgICAgICAgXCJcXHgwMFxceDAwXCIgK1xuICAgICAgICAvLyBleHRlcm5hbCBmaWxlIGF0dHJpYnV0ZXNcbiAgICAgICAgZGVjVG9IZXgoZXh0RmlsZUF0dHIsIDQpICtcbiAgICAgICAgLy8gcmVsYXRpdmUgb2Zmc2V0IG9mIGxvY2FsIGhlYWRlclxuICAgICAgICBkZWNUb0hleChvZmZzZXQsIDQpICtcbiAgICAgICAgLy8gZmlsZSBuYW1lXG4gICAgICAgIGVuY29kZWRGaWxlTmFtZSArXG4gICAgICAgIC8vIGV4dHJhIGZpZWxkXG4gICAgICAgIGV4dHJhRmllbGRzICtcbiAgICAgICAgLy8gZmlsZSBjb21tZW50XG4gICAgICAgIGVuY29kZWRDb21tZW50O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgZmlsZVJlY29yZDogZmlsZVJlY29yZCxcbiAgICAgICAgZGlyUmVjb3JkOiBkaXJSZWNvcmRcbiAgICB9O1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZSB0aGUgRU9DRCByZWNvcmQuXG4gKiBAcGFyYW0ge051bWJlcn0gZW50cmllc0NvdW50IHRoZSBudW1iZXIgb2YgZW50cmllcyBpbiB0aGUgemlwIGZpbGUuXG4gKiBAcGFyYW0ge051bWJlcn0gY2VudHJhbERpckxlbmd0aCB0aGUgbGVuZ3RoIChpbiBieXRlcykgb2YgdGhlIGNlbnRyYWwgZGlyLlxuICogQHBhcmFtIHtOdW1iZXJ9IGxvY2FsRGlyTGVuZ3RoIHRoZSBsZW5ndGggKGluIGJ5dGVzKSBvZiB0aGUgbG9jYWwgZGlyLlxuICogQHBhcmFtIHtTdHJpbmd9IGNvbW1lbnQgdGhlIHppcCBmaWxlIGNvbW1lbnQgYXMgYSBiaW5hcnkgc3RyaW5nLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZW5jb2RlRmlsZU5hbWUgdGhlIGZ1bmN0aW9uIHRvIGVuY29kZSB0aGUgY29tbWVudC5cbiAqIEByZXR1cm4ge1N0cmluZ30gdGhlIEVPQ0QgcmVjb3JkLlxuICovXG52YXIgZ2VuZXJhdGVDZW50cmFsRGlyZWN0b3J5RW5kID0gZnVuY3Rpb24gKGVudHJpZXNDb3VudCwgY2VudHJhbERpckxlbmd0aCwgbG9jYWxEaXJMZW5ndGgsIGNvbW1lbnQsIGVuY29kZUZpbGVOYW1lKSB7XG4gICAgdmFyIGRpckVuZCA9IFwiXCI7XG4gICAgdmFyIGVuY29kZWRDb21tZW50ID0gdXRpbHMudHJhbnNmb3JtVG8oXCJzdHJpbmdcIiwgZW5jb2RlRmlsZU5hbWUoY29tbWVudCkpO1xuXG4gICAgLy8gZW5kIG9mIGNlbnRyYWwgZGlyIHNpZ25hdHVyZVxuICAgIGRpckVuZCA9IHNpZ25hdHVyZS5DRU5UUkFMX0RJUkVDVE9SWV9FTkQgK1xuICAgICAgICAvLyBudW1iZXIgb2YgdGhpcyBkaXNrXG4gICAgICAgIFwiXFx4MDBcXHgwMFwiICtcbiAgICAgICAgLy8gbnVtYmVyIG9mIHRoZSBkaXNrIHdpdGggdGhlIHN0YXJ0IG9mIHRoZSBjZW50cmFsIGRpcmVjdG9yeVxuICAgICAgICBcIlxceDAwXFx4MDBcIiArXG4gICAgICAgIC8vIHRvdGFsIG51bWJlciBvZiBlbnRyaWVzIGluIHRoZSBjZW50cmFsIGRpcmVjdG9yeSBvbiB0aGlzIGRpc2tcbiAgICAgICAgZGVjVG9IZXgoZW50cmllc0NvdW50LCAyKSArXG4gICAgICAgIC8vIHRvdGFsIG51bWJlciBvZiBlbnRyaWVzIGluIHRoZSBjZW50cmFsIGRpcmVjdG9yeVxuICAgICAgICBkZWNUb0hleChlbnRyaWVzQ291bnQsIDIpICtcbiAgICAgICAgLy8gc2l6ZSBvZiB0aGUgY2VudHJhbCBkaXJlY3RvcnkgICA0IGJ5dGVzXG4gICAgICAgIGRlY1RvSGV4KGNlbnRyYWxEaXJMZW5ndGgsIDQpICtcbiAgICAgICAgLy8gb2Zmc2V0IG9mIHN0YXJ0IG9mIGNlbnRyYWwgZGlyZWN0b3J5IHdpdGggcmVzcGVjdCB0byB0aGUgc3RhcnRpbmcgZGlzayBudW1iZXJcbiAgICAgICAgZGVjVG9IZXgobG9jYWxEaXJMZW5ndGgsIDQpICtcbiAgICAgICAgLy8gLlpJUCBmaWxlIGNvbW1lbnQgbGVuZ3RoXG4gICAgICAgIGRlY1RvSGV4KGVuY29kZWRDb21tZW50Lmxlbmd0aCwgMikgK1xuICAgICAgICAvLyAuWklQIGZpbGUgY29tbWVudFxuICAgICAgICBlbmNvZGVkQ29tbWVudDtcblxuICAgIHJldHVybiBkaXJFbmQ7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlIGRhdGEgZGVzY3JpcHRvcnMgZm9yIGEgZmlsZSBlbnRyeS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdHJlYW1JbmZvIHRoZSBoYXNoIGdlbmVyYXRlZCBieSBhIHdvcmtlciwgY29udGFpbmluZyBpbmZvcm1hdGlvbnNcbiAqIG9uIHRoZSBmaWxlIGVudHJ5LlxuICogQHJldHVybiB7U3RyaW5nfSB0aGUgZGF0YSBkZXNjcmlwdG9ycy5cbiAqL1xudmFyIGdlbmVyYXRlRGF0YURlc2NyaXB0b3JzID0gZnVuY3Rpb24gKHN0cmVhbUluZm8pIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IFwiXCI7XG4gICAgZGVzY3JpcHRvciA9IHNpZ25hdHVyZS5EQVRBX0RFU0NSSVBUT1IgK1xuICAgICAgICAvLyBjcmMtMzIgICAgICAgICAgICAgICAgICAgICAgICAgIDQgYnl0ZXNcbiAgICAgICAgZGVjVG9IZXgoc3RyZWFtSW5mb1snY3JjMzInXSwgNCkgK1xuICAgICAgICAvLyBjb21wcmVzc2VkIHNpemUgICAgICAgICAgICAgICAgIDQgYnl0ZXNcbiAgICAgICAgZGVjVG9IZXgoc3RyZWFtSW5mb1snY29tcHJlc3NlZFNpemUnXSwgNCkgK1xuICAgICAgICAvLyB1bmNvbXByZXNzZWQgc2l6ZSAgICAgICAgICAgICAgIDQgYnl0ZXNcbiAgICAgICAgZGVjVG9IZXgoc3RyZWFtSW5mb1sndW5jb21wcmVzc2VkU2l6ZSddLCA0KTtcblxuICAgIHJldHVybiBkZXNjcmlwdG9yO1xufTtcblxuXG4vKipcbiAqIEEgd29ya2VyIHRvIGNvbmNhdGVuYXRlIG90aGVyIHdvcmtlcnMgdG8gY3JlYXRlIGEgemlwIGZpbGUuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHN0cmVhbUZpbGVzIGB0cnVlYCB0byBzdHJlYW0gdGhlIGNvbnRlbnQgb2YgdGhlIGZpbGVzLFxuICogYGZhbHNlYCB0byBhY2N1bXVsYXRlIGl0LlxuICogQHBhcmFtIHtTdHJpbmd9IGNvbW1lbnQgdGhlIGNvbW1lbnQgdG8gdXNlLlxuICogQHBhcmFtIHtTdHJpbmd9IHBsYXRmb3JtIHRoZSBwbGF0Zm9ybSB0byB1c2UsIFwiVU5JWFwiIG9yIFwiRE9TXCIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlbmNvZGVGaWxlTmFtZSB0aGUgZnVuY3Rpb24gdG8gZW5jb2RlIGZpbGUgbmFtZXMgYW5kIGNvbW1lbnRzLlxuICovXG5mdW5jdGlvbiBaaXBGaWxlV29ya2VyKHN0cmVhbUZpbGVzLCBjb21tZW50LCBwbGF0Zm9ybSwgZW5jb2RlRmlsZU5hbWUpIHtcbiAgICBHZW5lcmljV29ya2VyLmNhbGwodGhpcywgXCJaaXBGaWxlV29ya2VyXCIpO1xuICAgIC8vIFRoZSBudW1iZXIgb2YgYnl0ZXMgd3JpdHRlbiBzbyBmYXIuIFRoaXMgZG9lc24ndCBjb3VudCBhY2N1bXVsYXRlZCBjaHVua3MuXG4gICAgdGhpcy5ieXRlc1dyaXR0ZW4gPSAwO1xuICAgIC8vIFRoZSBjb21tZW50IG9mIHRoZSB6aXAgZmlsZVxuICAgIHRoaXMuemlwQ29tbWVudCA9IGNvbW1lbnQ7XG4gICAgLy8gVGhlIHBsYXRmb3JtIFwiZ2VuZXJhdGluZ1wiIHRoZSB6aXAgZmlsZS5cbiAgICB0aGlzLnppcFBsYXRmb3JtID0gcGxhdGZvcm07XG4gICAgLy8gdGhlIGZ1bmN0aW9uIHRvIGVuY29kZSBmaWxlIG5hbWVzIGFuZCBjb21tZW50cy5cbiAgICB0aGlzLmVuY29kZUZpbGVOYW1lID0gZW5jb2RlRmlsZU5hbWU7XG4gICAgLy8gU2hvdWxkIHdlIHN0cmVhbSB0aGUgY29udGVudCBvZiB0aGUgZmlsZXMgP1xuICAgIHRoaXMuc3RyZWFtRmlsZXMgPSBzdHJlYW1GaWxlcztcbiAgICAvLyBJZiBgc3RyZWFtRmlsZXNgIGlzIGZhbHNlLCB3ZSB3aWxsIG5lZWQgdG8gYWNjdW11bGF0ZSB0aGUgY29udGVudCBvZiB0aGVcbiAgICAvLyBmaWxlcyB0byBjYWxjdWxhdGUgc2l6ZXMgLyBjcmMzMiAoYW5kIHdyaXRlIHRoZW0gKmJlZm9yZSogdGhlIGNvbnRlbnQpLlxuICAgIC8vIFRoaXMgYm9vbGVhbiBpbmRpY2F0ZXMgaWYgd2UgYXJlIGFjY3VtdWxhdGluZyBjaHVua3MgKGl0IHdpbGwgY2hhbmdlIGEgbG90XG4gICAgLy8gZHVyaW5nIHRoZSBsaWZldGltZSBvZiB0aGlzIHdvcmtlcikuXG4gICAgdGhpcy5hY2N1bXVsYXRlID0gZmFsc2U7XG4gICAgLy8gVGhlIGJ1ZmZlciByZWNlaXZpbmcgY2h1bmtzIHdoZW4gYWNjdW11bGF0aW5nIGNvbnRlbnQuXG4gICAgdGhpcy5jb250ZW50QnVmZmVyID0gW107XG4gICAgLy8gVGhlIGxpc3Qgb2YgZ2VuZXJhdGVkIGRpcmVjdG9yeSByZWNvcmRzLlxuICAgIHRoaXMuZGlyUmVjb3JkcyA9IFtdO1xuICAgIC8vIFRoZSBvZmZzZXQgKGluIGJ5dGVzKSBmcm9tIHRoZSBiZWdpbm5pbmcgb2YgdGhlIHppcCBmaWxlIGZvciB0aGUgY3VycmVudCBzb3VyY2UuXG4gICAgdGhpcy5jdXJyZW50U291cmNlT2Zmc2V0ID0gMDtcbiAgICAvLyBUaGUgdG90YWwgbnVtYmVyIG9mIGVudHJpZXMgaW4gdGhpcyB6aXAgZmlsZS5cbiAgICB0aGlzLmVudHJpZXNDb3VudCA9IDA7XG4gICAgLy8gdGhlIG5hbWUgb2YgdGhlIGZpbGUgY3VycmVudGx5IGJlaW5nIGFkZGVkLCBudWxsIHdoZW4gaGFuZGxpbmcgdGhlIGVuZCBvZiB0aGUgemlwIGZpbGUuXG4gICAgLy8gVXNlZCBmb3IgdGhlIGVtaXRlZCBtZXRhZGF0YS5cbiAgICB0aGlzLmN1cnJlbnRGaWxlID0gbnVsbDtcblxuXG5cbiAgICB0aGlzLl9zb3VyY2VzID0gW107XG59XG51dGlscy5pbmhlcml0cyhaaXBGaWxlV29ya2VyLCBHZW5lcmljV29ya2VyKTtcblxuLyoqXG4gKiBAc2VlIEdlbmVyaWNXb3JrZXIucHVzaFxuICovXG5aaXBGaWxlV29ya2VyLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rKSB7XG5cbiAgICB2YXIgY3VycmVudEZpbGVQZXJjZW50ID0gY2h1bmsubWV0YS5wZXJjZW50IHx8IDA7XG4gICAgdmFyIGVudHJpZXNDb3VudCA9IHRoaXMuZW50cmllc0NvdW50O1xuICAgIHZhciByZW1haW5pbmdGaWxlcyA9IHRoaXMuX3NvdXJjZXMubGVuZ3RoO1xuXG4gICAgaWYodGhpcy5hY2N1bXVsYXRlKSB7XG4gICAgICAgIHRoaXMuY29udGVudEJ1ZmZlci5wdXNoKGNodW5rKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmJ5dGVzV3JpdHRlbiArPSBjaHVuay5kYXRhLmxlbmd0aDtcblxuICAgICAgICBHZW5lcmljV29ya2VyLnByb3RvdHlwZS5wdXNoLmNhbGwodGhpcywge1xuICAgICAgICAgICAgZGF0YSA6IGNodW5rLmRhdGEsXG4gICAgICAgICAgICBtZXRhIDoge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRGaWxlIDogdGhpcy5jdXJyZW50RmlsZSxcbiAgICAgICAgICAgICAgICBwZXJjZW50IDogZW50cmllc0NvdW50ID8gKGN1cnJlbnRGaWxlUGVyY2VudCArIDEwMCAqIChlbnRyaWVzQ291bnQgLSByZW1haW5pbmdGaWxlcyAtIDEpKSAvIGVudHJpZXNDb3VudCA6IDEwMFxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFRoZSB3b3JrZXIgc3RhcnRlZCBhIG5ldyBzb3VyY2UgKGFuIG90aGVyIHdvcmtlcikuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RyZWFtSW5mbyB0aGUgc3RyZWFtSW5mbyBvYmplY3QgZnJvbSB0aGUgbmV3IHNvdXJjZS5cbiAqL1xuWmlwRmlsZVdvcmtlci5wcm90b3R5cGUub3BlbmVkU291cmNlID0gZnVuY3Rpb24gKHN0cmVhbUluZm8pIHtcbiAgICB0aGlzLmN1cnJlbnRTb3VyY2VPZmZzZXQgPSB0aGlzLmJ5dGVzV3JpdHRlbjtcbiAgICB0aGlzLmN1cnJlbnRGaWxlID0gc3RyZWFtSW5mb1snZmlsZSddLm5hbWU7XG5cbiAgICB2YXIgc3RyZWFtZWRDb250ZW50ID0gdGhpcy5zdHJlYW1GaWxlcyAmJiAhc3RyZWFtSW5mb1snZmlsZSddLmRpcjtcblxuICAgIC8vIGRvbid0IHN0cmVhbSBmb2xkZXJzIChiZWNhdXNlIHRoZXkgZG9uJ3QgaGF2ZSBhbnkgY29udGVudClcbiAgICBpZihzdHJlYW1lZENvbnRlbnQpIHtcbiAgICAgICAgdmFyIHJlY29yZCA9IGdlbmVyYXRlWmlwUGFydHMoc3RyZWFtSW5mbywgc3RyZWFtZWRDb250ZW50LCBmYWxzZSwgdGhpcy5jdXJyZW50U291cmNlT2Zmc2V0LCB0aGlzLnppcFBsYXRmb3JtLCB0aGlzLmVuY29kZUZpbGVOYW1lKTtcbiAgICAgICAgdGhpcy5wdXNoKHtcbiAgICAgICAgICAgIGRhdGEgOiByZWNvcmQuZmlsZVJlY29yZCxcbiAgICAgICAgICAgIG1ldGEgOiB7cGVyY2VudDowfVxuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyB3ZSBuZWVkIHRvIHdhaXQgZm9yIHRoZSB3aG9sZSBmaWxlIGJlZm9yZSBwdXNoaW5nIGFueXRoaW5nXG4gICAgICAgIHRoaXMuYWNjdW11bGF0ZSA9IHRydWU7XG4gICAgfVxufTtcblxuLyoqXG4gKiBUaGUgd29ya2VyIGZpbmlzaGVkIGEgc291cmNlIChhbiBvdGhlciB3b3JrZXIpLlxuICogQHBhcmFtIHtPYmplY3R9IHN0cmVhbUluZm8gdGhlIHN0cmVhbUluZm8gb2JqZWN0IGZyb20gdGhlIGZpbmlzaGVkIHNvdXJjZS5cbiAqL1xuWmlwRmlsZVdvcmtlci5wcm90b3R5cGUuY2xvc2VkU291cmNlID0gZnVuY3Rpb24gKHN0cmVhbUluZm8pIHtcbiAgICB0aGlzLmFjY3VtdWxhdGUgPSBmYWxzZTtcbiAgICB2YXIgc3RyZWFtZWRDb250ZW50ID0gdGhpcy5zdHJlYW1GaWxlcyAmJiAhc3RyZWFtSW5mb1snZmlsZSddLmRpcjtcbiAgICB2YXIgcmVjb3JkID0gZ2VuZXJhdGVaaXBQYXJ0cyhzdHJlYW1JbmZvLCBzdHJlYW1lZENvbnRlbnQsIHRydWUsIHRoaXMuY3VycmVudFNvdXJjZU9mZnNldCwgdGhpcy56aXBQbGF0Zm9ybSwgdGhpcy5lbmNvZGVGaWxlTmFtZSk7XG5cbiAgICB0aGlzLmRpclJlY29yZHMucHVzaChyZWNvcmQuZGlyUmVjb3JkKTtcbiAgICBpZihzdHJlYW1lZENvbnRlbnQpIHtcbiAgICAgICAgLy8gYWZ0ZXIgdGhlIHN0cmVhbWVkIGZpbGUsIHdlIHB1dCBkYXRhIGRlc2NyaXB0b3JzXG4gICAgICAgIHRoaXMucHVzaCh7XG4gICAgICAgICAgICBkYXRhIDogZ2VuZXJhdGVEYXRhRGVzY3JpcHRvcnMoc3RyZWFtSW5mbyksXG4gICAgICAgICAgICBtZXRhIDoge3BlcmNlbnQ6MTAwfVxuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyB0aGUgY29udGVudCB3YXNuJ3Qgc3RyZWFtZWQsIHdlIG5lZWQgdG8gcHVzaCBldmVyeXRoaW5nIG5vd1xuICAgICAgICAvLyBmaXJzdCB0aGUgZmlsZSByZWNvcmQsIHRoZW4gdGhlIGNvbnRlbnRcbiAgICAgICAgdGhpcy5wdXNoKHtcbiAgICAgICAgICAgIGRhdGEgOiByZWNvcmQuZmlsZVJlY29yZCxcbiAgICAgICAgICAgIG1ldGEgOiB7cGVyY2VudDowfVxuICAgICAgICB9KTtcbiAgICAgICAgd2hpbGUodGhpcy5jb250ZW50QnVmZmVyLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5wdXNoKHRoaXMuY29udGVudEJ1ZmZlci5zaGlmdCgpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmN1cnJlbnRGaWxlID0gbnVsbDtcbn07XG5cbi8qKlxuICogQHNlZSBHZW5lcmljV29ya2VyLmZsdXNoXG4gKi9cblppcEZpbGVXb3JrZXIucHJvdG90eXBlLmZsdXNoID0gZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIGxvY2FsRGlyTGVuZ3RoID0gdGhpcy5ieXRlc1dyaXR0ZW47XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuZGlyUmVjb3Jkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLnB1c2goe1xuICAgICAgICAgICAgZGF0YSA6IHRoaXMuZGlyUmVjb3Jkc1tpXSxcbiAgICAgICAgICAgIG1ldGEgOiB7cGVyY2VudDoxMDB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB2YXIgY2VudHJhbERpckxlbmd0aCA9IHRoaXMuYnl0ZXNXcml0dGVuIC0gbG9jYWxEaXJMZW5ndGg7XG5cbiAgICB2YXIgZGlyRW5kID0gZ2VuZXJhdGVDZW50cmFsRGlyZWN0b3J5RW5kKHRoaXMuZGlyUmVjb3Jkcy5sZW5ndGgsIGNlbnRyYWxEaXJMZW5ndGgsIGxvY2FsRGlyTGVuZ3RoLCB0aGlzLnppcENvbW1lbnQsIHRoaXMuZW5jb2RlRmlsZU5hbWUpO1xuXG4gICAgdGhpcy5wdXNoKHtcbiAgICAgICAgZGF0YSA6IGRpckVuZCxcbiAgICAgICAgbWV0YSA6IHtwZXJjZW50OjEwMH1cbiAgICB9KTtcbn07XG5cbi8qKlxuICogUHJlcGFyZSB0aGUgbmV4dCBzb3VyY2UgdG8gYmUgcmVhZC5cbiAqL1xuWmlwRmlsZVdvcmtlci5wcm90b3R5cGUucHJlcGFyZU5leHRTb3VyY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5wcmV2aW91cyA9IHRoaXMuX3NvdXJjZXMuc2hpZnQoKTtcbiAgICB0aGlzLm9wZW5lZFNvdXJjZSh0aGlzLnByZXZpb3VzLnN0cmVhbUluZm8pO1xuICAgIGlmICh0aGlzLmlzUGF1c2VkKSB7XG4gICAgICAgIHRoaXMucHJldmlvdXMucGF1c2UoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnByZXZpb3VzLnJlc3VtZSgpO1xuICAgIH1cbn07XG5cbi8qKlxuICogQHNlZSBHZW5lcmljV29ya2VyLnJlZ2lzdGVyUHJldmlvdXNcbiAqL1xuWmlwRmlsZVdvcmtlci5wcm90b3R5cGUucmVnaXN0ZXJQcmV2aW91cyA9IGZ1bmN0aW9uIChwcmV2aW91cykge1xuICAgIHRoaXMuX3NvdXJjZXMucHVzaChwcmV2aW91cyk7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgcHJldmlvdXMub24oJ2RhdGEnLCBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgICAgc2VsZi5wcm9jZXNzQ2h1bmsoY2h1bmspO1xuICAgIH0pO1xuICAgIHByZXZpb3VzLm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYuY2xvc2VkU291cmNlKHNlbGYucHJldmlvdXMuc3RyZWFtSW5mbyk7XG4gICAgICAgIGlmKHNlbGYuX3NvdXJjZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBzZWxmLnByZXBhcmVOZXh0U291cmNlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZWxmLmVuZCgpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcHJldmlvdXMub24oJ2Vycm9yJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgc2VsZi5lcnJvcihlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQHNlZSBHZW5lcmljV29ya2VyLnJlc3VtZVxuICovXG5aaXBGaWxlV29ya2VyLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYoIUdlbmVyaWNXb3JrZXIucHJvdG90eXBlLnJlc3VtZS5jYWxsKHRoaXMpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMucHJldmlvdXMgJiYgdGhpcy5fc291cmNlcy5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5wcmVwYXJlTmV4dFNvdXJjZSgpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLnByZXZpb3VzICYmICF0aGlzLl9zb3VyY2VzLmxlbmd0aCAmJiAhdGhpcy5nZW5lcmF0ZWRFcnJvcikge1xuICAgICAgICB0aGlzLmVuZCgpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEBzZWUgR2VuZXJpY1dvcmtlci5lcnJvclxuICovXG5aaXBGaWxlV29ya2VyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIHNvdXJjZXMgPSB0aGlzLl9zb3VyY2VzO1xuICAgIGlmKCFHZW5lcmljV29ya2VyLnByb3RvdHlwZS5lcnJvci5jYWxsKHRoaXMsIGUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHNvdXJjZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHNvdXJjZXNbaV0uZXJyb3IoZSk7XG4gICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgICAgLy8gdGhlIGBlcnJvcmAgZXhwbG9kZWQsIG5vdGhpbmcgdG8gZG9cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogQHNlZSBHZW5lcmljV29ya2VyLmxvY2tcbiAqL1xuWmlwRmlsZVdvcmtlci5wcm90b3R5cGUubG9jayA9IGZ1bmN0aW9uICgpIHtcbiAgICBHZW5lcmljV29ya2VyLnByb3RvdHlwZS5sb2NrLmNhbGwodGhpcyk7XG4gICAgdmFyIHNvdXJjZXMgPSB0aGlzLl9zb3VyY2VzO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzb3VyY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHNvdXJjZXNbaV0ubG9jaygpO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gWmlwRmlsZVdvcmtlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGNvbXByZXNzaW9ucyA9IHJlcXVpcmUoJy4uL2NvbXByZXNzaW9ucycpO1xudmFyIFppcEZpbGVXb3JrZXIgPSByZXF1aXJlKCcuL1ppcEZpbGVXb3JrZXInKTtcblxuLyoqXG4gKiBGaW5kIHRoZSBjb21wcmVzc2lvbiB0byB1c2UuXG4gKiBAcGFyYW0ge1N0cmluZ30gZmlsZUNvbXByZXNzaW9uIHRoZSBjb21wcmVzc2lvbiBkZWZpbmVkIGF0IHRoZSBmaWxlIGxldmVsLCBpZiBhbnkuXG4gKiBAcGFyYW0ge1N0cmluZ30gemlwQ29tcHJlc3Npb24gdGhlIGNvbXByZXNzaW9uIGRlZmluZWQgYXQgdGhlIGxvYWQoKSBsZXZlbC5cbiAqIEByZXR1cm4ge09iamVjdH0gdGhlIGNvbXByZXNzaW9uIG9iamVjdCB0byB1c2UuXG4gKi9cbnZhciBnZXRDb21wcmVzc2lvbiA9IGZ1bmN0aW9uIChmaWxlQ29tcHJlc3Npb24sIHppcENvbXByZXNzaW9uKSB7XG5cbiAgICB2YXIgY29tcHJlc3Npb25OYW1lID0gZmlsZUNvbXByZXNzaW9uIHx8IHppcENvbXByZXNzaW9uO1xuICAgIHZhciBjb21wcmVzc2lvbiA9IGNvbXByZXNzaW9uc1tjb21wcmVzc2lvbk5hbWVdO1xuICAgIGlmICghY29tcHJlc3Npb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGNvbXByZXNzaW9uTmFtZSArIFwiIGlzIG5vdCBhIHZhbGlkIGNvbXByZXNzaW9uIG1ldGhvZCAhXCIpO1xuICAgIH1cbiAgICByZXR1cm4gY29tcHJlc3Npb247XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIHdvcmtlciB0byBnZW5lcmF0ZSBhIHppcCBmaWxlLlxuICogQHBhcmFtIHtKU1ppcH0gemlwIHRoZSBKU1ppcCBpbnN0YW5jZSBhdCB0aGUgcmlnaHQgcm9vdCBsZXZlbC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIHRvIGdlbmVyYXRlIHRoZSB6aXAgZmlsZS5cbiAqIEBwYXJhbSB7U3RyaW5nfSBjb21tZW50IHRoZSBjb21tZW50IHRvIHVzZS5cbiAqL1xuZXhwb3J0cy5nZW5lcmF0ZVdvcmtlciA9IGZ1bmN0aW9uICh6aXAsIG9wdGlvbnMsIGNvbW1lbnQpIHtcblxuICAgIHZhciB6aXBGaWxlV29ya2VyID0gbmV3IFppcEZpbGVXb3JrZXIob3B0aW9ucy5zdHJlYW1GaWxlcywgY29tbWVudCwgb3B0aW9ucy5wbGF0Zm9ybSwgb3B0aW9ucy5lbmNvZGVGaWxlTmFtZSk7XG4gICAgdmFyIGVudHJpZXNDb3VudCA9IDA7XG4gICAgdHJ5IHtcblxuICAgICAgICB6aXAuZm9yRWFjaChmdW5jdGlvbiAocmVsYXRpdmVQYXRoLCBmaWxlKSB7XG4gICAgICAgICAgICBlbnRyaWVzQ291bnQrKztcbiAgICAgICAgICAgIHZhciBjb21wcmVzc2lvbiA9IGdldENvbXByZXNzaW9uKGZpbGUub3B0aW9ucy5jb21wcmVzc2lvbiwgb3B0aW9ucy5jb21wcmVzc2lvbik7XG4gICAgICAgICAgICB2YXIgY29tcHJlc3Npb25PcHRpb25zID0gZmlsZS5vcHRpb25zLmNvbXByZXNzaW9uT3B0aW9ucyB8fCBvcHRpb25zLmNvbXByZXNzaW9uT3B0aW9ucyB8fCB7fTtcbiAgICAgICAgICAgIHZhciBkaXIgPSBmaWxlLmRpciwgZGF0ZSA9IGZpbGUuZGF0ZTtcblxuICAgICAgICAgICAgZmlsZS5fY29tcHJlc3NXb3JrZXIoY29tcHJlc3Npb24sIGNvbXByZXNzaW9uT3B0aW9ucylcbiAgICAgICAgICAgIC53aXRoU3RyZWFtSW5mbyhcImZpbGVcIiwge1xuICAgICAgICAgICAgICAgIG5hbWUgOiByZWxhdGl2ZVBhdGgsXG4gICAgICAgICAgICAgICAgZGlyIDogZGlyLFxuICAgICAgICAgICAgICAgIGRhdGUgOiBkYXRlLFxuICAgICAgICAgICAgICAgIGNvbW1lbnQgOiBmaWxlLmNvbW1lbnQgfHwgXCJcIixcbiAgICAgICAgICAgICAgICB1bml4UGVybWlzc2lvbnMgOiBmaWxlLnVuaXhQZXJtaXNzaW9ucyxcbiAgICAgICAgICAgICAgICBkb3NQZXJtaXNzaW9ucyA6IGZpbGUuZG9zUGVybWlzc2lvbnNcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAucGlwZSh6aXBGaWxlV29ya2VyKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHppcEZpbGVXb3JrZXIuZW50cmllc0NvdW50ID0gZW50cmllc0NvdW50O1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgemlwRmlsZVdvcmtlci5lcnJvcihlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gemlwRmlsZVdvcmtlcjtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogUmVwcmVzZW50YXRpb24gYSBvZiB6aXAgZmlsZSBpbiBqc1xuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIEpTWmlwKCkge1xuICAgIC8vIGlmIHRoaXMgY29uc3RydWN0b3IgaXPCoHVzZWQgd2l0aG91dMKgYG5ld2AsIGl0wqBhZGRzIGBuZXdgIGJlZm9yZcKgaXRzZWxmOlxuICAgIGlmKCEodGhpcyBpbnN0YW5jZW9mIEpTWmlwKSkge1xuICAgICAgICByZXR1cm4gbmV3IEpTWmlwKCk7XG4gICAgfVxuXG4gICAgaWYoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgY29uc3RydWN0b3Igd2l0aCBwYXJhbWV0ZXJzIGhhcyBiZWVuIHJlbW92ZWQgaW4gSlNaaXAgMy4wLCBwbGVhc2UgY2hlY2sgdGhlIHVwZ3JhZGUgZ3VpZGUuXCIpO1xuICAgIH1cblxuICAgIC8vIG9iamVjdCBjb250YWluaW5nIHRoZSBmaWxlcyA6XG4gICAgLy8ge1xuICAgIC8vICAgXCJmb2xkZXIvXCIgOiB7Li4ufSxcbiAgICAvLyAgIFwiZm9sZGVyL2RhdGEudHh0XCIgOiB7Li4ufVxuICAgIC8vIH1cbiAgICB0aGlzLmZpbGVzID0ge307XG5cbiAgICB0aGlzLmNvbW1lbnQgPSBudWxsO1xuXG4gICAgLy8gV2hlcmUgd2UgYXJlIGluIHRoZSBoaWVyYXJjaHlcbiAgICB0aGlzLnJvb3QgPSBcIlwiO1xuICAgIHRoaXMuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG5ld09iaiA9IG5ldyBKU1ppcCgpO1xuICAgICAgICBmb3IgKHZhciBpIGluIHRoaXMpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpc1tpXSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgbmV3T2JqW2ldID0gdGhpc1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3T2JqO1xuICAgIH07XG59XG5KU1ppcC5wcm90b3R5cGUgPSByZXF1aXJlKCcuL29iamVjdCcpO1xuSlNaaXAucHJvdG90eXBlLmxvYWRBc3luYyA9IHJlcXVpcmUoJy4vbG9hZCcpO1xuSlNaaXAuc3VwcG9ydCA9IHJlcXVpcmUoJy4vc3VwcG9ydCcpO1xuSlNaaXAuZGVmYXVsdHMgPSByZXF1aXJlKCcuL2RlZmF1bHRzJyk7XG5cbi8vIFRPRE8gZmluZCBhIGJldHRlciB3YXkgdG8gaGFuZGxlIHRoaXMgdmVyc2lvbixcbi8vIGEgcmVxdWlyZSgncGFja2FnZS5qc29uJykudmVyc2lvbiBkb2Vzbid0IHdvcmsgd2l0aCB3ZWJwYWNrLCBzZWUgIzMyN1xuSlNaaXAudmVyc2lvbiA9IFwiMy4xLjVcIjtcblxuSlNaaXAubG9hZEFzeW5jID0gZnVuY3Rpb24gKGNvbnRlbnQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IEpTWmlwKCkubG9hZEFzeW5jKGNvbnRlbnQsIG9wdGlvbnMpO1xufTtcblxuSlNaaXAuZXh0ZXJuYWwgPSByZXF1aXJlKFwiLi9leHRlcm5hbFwiKTtcbm1vZHVsZS5leHBvcnRzID0gSlNaaXA7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgZXh0ZXJuYWwgPSByZXF1aXJlKFwiLi9leHRlcm5hbFwiKTtcbnZhciB1dGY4ID0gcmVxdWlyZSgnLi91dGY4Jyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgWmlwRW50cmllcyA9IHJlcXVpcmUoJy4vemlwRW50cmllcycpO1xudmFyIENyYzMyUHJvYmUgPSByZXF1aXJlKCcuL3N0cmVhbS9DcmMzMlByb2JlJyk7XG52YXIgbm9kZWpzVXRpbHMgPSByZXF1aXJlKFwiLi9ub2RlanNVdGlsc1wiKTtcblxuLyoqXG4gKiBDaGVjayB0aGUgQ1JDMzIgb2YgYW4gZW50cnkuXG4gKiBAcGFyYW0ge1ppcEVudHJ5fSB6aXBFbnRyeSB0aGUgemlwIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybiB7UHJvbWlzZX0gdGhlIHJlc3VsdC5cbiAqL1xuZnVuY3Rpb24gY2hlY2tFbnRyeUNSQzMyKHppcEVudHJ5KSB7XG4gICAgcmV0dXJuIG5ldyBleHRlcm5hbC5Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgdmFyIHdvcmtlciA9IHppcEVudHJ5LmRlY29tcHJlc3NlZC5nZXRDb250ZW50V29ya2VyKCkucGlwZShuZXcgQ3JjMzJQcm9iZSgpKTtcbiAgICAgICAgd29ya2VyLm9uKFwiZXJyb3JcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgfSlcbiAgICAgICAgLm9uKFwiZW5kXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh3b3JrZXIuc3RyZWFtSW5mby5jcmMzMiAhPT0gemlwRW50cnkuZGVjb21wcmVzc2VkLmNyYzMyKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcIkNvcnJ1cHRlZCB6aXAgOiBDUkMzMiBtaXNtYXRjaFwiKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgLnJlc3VtZSgpO1xuICAgIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGRhdGEsIG9wdGlvbnMpIHtcbiAgICB2YXIgemlwID0gdGhpcztcbiAgICBvcHRpb25zID0gdXRpbHMuZXh0ZW5kKG9wdGlvbnMgfHwge30sIHtcbiAgICAgICAgYmFzZTY0OiBmYWxzZSxcbiAgICAgICAgY2hlY2tDUkMzMjogZmFsc2UsXG4gICAgICAgIG9wdGltaXplZEJpbmFyeVN0cmluZzogZmFsc2UsXG4gICAgICAgIGNyZWF0ZUZvbGRlcnM6IGZhbHNlLFxuICAgICAgICBkZWNvZGVGaWxlTmFtZTogdXRmOC51dGY4ZGVjb2RlXG4gICAgfSk7XG5cbiAgICBpZiAobm9kZWpzVXRpbHMuaXNOb2RlICYmIG5vZGVqc1V0aWxzLmlzU3RyZWFtKGRhdGEpKSB7XG4gICAgICAgIHJldHVybiBleHRlcm5hbC5Qcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJKU1ppcCBjYW4ndCBhY2NlcHQgYSBzdHJlYW0gd2hlbiBsb2FkaW5nIGEgemlwIGZpbGUuXCIpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdXRpbHMucHJlcGFyZUNvbnRlbnQoXCJ0aGUgbG9hZGVkIHppcCBmaWxlXCIsIGRhdGEsIHRydWUsIG9wdGlvbnMub3B0aW1pemVkQmluYXJ5U3RyaW5nLCBvcHRpb25zLmJhc2U2NClcbiAgICAudGhlbihmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHZhciB6aXBFbnRyaWVzID0gbmV3IFppcEVudHJpZXMob3B0aW9ucyk7XG4gICAgICAgIHppcEVudHJpZXMubG9hZChkYXRhKTtcbiAgICAgICAgcmV0dXJuIHppcEVudHJpZXM7XG4gICAgfSkudGhlbihmdW5jdGlvbiBjaGVja0NSQzMyKHppcEVudHJpZXMpIHtcbiAgICAgICAgdmFyIHByb21pc2VzID0gW2V4dGVybmFsLlByb21pc2UucmVzb2x2ZSh6aXBFbnRyaWVzKV07XG4gICAgICAgIHZhciBmaWxlcyA9IHppcEVudHJpZXMuZmlsZXM7XG4gICAgICAgIGlmIChvcHRpb25zLmNoZWNrQ1JDMzIpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKGNoZWNrRW50cnlDUkMzMihmaWxlc1tpXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBleHRlcm5hbC5Qcm9taXNlLmFsbChwcm9taXNlcyk7XG4gICAgfSkudGhlbihmdW5jdGlvbiBhZGRGaWxlcyhyZXN1bHRzKSB7XG4gICAgICAgIHZhciB6aXBFbnRyaWVzID0gcmVzdWx0cy5zaGlmdCgpO1xuICAgICAgICB2YXIgZmlsZXMgPSB6aXBFbnRyaWVzLmZpbGVzO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgaW5wdXQgPSBmaWxlc1tpXTtcbiAgICAgICAgICAgIHppcC5maWxlKGlucHV0LmZpbGVOYW1lU3RyLCBpbnB1dC5kZWNvbXByZXNzZWQsIHtcbiAgICAgICAgICAgICAgICBiaW5hcnk6IHRydWUsXG4gICAgICAgICAgICAgICAgb3B0aW1pemVkQmluYXJ5U3RyaW5nOiB0cnVlLFxuICAgICAgICAgICAgICAgIGRhdGU6IGlucHV0LmRhdGUsXG4gICAgICAgICAgICAgICAgZGlyOiBpbnB1dC5kaXIsXG4gICAgICAgICAgICAgICAgY29tbWVudCA6IGlucHV0LmZpbGVDb21tZW50U3RyLmxlbmd0aCA/IGlucHV0LmZpbGVDb21tZW50U3RyIDogbnVsbCxcbiAgICAgICAgICAgICAgICB1bml4UGVybWlzc2lvbnMgOiBpbnB1dC51bml4UGVybWlzc2lvbnMsXG4gICAgICAgICAgICAgICAgZG9zUGVybWlzc2lvbnMgOiBpbnB1dC5kb3NQZXJtaXNzaW9ucyxcbiAgICAgICAgICAgICAgICBjcmVhdGVGb2xkZXJzOiBvcHRpb25zLmNyZWF0ZUZvbGRlcnNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh6aXBFbnRyaWVzLnppcENvbW1lbnQubGVuZ3RoKSB7XG4gICAgICAgICAgICB6aXAuY29tbWVudCA9IHppcEVudHJpZXMuemlwQ29tbWVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB6aXA7XG4gICAgfSk7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG52YXIgR2VuZXJpY1dvcmtlciA9IHJlcXVpcmUoJy4uL3N0cmVhbS9HZW5lcmljV29ya2VyJyk7XG5cbi8qKlxuICogQSB3b3JrZXIgdGhhdCB1c2UgYSBub2RlanMgc3RyZWFtIGFzIHNvdXJjZS5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtTdHJpbmd9IGZpbGVuYW1lIHRoZSBuYW1lIG9mIHRoZSBmaWxlIGVudHJ5IGZvciB0aGlzIHN0cmVhbS5cbiAqIEBwYXJhbSB7UmVhZGFibGV9IHN0cmVhbSB0aGUgbm9kZWpzIHN0cmVhbS5cbiAqL1xuZnVuY3Rpb24gTm9kZWpzU3RyZWFtSW5wdXRBZGFwdGVyKGZpbGVuYW1lLCBzdHJlYW0pIHtcbiAgICBHZW5lcmljV29ya2VyLmNhbGwodGhpcywgXCJOb2RlanMgc3RyZWFtIGlucHV0IGFkYXB0ZXIgZm9yIFwiICsgZmlsZW5hbWUpO1xuICAgIHRoaXMuX3Vwc3RyZWFtRW5kZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9iaW5kU3RyZWFtKHN0cmVhbSk7XG59XG5cbnV0aWxzLmluaGVyaXRzKE5vZGVqc1N0cmVhbUlucHV0QWRhcHRlciwgR2VuZXJpY1dvcmtlcik7XG5cbi8qKlxuICogUHJlcGFyZSB0aGUgc3RyZWFtIGFuZCBiaW5kIHRoZSBjYWxsYmFja3Mgb24gaXQuXG4gKiBEbyB0aGlzIEFTQVAgb24gbm9kZSAwLjEwICEgQSBsYXp5IGJpbmRpbmcgZG9lc24ndCBhbHdheXMgd29yay5cbiAqIEBwYXJhbSB7U3RyZWFtfSBzdHJlYW0gdGhlIG5vZGVqcyBzdHJlYW0gdG8gdXNlLlxuICovXG5Ob2RlanNTdHJlYW1JbnB1dEFkYXB0ZXIucHJvdG90eXBlLl9iaW5kU3RyZWFtID0gZnVuY3Rpb24gKHN0cmVhbSkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0aGlzLl9zdHJlYW0gPSBzdHJlYW07XG4gICAgc3RyZWFtLnBhdXNlKCk7XG4gICAgc3RyZWFtXG4gICAgLm9uKFwiZGF0YVwiLCBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgICAgc2VsZi5wdXNoKHtcbiAgICAgICAgICAgIGRhdGE6IGNodW5rLFxuICAgICAgICAgICAgbWV0YSA6IHtcbiAgICAgICAgICAgICAgICBwZXJjZW50IDogMFxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KVxuICAgIC5vbihcImVycm9yXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmKHNlbGYuaXNQYXVzZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZ2VuZXJhdGVkRXJyb3IgPSBlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VsZi5lcnJvcihlKTtcbiAgICAgICAgfVxuICAgIH0pXG4gICAgLm9uKFwiZW5kXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYoc2VsZi5pc1BhdXNlZCkge1xuICAgICAgICAgICAgc2VsZi5fdXBzdHJlYW1FbmRlZCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZWxmLmVuZCgpO1xuICAgICAgICB9XG4gICAgfSk7XG59O1xuTm9kZWpzU3RyZWFtSW5wdXRBZGFwdGVyLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZighR2VuZXJpY1dvcmtlci5wcm90b3R5cGUucGF1c2UuY2FsbCh0aGlzKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMuX3N0cmVhbS5wYXVzZSgpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbk5vZGVqc1N0cmVhbUlucHV0QWRhcHRlci5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24gKCkge1xuICAgIGlmKCFHZW5lcmljV29ya2VyLnByb3RvdHlwZS5yZXN1bWUuY2FsbCh0aGlzKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYodGhpcy5fdXBzdHJlYW1FbmRlZCkge1xuICAgICAgICB0aGlzLmVuZCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3N0cmVhbS5yZXN1bWUoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTm9kZWpzU3RyZWFtSW5wdXRBZGFwdGVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhZGFibGUgPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0nKS5SZWFkYWJsZTtcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcbnV0aWxzLmluaGVyaXRzKE5vZGVqc1N0cmVhbU91dHB1dEFkYXB0ZXIsIFJlYWRhYmxlKTtcblxuLyoqXG4qIEEgbm9kZWpzIHN0cmVhbSB1c2luZyBhIHdvcmtlciBhcyBzb3VyY2UuXG4qIEBzZWUgdGhlIFNvdXJjZVdyYXBwZXIgaW4gaHR0cDovL25vZGVqcy5vcmcvYXBpL3N0cmVhbS5odG1sXG4qIEBjb25zdHJ1Y3RvclxuKiBAcGFyYW0ge1N0cmVhbUhlbHBlcn0gaGVscGVyIHRoZSBoZWxwZXIgd3JhcHBpbmcgdGhlIHdvcmtlclxuKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyB0aGUgbm9kZWpzIHN0cmVhbSBvcHRpb25zXG4qIEBwYXJhbSB7RnVuY3Rpb259IHVwZGF0ZUNiIHRoZSB1cGRhdGUgY2FsbGJhY2suXG4qL1xuZnVuY3Rpb24gTm9kZWpzU3RyZWFtT3V0cHV0QWRhcHRlcihoZWxwZXIsIG9wdGlvbnMsIHVwZGF0ZUNiKSB7XG4gICAgUmVhZGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICB0aGlzLl9oZWxwZXIgPSBoZWxwZXI7XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgaGVscGVyLm9uKFwiZGF0YVwiLCBmdW5jdGlvbiAoZGF0YSwgbWV0YSkge1xuICAgICAgICBpZiAoIXNlbGYucHVzaChkYXRhKSkge1xuICAgICAgICAgICAgc2VsZi5faGVscGVyLnBhdXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYodXBkYXRlQ2IpIHtcbiAgICAgICAgICAgIHVwZGF0ZUNiKG1ldGEpO1xuICAgICAgICB9XG4gICAgfSlcbiAgICAub24oXCJlcnJvclwiLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIHNlbGYuZW1pdCgnZXJyb3InLCBlKTtcbiAgICB9KVxuICAgIC5vbihcImVuZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYucHVzaChudWxsKTtcbiAgICB9KTtcbn1cblxuXG5Ob2RlanNTdHJlYW1PdXRwdXRBZGFwdGVyLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2hlbHBlci5yZXN1bWUoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTm9kZWpzU3RyZWFtT3V0cHV0QWRhcHRlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgLyoqXG4gICAgICogVHJ1ZSBpZiB0aGlzIGlzIHJ1bm5pbmcgaW4gTm9kZWpzLCB3aWxsIGJlIHVuZGVmaW5lZCBpbiBhIGJyb3dzZXIuXG4gICAgICogSW4gYSBicm93c2VyLCBicm93c2VyaWZ5IHdvbid0IGluY2x1ZGUgdGhpcyBmaWxlIGFuZCB0aGUgd2hvbGUgbW9kdWxlXG4gICAgICogd2lsbCBiZSByZXNvbHZlZCBhbiBlbXB0eSBvYmplY3QuXG4gICAgICovXG4gICAgaXNOb2RlIDogdHlwZW9mIEJ1ZmZlciAhPT0gXCJ1bmRlZmluZWRcIixcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgbm9kZWpzIEJ1ZmZlciBmcm9tIGFuIGV4aXN0aW5nIGNvbnRlbnQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgdGhlIGRhdGEgdG8gcGFzcyB0byB0aGUgY29uc3RydWN0b3IuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGVuY29kaW5nIHRoZSBlbmNvZGluZyB0byB1c2UuXG4gICAgICogQHJldHVybiB7QnVmZmVyfSBhIG5ldyBCdWZmZXIuXG4gICAgICovXG4gICAgbmV3QnVmZmVyRnJvbTogZnVuY3Rpb24oZGF0YSwgZW5jb2RpbmcpIHtcbiAgICAgICAgLy8gWFhYIFdlIGNhbid0IHVzZSBgQnVmZmVyLmZyb21gIHdoaWNoIGNvbWVzIGZyb20gYFVpbnQ4QXJyYXkuZnJvbWBcbiAgICAgICAgLy8gaW4gbm9kZWpzIHY0ICg8IHYuNC41KS4gSXQncyBub3QgdGhlIGV4cGVjdGVkIGltcGxlbWVudGF0aW9uIChhbmRcbiAgICAgICAgLy8gaGFzIGEgZGlmZmVyZW50IHNpZ25hdHVyZSkuXG4gICAgICAgIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvaXNzdWVzLzgwNTNcbiAgICAgICAgLy8gQSBjb25kaXRpb24gb24gbm9kZWpzJyB2ZXJzaW9uIHdvbid0IHNvbHZlIHRoZSBpc3N1ZSBhcyB3ZSBkb24ndFxuICAgICAgICAvLyBjb250cm9sIHRoZSBCdWZmZXIgcG9seWZpbGxzIHRoYXQgbWF5IG9yIG1heSBub3QgYmUgdXNlZC5cbiAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXIoZGF0YSwgZW5jb2RpbmcpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IG5vZGVqcyBCdWZmZXIgd2l0aCB0aGUgc3BlY2lmaWVkIHNpemUuXG4gICAgICogQHBhcmFtIHtJbnRlZ2VyfSBzaXplIHRoZSBzaXplIG9mIHRoZSBidWZmZXIuXG4gICAgICogQHJldHVybiB7QnVmZmVyfSBhIG5ldyBCdWZmZXIuXG4gICAgICovXG4gICAgYWxsb2NCdWZmZXI6IGZ1bmN0aW9uIChzaXplKSB7XG4gICAgICAgIGlmIChCdWZmZXIuYWxsb2MpIHtcbiAgICAgICAgICAgIHJldHVybiBCdWZmZXIuYWxsb2Moc2l6ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJ1ZmZlcihzaXplKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogRmluZCBvdXQgaWYgYW4gb2JqZWN0IGlzIGEgQnVmZmVyLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBiIHRoZSBvYmplY3QgdG8gdGVzdC5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHRoZSBvYmplY3QgaXMgYSBCdWZmZXIsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBpc0J1ZmZlciA6IGZ1bmN0aW9uKGIpe1xuICAgICAgICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKGIpO1xuICAgIH0sXG5cbiAgICBpc1N0cmVhbSA6IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iaiAmJlxuICAgICAgICAgICAgdHlwZW9mIG9iai5vbiA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAgICAgICB0eXBlb2Ygb2JqLnBhdXNlID09PSBcImZ1bmN0aW9uXCIgJiZcbiAgICAgICAgICAgIHR5cGVvZiBvYmoucmVzdW1lID09PSBcImZ1bmN0aW9uXCI7XG4gICAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciB1dGY4ID0gcmVxdWlyZSgnLi91dGY4Jyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgR2VuZXJpY1dvcmtlciA9IHJlcXVpcmUoJy4vc3RyZWFtL0dlbmVyaWNXb3JrZXInKTtcbnZhciBTdHJlYW1IZWxwZXIgPSByZXF1aXJlKCcuL3N0cmVhbS9TdHJlYW1IZWxwZXInKTtcbnZhciBkZWZhdWx0cyA9IHJlcXVpcmUoJy4vZGVmYXVsdHMnKTtcbnZhciBDb21wcmVzc2VkT2JqZWN0ID0gcmVxdWlyZSgnLi9jb21wcmVzc2VkT2JqZWN0Jyk7XG52YXIgWmlwT2JqZWN0ID0gcmVxdWlyZSgnLi96aXBPYmplY3QnKTtcbnZhciBnZW5lcmF0ZSA9IHJlcXVpcmUoXCIuL2dlbmVyYXRlXCIpO1xudmFyIG5vZGVqc1V0aWxzID0gcmVxdWlyZShcIi4vbm9kZWpzVXRpbHNcIik7XG52YXIgTm9kZWpzU3RyZWFtSW5wdXRBZGFwdGVyID0gcmVxdWlyZShcIi4vbm9kZWpzL05vZGVqc1N0cmVhbUlucHV0QWRhcHRlclwiKTtcblxuXG4vKipcbiAqIEFkZCBhIGZpbGUgaW4gdGhlIGN1cnJlbnQgZm9sZGVyLlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIHRoZSBuYW1lIG9mIHRoZSBmaWxlXG4gKiBAcGFyYW0ge1N0cmluZ3xBcnJheUJ1ZmZlcnxVaW50OEFycmF5fEJ1ZmZlcn0gZGF0YSB0aGUgZGF0YSBvZiB0aGUgZmlsZVxuICogQHBhcmFtIHtPYmplY3R9IG9yaWdpbmFsT3B0aW9ucyB0aGUgb3B0aW9ucyBvZiB0aGUgZmlsZVxuICogQHJldHVybiB7T2JqZWN0fSB0aGUgbmV3IGZpbGUuXG4gKi9cbnZhciBmaWxlQWRkID0gZnVuY3Rpb24obmFtZSwgZGF0YSwgb3JpZ2luYWxPcHRpb25zKSB7XG4gICAgLy8gYmUgc3VyZSBzdWIgZm9sZGVycyBleGlzdFxuICAgIHZhciBkYXRhVHlwZSA9IHV0aWxzLmdldFR5cGVPZihkYXRhKSxcbiAgICAgICAgcGFyZW50O1xuXG5cbiAgICAvKlxuICAgICAqIENvcnJlY3Qgb3B0aW9ucy5cbiAgICAgKi9cblxuICAgIHZhciBvID0gdXRpbHMuZXh0ZW5kKG9yaWdpbmFsT3B0aW9ucyB8fCB7fSwgZGVmYXVsdHMpO1xuICAgIG8uZGF0ZSA9IG8uZGF0ZSB8fCBuZXcgRGF0ZSgpO1xuICAgIGlmIChvLmNvbXByZXNzaW9uICE9PSBudWxsKSB7XG4gICAgICAgIG8uY29tcHJlc3Npb24gPSBvLmNvbXByZXNzaW9uLnRvVXBwZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvLnVuaXhQZXJtaXNzaW9ucyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBvLnVuaXhQZXJtaXNzaW9ucyA9IHBhcnNlSW50KG8udW5peFBlcm1pc3Npb25zLCA4KTtcbiAgICB9XG5cbiAgICAvLyBVTlhfSUZESVIgIDAwNDAwMDAgc2VlIHppcGluZm8uY1xuICAgIGlmIChvLnVuaXhQZXJtaXNzaW9ucyAmJiAoby51bml4UGVybWlzc2lvbnMgJiAweDQwMDApKSB7XG4gICAgICAgIG8uZGlyID0gdHJ1ZTtcbiAgICB9XG4gICAgLy8gQml0IDQgICAgRGlyZWN0b3J5XG4gICAgaWYgKG8uZG9zUGVybWlzc2lvbnMgJiYgKG8uZG9zUGVybWlzc2lvbnMgJiAweDAwMTApKSB7XG4gICAgICAgIG8uZGlyID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoby5kaXIpIHtcbiAgICAgICAgbmFtZSA9IGZvcmNlVHJhaWxpbmdTbGFzaChuYW1lKTtcbiAgICB9XG4gICAgaWYgKG8uY3JlYXRlRm9sZGVycyAmJiAocGFyZW50ID0gcGFyZW50Rm9sZGVyKG5hbWUpKSkge1xuICAgICAgICBmb2xkZXJBZGQuY2FsbCh0aGlzLCBwYXJlbnQsIHRydWUpO1xuICAgIH1cblxuICAgIHZhciBpc1VuaWNvZGVTdHJpbmcgPSBkYXRhVHlwZSA9PT0gXCJzdHJpbmdcIiAmJiBvLmJpbmFyeSA9PT0gZmFsc2UgJiYgby5iYXNlNjQgPT09IGZhbHNlO1xuICAgIGlmICghb3JpZ2luYWxPcHRpb25zIHx8IHR5cGVvZiBvcmlnaW5hbE9wdGlvbnMuYmluYXJ5ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIG8uYmluYXJ5ID0gIWlzVW5pY29kZVN0cmluZztcbiAgICB9XG5cblxuICAgIHZhciBpc0NvbXByZXNzZWRFbXB0eSA9IChkYXRhIGluc3RhbmNlb2YgQ29tcHJlc3NlZE9iamVjdCkgJiYgZGF0YS51bmNvbXByZXNzZWRTaXplID09PSAwO1xuXG4gICAgaWYgKGlzQ29tcHJlc3NlZEVtcHR5IHx8IG8uZGlyIHx8ICFkYXRhIHx8IGRhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIG8uYmFzZTY0ID0gZmFsc2U7XG4gICAgICAgIG8uYmluYXJ5ID0gdHJ1ZTtcbiAgICAgICAgZGF0YSA9IFwiXCI7XG4gICAgICAgIG8uY29tcHJlc3Npb24gPSBcIlNUT1JFXCI7XG4gICAgICAgIGRhdGFUeXBlID0gXCJzdHJpbmdcIjtcbiAgICB9XG5cbiAgICAvKlxuICAgICAqIENvbnZlcnQgY29udGVudCB0byBmaXQuXG4gICAgICovXG5cbiAgICB2YXIgemlwT2JqZWN0Q29udGVudCA9IG51bGw7XG4gICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBDb21wcmVzc2VkT2JqZWN0IHx8IGRhdGEgaW5zdGFuY2VvZiBHZW5lcmljV29ya2VyKSB7XG4gICAgICAgIHppcE9iamVjdENvbnRlbnQgPSBkYXRhO1xuICAgIH0gZWxzZSBpZiAobm9kZWpzVXRpbHMuaXNOb2RlICYmIG5vZGVqc1V0aWxzLmlzU3RyZWFtKGRhdGEpKSB7XG4gICAgICAgIHppcE9iamVjdENvbnRlbnQgPSBuZXcgTm9kZWpzU3RyZWFtSW5wdXRBZGFwdGVyKG5hbWUsIGRhdGEpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHppcE9iamVjdENvbnRlbnQgPSB1dGlscy5wcmVwYXJlQ29udGVudChuYW1lLCBkYXRhLCBvLmJpbmFyeSwgby5vcHRpbWl6ZWRCaW5hcnlTdHJpbmcsIG8uYmFzZTY0KTtcbiAgICB9XG5cbiAgICB2YXIgb2JqZWN0ID0gbmV3IFppcE9iamVjdChuYW1lLCB6aXBPYmplY3RDb250ZW50LCBvKTtcbiAgICB0aGlzLmZpbGVzW25hbWVdID0gb2JqZWN0O1xuICAgIC8qXG4gICAgVE9ETzogd2UgY2FuJ3QgdGhyb3cgYW4gZXhjZXB0aW9uIGJlY2F1c2Ugd2UgaGF2ZSBhc3luYyBwcm9taXNlc1xuICAgICh3ZSBjYW4gaGF2ZSBhIHByb21pc2Ugb2YgYSBEYXRlKCkgZm9yIGV4YW1wbGUpIGJ1dCByZXR1cm5pbmcgYVxuICAgIHByb21pc2UgaXMgdXNlbGVzcyBiZWNhdXNlIGZpbGUobmFtZSwgZGF0YSkgcmV0dXJucyB0aGUgSlNaaXBcbiAgICBvYmplY3QgZm9yIGNoYWluaW5nLiBTaG91bGQgd2UgYnJlYWsgdGhhdCB0byBhbGxvdyB0aGUgdXNlclxuICAgIHRvIGNhdGNoIHRoZSBlcnJvciA/XG5cbiAgICByZXR1cm4gZXh0ZXJuYWwuUHJvbWlzZS5yZXNvbHZlKHppcE9iamVjdENvbnRlbnQpXG4gICAgLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH0pO1xuICAgICovXG59O1xuXG4vKipcbiAqIEZpbmQgdGhlIHBhcmVudCBmb2xkZXIgb2YgdGhlIHBhdGguXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGggdGhlIHBhdGggdG8gdXNlXG4gKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSBwYXJlbnQgZm9sZGVyLCBvciBcIlwiXG4gKi9cbnZhciBwYXJlbnRGb2xkZXIgPSBmdW5jdGlvbiAocGF0aCkge1xuICAgIGlmIChwYXRoLnNsaWNlKC0xKSA9PT0gJy8nKSB7XG4gICAgICAgIHBhdGggPSBwYXRoLnN1YnN0cmluZygwLCBwYXRoLmxlbmd0aCAtIDEpO1xuICAgIH1cbiAgICB2YXIgbGFzdFNsYXNoID0gcGF0aC5sYXN0SW5kZXhPZignLycpO1xuICAgIHJldHVybiAobGFzdFNsYXNoID4gMCkgPyBwYXRoLnN1YnN0cmluZygwLCBsYXN0U2xhc2gpIDogXCJcIjtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgcGF0aCB3aXRoIGEgc2xhc2ggYXQgdGhlIGVuZC5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aCB0aGUgcGF0aCB0byBjaGVjay5cbiAqIEByZXR1cm4ge1N0cmluZ30gdGhlIHBhdGggd2l0aCBhIHRyYWlsaW5nIHNsYXNoLlxuICovXG52YXIgZm9yY2VUcmFpbGluZ1NsYXNoID0gZnVuY3Rpb24ocGF0aCkge1xuICAgIC8vIENoZWNrIHRoZSBuYW1lIGVuZHMgd2l0aCBhIC9cbiAgICBpZiAocGF0aC5zbGljZSgtMSkgIT09IFwiL1wiKSB7XG4gICAgICAgIHBhdGggKz0gXCIvXCI7IC8vIElFIGRvZXNuJ3QgbGlrZSBzdWJzdHIoLTEpXG4gICAgfVxuICAgIHJldHVybiBwYXRoO1xufTtcblxuLyoqXG4gKiBBZGQgYSAoc3ViKSBmb2xkZXIgaW4gdGhlIGN1cnJlbnQgZm9sZGVyLlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIHRoZSBmb2xkZXIncyBuYW1lXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBbY3JlYXRlRm9sZGVyc10gSWYgdHJ1ZSwgYXV0b21hdGljYWxseSBjcmVhdGUgc3ViXG4gKiAgZm9sZGVycy4gRGVmYXVsdHMgdG8gZmFsc2UuXG4gKiBAcmV0dXJuIHtPYmplY3R9IHRoZSBuZXcgZm9sZGVyLlxuICovXG52YXIgZm9sZGVyQWRkID0gZnVuY3Rpb24obmFtZSwgY3JlYXRlRm9sZGVycykge1xuICAgIGNyZWF0ZUZvbGRlcnMgPSAodHlwZW9mIGNyZWF0ZUZvbGRlcnMgIT09ICd1bmRlZmluZWQnKSA/IGNyZWF0ZUZvbGRlcnMgOiBkZWZhdWx0cy5jcmVhdGVGb2xkZXJzO1xuXG4gICAgbmFtZSA9IGZvcmNlVHJhaWxpbmdTbGFzaChuYW1lKTtcblxuICAgIC8vIERvZXMgdGhpcyBmb2xkZXIgYWxyZWFkeSBleGlzdD9cbiAgICBpZiAoIXRoaXMuZmlsZXNbbmFtZV0pIHtcbiAgICAgICAgZmlsZUFkZC5jYWxsKHRoaXMsIG5hbWUsIG51bGwsIHtcbiAgICAgICAgICAgIGRpcjogdHJ1ZSxcbiAgICAgICAgICAgIGNyZWF0ZUZvbGRlcnM6IGNyZWF0ZUZvbGRlcnNcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZpbGVzW25hbWVdO1xufTtcblxuLyoqXG4qIENyb3NzLXdpbmRvdywgY3Jvc3MtTm9kZS1jb250ZXh0IHJlZ3VsYXIgZXhwcmVzc2lvbiBkZXRlY3Rpb25cbiogQHBhcmFtICB7T2JqZWN0fSAgb2JqZWN0IEFueXRoaW5nXG4qIEByZXR1cm4ge0Jvb2xlYW59ICAgICAgICB0cnVlIGlmIHRoZSBvYmplY3QgaXMgYSByZWd1bGFyIGV4cHJlc3Npb24sXG4qIGZhbHNlIG90aGVyd2lzZVxuKi9cbmZ1bmN0aW9uIGlzUmVnRXhwKG9iamVjdCkge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqZWN0KSA9PT0gXCJbb2JqZWN0IFJlZ0V4cF1cIjtcbn1cblxuLy8gcmV0dXJuIHRoZSBhY3R1YWwgcHJvdG90eXBlIG9mIEpTWmlwXG52YXIgb3V0ID0ge1xuICAgIC8qKlxuICAgICAqIEBzZWUgbG9hZEFzeW5jXG4gICAgICovXG4gICAgbG9hZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoaXMgbWV0aG9kIGhhcyBiZWVuIHJlbW92ZWQgaW4gSlNaaXAgMy4wLCBwbGVhc2UgY2hlY2sgdGhlIHVwZ3JhZGUgZ3VpZGUuXCIpO1xuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqIENhbGwgYSBjYWxsYmFjayBmdW5jdGlvbiBmb3IgZWFjaCBlbnRyeSBhdCB0aGlzIGZvbGRlciBsZXZlbC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiB0aGUgY2FsbGJhY2sgZnVuY3Rpb246XG4gICAgICogZnVuY3Rpb24gKHJlbGF0aXZlUGF0aCwgZmlsZSkgey4uLn1cbiAgICAgKiBJdCB0YWtlcyAyIGFyZ3VtZW50cyA6IHRoZSByZWxhdGl2ZSBwYXRoIGFuZCB0aGUgZmlsZS5cbiAgICAgKi9cbiAgICBmb3JFYWNoOiBmdW5jdGlvbihjYikge1xuICAgICAgICB2YXIgZmlsZW5hbWUsIHJlbGF0aXZlUGF0aCwgZmlsZTtcbiAgICAgICAgZm9yIChmaWxlbmFtZSBpbiB0aGlzLmZpbGVzKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuZmlsZXMuaGFzT3duUHJvcGVydHkoZmlsZW5hbWUpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaWxlID0gdGhpcy5maWxlc1tmaWxlbmFtZV07XG4gICAgICAgICAgICByZWxhdGl2ZVBhdGggPSBmaWxlbmFtZS5zbGljZSh0aGlzLnJvb3QubGVuZ3RoLCBmaWxlbmFtZS5sZW5ndGgpO1xuICAgICAgICAgICAgaWYgKHJlbGF0aXZlUGF0aCAmJiBmaWxlbmFtZS5zbGljZSgwLCB0aGlzLnJvb3QubGVuZ3RoKSA9PT0gdGhpcy5yb290KSB7IC8vIHRoZSBmaWxlIGlzIGluIHRoZSBjdXJyZW50IHJvb3RcbiAgICAgICAgICAgICAgICBjYihyZWxhdGl2ZVBhdGgsIGZpbGUpOyAvLyBUT0RPIHJldmVyc2UgdGhlIHBhcmFtZXRlcnMgPyBuZWVkIHRvIGJlIGNsZWFuIEFORCBjb25zaXN0ZW50IHdpdGggdGhlIGZpbHRlciBzZWFyY2ggZm4uLi5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaWx0ZXIgbmVzdGVkIGZpbGVzL2ZvbGRlcnMgd2l0aCB0aGUgc3BlY2lmaWVkIGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHNlYXJjaCB0aGUgcHJlZGljYXRlIHRvIHVzZSA6XG4gICAgICogZnVuY3Rpb24gKHJlbGF0aXZlUGF0aCwgZmlsZSkgey4uLn1cbiAgICAgKiBJdCB0YWtlcyAyIGFyZ3VtZW50cyA6IHRoZSByZWxhdGl2ZSBwYXRoIGFuZCB0aGUgZmlsZS5cbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gQW4gYXJyYXkgb2YgbWF0Y2hpbmcgZWxlbWVudHMuXG4gICAgICovXG4gICAgZmlsdGVyOiBmdW5jdGlvbihzZWFyY2gpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24gKHJlbGF0aXZlUGF0aCwgZW50cnkpIHtcbiAgICAgICAgICAgIGlmIChzZWFyY2gocmVsYXRpdmVQYXRoLCBlbnRyeSkpIHsgLy8gdGhlIGZpbGUgbWF0Y2hlcyB0aGUgZnVuY3Rpb25cbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChlbnRyeSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZCBhIGZpbGUgdG8gdGhlIHppcCBmaWxlLCBvciBzZWFyY2ggYSBmaWxlLlxuICAgICAqIEBwYXJhbSAgIHtzdHJpbmd8UmVnRXhwfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBmaWxlIHRvIGFkZCAoaWYgZGF0YSBpcyBkZWZpbmVkKSxcbiAgICAgKiB0aGUgbmFtZSBvZiB0aGUgZmlsZSB0byBmaW5kIChpZiBubyBkYXRhKSBvciBhIHJlZ2V4IHRvIG1hdGNoIGZpbGVzLlxuICAgICAqIEBwYXJhbSAgIHtTdHJpbmd8QXJyYXlCdWZmZXJ8VWludDhBcnJheXxCdWZmZXJ9IGRhdGEgIFRoZSBmaWxlIGRhdGEsIGVpdGhlciByYXcgb3IgYmFzZTY0IGVuY29kZWRcbiAgICAgKiBAcGFyYW0gICB7T2JqZWN0fSBvICAgICBGaWxlIG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuICB7SlNaaXB8T2JqZWN0fEFycmF5fSB0aGlzIEpTWmlwIG9iamVjdCAod2hlbiBhZGRpbmcgYSBmaWxlKSxcbiAgICAgKiBhIGZpbGUgKHdoZW4gc2VhcmNoaW5nIGJ5IHN0cmluZykgb3IgYW4gYXJyYXkgb2YgZmlsZXMgKHdoZW4gc2VhcmNoaW5nIGJ5IHJlZ2V4KS5cbiAgICAgKi9cbiAgICBmaWxlOiBmdW5jdGlvbihuYW1lLCBkYXRhLCBvKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBpZiAoaXNSZWdFeHAobmFtZSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVnZXhwID0gbmFtZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXIoZnVuY3Rpb24ocmVsYXRpdmVQYXRoLCBmaWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhZmlsZS5kaXIgJiYgcmVnZXhwLnRlc3QocmVsYXRpdmVQYXRoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgeyAvLyB0ZXh0XG4gICAgICAgICAgICAgICAgdmFyIG9iaiA9IHRoaXMuZmlsZXNbdGhpcy5yb290ICsgbmFtZV07XG4gICAgICAgICAgICAgICAgaWYgKG9iaiAmJiAhb2JqLmRpcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsgLy8gbW9yZSB0aGFuIG9uZSBhcmd1bWVudCA6IHdlIGhhdmUgZGF0YSAhXG4gICAgICAgICAgICBuYW1lID0gdGhpcy5yb290ICsgbmFtZTtcbiAgICAgICAgICAgIGZpbGVBZGQuY2FsbCh0aGlzLCBuYW1lLCBkYXRhLCBvKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkIGEgZGlyZWN0b3J5IHRvIHRoZSB6aXAgZmlsZSwgb3Igc2VhcmNoLlxuICAgICAqIEBwYXJhbSAgIHtTdHJpbmd8UmVnRXhwfSBhcmcgVGhlIG5hbWUgb2YgdGhlIGRpcmVjdG9yeSB0byBhZGQsIG9yIGEgcmVnZXggdG8gc2VhcmNoIGZvbGRlcnMuXG4gICAgICogQHJldHVybiAge0pTWmlwfSBhbiBvYmplY3Qgd2l0aCB0aGUgbmV3IGRpcmVjdG9yeSBhcyB0aGUgcm9vdCwgb3IgYW4gYXJyYXkgY29udGFpbmluZyBtYXRjaGluZyBmb2xkZXJzLlxuICAgICAqL1xuICAgIGZvbGRlcjogZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgIGlmICghYXJnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc1JlZ0V4cChhcmcpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXIoZnVuY3Rpb24ocmVsYXRpdmVQYXRoLCBmaWxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpbGUuZGlyICYmIGFyZy50ZXN0KHJlbGF0aXZlUGF0aCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGVsc2UsIG5hbWUgaXMgYSBuZXcgZm9sZGVyXG4gICAgICAgIHZhciBuYW1lID0gdGhpcy5yb290ICsgYXJnO1xuICAgICAgICB2YXIgbmV3Rm9sZGVyID0gZm9sZGVyQWRkLmNhbGwodGhpcywgbmFtZSk7XG5cbiAgICAgICAgLy8gQWxsb3cgY2hhaW5pbmcgYnkgcmV0dXJuaW5nIGEgbmV3IG9iamVjdCB3aXRoIHRoaXMgZm9sZGVyIGFzIHRoZSByb290XG4gICAgICAgIHZhciByZXQgPSB0aGlzLmNsb25lKCk7XG4gICAgICAgIHJldC5yb290ID0gbmV3Rm9sZGVyLm5hbWU7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERlbGV0ZSBhIGZpbGUsIG9yIGEgZGlyZWN0b3J5IGFuZCBhbGwgc3ViLWZpbGVzLCBmcm9tIHRoZSB6aXBcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSB0aGUgbmFtZSBvZiB0aGUgZmlsZSB0byBkZWxldGVcbiAgICAgKiBAcmV0dXJuIHtKU1ppcH0gdGhpcyBKU1ppcCBvYmplY3RcbiAgICAgKi9cbiAgICByZW1vdmU6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgbmFtZSA9IHRoaXMucm9vdCArIG5hbWU7XG4gICAgICAgIHZhciBmaWxlID0gdGhpcy5maWxlc1tuYW1lXTtcbiAgICAgICAgaWYgKCFmaWxlKSB7XG4gICAgICAgICAgICAvLyBMb29rIGZvciBhbnkgZm9sZGVyc1xuICAgICAgICAgICAgaWYgKG5hbWUuc2xpY2UoLTEpICE9PSBcIi9cIikge1xuICAgICAgICAgICAgICAgIG5hbWUgKz0gXCIvXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaWxlID0gdGhpcy5maWxlc1tuYW1lXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmaWxlICYmICFmaWxlLmRpcikge1xuICAgICAgICAgICAgLy8gZmlsZVxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuZmlsZXNbbmFtZV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBtYXliZSBhIGZvbGRlciwgZGVsZXRlIHJlY3Vyc2l2ZWx5XG4gICAgICAgICAgICB2YXIga2lkcyA9IHRoaXMuZmlsdGVyKGZ1bmN0aW9uKHJlbGF0aXZlUGF0aCwgZmlsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmaWxlLm5hbWUuc2xpY2UoMCwgbmFtZS5sZW5ndGgpID09PSBuYW1lO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtpZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5maWxlc1traWRzW2ldLm5hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIHRoZSBjb21wbGV0ZSB6aXAgZmlsZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIHRoZSBvcHRpb25zIHRvIGdlbmVyYXRlIHRoZSB6aXAgZmlsZSA6XG4gICAgICogLSBjb21wcmVzc2lvbiwgXCJTVE9SRVwiIGJ5IGRlZmF1bHQuXG4gICAgICogLSB0eXBlLCBcImJhc2U2NFwiIGJ5IGRlZmF1bHQuIFZhbHVlcyBhcmUgOiBzdHJpbmcsIGJhc2U2NCwgdWludDhhcnJheSwgYXJyYXlidWZmZXIsIGJsb2IuXG4gICAgICogQHJldHVybiB7U3RyaW5nfFVpbnQ4QXJyYXl8QXJyYXlCdWZmZXJ8QnVmZmVyfEJsb2J9IHRoZSB6aXAgZmlsZVxuICAgICAqL1xuICAgIGdlbmVyYXRlOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoaXMgbWV0aG9kIGhhcyBiZWVuIHJlbW92ZWQgaW4gSlNaaXAgMy4wLCBwbGVhc2UgY2hlY2sgdGhlIHVwZ3JhZGUgZ3VpZGUuXCIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSB0aGUgY29tcGxldGUgemlwIGZpbGUgYXMgYW4gaW50ZXJuYWwgc3RyZWFtLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIHRoZSBvcHRpb25zIHRvIGdlbmVyYXRlIHRoZSB6aXAgZmlsZSA6XG4gICAgICogLSBjb21wcmVzc2lvbiwgXCJTVE9SRVwiIGJ5IGRlZmF1bHQuXG4gICAgICogLSB0eXBlLCBcImJhc2U2NFwiIGJ5IGRlZmF1bHQuIFZhbHVlcyBhcmUgOiBzdHJpbmcsIGJhc2U2NCwgdWludDhhcnJheSwgYXJyYXlidWZmZXIsIGJsb2IuXG4gICAgICogQHJldHVybiB7U3RyZWFtSGVscGVyfSB0aGUgc3RyZWFtZWQgemlwIGZpbGUuXG4gICAgICovXG4gICAgZ2VuZXJhdGVJbnRlcm5hbFN0cmVhbTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIHdvcmtlciwgb3B0cyA9IHt9O1xuICAgICAgdHJ5IHtcbiAgICAgICAgICBvcHRzID0gdXRpbHMuZXh0ZW5kKG9wdGlvbnMgfHwge30sIHtcbiAgICAgICAgICAgICAgc3RyZWFtRmlsZXM6IGZhbHNlLFxuICAgICAgICAgICAgICBjb21wcmVzc2lvbjogXCJTVE9SRVwiLFxuICAgICAgICAgICAgICBjb21wcmVzc2lvbk9wdGlvbnMgOiBudWxsLFxuICAgICAgICAgICAgICB0eXBlOiBcIlwiLFxuICAgICAgICAgICAgICBwbGF0Zm9ybTogXCJET1NcIixcbiAgICAgICAgICAgICAgY29tbWVudDogbnVsbCxcbiAgICAgICAgICAgICAgbWltZVR5cGU6ICdhcHBsaWNhdGlvbi96aXAnLFxuICAgICAgICAgICAgICBlbmNvZGVGaWxlTmFtZTogdXRmOC51dGY4ZW5jb2RlXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBvcHRzLnR5cGUgPSBvcHRzLnR5cGUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICBvcHRzLmNvbXByZXNzaW9uID0gb3B0cy5jb21wcmVzc2lvbi50b1VwcGVyQ2FzZSgpO1xuXG4gICAgICAgICAgLy8gXCJiaW5hcnlzdHJpbmdcIiBpcyBwcmVmZXJlZCBidXQgdGhlIGludGVybmFscyB1c2UgXCJzdHJpbmdcIi5cbiAgICAgICAgICBpZihvcHRzLnR5cGUgPT09IFwiYmluYXJ5c3RyaW5nXCIpIHtcbiAgICAgICAgICAgIG9wdHMudHlwZSA9IFwic3RyaW5nXCI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFvcHRzLnR5cGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIG91dHB1dCB0eXBlIHNwZWNpZmllZC5cIik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdXRpbHMuY2hlY2tTdXBwb3J0KG9wdHMudHlwZSk7XG5cbiAgICAgICAgICAvLyBhY2NlcHQgbm9kZWpzIGBwcm9jZXNzLnBsYXRmb3JtYFxuICAgICAgICAgIGlmKFxuICAgICAgICAgICAgICBvcHRzLnBsYXRmb3JtID09PSAnZGFyd2luJyB8fFxuICAgICAgICAgICAgICBvcHRzLnBsYXRmb3JtID09PSAnZnJlZWJzZCcgfHxcbiAgICAgICAgICAgICAgb3B0cy5wbGF0Zm9ybSA9PT0gJ2xpbnV4JyB8fFxuICAgICAgICAgICAgICBvcHRzLnBsYXRmb3JtID09PSAnc3Vub3MnXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIG9wdHMucGxhdGZvcm0gPSBcIlVOSVhcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9wdHMucGxhdGZvcm0gPT09ICd3aW4zMicpIHtcbiAgICAgICAgICAgICAgb3B0cy5wbGF0Zm9ybSA9IFwiRE9TXCI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGNvbW1lbnQgPSBvcHRzLmNvbW1lbnQgfHwgdGhpcy5jb21tZW50IHx8IFwiXCI7XG4gICAgICAgICAgd29ya2VyID0gZ2VuZXJhdGUuZ2VuZXJhdGVXb3JrZXIodGhpcywgb3B0cywgY29tbWVudCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHdvcmtlciA9IG5ldyBHZW5lcmljV29ya2VyKFwiZXJyb3JcIik7XG4gICAgICAgIHdvcmtlci5lcnJvcihlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgU3RyZWFtSGVscGVyKHdvcmtlciwgb3B0cy50eXBlIHx8IFwic3RyaW5nXCIsIG9wdHMubWltZVR5cGUpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgdGhlIGNvbXBsZXRlIHppcCBmaWxlIGFzeW5jaHJvbm91c2x5LlxuICAgICAqIEBzZWUgZ2VuZXJhdGVJbnRlcm5hbFN0cmVhbVxuICAgICAqL1xuICAgIGdlbmVyYXRlQXN5bmM6IGZ1bmN0aW9uKG9wdGlvbnMsIG9uVXBkYXRlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdlbmVyYXRlSW50ZXJuYWxTdHJlYW0ob3B0aW9ucykuYWNjdW11bGF0ZShvblVwZGF0ZSk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSB0aGUgY29tcGxldGUgemlwIGZpbGUgYXN5bmNocm9ub3VzbHkuXG4gICAgICogQHNlZSBnZW5lcmF0ZUludGVybmFsU3RyZWFtXG4gICAgICovXG4gICAgZ2VuZXJhdGVOb2RlU3RyZWFtOiBmdW5jdGlvbihvcHRpb25zLCBvblVwZGF0ZSkge1xuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgaWYgKCFvcHRpb25zLnR5cGUpIHtcbiAgICAgICAgICAgIG9wdGlvbnMudHlwZSA9IFwibm9kZWJ1ZmZlclwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmdlbmVyYXRlSW50ZXJuYWxTdHJlYW0ob3B0aW9ucykudG9Ob2RlanNTdHJlYW0ob25VcGRhdGUpO1xuICAgIH1cbn07XG5tb2R1bGUuZXhwb3J0cyA9IG91dDtcbiIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgdXNlZCBieSBtb2R1bGUgYnVuZGxlcnMgKGJyb3dzZXJpZnkvd2VicGFjay9ldGMpIHdoZW5cbiAqIGluY2x1ZGluZyBhIHN0cmVhbSBpbXBsZW1lbnRhdGlvbi4gV2UgdXNlIFwicmVhZGFibGUtc3RyZWFtXCIgdG8gZ2V0IGFcbiAqIGNvbnNpc3RlbnQgYmVoYXZpb3IgYmV0d2VlbiBub2RlanMgdmVyc2lvbnMgYnV0IGJ1bmRsZXJzIG9mdGVuIGhhdmUgYSBzaGltXG4gKiBmb3IgXCJzdHJlYW1cIi4gVXNpbmcgdGhpcyBzaGltIGdyZWF0bHkgaW1wcm92ZSB0aGUgY29tcGF0aWJpbGl0eSBhbmQgZ3JlYXRseVxuICogcmVkdWNlIHRoZSBmaW5hbCBzaXplIG9mIHRoZSBidW5kbGUgKG9ubHkgb25lIHN0cmVhbSBpbXBsZW1lbnRhdGlvbiwgbm90XG4gKiB0d28pLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJzdHJlYW1cIik7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgRGF0YVJlYWRlciA9IHJlcXVpcmUoJy4vRGF0YVJlYWRlcicpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcblxuZnVuY3Rpb24gQXJyYXlSZWFkZXIoZGF0YSkge1xuICAgIERhdGFSZWFkZXIuY2FsbCh0aGlzLCBkYXRhKTtcblx0Zm9yKHZhciBpID0gMDsgaSA8IHRoaXMuZGF0YS5sZW5ndGg7IGkrKykge1xuXHRcdGRhdGFbaV0gPSBkYXRhW2ldICYgMHhGRjtcblx0fVxufVxudXRpbHMuaW5oZXJpdHMoQXJyYXlSZWFkZXIsIERhdGFSZWFkZXIpO1xuLyoqXG4gKiBAc2VlIERhdGFSZWFkZXIuYnl0ZUF0XG4gKi9cbkFycmF5UmVhZGVyLnByb3RvdHlwZS5ieXRlQXQgPSBmdW5jdGlvbihpKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YVt0aGlzLnplcm8gKyBpXTtcbn07XG4vKipcbiAqIEBzZWUgRGF0YVJlYWRlci5sYXN0SW5kZXhPZlNpZ25hdHVyZVxuICovXG5BcnJheVJlYWRlci5wcm90b3R5cGUubGFzdEluZGV4T2ZTaWduYXR1cmUgPSBmdW5jdGlvbihzaWcpIHtcbiAgICB2YXIgc2lnMCA9IHNpZy5jaGFyQ29kZUF0KDApLFxuICAgICAgICBzaWcxID0gc2lnLmNoYXJDb2RlQXQoMSksXG4gICAgICAgIHNpZzIgPSBzaWcuY2hhckNvZGVBdCgyKSxcbiAgICAgICAgc2lnMyA9IHNpZy5jaGFyQ29kZUF0KDMpO1xuICAgIGZvciAodmFyIGkgPSB0aGlzLmxlbmd0aCAtIDQ7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIGlmICh0aGlzLmRhdGFbaV0gPT09IHNpZzAgJiYgdGhpcy5kYXRhW2kgKyAxXSA9PT0gc2lnMSAmJiB0aGlzLmRhdGFbaSArIDJdID09PSBzaWcyICYmIHRoaXMuZGF0YVtpICsgM10gPT09IHNpZzMpIHtcbiAgICAgICAgICAgIHJldHVybiBpIC0gdGhpcy56ZXJvO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIC0xO1xufTtcbi8qKlxuICogQHNlZSBEYXRhUmVhZGVyLnJlYWRBbmRDaGVja1NpZ25hdHVyZVxuICovXG5BcnJheVJlYWRlci5wcm90b3R5cGUucmVhZEFuZENoZWNrU2lnbmF0dXJlID0gZnVuY3Rpb24gKHNpZykge1xuICAgIHZhciBzaWcwID0gc2lnLmNoYXJDb2RlQXQoMCksXG4gICAgICAgIHNpZzEgPSBzaWcuY2hhckNvZGVBdCgxKSxcbiAgICAgICAgc2lnMiA9IHNpZy5jaGFyQ29kZUF0KDIpLFxuICAgICAgICBzaWczID0gc2lnLmNoYXJDb2RlQXQoMyksXG4gICAgICAgIGRhdGEgPSB0aGlzLnJlYWREYXRhKDQpO1xuICAgIHJldHVybiBzaWcwID09PSBkYXRhWzBdICYmIHNpZzEgPT09IGRhdGFbMV0gJiYgc2lnMiA9PT0gZGF0YVsyXSAmJiBzaWczID09PSBkYXRhWzNdO1xufTtcbi8qKlxuICogQHNlZSBEYXRhUmVhZGVyLnJlYWREYXRhXG4gKi9cbkFycmF5UmVhZGVyLnByb3RvdHlwZS5yZWFkRGF0YSA9IGZ1bmN0aW9uKHNpemUpIHtcbiAgICB0aGlzLmNoZWNrT2Zmc2V0KHNpemUpO1xuICAgIGlmKHNpemUgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gdGhpcy5kYXRhLnNsaWNlKHRoaXMuemVybyArIHRoaXMuaW5kZXgsIHRoaXMuemVybyArIHRoaXMuaW5kZXggKyBzaXplKTtcbiAgICB0aGlzLmluZGV4ICs9IHNpemU7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5UmVhZGVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcblxuZnVuY3Rpb24gRGF0YVJlYWRlcihkYXRhKSB7XG4gICAgdGhpcy5kYXRhID0gZGF0YTsgLy8gdHlwZSA6IHNlZSBpbXBsZW1lbnRhdGlvblxuICAgIHRoaXMubGVuZ3RoID0gZGF0YS5sZW5ndGg7XG4gICAgdGhpcy5pbmRleCA9IDA7XG4gICAgdGhpcy56ZXJvID0gMDtcbn1cbkRhdGFSZWFkZXIucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAqIENoZWNrIHRoYXQgdGhlIG9mZnNldCB3aWxsIG5vdCBnbyB0b28gZmFyLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvZmZzZXQgdGhlIGFkZGl0aW9uYWwgb2Zmc2V0IHRvIGNoZWNrLlxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBhbiBFcnJvciBpZiB0aGUgb2Zmc2V0IGlzIG91dCBvZiBib3VuZHMuXG4gICAgICovXG4gICAgY2hlY2tPZmZzZXQ6IGZ1bmN0aW9uKG9mZnNldCkge1xuICAgICAgICB0aGlzLmNoZWNrSW5kZXgodGhpcy5pbmRleCArIG9mZnNldCk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBDaGVjayB0aGF0IHRoZSBzcGVjaWZpZWQgaW5kZXggd2lsbCBub3QgYmUgdG9vIGZhci5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV3SW5kZXggdGhlIGluZGV4IHRvIGNoZWNrLlxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBhbiBFcnJvciBpZiB0aGUgaW5kZXggaXMgb3V0IG9mIGJvdW5kcy5cbiAgICAgKi9cbiAgICBjaGVja0luZGV4OiBmdW5jdGlvbihuZXdJbmRleCkge1xuICAgICAgICBpZiAodGhpcy5sZW5ndGggPCB0aGlzLnplcm8gKyBuZXdJbmRleCB8fCBuZXdJbmRleCA8IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVuZCBvZiBkYXRhIHJlYWNoZWQgKGRhdGEgbGVuZ3RoID0gXCIgKyB0aGlzLmxlbmd0aCArIFwiLCBhc2tlZCBpbmRleCA9IFwiICsgKG5ld0luZGV4KSArIFwiKS4gQ29ycnVwdGVkIHppcCA/XCIpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBDaGFuZ2UgdGhlIGluZGV4LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuZXdJbmRleCBUaGUgbmV3IGluZGV4LlxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBpZiB0aGUgbmV3IGluZGV4IGlzIG91dCBvZiB0aGUgZGF0YS5cbiAgICAgKi9cbiAgICBzZXRJbmRleDogZnVuY3Rpb24obmV3SW5kZXgpIHtcbiAgICAgICAgdGhpcy5jaGVja0luZGV4KG5ld0luZGV4KTtcbiAgICAgICAgdGhpcy5pbmRleCA9IG5ld0luZGV4O1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogU2tpcCB0aGUgbmV4dCBuIGJ5dGVzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIHRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gc2tpcC5cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gaWYgdGhlIG5ldyBpbmRleCBpcyBvdXQgb2YgdGhlIGRhdGEuXG4gICAgICovXG4gICAgc2tpcDogZnVuY3Rpb24obikge1xuICAgICAgICB0aGlzLnNldEluZGV4KHRoaXMuaW5kZXggKyBuKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgYnl0ZSBhdCB0aGUgc3BlY2lmaWVkIGluZGV4LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpIHRoZSBpbmRleCB0byB1c2UuXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBhIGJ5dGUuXG4gICAgICovXG4gICAgYnl0ZUF0OiBmdW5jdGlvbihpKSB7XG4gICAgICAgIC8vIHNlZSBpbXBsZW1lbnRhdGlvbnNcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbmV4dCBudW1iZXIgd2l0aCBhIGdpdmVuIGJ5dGUgc2l6ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2l6ZSB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRvIHJlYWQuXG4gICAgICogQHJldHVybiB7bnVtYmVyfSB0aGUgY29ycmVzcG9uZGluZyBudW1iZXIuXG4gICAgICovXG4gICAgcmVhZEludDogZnVuY3Rpb24oc2l6ZSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gMCxcbiAgICAgICAgICAgIGk7XG4gICAgICAgIHRoaXMuY2hlY2tPZmZzZXQoc2l6ZSk7XG4gICAgICAgIGZvciAoaSA9IHRoaXMuaW5kZXggKyBzaXplIC0gMTsgaSA+PSB0aGlzLmluZGV4OyBpLS0pIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IChyZXN1bHQgPDwgOCkgKyB0aGlzLmJ5dGVBdChpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmluZGV4ICs9IHNpemU7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIG5leHQgc3RyaW5nIHdpdGggYSBnaXZlbiBieXRlIHNpemUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNpemUgdGhlIG51bWJlciBvZiBieXRlcyB0byByZWFkLlxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gdGhlIGNvcnJlc3BvbmRpbmcgc3RyaW5nLlxuICAgICAqL1xuICAgIHJlYWRTdHJpbmc6IGZ1bmN0aW9uKHNpemUpIHtcbiAgICAgICAgcmV0dXJuIHV0aWxzLnRyYW5zZm9ybVRvKFwic3RyaW5nXCIsIHRoaXMucmVhZERhdGEoc2l6ZSkpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogR2V0IHJhdyBkYXRhIHdpdGhvdXQgY29udmVyc2lvbiwgPHNpemU+IGJ5dGVzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzaXplIHRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gcmVhZC5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHRoZSByYXcgZGF0YSwgaW1wbGVtZW50YXRpb24gc3BlY2lmaWMuXG4gICAgICovXG4gICAgcmVhZERhdGE6IGZ1bmN0aW9uKHNpemUpIHtcbiAgICAgICAgLy8gc2VlIGltcGxlbWVudGF0aW9uc1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogRmluZCB0aGUgbGFzdCBvY2N1cmVuY2Ugb2YgYSB6aXAgc2lnbmF0dXJlICg0IGJ5dGVzKS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2lnIHRoZSBzaWduYXR1cmUgdG8gZmluZC5cbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IHRoZSBpbmRleCBvZiB0aGUgbGFzdCBvY2N1cmVuY2UsIC0xIGlmIG5vdCBmb3VuZC5cbiAgICAgKi9cbiAgICBsYXN0SW5kZXhPZlNpZ25hdHVyZTogZnVuY3Rpb24oc2lnKSB7XG4gICAgICAgIC8vIHNlZSBpbXBsZW1lbnRhdGlvbnNcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJlYWQgdGhlIHNpZ25hdHVyZSAoNCBieXRlcykgYXQgdGhlIGN1cnJlbnQgcG9zaXRpb24gYW5kIGNvbXBhcmUgaXQgd2l0aCBzaWcuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNpZyB0aGUgZXhwZWN0ZWQgc2lnbmF0dXJlXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgc2lnbmF0dXJlIG1hdGNoZXMsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICByZWFkQW5kQ2hlY2tTaWduYXR1cmU6IGZ1bmN0aW9uKHNpZykge1xuICAgICAgICAvLyBzZWUgaW1wbGVtZW50YXRpb25zXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIG5leHQgZGF0ZS5cbiAgICAgKiBAcmV0dXJuIHtEYXRlfSB0aGUgZGF0ZS5cbiAgICAgKi9cbiAgICByZWFkRGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBkb3N0aW1lID0gdGhpcy5yZWFkSW50KDQpO1xuICAgICAgICByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMoXG4gICAgICAgICgoZG9zdGltZSA+PiAyNSkgJiAweDdmKSArIDE5ODAsIC8vIHllYXJcbiAgICAgICAgKChkb3N0aW1lID4+IDIxKSAmIDB4MGYpIC0gMSwgLy8gbW9udGhcbiAgICAgICAgKGRvc3RpbWUgPj4gMTYpICYgMHgxZiwgLy8gZGF5XG4gICAgICAgIChkb3N0aW1lID4+IDExKSAmIDB4MWYsIC8vIGhvdXJcbiAgICAgICAgKGRvc3RpbWUgPj4gNSkgJiAweDNmLCAvLyBtaW51dGVcbiAgICAgICAgKGRvc3RpbWUgJiAweDFmKSA8PCAxKSk7IC8vIHNlY29uZFxuICAgIH1cbn07XG5tb2R1bGUuZXhwb3J0cyA9IERhdGFSZWFkZXI7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgVWludDhBcnJheVJlYWRlciA9IHJlcXVpcmUoJy4vVWludDhBcnJheVJlYWRlcicpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcblxuZnVuY3Rpb24gTm9kZUJ1ZmZlclJlYWRlcihkYXRhKSB7XG4gICAgVWludDhBcnJheVJlYWRlci5jYWxsKHRoaXMsIGRhdGEpO1xufVxudXRpbHMuaW5oZXJpdHMoTm9kZUJ1ZmZlclJlYWRlciwgVWludDhBcnJheVJlYWRlcik7XG5cbi8qKlxuICogQHNlZSBEYXRhUmVhZGVyLnJlYWREYXRhXG4gKi9cbk5vZGVCdWZmZXJSZWFkZXIucHJvdG90eXBlLnJlYWREYXRhID0gZnVuY3Rpb24oc2l6ZSkge1xuICAgIHRoaXMuY2hlY2tPZmZzZXQoc2l6ZSk7XG4gICAgdmFyIHJlc3VsdCA9IHRoaXMuZGF0YS5zbGljZSh0aGlzLnplcm8gKyB0aGlzLmluZGV4LCB0aGlzLnplcm8gKyB0aGlzLmluZGV4ICsgc2l6ZSk7XG4gICAgdGhpcy5pbmRleCArPSBzaXplO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xubW9kdWxlLmV4cG9ydHMgPSBOb2RlQnVmZmVyUmVhZGVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIERhdGFSZWFkZXIgPSByZXF1aXJlKCcuL0RhdGFSZWFkZXInKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbmZ1bmN0aW9uIFN0cmluZ1JlYWRlcihkYXRhKSB7XG4gICAgRGF0YVJlYWRlci5jYWxsKHRoaXMsIGRhdGEpO1xufVxudXRpbHMuaW5oZXJpdHMoU3RyaW5nUmVhZGVyLCBEYXRhUmVhZGVyKTtcbi8qKlxuICogQHNlZSBEYXRhUmVhZGVyLmJ5dGVBdFxuICovXG5TdHJpbmdSZWFkZXIucHJvdG90eXBlLmJ5dGVBdCA9IGZ1bmN0aW9uKGkpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLmNoYXJDb2RlQXQodGhpcy56ZXJvICsgaSk7XG59O1xuLyoqXG4gKiBAc2VlIERhdGFSZWFkZXIubGFzdEluZGV4T2ZTaWduYXR1cmVcbiAqL1xuU3RyaW5nUmVhZGVyLnByb3RvdHlwZS5sYXN0SW5kZXhPZlNpZ25hdHVyZSA9IGZ1bmN0aW9uKHNpZykge1xuICAgIHJldHVybiB0aGlzLmRhdGEubGFzdEluZGV4T2Yoc2lnKSAtIHRoaXMuemVybztcbn07XG4vKipcbiAqIEBzZWUgRGF0YVJlYWRlci5yZWFkQW5kQ2hlY2tTaWduYXR1cmVcbiAqL1xuU3RyaW5nUmVhZGVyLnByb3RvdHlwZS5yZWFkQW5kQ2hlY2tTaWduYXR1cmUgPSBmdW5jdGlvbiAoc2lnKSB7XG4gICAgdmFyIGRhdGEgPSB0aGlzLnJlYWREYXRhKDQpO1xuICAgIHJldHVybiBzaWcgPT09IGRhdGE7XG59O1xuLyoqXG4gKiBAc2VlIERhdGFSZWFkZXIucmVhZERhdGFcbiAqL1xuU3RyaW5nUmVhZGVyLnByb3RvdHlwZS5yZWFkRGF0YSA9IGZ1bmN0aW9uKHNpemUpIHtcbiAgICB0aGlzLmNoZWNrT2Zmc2V0KHNpemUpO1xuICAgIC8vIHRoaXMgd2lsbCB3b3JrIGJlY2F1c2UgdGhlIGNvbnN0cnVjdG9yIGFwcGxpZWQgdGhlIFwiJiAweGZmXCIgbWFzay5cbiAgICB2YXIgcmVzdWx0ID0gdGhpcy5kYXRhLnNsaWNlKHRoaXMuemVybyArIHRoaXMuaW5kZXgsIHRoaXMuemVybyArIHRoaXMuaW5kZXggKyBzaXplKTtcbiAgICB0aGlzLmluZGV4ICs9IHNpemU7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IFN0cmluZ1JlYWRlcjtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBBcnJheVJlYWRlciA9IHJlcXVpcmUoJy4vQXJyYXlSZWFkZXInKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbmZ1bmN0aW9uIFVpbnQ4QXJyYXlSZWFkZXIoZGF0YSkge1xuICAgIEFycmF5UmVhZGVyLmNhbGwodGhpcywgZGF0YSk7XG59XG51dGlscy5pbmhlcml0cyhVaW50OEFycmF5UmVhZGVyLCBBcnJheVJlYWRlcik7XG4vKipcbiAqIEBzZWUgRGF0YVJlYWRlci5yZWFkRGF0YVxuICovXG5VaW50OEFycmF5UmVhZGVyLnByb3RvdHlwZS5yZWFkRGF0YSA9IGZ1bmN0aW9uKHNpemUpIHtcbiAgICB0aGlzLmNoZWNrT2Zmc2V0KHNpemUpO1xuICAgIGlmKHNpemUgPT09IDApIHtcbiAgICAgICAgLy8gaW4gSUUxMCwgd2hlbiB1c2luZyBzdWJhcnJheShpZHgsIGlkeCksIHdlIGdldCB0aGUgYXJyYXkgWzB4MDBdIGluc3RlYWQgb2YgW10uXG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheSgwKTtcbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IHRoaXMuZGF0YS5zdWJhcnJheSh0aGlzLnplcm8gKyB0aGlzLmluZGV4LCB0aGlzLnplcm8gKyB0aGlzLmluZGV4ICsgc2l6ZSk7XG4gICAgdGhpcy5pbmRleCArPSBzaXplO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xubW9kdWxlLmV4cG9ydHMgPSBVaW50OEFycmF5UmVhZGVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xudmFyIHN1cHBvcnQgPSByZXF1aXJlKCcuLi9zdXBwb3J0Jyk7XG52YXIgQXJyYXlSZWFkZXIgPSByZXF1aXJlKCcuL0FycmF5UmVhZGVyJyk7XG52YXIgU3RyaW5nUmVhZGVyID0gcmVxdWlyZSgnLi9TdHJpbmdSZWFkZXInKTtcbnZhciBOb2RlQnVmZmVyUmVhZGVyID0gcmVxdWlyZSgnLi9Ob2RlQnVmZmVyUmVhZGVyJyk7XG52YXIgVWludDhBcnJheVJlYWRlciA9IHJlcXVpcmUoJy4vVWludDhBcnJheVJlYWRlcicpO1xuXG4vKipcbiAqIENyZWF0ZSBhIHJlYWRlciBhZGFwdGVkIHRvIHRoZSBkYXRhLlxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXlCdWZmZXJ8VWludDhBcnJheXxCdWZmZXJ9IGRhdGEgdGhlIGRhdGEgdG8gcmVhZC5cbiAqIEByZXR1cm4ge0RhdGFSZWFkZXJ9IHRoZSBkYXRhIHJlYWRlci5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciB0eXBlID0gdXRpbHMuZ2V0VHlwZU9mKGRhdGEpO1xuICAgIHV0aWxzLmNoZWNrU3VwcG9ydCh0eXBlKTtcbiAgICBpZiAodHlwZSA9PT0gXCJzdHJpbmdcIiAmJiAhc3VwcG9ydC51aW50OGFycmF5KSB7XG4gICAgICAgIHJldHVybiBuZXcgU3RyaW5nUmVhZGVyKGRhdGEpO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gXCJub2RlYnVmZmVyXCIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBOb2RlQnVmZmVyUmVhZGVyKGRhdGEpO1xuICAgIH1cbiAgICBpZiAoc3VwcG9ydC51aW50OGFycmF5KSB7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheVJlYWRlcih1dGlscy50cmFuc2Zvcm1UbyhcInVpbnQ4YXJyYXlcIiwgZGF0YSkpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEFycmF5UmVhZGVyKHV0aWxzLnRyYW5zZm9ybVRvKFwiYXJyYXlcIiwgZGF0YSkpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbmV4cG9ydHMuTE9DQUxfRklMRV9IRUFERVIgPSBcIlBLXFx4MDNcXHgwNFwiO1xuZXhwb3J0cy5DRU5UUkFMX0ZJTEVfSEVBREVSID0gXCJQS1xceDAxXFx4MDJcIjtcbmV4cG9ydHMuQ0VOVFJBTF9ESVJFQ1RPUllfRU5EID0gXCJQS1xceDA1XFx4MDZcIjtcbmV4cG9ydHMuWklQNjRfQ0VOVFJBTF9ESVJFQ1RPUllfTE9DQVRPUiA9IFwiUEtcXHgwNlxceDA3XCI7XG5leHBvcnRzLlpJUDY0X0NFTlRSQUxfRElSRUNUT1JZX0VORCA9IFwiUEtcXHgwNlxceDA2XCI7XG5leHBvcnRzLkRBVEFfREVTQ1JJUFRPUiA9IFwiUEtcXHgwN1xceDA4XCI7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBHZW5lcmljV29ya2VyID0gcmVxdWlyZSgnLi9HZW5lcmljV29ya2VyJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG4vKipcbiAqIEEgd29ya2VyIHdoaWNoIGNvbnZlcnQgY2h1bmtzIHRvIGEgc3BlY2lmaWVkIHR5cGUuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7U3RyaW5nfSBkZXN0VHlwZSB0aGUgZGVzdGluYXRpb24gdHlwZS5cbiAqL1xuZnVuY3Rpb24gQ29udmVydFdvcmtlcihkZXN0VHlwZSkge1xuICAgIEdlbmVyaWNXb3JrZXIuY2FsbCh0aGlzLCBcIkNvbnZlcnRXb3JrZXIgdG8gXCIgKyBkZXN0VHlwZSk7XG4gICAgdGhpcy5kZXN0VHlwZSA9IGRlc3RUeXBlO1xufVxudXRpbHMuaW5oZXJpdHMoQ29udmVydFdvcmtlciwgR2VuZXJpY1dvcmtlcik7XG5cbi8qKlxuICogQHNlZSBHZW5lcmljV29ya2VyLnByb2Nlc3NDaHVua1xuICovXG5Db252ZXJ0V29ya2VyLnByb3RvdHlwZS5wcm9jZXNzQ2h1bmsgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICB0aGlzLnB1c2goe1xuICAgICAgICBkYXRhIDogdXRpbHMudHJhbnNmb3JtVG8odGhpcy5kZXN0VHlwZSwgY2h1bmsuZGF0YSksXG4gICAgICAgIG1ldGEgOiBjaHVuay5tZXRhXG4gICAgfSk7XG59O1xubW9kdWxlLmV4cG9ydHMgPSBDb252ZXJ0V29ya2VyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgR2VuZXJpY1dvcmtlciA9IHJlcXVpcmUoJy4vR2VuZXJpY1dvcmtlcicpO1xudmFyIGNyYzMyID0gcmVxdWlyZSgnLi4vY3JjMzInKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbi8qKlxuICogQSB3b3JrZXIgd2hpY2ggY2FsY3VsYXRlIHRoZSBjcmMzMiBvZiB0aGUgZGF0YSBmbG93aW5nIHRocm91Z2guXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gQ3JjMzJQcm9iZSgpIHtcbiAgICBHZW5lcmljV29ya2VyLmNhbGwodGhpcywgXCJDcmMzMlByb2JlXCIpO1xuICAgIHRoaXMud2l0aFN0cmVhbUluZm8oXCJjcmMzMlwiLCAwKTtcbn1cbnV0aWxzLmluaGVyaXRzKENyYzMyUHJvYmUsIEdlbmVyaWNXb3JrZXIpO1xuXG4vKipcbiAqIEBzZWUgR2VuZXJpY1dvcmtlci5wcm9jZXNzQ2h1bmtcbiAqL1xuQ3JjMzJQcm9iZS5wcm90b3R5cGUucHJvY2Vzc0NodW5rID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgdGhpcy5zdHJlYW1JbmZvLmNyYzMyID0gY3JjMzIoY2h1bmsuZGF0YSwgdGhpcy5zdHJlYW1JbmZvLmNyYzMyIHx8IDApO1xuICAgIHRoaXMucHVzaChjaHVuayk7XG59O1xubW9kdWxlLmV4cG9ydHMgPSBDcmMzMlByb2JlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xudmFyIEdlbmVyaWNXb3JrZXIgPSByZXF1aXJlKCcuL0dlbmVyaWNXb3JrZXInKTtcblxuLyoqXG4gKiBBIHdvcmtlciB3aGljaCBjYWxjdWxhdGUgdGhlIHRvdGFsIGxlbmd0aCBvZiB0aGUgZGF0YSBmbG93aW5nIHRocm91Z2guXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wTmFtZSB0aGUgbmFtZSB1c2VkIHRvIGV4cG9zZSB0aGUgbGVuZ3RoXG4gKi9cbmZ1bmN0aW9uIERhdGFMZW5ndGhQcm9iZShwcm9wTmFtZSkge1xuICAgIEdlbmVyaWNXb3JrZXIuY2FsbCh0aGlzLCBcIkRhdGFMZW5ndGhQcm9iZSBmb3IgXCIgKyBwcm9wTmFtZSk7XG4gICAgdGhpcy5wcm9wTmFtZSA9IHByb3BOYW1lO1xuICAgIHRoaXMud2l0aFN0cmVhbUluZm8ocHJvcE5hbWUsIDApO1xufVxudXRpbHMuaW5oZXJpdHMoRGF0YUxlbmd0aFByb2JlLCBHZW5lcmljV29ya2VyKTtcblxuLyoqXG4gKiBAc2VlIEdlbmVyaWNXb3JrZXIucHJvY2Vzc0NodW5rXG4gKi9cbkRhdGFMZW5ndGhQcm9iZS5wcm90b3R5cGUucHJvY2Vzc0NodW5rID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgaWYoY2h1bmspIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IHRoaXMuc3RyZWFtSW5mb1t0aGlzLnByb3BOYW1lXSB8fCAwO1xuICAgICAgICB0aGlzLnN0cmVhbUluZm9bdGhpcy5wcm9wTmFtZV0gPSBsZW5ndGggKyBjaHVuay5kYXRhLmxlbmd0aDtcbiAgICB9XG4gICAgR2VuZXJpY1dvcmtlci5wcm90b3R5cGUucHJvY2Vzc0NodW5rLmNhbGwodGhpcywgY2h1bmspO1xufTtcbm1vZHVsZS5leHBvcnRzID0gRGF0YUxlbmd0aFByb2JlO1xuXG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG52YXIgR2VuZXJpY1dvcmtlciA9IHJlcXVpcmUoJy4vR2VuZXJpY1dvcmtlcicpO1xuXG4vLyB0aGUgc2l6ZSBvZiB0aGUgZ2VuZXJhdGVkIGNodW5rc1xuLy8gVE9ETyBleHBvc2UgdGhpcyBhcyBhIHB1YmxpYyB2YXJpYWJsZVxudmFyIERFRkFVTFRfQkxPQ0tfU0laRSA9IDE2ICogMTAyNDtcblxuLyoqXG4gKiBBIHdvcmtlciB0aGF0IHJlYWRzIGEgY29udGVudCBhbmQgZW1pdHMgY2h1bmtzLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1Byb21pc2V9IGRhdGFQIHRoZSBwcm9taXNlIG9mIHRoZSBkYXRhIHRvIHNwbGl0XG4gKi9cbmZ1bmN0aW9uIERhdGFXb3JrZXIoZGF0YVApIHtcbiAgICBHZW5lcmljV29ya2VyLmNhbGwodGhpcywgXCJEYXRhV29ya2VyXCIpO1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0aGlzLmRhdGFJc1JlYWR5ID0gZmFsc2U7XG4gICAgdGhpcy5pbmRleCA9IDA7XG4gICAgdGhpcy5tYXggPSAwO1xuICAgIHRoaXMuZGF0YSA9IG51bGw7XG4gICAgdGhpcy50eXBlID0gXCJcIjtcblxuICAgIHRoaXMuX3RpY2tTY2hlZHVsZWQgPSBmYWxzZTtcblxuICAgIGRhdGFQLnRoZW4oZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgc2VsZi5kYXRhSXNSZWFkeSA9IHRydWU7XG4gICAgICAgIHNlbGYuZGF0YSA9IGRhdGE7XG4gICAgICAgIHNlbGYubWF4ID0gZGF0YSAmJiBkYXRhLmxlbmd0aCB8fCAwO1xuICAgICAgICBzZWxmLnR5cGUgPSB1dGlscy5nZXRUeXBlT2YoZGF0YSk7XG4gICAgICAgIGlmKCFzZWxmLmlzUGF1c2VkKSB7XG4gICAgICAgICAgICBzZWxmLl90aWNrQW5kUmVwZWF0KCk7XG4gICAgICAgIH1cbiAgICB9LCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBzZWxmLmVycm9yKGUpO1xuICAgIH0pO1xufVxuXG51dGlscy5pbmhlcml0cyhEYXRhV29ya2VyLCBHZW5lcmljV29ya2VyKTtcblxuLyoqXG4gKiBAc2VlIEdlbmVyaWNXb3JrZXIuY2xlYW5VcFxuICovXG5EYXRhV29ya2VyLnByb3RvdHlwZS5jbGVhblVwID0gZnVuY3Rpb24gKCkge1xuICAgIEdlbmVyaWNXb3JrZXIucHJvdG90eXBlLmNsZWFuVXAuY2FsbCh0aGlzKTtcbiAgICB0aGlzLmRhdGEgPSBudWxsO1xufTtcblxuLyoqXG4gKiBAc2VlIEdlbmVyaWNXb3JrZXIucmVzdW1lXG4gKi9cbkRhdGFXb3JrZXIucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZighR2VuZXJpY1dvcmtlci5wcm90b3R5cGUucmVzdW1lLmNhbGwodGhpcykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5fdGlja1NjaGVkdWxlZCAmJiB0aGlzLmRhdGFJc1JlYWR5KSB7XG4gICAgICAgIHRoaXMuX3RpY2tTY2hlZHVsZWQgPSB0cnVlO1xuICAgICAgICB1dGlscy5kZWxheSh0aGlzLl90aWNrQW5kUmVwZWF0LCBbXSwgdGhpcyk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBUcmlnZ2VyIGEgdGljayBhIHNjaGVkdWxlIGFuIG90aGVyIGNhbGwgdG8gdGhpcyBmdW5jdGlvbi5cbiAqL1xuRGF0YVdvcmtlci5wcm90b3R5cGUuX3RpY2tBbmRSZXBlYXQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl90aWNrU2NoZWR1bGVkID0gZmFsc2U7XG4gICAgaWYodGhpcy5pc1BhdXNlZCB8fCB0aGlzLmlzRmluaXNoZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl90aWNrKCk7XG4gICAgaWYoIXRoaXMuaXNGaW5pc2hlZCkge1xuICAgICAgICB1dGlscy5kZWxheSh0aGlzLl90aWNrQW5kUmVwZWF0LCBbXSwgdGhpcyk7XG4gICAgICAgIHRoaXMuX3RpY2tTY2hlZHVsZWQgPSB0cnVlO1xuICAgIH1cbn07XG5cbi8qKlxuICogUmVhZCBhbmQgcHVzaCBhIGNodW5rLlxuICovXG5EYXRhV29ya2VyLnByb3RvdHlwZS5fdGljayA9IGZ1bmN0aW9uKCkge1xuXG4gICAgaWYodGhpcy5pc1BhdXNlZCB8fCB0aGlzLmlzRmluaXNoZWQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBzaXplID0gREVGQVVMVF9CTE9DS19TSVpFO1xuICAgIHZhciBkYXRhID0gbnVsbCwgbmV4dEluZGV4ID0gTWF0aC5taW4odGhpcy5tYXgsIHRoaXMuaW5kZXggKyBzaXplKTtcbiAgICBpZiAodGhpcy5pbmRleCA+PSB0aGlzLm1heCkge1xuICAgICAgICAvLyBFT0ZcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5kKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc3dpdGNoKHRoaXMudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgICAgIGRhdGEgPSB0aGlzLmRhdGEuc3Vic3RyaW5nKHRoaXMuaW5kZXgsIG5leHRJbmRleCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJ1aW50OGFycmF5XCI6XG4gICAgICAgICAgICAgICAgZGF0YSA9IHRoaXMuZGF0YS5zdWJhcnJheSh0aGlzLmluZGV4LCBuZXh0SW5kZXgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiYXJyYXlcIjpcbiAgICAgICAgICAgIGNhc2UgXCJub2RlYnVmZmVyXCI6XG4gICAgICAgICAgICAgICAgZGF0YSA9IHRoaXMuZGF0YS5zbGljZSh0aGlzLmluZGV4LCBuZXh0SW5kZXgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbmRleCA9IG5leHRJbmRleDtcbiAgICAgICAgcmV0dXJuIHRoaXMucHVzaCh7XG4gICAgICAgICAgICBkYXRhIDogZGF0YSxcbiAgICAgICAgICAgIG1ldGEgOiB7XG4gICAgICAgICAgICAgICAgcGVyY2VudCA6IHRoaXMubWF4ID8gdGhpcy5pbmRleCAvIHRoaXMubWF4ICogMTAwIDogMFxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IERhdGFXb3JrZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQSB3b3JrZXIgdGhhdCBkb2VzIG5vdGhpbmcgYnV0IHBhc3NpbmcgY2h1bmtzIHRvIHRoZSBuZXh0IG9uZS4gVGhpcyBpcyBsaWtlXG4gKiBhIG5vZGVqcyBzdHJlYW0gYnV0IHdpdGggc29tZSBkaWZmZXJlbmNlcy4gT24gdGhlIGdvb2Qgc2lkZSA6XG4gKiAtIGl0IHdvcmtzIG9uIElFIDYtOSB3aXRob3V0IGFueSBpc3N1ZSAvIHBvbHlmaWxsXG4gKiAtIGl0IHdlaWdodHMgbGVzcyB0aGFuIHRoZSBmdWxsIGRlcGVuZGVuY2llcyBidW5kbGVkIHdpdGggYnJvd3NlcmlmeVxuICogLSBpdCBmb3J3YXJkcyBlcnJvcnMgKG5vIG5lZWQgdG8gZGVjbGFyZSBhbiBlcnJvciBoYW5kbGVyIEVWRVJZV0hFUkUpXG4gKlxuICogQSBjaHVuayBpcyBhbiBvYmplY3Qgd2l0aCAyIGF0dHJpYnV0ZXMgOiBgbWV0YWAgYW5kIGBkYXRhYC4gVGhlIGZvcm1lciBpcyBhblxuICogb2JqZWN0IGNvbnRhaW5pbmcgYW55dGhpbmcgKGBwZXJjZW50YCBmb3IgZXhhbXBsZSksIHNlZSBlYWNoIHdvcmtlciBmb3IgbW9yZVxuICogZGV0YWlscy4gVGhlIGxhdHRlciBpcyB0aGUgcmVhbCBkYXRhIChTdHJpbmcsIFVpbnQ4QXJyYXksIGV0YykuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSB0aGUgbmFtZSBvZiB0aGUgc3RyZWFtIChtYWlubHkgdXNlZCBmb3IgZGVidWdnaW5nIHB1cnBvc2VzKVxuICovXG5mdW5jdGlvbiBHZW5lcmljV29ya2VyKG5hbWUpIHtcbiAgICAvLyB0aGUgbmFtZSBvZiB0aGUgd29ya2VyXG4gICAgdGhpcy5uYW1lID0gbmFtZSB8fCBcImRlZmF1bHRcIjtcbiAgICAvLyBhbiBvYmplY3QgY29udGFpbmluZyBtZXRhZGF0YSBhYm91dCB0aGUgd29ya2VycyBjaGFpblxuICAgIHRoaXMuc3RyZWFtSW5mbyA9IHt9O1xuICAgIC8vIGFuIGVycm9yIHdoaWNoIGhhcHBlbmVkIHdoZW4gdGhlIHdvcmtlciB3YXMgcGF1c2VkXG4gICAgdGhpcy5nZW5lcmF0ZWRFcnJvciA9IG51bGw7XG4gICAgLy8gYW4gb2JqZWN0IGNvbnRhaW5pbmcgbWV0YWRhdGEgdG8gYmUgbWVyZ2VkIGJ5IHRoaXMgd29ya2VyIGludG8gdGhlIGdlbmVyYWwgbWV0YWRhdGFcbiAgICB0aGlzLmV4dHJhU3RyZWFtSW5mbyA9IHt9O1xuICAgIC8vIHRydWUgaWYgdGhlIHN0cmVhbSBpcyBwYXVzZWQgKGFuZCBzaG91bGQgbm90IGRvIGFueXRoaW5nKSwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgdGhpcy5pc1BhdXNlZCA9IHRydWU7XG4gICAgLy8gdHJ1ZSBpZiB0aGUgc3RyZWFtIGlzIGZpbmlzaGVkIChhbmQgc2hvdWxkIG5vdCBkbyBhbnl0aGluZyksIGZhbHNlIG90aGVyd2lzZVxuICAgIHRoaXMuaXNGaW5pc2hlZCA9IGZhbHNlO1xuICAgIC8vIHRydWUgaWYgdGhlIHN0cmVhbSBpcyBsb2NrZWQgdG8gcHJldmVudCBmdXJ0aGVyIHN0cnVjdHVyZSB1cGRhdGVzIChwaXBlKSwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgdGhpcy5pc0xvY2tlZCA9IGZhbHNlO1xuICAgIC8vIHRoZSBldmVudCBsaXN0ZW5lcnNcbiAgICB0aGlzLl9saXN0ZW5lcnMgPSB7XG4gICAgICAgICdkYXRhJzpbXSxcbiAgICAgICAgJ2VuZCc6W10sXG4gICAgICAgICdlcnJvcic6W11cbiAgICB9O1xuICAgIC8vIHRoZSBwcmV2aW91cyB3b3JrZXIsIGlmIGFueVxuICAgIHRoaXMucHJldmlvdXMgPSBudWxsO1xufVxuXG5HZW5lcmljV29ya2VyLnByb3RvdHlwZSA9IHtcbiAgICAvKipcbiAgICAgKiBQdXNoIGEgY2h1bmsgdG8gdGhlIG5leHQgd29ya2Vycy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY2h1bmsgdGhlIGNodW5rIHRvIHB1c2hcbiAgICAgKi9cbiAgICBwdXNoIDogZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICAgIHRoaXMuZW1pdChcImRhdGFcIiwgY2h1bmspO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogRW5kIHRoZSBzdHJlYW0uXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiB0aGlzIGNhbGwgZW5kZWQgdGhlIHdvcmtlciwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIGVuZCA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNGaW5pc2hlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5mbHVzaCgpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwiZW5kXCIpO1xuICAgICAgICAgICAgdGhpcy5jbGVhblVwKCk7XG4gICAgICAgICAgICB0aGlzLmlzRmluaXNoZWQgPSB0cnVlO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJlcnJvclwiLCBlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEVuZCB0aGUgc3RyZWFtIHdpdGggYW4gZXJyb3IuXG4gICAgICogQHBhcmFtIHtFcnJvcn0gZSB0aGUgZXJyb3Igd2hpY2ggY2F1c2VkIHRoZSBwcmVtYXR1cmUgZW5kLlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgdGhpcyBjYWxsIGVuZGVkIHRoZSB3b3JrZXIgd2l0aCBhbiBlcnJvciwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIGVycm9yIDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNGaW5pc2hlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYodGhpcy5pc1BhdXNlZCkge1xuICAgICAgICAgICAgdGhpcy5nZW5lcmF0ZWRFcnJvciA9IGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmlzRmluaXNoZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJlcnJvclwiLCBlKTtcblxuICAgICAgICAgICAgLy8gaW4gdGhlIHdvcmtlcnMgY2hhaW4gZXhwbG9kZWQgaW4gdGhlIG1pZGRsZSBvZiB0aGUgY2hhaW4sXG4gICAgICAgICAgICAvLyB0aGUgZXJyb3IgZXZlbnQgd2lsbCBnbyBkb3dud2FyZCBidXQgd2UgYWxzbyBuZWVkIHRvIG5vdGlmeVxuICAgICAgICAgICAgLy8gd29ya2VycyB1cHdhcmQgdGhhdCB0aGVyZSBoYXMgYmVlbiBhbiBlcnJvci5cbiAgICAgICAgICAgIGlmKHRoaXMucHJldmlvdXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByZXZpb3VzLmVycm9yKGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmNsZWFuVXAoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEFkZCBhIGNhbGxiYWNrIG9uIGFuIGV2ZW50LlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIHRoZSBuYW1lIG9mIHRoZSBldmVudCAoZGF0YSwgZW5kLCBlcnJvcilcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lciB0aGUgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIHRoZSBldmVudCBpcyB0cmlnZ2VyZWRcbiAgICAgKiBAcmV0dXJuIHtHZW5lcmljV29ya2VyfSB0aGUgY3VycmVudCBvYmplY3QgZm9yIGNoYWluYWJpbGl0eVxuICAgICAqL1xuICAgIG9uIDogZnVuY3Rpb24gKG5hbWUsIGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuX2xpc3RlbmVyc1tuYW1lXS5wdXNoKGxpc3RlbmVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBDbGVhbiBhbnkgcmVmZXJlbmNlcyB3aGVuIGEgd29ya2VyIGlzIGVuZGluZy5cbiAgICAgKi9cbiAgICBjbGVhblVwIDogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnN0cmVhbUluZm8gPSB0aGlzLmdlbmVyYXRlZEVycm9yID0gdGhpcy5leHRyYVN0cmVhbUluZm8gPSBudWxsO1xuICAgICAgICB0aGlzLl9saXN0ZW5lcnMgPSBbXTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRyaWdnZXIgYW4gZXZlbnQuIFRoaXMgd2lsbCBjYWxsIHJlZ2lzdGVyZWQgY2FsbGJhY2sgd2l0aCB0aGUgcHJvdmlkZWQgYXJnLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIHRoZSBuYW1lIG9mIHRoZSBldmVudCAoZGF0YSwgZW5kLCBlcnJvcilcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYXJnIHRoZSBhcmd1bWVudCB0byBjYWxsIHRoZSBjYWxsYmFjayB3aXRoLlxuICAgICAqL1xuICAgIGVtaXQgOiBmdW5jdGlvbiAobmFtZSwgYXJnKSB7XG4gICAgICAgIGlmICh0aGlzLl9saXN0ZW5lcnNbbmFtZV0pIHtcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLl9saXN0ZW5lcnNbbmFtZV0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9saXN0ZW5lcnNbbmFtZV1baV0uY2FsbCh0aGlzLCBhcmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBDaGFpbiBhIHdvcmtlciB3aXRoIGFuIG90aGVyLlxuICAgICAqIEBwYXJhbSB7V29ya2VyfSBuZXh0IHRoZSB3b3JrZXIgcmVjZWl2aW5nIGV2ZW50cyBmcm9tIHRoZSBjdXJyZW50IG9uZS5cbiAgICAgKiBAcmV0dXJuIHt3b3JrZXJ9IHRoZSBuZXh0IHdvcmtlciBmb3IgY2hhaW5hYmlsaXR5XG4gICAgICovXG4gICAgcGlwZSA6IGZ1bmN0aW9uIChuZXh0KSB7XG4gICAgICAgIHJldHVybiBuZXh0LnJlZ2lzdGVyUHJldmlvdXModGhpcyk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBTYW1lIGFzIGBwaXBlYCBpbiB0aGUgb3RoZXIgZGlyZWN0aW9uLlxuICAgICAqIFVzaW5nIGFuIEFQSSB3aXRoIGBwaXBlKG5leHQpYCBpcyB2ZXJ5IGVhc3kuXG4gICAgICogSW1wbGVtZW50aW5nIHRoZSBBUEkgd2l0aCB0aGUgcG9pbnQgb2YgdmlldyBvZiB0aGUgbmV4dCBvbmUgcmVnaXN0ZXJpbmdcbiAgICAgKiBhIHNvdXJjZSBpcyBlYXNpZXIsIHNlZSB0aGUgWmlwRmlsZVdvcmtlci5cbiAgICAgKiBAcGFyYW0ge1dvcmtlcn0gcHJldmlvdXMgdGhlIHByZXZpb3VzIHdvcmtlciwgc2VuZGluZyBldmVudHMgdG8gdGhpcyBvbmVcbiAgICAgKiBAcmV0dXJuIHtXb3JrZXJ9IHRoZSBjdXJyZW50IHdvcmtlciBmb3IgY2hhaW5hYmlsaXR5XG4gICAgICovXG4gICAgcmVnaXN0ZXJQcmV2aW91cyA6IGZ1bmN0aW9uIChwcmV2aW91cykge1xuICAgICAgICBpZiAodGhpcy5pc0xvY2tlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHN0cmVhbSAnXCIgKyB0aGlzICsgXCInIGhhcyBhbHJlYWR5IGJlZW4gdXNlZC5cIik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzaGFyaW5nIHRoZSBzdHJlYW1JbmZvLi4uXG4gICAgICAgIHRoaXMuc3RyZWFtSW5mbyA9IHByZXZpb3VzLnN0cmVhbUluZm87XG4gICAgICAgIC8vIC4uLiBhbmQgYWRkaW5nIG91ciBvd24gYml0c1xuICAgICAgICB0aGlzLm1lcmdlU3RyZWFtSW5mbygpO1xuICAgICAgICB0aGlzLnByZXZpb3VzID0gIHByZXZpb3VzO1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHByZXZpb3VzLm9uKCdkYXRhJywgZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICAgICAgICBzZWxmLnByb2Nlc3NDaHVuayhjaHVuayk7XG4gICAgICAgIH0pO1xuICAgICAgICBwcmV2aW91cy5vbignZW5kJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc2VsZi5lbmQoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHByZXZpb3VzLm9uKCdlcnJvcicsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBzZWxmLmVycm9yKGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBQYXVzZSB0aGUgc3RyZWFtIHNvIGl0IGRvZXNuJ3Qgc2VuZCBldmVudHMgYW55bW9yZS5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHRoaXMgY2FsbCBwYXVzZWQgdGhlIHdvcmtlciwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIHBhdXNlIDogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZih0aGlzLmlzUGF1c2VkIHx8IHRoaXMuaXNGaW5pc2hlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNQYXVzZWQgPSB0cnVlO1xuXG4gICAgICAgIGlmKHRoaXMucHJldmlvdXMpIHtcbiAgICAgICAgICAgIHRoaXMucHJldmlvdXMucGF1c2UoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJlc3VtZSBhIHBhdXNlZCBzdHJlYW0uXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiB0aGlzIGNhbGwgcmVzdW1lZCB0aGUgd29ya2VyLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgcmVzdW1lIDogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZighdGhpcy5pc1BhdXNlZCB8fCB0aGlzLmlzRmluaXNoZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzUGF1c2VkID0gZmFsc2U7XG5cbiAgICAgICAgLy8gaWYgdHJ1ZSwgdGhlIHdvcmtlciB0cmllZCB0byByZXN1bWUgYnV0IGZhaWxlZFxuICAgICAgICB2YXIgd2l0aEVycm9yID0gZmFsc2U7XG4gICAgICAgIGlmKHRoaXMuZ2VuZXJhdGVkRXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMuZXJyb3IodGhpcy5nZW5lcmF0ZWRFcnJvcik7XG4gICAgICAgICAgICB3aXRoRXJyb3IgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmKHRoaXMucHJldmlvdXMpIHtcbiAgICAgICAgICAgIHRoaXMucHJldmlvdXMucmVzdW1lKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gIXdpdGhFcnJvcjtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEZsdXNoIGFueSByZW1haW5pbmcgYnl0ZXMgYXMgdGhlIHN0cmVhbSBpcyBlbmRpbmcuXG4gICAgICovXG4gICAgZmx1c2ggOiBmdW5jdGlvbiAoKSB7fSxcbiAgICAvKipcbiAgICAgKiBQcm9jZXNzIGEgY2h1bmsuIFRoaXMgaXMgdXN1YWxseSB0aGUgbWV0aG9kIG92ZXJyaWRkZW4uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNodW5rIHRoZSBjaHVuayB0byBwcm9jZXNzLlxuICAgICAqL1xuICAgIHByb2Nlc3NDaHVuayA6IGZ1bmN0aW9uKGNodW5rKSB7XG4gICAgICAgIHRoaXMucHVzaChjaHVuayk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBBZGQgYSBrZXkvdmFsdWUgdG8gYmUgYWRkZWQgaW4gdGhlIHdvcmtlcnMgY2hhaW4gc3RyZWFtSW5mbyBvbmNlIGFjdGl2YXRlZC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5IHRoZSBrZXkgdG8gdXNlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlIHRoZSBhc3NvY2lhdGVkIHZhbHVlXG4gICAgICogQHJldHVybiB7V29ya2VyfSB0aGUgY3VycmVudCB3b3JrZXIgZm9yIGNoYWluYWJpbGl0eVxuICAgICAqL1xuICAgIHdpdGhTdHJlYW1JbmZvIDogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5leHRyYVN0cmVhbUluZm9ba2V5XSA9IHZhbHVlO1xuICAgICAgICB0aGlzLm1lcmdlU3RyZWFtSW5mbygpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIE1lcmdlIHRoaXMgd29ya2VyJ3Mgc3RyZWFtSW5mbyBpbnRvIHRoZSBjaGFpbidzIHN0cmVhbUluZm8uXG4gICAgICovXG4gICAgbWVyZ2VTdHJlYW1JbmZvIDogZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3IodmFyIGtleSBpbiB0aGlzLmV4dHJhU3RyZWFtSW5mbykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmV4dHJhU3RyZWFtSW5mby5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnN0cmVhbUluZm9ba2V5XSA9IHRoaXMuZXh0cmFTdHJlYW1JbmZvW2tleV07XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTG9jayB0aGUgc3RyZWFtIHRvIHByZXZlbnQgZnVydGhlciB1cGRhdGVzIG9uIHRoZSB3b3JrZXJzIGNoYWluLlxuICAgICAqIEFmdGVyIGNhbGxpbmcgdGhpcyBtZXRob2QsIGFsbCBjYWxscyB0byBwaXBlIHdpbGwgZmFpbC5cbiAgICAgKi9cbiAgICBsb2NrOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzTG9ja2VkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgc3RyZWFtICdcIiArIHRoaXMgKyBcIicgaGFzIGFscmVhZHkgYmVlbiB1c2VkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzTG9ja2VkID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMucHJldmlvdXMpIHtcbiAgICAgICAgICAgIHRoaXMucHJldmlvdXMubG9jaygpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogUHJldHR5IHByaW50IHRoZSB3b3JrZXJzIGNoYWluLlxuICAgICAqL1xuICAgIHRvU3RyaW5nIDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbWUgPSBcIldvcmtlciBcIiArIHRoaXMubmFtZTtcbiAgICAgICAgaWYgKHRoaXMucHJldmlvdXMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByZXZpb3VzICsgXCIgLT4gXCIgKyBtZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBtZTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gR2VuZXJpY1dvcmtlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcbnZhciBDb252ZXJ0V29ya2VyID0gcmVxdWlyZSgnLi9Db252ZXJ0V29ya2VyJyk7XG52YXIgR2VuZXJpY1dvcmtlciA9IHJlcXVpcmUoJy4vR2VuZXJpY1dvcmtlcicpO1xudmFyIGJhc2U2NCA9IHJlcXVpcmUoJy4uL2Jhc2U2NCcpO1xudmFyIHN1cHBvcnQgPSByZXF1aXJlKFwiLi4vc3VwcG9ydFwiKTtcbnZhciBleHRlcm5hbCA9IHJlcXVpcmUoXCIuLi9leHRlcm5hbFwiKTtcblxudmFyIE5vZGVqc1N0cmVhbU91dHB1dEFkYXB0ZXIgPSBudWxsO1xuaWYgKHN1cHBvcnQubm9kZXN0cmVhbSkge1xuICAgIHRyeSB7XG4gICAgICAgIE5vZGVqc1N0cmVhbU91dHB1dEFkYXB0ZXIgPSByZXF1aXJlKCcuLi9ub2RlanMvTm9kZWpzU3RyZWFtT3V0cHV0QWRhcHRlcicpO1xuICAgIH0gY2F0Y2goZSkge31cbn1cblxuLyoqXG4gKiBBcHBseSB0aGUgZmluYWwgdHJhbnNmb3JtYXRpb24gb2YgdGhlIGRhdGEuIElmIHRoZSB1c2VyIHdhbnRzIGEgQmxvYiBmb3JcbiAqIGV4YW1wbGUsIGl0J3MgZWFzaWVyIHRvIHdvcmsgd2l0aCBhbiBVOGludEFycmF5IGFuZCBmaW5hbGx5IGRvIHRoZVxuICogQXJyYXlCdWZmZXIvQmxvYiBjb252ZXJzaW9uLlxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgdGhlIG5hbWUgb2YgdGhlIGZpbmFsIHR5cGVcbiAqIEBwYXJhbSB7U3RyaW5nfFVpbnQ4QXJyYXl8QnVmZmVyfSBjb250ZW50IHRoZSBjb250ZW50IHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHtTdHJpbmd9IG1pbWVUeXBlIHRoZSBtaW1lIHR5cGUgb2YgdGhlIGNvbnRlbnQsIGlmIGFwcGxpY2FibGUuXG4gKiBAcmV0dXJuIHtTdHJpbmd8VWludDhBcnJheXxBcnJheUJ1ZmZlcnxCdWZmZXJ8QmxvYn0gdGhlIGNvbnRlbnQgaW4gdGhlIHJpZ2h0IGZvcm1hdC5cbiAqL1xuZnVuY3Rpb24gdHJhbnNmb3JtWmlwT3V0cHV0KHR5cGUsIGNvbnRlbnQsIG1pbWVUeXBlKSB7XG4gICAgc3dpdGNoKHR5cGUpIHtcbiAgICAgICAgY2FzZSBcImJsb2JcIiA6XG4gICAgICAgICAgICByZXR1cm4gdXRpbHMubmV3QmxvYih1dGlscy50cmFuc2Zvcm1UbyhcImFycmF5YnVmZmVyXCIsIGNvbnRlbnQpLCBtaW1lVHlwZSk7XG4gICAgICAgIGNhc2UgXCJiYXNlNjRcIiA6XG4gICAgICAgICAgICByZXR1cm4gYmFzZTY0LmVuY29kZShjb250ZW50KTtcbiAgICAgICAgZGVmYXVsdCA6XG4gICAgICAgICAgICByZXR1cm4gdXRpbHMudHJhbnNmb3JtVG8odHlwZSwgY29udGVudCk7XG4gICAgfVxufVxuXG4vKipcbiAqIENvbmNhdGVuYXRlIGFuIGFycmF5IG9mIGRhdGEgb2YgdGhlIGdpdmVuIHR5cGUuXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZSB0aGUgdHlwZSBvZiB0aGUgZGF0YSBpbiB0aGUgZ2l2ZW4gYXJyYXkuXG4gKiBAcGFyYW0ge0FycmF5fSBkYXRhQXJyYXkgdGhlIGFycmF5IGNvbnRhaW5pbmcgdGhlIGRhdGEgY2h1bmtzIHRvIGNvbmNhdGVuYXRlXG4gKiBAcmV0dXJuIHtTdHJpbmd8VWludDhBcnJheXxCdWZmZXJ9IHRoZSBjb25jYXRlbmF0ZWQgZGF0YVxuICogQHRocm93cyBFcnJvciBpZiB0aGUgYXNrZWQgdHlwZSBpcyB1bnN1cHBvcnRlZFxuICovXG5mdW5jdGlvbiBjb25jYXQgKHR5cGUsIGRhdGFBcnJheSkge1xuICAgIHZhciBpLCBpbmRleCA9IDAsIHJlcyA9IG51bGwsIHRvdGFsTGVuZ3RoID0gMDtcbiAgICBmb3IoaSA9IDA7IGkgPCBkYXRhQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdG90YWxMZW5ndGggKz0gZGF0YUFycmF5W2ldLmxlbmd0aDtcbiAgICB9XG4gICAgc3dpdGNoKHR5cGUpIHtcbiAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgcmV0dXJuIGRhdGFBcnJheS5qb2luKFwiXCIpO1xuICAgICAgICAgIGNhc2UgXCJhcnJheVwiOlxuICAgICAgICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoW10sIGRhdGFBcnJheSk7XG4gICAgICAgIGNhc2UgXCJ1aW50OGFycmF5XCI6XG4gICAgICAgICAgICByZXMgPSBuZXcgVWludDhBcnJheSh0b3RhbExlbmd0aCk7XG4gICAgICAgICAgICBmb3IoaSA9IDA7IGkgPCBkYXRhQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICByZXMuc2V0KGRhdGFBcnJheVtpXSwgaW5kZXgpO1xuICAgICAgICAgICAgICAgIGluZGV4ICs9IGRhdGFBcnJheVtpXS5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICBjYXNlIFwibm9kZWJ1ZmZlclwiOlxuICAgICAgICAgICAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoZGF0YUFycmF5KTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImNvbmNhdCA6IHVuc3VwcG9ydGVkIHR5cGUgJ1wiICArIHR5cGUgKyBcIidcIik7XG4gICAgfVxufVxuXG4vKipcbiAqIExpc3RlbiBhIFN0cmVhbUhlbHBlciwgYWNjdW11bGF0ZSBpdHMgY29udGVudCBhbmQgY29uY2F0ZW5hdGUgaXQgaW50byBhXG4gKiBjb21wbGV0ZSBibG9jay5cbiAqIEBwYXJhbSB7U3RyZWFtSGVscGVyfSBoZWxwZXIgdGhlIGhlbHBlciB0byB1c2UuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB1cGRhdGVDYWxsYmFjayBhIGNhbGxiYWNrIGNhbGxlZCBvbiBlYWNoIHVwZGF0ZS4gQ2FsbGVkXG4gKiB3aXRoIG9uZSBhcmcgOlxuICogLSB0aGUgbWV0YWRhdGEgbGlua2VkIHRvIHRoZSB1cGRhdGUgcmVjZWl2ZWQuXG4gKiBAcmV0dXJuIFByb21pc2UgdGhlIHByb21pc2UgZm9yIHRoZSBhY2N1bXVsYXRpb24uXG4gKi9cbmZ1bmN0aW9uIGFjY3VtdWxhdGUoaGVscGVyLCB1cGRhdGVDYWxsYmFjaykge1xuICAgIHJldHVybiBuZXcgZXh0ZXJuYWwuUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KXtcbiAgICAgICAgdmFyIGRhdGFBcnJheSA9IFtdO1xuICAgICAgICB2YXIgY2h1bmtUeXBlID0gaGVscGVyLl9pbnRlcm5hbFR5cGUsXG4gICAgICAgICAgICByZXN1bHRUeXBlID0gaGVscGVyLl9vdXRwdXRUeXBlLFxuICAgICAgICAgICAgbWltZVR5cGUgPSBoZWxwZXIuX21pbWVUeXBlO1xuICAgICAgICBoZWxwZXJcbiAgICAgICAgLm9uKCdkYXRhJywgZnVuY3Rpb24gKGRhdGEsIG1ldGEpIHtcbiAgICAgICAgICAgIGRhdGFBcnJheS5wdXNoKGRhdGEpO1xuICAgICAgICAgICAgaWYodXBkYXRlQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICB1cGRhdGVDYWxsYmFjayhtZXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgLm9uKCdlcnJvcicsIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgZGF0YUFycmF5ID0gW107XG4gICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgfSlcbiAgICAgICAgLm9uKCdlbmQnLCBmdW5jdGlvbiAoKXtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRyYW5zZm9ybVppcE91dHB1dChyZXN1bHRUeXBlLCBjb25jYXQoY2h1bmtUeXBlLCBkYXRhQXJyYXkpLCBtaW1lVHlwZSk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRhdGFBcnJheSA9IFtdO1xuICAgICAgICB9KVxuICAgICAgICAucmVzdW1lKCk7XG4gICAgfSk7XG59XG5cbi8qKlxuICogQW4gaGVscGVyIHRvIGVhc2lseSB1c2Ugd29ya2VycyBvdXRzaWRlIG9mIEpTWmlwLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1dvcmtlcn0gd29ya2VyIHRoZSB3b3JrZXIgdG8gd3JhcFxuICogQHBhcmFtIHtTdHJpbmd9IG91dHB1dFR5cGUgdGhlIHR5cGUgb2YgZGF0YSBleHBlY3RlZCBieSB0aGUgdXNlXG4gKiBAcGFyYW0ge1N0cmluZ30gbWltZVR5cGUgdGhlIG1pbWUgdHlwZSBvZiB0aGUgY29udGVudCwgaWYgYXBwbGljYWJsZS5cbiAqL1xuZnVuY3Rpb24gU3RyZWFtSGVscGVyKHdvcmtlciwgb3V0cHV0VHlwZSwgbWltZVR5cGUpIHtcbiAgICB2YXIgaW50ZXJuYWxUeXBlID0gb3V0cHV0VHlwZTtcbiAgICBzd2l0Y2gob3V0cHV0VHlwZSkge1xuICAgICAgICBjYXNlIFwiYmxvYlwiOlxuICAgICAgICBjYXNlIFwiYXJyYXlidWZmZXJcIjpcbiAgICAgICAgICAgIGludGVybmFsVHlwZSA9IFwidWludDhhcnJheVwiO1xuICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImJhc2U2NFwiOlxuICAgICAgICAgICAgaW50ZXJuYWxUeXBlID0gXCJzdHJpbmdcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgICAgLy8gdGhlIHR5cGUgdXNlZCBpbnRlcm5hbGx5XG4gICAgICAgIHRoaXMuX2ludGVybmFsVHlwZSA9IGludGVybmFsVHlwZTtcbiAgICAgICAgLy8gdGhlIHR5cGUgdXNlZCB0byBvdXRwdXQgcmVzdWx0c1xuICAgICAgICB0aGlzLl9vdXRwdXRUeXBlID0gb3V0cHV0VHlwZTtcbiAgICAgICAgLy8gdGhlIG1pbWUgdHlwZVxuICAgICAgICB0aGlzLl9taW1lVHlwZSA9IG1pbWVUeXBlO1xuICAgICAgICB1dGlscy5jaGVja1N1cHBvcnQoaW50ZXJuYWxUeXBlKTtcbiAgICAgICAgdGhpcy5fd29ya2VyID0gd29ya2VyLnBpcGUobmV3IENvbnZlcnRXb3JrZXIoaW50ZXJuYWxUeXBlKSk7XG4gICAgICAgIC8vIHRoZSBsYXN0IHdvcmtlcnMgY2FuIGJlIHJld2lyZWQgd2l0aG91dCBpc3N1ZXMgYnV0IHdlIG5lZWQgdG9cbiAgICAgICAgLy8gcHJldmVudCBhbnkgdXBkYXRlcyBvbiBwcmV2aW91cyB3b3JrZXJzLlxuICAgICAgICB3b3JrZXIubG9jaygpO1xuICAgIH0gY2F0Y2goZSkge1xuICAgICAgICB0aGlzLl93b3JrZXIgPSBuZXcgR2VuZXJpY1dvcmtlcihcImVycm9yXCIpO1xuICAgICAgICB0aGlzLl93b3JrZXIuZXJyb3IoZSk7XG4gICAgfVxufVxuXG5TdHJlYW1IZWxwZXIucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAqIExpc3RlbiBhIFN0cmVhbUhlbHBlciwgYWNjdW11bGF0ZSBpdHMgY29udGVudCBhbmQgY29uY2F0ZW5hdGUgaXQgaW50byBhXG4gICAgICogY29tcGxldGUgYmxvY2suXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gdXBkYXRlQ2IgdGhlIHVwZGF0ZSBjYWxsYmFjay5cbiAgICAgKiBAcmV0dXJuIFByb21pc2UgdGhlIHByb21pc2UgZm9yIHRoZSBhY2N1bXVsYXRpb24uXG4gICAgICovXG4gICAgYWNjdW11bGF0ZSA6IGZ1bmN0aW9uICh1cGRhdGVDYikge1xuICAgICAgICByZXR1cm4gYWNjdW11bGF0ZSh0aGlzLCB1cGRhdGVDYik7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBBZGQgYSBsaXN0ZW5lciBvbiBhbiBldmVudCB0cmlnZ2VyZWQgb24gYSBzdHJlYW0uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGV2dCB0aGUgbmFtZSBvZiB0aGUgZXZlbnRcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiB0aGUgbGlzdGVuZXJcbiAgICAgKiBAcmV0dXJuIHtTdHJlYW1IZWxwZXJ9IHRoZSBjdXJyZW50IGhlbHBlci5cbiAgICAgKi9cbiAgICBvbiA6IGZ1bmN0aW9uIChldnQsIGZuKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICBpZihldnQgPT09IFwiZGF0YVwiKSB7XG4gICAgICAgICAgICB0aGlzLl93b3JrZXIub24oZXZ0LCBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgICAgICAgICAgICBmbi5jYWxsKHNlbGYsIGNodW5rLmRhdGEsIGNodW5rLm1ldGEpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl93b3JrZXIub24oZXZ0LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdXRpbHMuZGVsYXkoZm4sIGFyZ3VtZW50cywgc2VsZik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJlc3VtZSB0aGUgZmxvdyBvZiBjaHVua3MuXG4gICAgICogQHJldHVybiB7U3RyZWFtSGVscGVyfSB0aGUgY3VycmVudCBoZWxwZXIuXG4gICAgICovXG4gICAgcmVzdW1lIDogZnVuY3Rpb24gKCkge1xuICAgICAgICB1dGlscy5kZWxheSh0aGlzLl93b3JrZXIucmVzdW1lLCBbXSwgdGhpcy5fd29ya2VyKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBQYXVzZSB0aGUgZmxvdyBvZiBjaHVua3MuXG4gICAgICogQHJldHVybiB7U3RyZWFtSGVscGVyfSB0aGUgY3VycmVudCBoZWxwZXIuXG4gICAgICovXG4gICAgcGF1c2UgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3dvcmtlci5wYXVzZSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIG5vZGVqcyBzdHJlYW0gZm9yIHRoaXMgaGVscGVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHVwZGF0ZUNiIHRoZSB1cGRhdGUgY2FsbGJhY2suXG4gICAgICogQHJldHVybiB7Tm9kZWpzU3RyZWFtT3V0cHV0QWRhcHRlcn0gdGhlIG5vZGVqcyBzdHJlYW0uXG4gICAgICovXG4gICAgdG9Ob2RlanNTdHJlYW0gOiBmdW5jdGlvbiAodXBkYXRlQ2IpIHtcbiAgICAgICAgdXRpbHMuY2hlY2tTdXBwb3J0KFwibm9kZXN0cmVhbVwiKTtcbiAgICAgICAgaWYgKHRoaXMuX291dHB1dFR5cGUgIT09IFwibm9kZWJ1ZmZlclwiKSB7XG4gICAgICAgICAgICAvLyBhbiBvYmplY3Qgc3RyZWFtIGNvbnRhaW5pbmcgYmxvYi9hcnJheWJ1ZmZlci91aW50OGFycmF5L3N0cmluZ1xuICAgICAgICAgICAgLy8gaXMgc3RyYW5nZSBhbmQgSSBkb24ndCBrbm93IGlmIGl0IHdvdWxkIGJlIHVzZWZ1bC5cbiAgICAgICAgICAgIC8vIEkgeW91IGZpbmQgdGhpcyBjb21tZW50IGFuZCBoYXZlIGEgZ29vZCB1c2VjYXNlLCBwbGVhc2Ugb3BlbiBhXG4gICAgICAgICAgICAvLyBidWcgcmVwb3J0ICFcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcih0aGlzLl9vdXRwdXRUeXBlICsgXCIgaXMgbm90IHN1cHBvcnRlZCBieSB0aGlzIG1ldGhvZFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgTm9kZWpzU3RyZWFtT3V0cHV0QWRhcHRlcih0aGlzLCB7XG4gICAgICAgICAgICBvYmplY3RNb2RlIDogdGhpcy5fb3V0cHV0VHlwZSAhPT0gXCJub2RlYnVmZmVyXCJcbiAgICAgICAgfSwgdXBkYXRlQ2IpO1xuICAgIH1cbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBTdHJlYW1IZWxwZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuYmFzZTY0ID0gdHJ1ZTtcbmV4cG9ydHMuYXJyYXkgPSB0cnVlO1xuZXhwb3J0cy5zdHJpbmcgPSB0cnVlO1xuZXhwb3J0cy5hcnJheWJ1ZmZlciA9IHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgVWludDhBcnJheSAhPT0gXCJ1bmRlZmluZWRcIjtcbmV4cG9ydHMubm9kZWJ1ZmZlciA9IHR5cGVvZiBCdWZmZXIgIT09IFwidW5kZWZpbmVkXCI7XG4vLyBjb250YWlucyB0cnVlIGlmIEpTWmlwIGNhbiByZWFkL2dlbmVyYXRlIFVpbnQ4QXJyYXksIGZhbHNlIG90aGVyd2lzZS5cbmV4cG9ydHMudWludDhhcnJheSA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSBcInVuZGVmaW5lZFwiO1xuXG5pZiAodHlwZW9mIEFycmF5QnVmZmVyID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgZXhwb3J0cy5ibG9iID0gZmFsc2U7XG59XG5lbHNlIHtcbiAgICB2YXIgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKDApO1xuICAgIHRyeSB7XG4gICAgICAgIGV4cG9ydHMuYmxvYiA9IG5ldyBCbG9iKFtidWZmZXJdLCB7XG4gICAgICAgICAgICB0eXBlOiBcImFwcGxpY2F0aW9uL3ppcFwiXG4gICAgICAgIH0pLnNpemUgPT09IDA7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgQnVpbGRlciA9IHNlbGYuQmxvYkJ1aWxkZXIgfHwgc2VsZi5XZWJLaXRCbG9iQnVpbGRlciB8fCBzZWxmLk1vekJsb2JCdWlsZGVyIHx8IHNlbGYuTVNCbG9iQnVpbGRlcjtcbiAgICAgICAgICAgIHZhciBidWlsZGVyID0gbmV3IEJ1aWxkZXIoKTtcbiAgICAgICAgICAgIGJ1aWxkZXIuYXBwZW5kKGJ1ZmZlcik7XG4gICAgICAgICAgICBleHBvcnRzLmJsb2IgPSBidWlsZGVyLmdldEJsb2IoJ2FwcGxpY2F0aW9uL3ppcCcpLnNpemUgPT09IDA7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGV4cG9ydHMuYmxvYiA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxufVxuXG50cnkge1xuICAgIGV4cG9ydHMubm9kZXN0cmVhbSA9ICEhcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtJykuUmVhZGFibGU7XG59IGNhdGNoKGUpIHtcbiAgICBleHBvcnRzLm5vZGVzdHJlYW0gPSBmYWxzZTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIHN1cHBvcnQgPSByZXF1aXJlKCcuL3N1cHBvcnQnKTtcbnZhciBub2RlanNVdGlscyA9IHJlcXVpcmUoJy4vbm9kZWpzVXRpbHMnKTtcbnZhciBHZW5lcmljV29ya2VyID0gcmVxdWlyZSgnLi9zdHJlYW0vR2VuZXJpY1dvcmtlcicpO1xuXG4vKipcbiAqIFRoZSBmb2xsb3dpbmcgZnVuY3Rpb25zIGNvbWUgZnJvbSBwYWtvLCBmcm9tIHBha28vbGliL3V0aWxzL3N0cmluZ3NcbiAqIHJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSwgc2VlIHBha28gaHR0cHM6Ly9naXRodWIuY29tL25vZGVjYS9wYWtvL1xuICovXG5cbi8vIFRhYmxlIHdpdGggdXRmOCBsZW5ndGhzIChjYWxjdWxhdGVkIGJ5IGZpcnN0IGJ5dGUgb2Ygc2VxdWVuY2UpXG4vLyBOb3RlLCB0aGF0IDUgJiA2LWJ5dGUgdmFsdWVzIGFuZCBzb21lIDQtYnl0ZSB2YWx1ZXMgY2FuIG5vdCBiZSByZXByZXNlbnRlZCBpbiBKUyxcbi8vIGJlY2F1c2UgbWF4IHBvc3NpYmxlIGNvZGVwb2ludCBpcyAweDEwZmZmZlxudmFyIF91dGY4bGVuID0gbmV3IEFycmF5KDI1Nik7XG5mb3IgKHZhciBpPTA7IGk8MjU2OyBpKyspIHtcbiAgX3V0ZjhsZW5baV0gPSAoaSA+PSAyNTIgPyA2IDogaSA+PSAyNDggPyA1IDogaSA+PSAyNDAgPyA0IDogaSA+PSAyMjQgPyAzIDogaSA+PSAxOTIgPyAyIDogMSk7XG59XG5fdXRmOGxlblsyNTRdPV91dGY4bGVuWzI1NF09MTsgLy8gSW52YWxpZCBzZXF1ZW5jZSBzdGFydFxuXG4vLyBjb252ZXJ0IHN0cmluZyB0byBhcnJheSAodHlwZWQsIHdoZW4gcG9zc2libGUpXG52YXIgc3RyaW5nMmJ1ZiA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICB2YXIgYnVmLCBjLCBjMiwgbV9wb3MsIGksIHN0cl9sZW4gPSBzdHIubGVuZ3RoLCBidWZfbGVuID0gMDtcblxuICAgIC8vIGNvdW50IGJpbmFyeSBzaXplXG4gICAgZm9yIChtX3BvcyA9IDA7IG1fcG9zIDwgc3RyX2xlbjsgbV9wb3MrKykge1xuICAgICAgICBjID0gc3RyLmNoYXJDb2RlQXQobV9wb3MpO1xuICAgICAgICBpZiAoKGMgJiAweGZjMDApID09PSAweGQ4MDAgJiYgKG1fcG9zKzEgPCBzdHJfbGVuKSkge1xuICAgICAgICAgICAgYzIgPSBzdHIuY2hhckNvZGVBdChtX3BvcysxKTtcbiAgICAgICAgICAgIGlmICgoYzIgJiAweGZjMDApID09PSAweGRjMDApIHtcbiAgICAgICAgICAgICAgICBjID0gMHgxMDAwMCArICgoYyAtIDB4ZDgwMCkgPDwgMTApICsgKGMyIC0gMHhkYzAwKTtcbiAgICAgICAgICAgICAgICBtX3BvcysrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJ1Zl9sZW4gKz0gYyA8IDB4ODAgPyAxIDogYyA8IDB4ODAwID8gMiA6IGMgPCAweDEwMDAwID8gMyA6IDQ7XG4gICAgfVxuXG4gICAgLy8gYWxsb2NhdGUgYnVmZmVyXG4gICAgaWYgKHN1cHBvcnQudWludDhhcnJheSkge1xuICAgICAgICBidWYgPSBuZXcgVWludDhBcnJheShidWZfbGVuKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBidWYgPSBuZXcgQXJyYXkoYnVmX2xlbik7XG4gICAgfVxuXG4gICAgLy8gY29udmVydFxuICAgIGZvciAoaT0wLCBtX3BvcyA9IDA7IGkgPCBidWZfbGVuOyBtX3BvcysrKSB7XG4gICAgICAgIGMgPSBzdHIuY2hhckNvZGVBdChtX3Bvcyk7XG4gICAgICAgIGlmICgoYyAmIDB4ZmMwMCkgPT09IDB4ZDgwMCAmJiAobV9wb3MrMSA8IHN0cl9sZW4pKSB7XG4gICAgICAgICAgICBjMiA9IHN0ci5jaGFyQ29kZUF0KG1fcG9zKzEpO1xuICAgICAgICAgICAgaWYgKChjMiAmIDB4ZmMwMCkgPT09IDB4ZGMwMCkge1xuICAgICAgICAgICAgICAgIGMgPSAweDEwMDAwICsgKChjIC0gMHhkODAwKSA8PCAxMCkgKyAoYzIgLSAweGRjMDApO1xuICAgICAgICAgICAgICAgIG1fcG9zKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGMgPCAweDgwKSB7XG4gICAgICAgICAgICAvKiBvbmUgYnl0ZSAqL1xuICAgICAgICAgICAgYnVmW2krK10gPSBjO1xuICAgICAgICB9IGVsc2UgaWYgKGMgPCAweDgwMCkge1xuICAgICAgICAgICAgLyogdHdvIGJ5dGVzICovXG4gICAgICAgICAgICBidWZbaSsrXSA9IDB4QzAgfCAoYyA+Pj4gNik7XG4gICAgICAgICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyAmIDB4M2YpO1xuICAgICAgICB9IGVsc2UgaWYgKGMgPCAweDEwMDAwKSB7XG4gICAgICAgICAgICAvKiB0aHJlZSBieXRlcyAqL1xuICAgICAgICAgICAgYnVmW2krK10gPSAweEUwIHwgKGMgPj4+IDEyKTtcbiAgICAgICAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjID4+PiA2ICYgMHgzZik7XG4gICAgICAgICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyAmIDB4M2YpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLyogZm91ciBieXRlcyAqL1xuICAgICAgICAgICAgYnVmW2krK10gPSAweGYwIHwgKGMgPj4+IDE4KTtcbiAgICAgICAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjID4+PiAxMiAmIDB4M2YpO1xuICAgICAgICAgICAgYnVmW2krK10gPSAweDgwIHwgKGMgPj4+IDYgJiAweDNmKTtcbiAgICAgICAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjICYgMHgzZik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYnVmO1xufTtcblxuLy8gQ2FsY3VsYXRlIG1heCBwb3NzaWJsZSBwb3NpdGlvbiBpbiB1dGY4IGJ1ZmZlcixcbi8vIHRoYXQgd2lsbCBub3QgYnJlYWsgc2VxdWVuY2UuIElmIHRoYXQncyBub3QgcG9zc2libGVcbi8vIC0gKHZlcnkgc21hbGwgbGltaXRzKSByZXR1cm4gbWF4IHNpemUgYXMgaXMuXG4vL1xuLy8gYnVmW10gLSB1dGY4IGJ5dGVzIGFycmF5XG4vLyBtYXggICAtIGxlbmd0aCBsaW1pdCAobWFuZGF0b3J5KTtcbnZhciB1dGY4Ym9yZGVyID0gZnVuY3Rpb24oYnVmLCBtYXgpIHtcbiAgICB2YXIgcG9zO1xuXG4gICAgbWF4ID0gbWF4IHx8IGJ1Zi5sZW5ndGg7XG4gICAgaWYgKG1heCA+IGJ1Zi5sZW5ndGgpIHsgbWF4ID0gYnVmLmxlbmd0aDsgfVxuXG4gICAgLy8gZ28gYmFjayBmcm9tIGxhc3QgcG9zaXRpb24sIHVudGlsIHN0YXJ0IG9mIHNlcXVlbmNlIGZvdW5kXG4gICAgcG9zID0gbWF4LTE7XG4gICAgd2hpbGUgKHBvcyA+PSAwICYmIChidWZbcG9zXSAmIDB4QzApID09PSAweDgwKSB7IHBvcy0tOyB9XG5cbiAgICAvLyBGdWNrdXAgLSB2ZXJ5IHNtYWxsIGFuZCBicm9rZW4gc2VxdWVuY2UsXG4gICAgLy8gcmV0dXJuIG1heCwgYmVjYXVzZSB3ZSBzaG91bGQgcmV0dXJuIHNvbWV0aGluZyBhbnl3YXkuXG4gICAgaWYgKHBvcyA8IDApIHsgcmV0dXJuIG1heDsgfVxuXG4gICAgLy8gSWYgd2UgY2FtZSB0byBzdGFydCBvZiBidWZmZXIgLSB0aGF0IG1lYW5zIHZ1ZmZlciBpcyB0b28gc21hbGwsXG4gICAgLy8gcmV0dXJuIG1heCB0b28uXG4gICAgaWYgKHBvcyA9PT0gMCkgeyByZXR1cm4gbWF4OyB9XG5cbiAgICByZXR1cm4gKHBvcyArIF91dGY4bGVuW2J1Zltwb3NdXSA+IG1heCkgPyBwb3MgOiBtYXg7XG59O1xuXG4vLyBjb252ZXJ0IGFycmF5IHRvIHN0cmluZ1xudmFyIGJ1ZjJzdHJpbmcgPSBmdW5jdGlvbiAoYnVmKSB7XG4gICAgdmFyIHN0ciwgaSwgb3V0LCBjLCBjX2xlbjtcbiAgICB2YXIgbGVuID0gYnVmLmxlbmd0aDtcblxuICAgIC8vIFJlc2VydmUgbWF4IHBvc3NpYmxlIGxlbmd0aCAoMiB3b3JkcyBwZXIgY2hhcilcbiAgICAvLyBOQjogYnkgdW5rbm93biByZWFzb25zLCBBcnJheSBpcyBzaWduaWZpY2FudGx5IGZhc3RlciBmb3JcbiAgICAvLyAgICAgU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseSB0aGFuIFVpbnQxNkFycmF5LlxuICAgIHZhciB1dGYxNmJ1ZiA9IG5ldyBBcnJheShsZW4qMik7XG5cbiAgICBmb3IgKG91dD0wLCBpPTA7IGk8bGVuOykge1xuICAgICAgICBjID0gYnVmW2krK107XG4gICAgICAgIC8vIHF1aWNrIHByb2Nlc3MgYXNjaWlcbiAgICAgICAgaWYgKGMgPCAweDgwKSB7IHV0ZjE2YnVmW291dCsrXSA9IGM7IGNvbnRpbnVlOyB9XG5cbiAgICAgICAgY19sZW4gPSBfdXRmOGxlbltjXTtcbiAgICAgICAgLy8gc2tpcCA1ICYgNiBieXRlIGNvZGVzXG4gICAgICAgIGlmIChjX2xlbiA+IDQpIHsgdXRmMTZidWZbb3V0KytdID0gMHhmZmZkOyBpICs9IGNfbGVuLTE7IGNvbnRpbnVlOyB9XG5cbiAgICAgICAgLy8gYXBwbHkgbWFzayBvbiBmaXJzdCBieXRlXG4gICAgICAgIGMgJj0gY19sZW4gPT09IDIgPyAweDFmIDogY19sZW4gPT09IDMgPyAweDBmIDogMHgwNztcbiAgICAgICAgLy8gam9pbiB0aGUgcmVzdFxuICAgICAgICB3aGlsZSAoY19sZW4gPiAxICYmIGkgPCBsZW4pIHtcbiAgICAgICAgICAgIGMgPSAoYyA8PCA2KSB8IChidWZbaSsrXSAmIDB4M2YpO1xuICAgICAgICAgICAgY19sZW4tLTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRlcm1pbmF0ZWQgYnkgZW5kIG9mIHN0cmluZz9cbiAgICAgICAgaWYgKGNfbGVuID4gMSkgeyB1dGYxNmJ1ZltvdXQrK10gPSAweGZmZmQ7IGNvbnRpbnVlOyB9XG5cbiAgICAgICAgaWYgKGMgPCAweDEwMDAwKSB7XG4gICAgICAgICAgICB1dGYxNmJ1ZltvdXQrK10gPSBjO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYyAtPSAweDEwMDAwO1xuICAgICAgICAgICAgdXRmMTZidWZbb3V0KytdID0gMHhkODAwIHwgKChjID4+IDEwKSAmIDB4M2ZmKTtcbiAgICAgICAgICAgIHV0ZjE2YnVmW291dCsrXSA9IDB4ZGMwMCB8IChjICYgMHgzZmYpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gc2hyaW5rQnVmKHV0ZjE2YnVmLCBvdXQpXG4gICAgaWYgKHV0ZjE2YnVmLmxlbmd0aCAhPT0gb3V0KSB7XG4gICAgICAgIGlmKHV0ZjE2YnVmLnN1YmFycmF5KSB7XG4gICAgICAgICAgICB1dGYxNmJ1ZiA9IHV0ZjE2YnVmLnN1YmFycmF5KDAsIG91dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB1dGYxNmJ1Zi5sZW5ndGggPSBvdXQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCB1dGYxNmJ1Zik7XG4gICAgcmV0dXJuIHV0aWxzLmFwcGx5RnJvbUNoYXJDb2RlKHV0ZjE2YnVmKTtcbn07XG5cblxuLy8gVGhhdCdzIGFsbCBmb3IgdGhlIHBha28gZnVuY3Rpb25zLlxuXG5cbi8qKlxuICogVHJhbnNmb3JtIGEgamF2YXNjcmlwdCBzdHJpbmcgaW50byBhbiBhcnJheSAodHlwZWQgaWYgcG9zc2libGUpIG9mIGJ5dGVzLFxuICogVVRGLTggZW5jb2RlZC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgdGhlIHN0cmluZyB0byBlbmNvZGVcbiAqIEByZXR1cm4ge0FycmF5fFVpbnQ4QXJyYXl8QnVmZmVyfSB0aGUgVVRGLTggZW5jb2RlZCBzdHJpbmcuXG4gKi9cbmV4cG9ydHMudXRmOGVuY29kZSA9IGZ1bmN0aW9uIHV0ZjhlbmNvZGUoc3RyKSB7XG4gICAgaWYgKHN1cHBvcnQubm9kZWJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gbm9kZWpzVXRpbHMubmV3QnVmZmVyRnJvbShzdHIsIFwidXRmLThcIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0cmluZzJidWYoc3RyKTtcbn07XG5cblxuLyoqXG4gKiBUcmFuc2Zvcm0gYSBieXRlcyBhcnJheSAob3IgYSByZXByZXNlbnRhdGlvbikgcmVwcmVzZW50aW5nIGFuIFVURi04IGVuY29kZWRcbiAqIHN0cmluZyBpbnRvIGEgamF2YXNjcmlwdCBzdHJpbmcuXG4gKiBAcGFyYW0ge0FycmF5fFVpbnQ4QXJyYXl8QnVmZmVyfSBidWYgdGhlIGRhdGEgZGUgZGVjb2RlXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHRoZSBkZWNvZGVkIHN0cmluZy5cbiAqL1xuZXhwb3J0cy51dGY4ZGVjb2RlID0gZnVuY3Rpb24gdXRmOGRlY29kZShidWYpIHtcbiAgICBpZiAoc3VwcG9ydC5ub2RlYnVmZmVyKSB7XG4gICAgICAgIHJldHVybiB1dGlscy50cmFuc2Zvcm1UbyhcIm5vZGVidWZmZXJcIiwgYnVmKS50b1N0cmluZyhcInV0Zi04XCIpO1xuICAgIH1cblxuICAgIGJ1ZiA9IHV0aWxzLnRyYW5zZm9ybVRvKHN1cHBvcnQudWludDhhcnJheSA/IFwidWludDhhcnJheVwiIDogXCJhcnJheVwiLCBidWYpO1xuXG4gICAgcmV0dXJuIGJ1ZjJzdHJpbmcoYnVmKTtcbn07XG5cbi8qKlxuICogQSB3b3JrZXIgdG8gZGVjb2RlIHV0ZjggZW5jb2RlZCBiaW5hcnkgY2h1bmtzIGludG8gc3RyaW5nIGNodW5rcy5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBVdGY4RGVjb2RlV29ya2VyKCkge1xuICAgIEdlbmVyaWNXb3JrZXIuY2FsbCh0aGlzLCBcInV0Zi04IGRlY29kZVwiKTtcbiAgICAvLyB0aGUgbGFzdCBieXRlcyBpZiBhIGNodW5rIGRpZG4ndCBlbmQgd2l0aCBhIGNvbXBsZXRlIGNvZGVwb2ludC5cbiAgICB0aGlzLmxlZnRPdmVyID0gbnVsbDtcbn1cbnV0aWxzLmluaGVyaXRzKFV0ZjhEZWNvZGVXb3JrZXIsIEdlbmVyaWNXb3JrZXIpO1xuXG4vKipcbiAqIEBzZWUgR2VuZXJpY1dvcmtlci5wcm9jZXNzQ2h1bmtcbiAqL1xuVXRmOERlY29kZVdvcmtlci5wcm90b3R5cGUucHJvY2Vzc0NodW5rID0gZnVuY3Rpb24gKGNodW5rKSB7XG5cbiAgICB2YXIgZGF0YSA9IHV0aWxzLnRyYW5zZm9ybVRvKHN1cHBvcnQudWludDhhcnJheSA/IFwidWludDhhcnJheVwiIDogXCJhcnJheVwiLCBjaHVuay5kYXRhKTtcblxuICAgIC8vIDFzdCBzdGVwLCByZS11c2Ugd2hhdCdzIGxlZnQgb2YgdGhlIHByZXZpb3VzIGNodW5rXG4gICAgaWYgKHRoaXMubGVmdE92ZXIgJiYgdGhpcy5sZWZ0T3Zlci5sZW5ndGgpIHtcbiAgICAgICAgaWYoc3VwcG9ydC51aW50OGFycmF5KSB7XG4gICAgICAgICAgICB2YXIgcHJldmlvdXNEYXRhID0gZGF0YTtcbiAgICAgICAgICAgIGRhdGEgPSBuZXcgVWludDhBcnJheShwcmV2aW91c0RhdGEubGVuZ3RoICsgdGhpcy5sZWZ0T3Zlci5sZW5ndGgpO1xuICAgICAgICAgICAgZGF0YS5zZXQodGhpcy5sZWZ0T3ZlciwgMCk7XG4gICAgICAgICAgICBkYXRhLnNldChwcmV2aW91c0RhdGEsIHRoaXMubGVmdE92ZXIubGVuZ3RoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRhdGEgPSB0aGlzLmxlZnRPdmVyLmNvbmNhdChkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxlZnRPdmVyID0gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgbmV4dEJvdW5kYXJ5ID0gdXRmOGJvcmRlcihkYXRhKTtcbiAgICB2YXIgdXNhYmxlRGF0YSA9IGRhdGE7XG4gICAgaWYgKG5leHRCb3VuZGFyeSAhPT0gZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgaWYgKHN1cHBvcnQudWludDhhcnJheSkge1xuICAgICAgICAgICAgdXNhYmxlRGF0YSA9IGRhdGEuc3ViYXJyYXkoMCwgbmV4dEJvdW5kYXJ5KTtcbiAgICAgICAgICAgIHRoaXMubGVmdE92ZXIgPSBkYXRhLnN1YmFycmF5KG5leHRCb3VuZGFyeSwgZGF0YS5sZW5ndGgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdXNhYmxlRGF0YSA9IGRhdGEuc2xpY2UoMCwgbmV4dEJvdW5kYXJ5KTtcbiAgICAgICAgICAgIHRoaXMubGVmdE92ZXIgPSBkYXRhLnNsaWNlKG5leHRCb3VuZGFyeSwgZGF0YS5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5wdXNoKHtcbiAgICAgICAgZGF0YSA6IGV4cG9ydHMudXRmOGRlY29kZSh1c2FibGVEYXRhKSxcbiAgICAgICAgbWV0YSA6IGNodW5rLm1ldGFcbiAgICB9KTtcbn07XG5cbi8qKlxuICogQHNlZSBHZW5lcmljV29ya2VyLmZsdXNoXG4gKi9cblV0ZjhEZWNvZGVXb3JrZXIucHJvdG90eXBlLmZsdXNoID0gZnVuY3Rpb24gKCkge1xuICAgIGlmKHRoaXMubGVmdE92ZXIgJiYgdGhpcy5sZWZ0T3Zlci5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5wdXNoKHtcbiAgICAgICAgICAgIGRhdGEgOiBleHBvcnRzLnV0ZjhkZWNvZGUodGhpcy5sZWZ0T3ZlciksXG4gICAgICAgICAgICBtZXRhIDoge31cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubGVmdE92ZXIgPSBudWxsO1xuICAgIH1cbn07XG5leHBvcnRzLlV0ZjhEZWNvZGVXb3JrZXIgPSBVdGY4RGVjb2RlV29ya2VyO1xuXG4vKipcbiAqIEEgd29ya2VyIHRvIGVuZGNvZGUgc3RyaW5nIGNodW5rcyBpbnRvIHV0ZjggZW5jb2RlZCBiaW5hcnkgY2h1bmtzLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFV0ZjhFbmNvZGVXb3JrZXIoKSB7XG4gICAgR2VuZXJpY1dvcmtlci5jYWxsKHRoaXMsIFwidXRmLTggZW5jb2RlXCIpO1xufVxudXRpbHMuaW5oZXJpdHMoVXRmOEVuY29kZVdvcmtlciwgR2VuZXJpY1dvcmtlcik7XG5cbi8qKlxuICogQHNlZSBHZW5lcmljV29ya2VyLnByb2Nlc3NDaHVua1xuICovXG5VdGY4RW5jb2RlV29ya2VyLnByb3RvdHlwZS5wcm9jZXNzQ2h1bmsgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICB0aGlzLnB1c2goe1xuICAgICAgICBkYXRhIDogZXhwb3J0cy51dGY4ZW5jb2RlKGNodW5rLmRhdGEpLFxuICAgICAgICBtZXRhIDogY2h1bmsubWV0YVxuICAgIH0pO1xufTtcbmV4cG9ydHMuVXRmOEVuY29kZVdvcmtlciA9IFV0ZjhFbmNvZGVXb3JrZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBzdXBwb3J0ID0gcmVxdWlyZSgnLi9zdXBwb3J0Jyk7XG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnLi9iYXNlNjQnKTtcbnZhciBub2RlanNVdGlscyA9IHJlcXVpcmUoJy4vbm9kZWpzVXRpbHMnKTtcbnZhciBzZXRJbW1lZGlhdGUgPSByZXF1aXJlKCdjb3JlLWpzL2xpYnJhcnkvZm4vc2V0LWltbWVkaWF0ZScpO1xudmFyIGV4dGVybmFsID0gcmVxdWlyZShcIi4vZXh0ZXJuYWxcIik7XG5cblxuLyoqXG4gKiBDb252ZXJ0IGEgc3RyaW5nIHRoYXQgcGFzcyBhcyBhIFwiYmluYXJ5IHN0cmluZ1wiOiBpdCBzaG91bGQgcmVwcmVzZW50IGEgYnl0ZVxuICogYXJyYXkgYnV0IG1heSBoYXZlID4gMjU1IGNoYXIgY29kZXMuIEJlIHN1cmUgdG8gdGFrZSBvbmx5IHRoZSBmaXJzdCBieXRlXG4gKiBhbmQgcmV0dXJucyB0aGUgYnl0ZSBhcnJheS5cbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgdGhlIHN0cmluZyB0byB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJuIHtBcnJheXxVaW50OEFycmF5fSB0aGUgc3RyaW5nIGluIGEgYmluYXJ5IGZvcm1hdC5cbiAqL1xuZnVuY3Rpb24gc3RyaW5nMmJpbmFyeShzdHIpIHtcbiAgICB2YXIgcmVzdWx0ID0gbnVsbDtcbiAgICBpZiAoc3VwcG9ydC51aW50OGFycmF5KSB7XG4gICAgICByZXN1bHQgPSBuZXcgVWludDhBcnJheShzdHIubGVuZ3RoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gbmV3IEFycmF5KHN0ci5sZW5ndGgpO1xuICAgIH1cbiAgICByZXR1cm4gc3RyaW5nVG9BcnJheUxpa2Uoc3RyLCByZXN1bHQpO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBibG9iIHdpdGggdGhlIGdpdmVuIGNvbnRlbnQgYW5kIHRoZSBnaXZlbiB0eXBlLlxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXlCdWZmZXJ9IHBhcnQgdGhlIGNvbnRlbnQgdG8gcHV0IGluIHRoZSBibG9iLiBETyBOT1QgdXNlXG4gKiBhbiBVaW50OEFycmF5IGJlY2F1c2UgdGhlIHN0b2NrIGJyb3dzZXIgb2YgYW5kcm9pZCA0IHdvbid0IGFjY2VwdCBpdCAoaXRcbiAqIHdpbGwgYmUgc2lsZW50bHkgY29udmVydGVkIHRvIGEgc3RyaW5nLCBcIltvYmplY3QgVWludDhBcnJheV1cIikuXG4gKlxuICogVXNlIG9ubHkgT05FIHBhcnQgdG8gYnVpbGQgdGhlIGJsb2IgdG8gYXZvaWQgYSBtZW1vcnkgbGVhayBpbiBJRTExIC8gRWRnZTpcbiAqIHdoZW4gYSBsYXJnZSBhbW91bnQgb2YgQXJyYXkgaXMgdXNlZCB0byBjcmVhdGUgdGhlIEJsb2IsIHRoZSBhbW91bnQgb2ZcbiAqIG1lbW9yeSBjb25zdW1lZCBpcyBuZWFybHkgMTAwIHRpbWVzIHRoZSBvcmlnaW5hbCBkYXRhIGFtb3VudC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZSB0aGUgbWltZSB0eXBlIG9mIHRoZSBibG9iLlxuICogQHJldHVybiB7QmxvYn0gdGhlIGNyZWF0ZWQgYmxvYi5cbiAqL1xuZXhwb3J0cy5uZXdCbG9iID0gZnVuY3Rpb24ocGFydCwgdHlwZSkge1xuICAgIGV4cG9ydHMuY2hlY2tTdXBwb3J0KFwiYmxvYlwiKTtcblxuICAgIHRyeSB7XG4gICAgICAgIC8vIEJsb2IgY29uc3RydWN0b3JcbiAgICAgICAgcmV0dXJuIG5ldyBCbG9iKFtwYXJ0XSwge1xuICAgICAgICAgICAgdHlwZTogdHlwZVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gZGVwcmVjYXRlZCwgYnJvd3NlciBvbmx5LCBvbGQgd2F5XG4gICAgICAgICAgICB2YXIgQnVpbGRlciA9IHNlbGYuQmxvYkJ1aWxkZXIgfHwgc2VsZi5XZWJLaXRCbG9iQnVpbGRlciB8fCBzZWxmLk1vekJsb2JCdWlsZGVyIHx8IHNlbGYuTVNCbG9iQnVpbGRlcjtcbiAgICAgICAgICAgIHZhciBidWlsZGVyID0gbmV3IEJ1aWxkZXIoKTtcbiAgICAgICAgICAgIGJ1aWxkZXIuYXBwZW5kKHBhcnQpO1xuICAgICAgICAgICAgcmV0dXJuIGJ1aWxkZXIuZ2V0QmxvYih0eXBlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuXG4gICAgICAgICAgICAvLyB3ZWxsLCBmdWNrID8hXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJCdWcgOiBjYW4ndCBjb25zdHJ1Y3QgdGhlIEJsb2IuXCIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn07XG4vKipcbiAqIFRoZSBpZGVudGl0eSBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dCB0aGUgaW5wdXQuXG4gKiBAcmV0dXJuIHtPYmplY3R9IHRoZSBzYW1lIGlucHV0LlxuICovXG5mdW5jdGlvbiBpZGVudGl0eShpbnB1dCkge1xuICAgIHJldHVybiBpbnB1dDtcbn1cblxuLyoqXG4gKiBGaWxsIGluIGFuIGFycmF5IHdpdGggYSBzdHJpbmcuXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIHRoZSBzdHJpbmcgdG8gdXNlLlxuICogQHBhcmFtIHtBcnJheXxBcnJheUJ1ZmZlcnxVaW50OEFycmF5fEJ1ZmZlcn0gYXJyYXkgdGhlIGFycmF5IHRvIGZpbGwgaW4gKHdpbGwgYmUgbXV0YXRlZCkuXG4gKiBAcmV0dXJuIHtBcnJheXxBcnJheUJ1ZmZlcnxVaW50OEFycmF5fEJ1ZmZlcn0gdGhlIHVwZGF0ZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIHN0cmluZ1RvQXJyYXlMaWtlKHN0ciwgYXJyYXkpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgICAgICBhcnJheVtpXSA9IHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRjtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xufVxuXG4vKipcbiAqIEFuIGhlbHBlciBmb3IgdGhlIGZ1bmN0aW9uIGFycmF5TGlrZVRvU3RyaW5nLlxuICogVGhpcyBjb250YWlucyBzdGF0aWMgaW5mb3JtYXRpb25zIGFuZCBmdW5jdGlvbnMgdGhhdFxuICogY2FuIGJlIG9wdGltaXplZCBieSB0aGUgYnJvd3NlciBKSVQgY29tcGlsZXIuXG4gKi9cbnZhciBhcnJheVRvU3RyaW5nSGVscGVyID0ge1xuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybSBhbiBhcnJheSBvZiBpbnQgaW50byBhIHN0cmluZywgY2h1bmsgYnkgY2h1bmsuXG4gICAgICogU2VlIHRoZSBwZXJmb3JtYW5jZXMgbm90ZXMgb24gYXJyYXlMaWtlVG9TdHJpbmcuXG4gICAgICogQHBhcmFtIHtBcnJheXxBcnJheUJ1ZmZlcnxVaW50OEFycmF5fEJ1ZmZlcn0gYXJyYXkgdGhlIGFycmF5IHRvIHRyYW5zZm9ybS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSB0aGUgdHlwZSBvZiB0aGUgYXJyYXkuXG4gICAgICogQHBhcmFtIHtJbnRlZ2VyfSBjaHVuayB0aGUgY2h1bmsgc2l6ZS5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IHRoZSByZXN1bHRpbmcgc3RyaW5nLlxuICAgICAqIEB0aHJvd3MgRXJyb3IgaWYgdGhlIGNodW5rIGlzIHRvbyBiaWcgZm9yIHRoZSBzdGFjay5cbiAgICAgKi9cbiAgICBzdHJpbmdpZnlCeUNodW5rOiBmdW5jdGlvbihhcnJheSwgdHlwZSwgY2h1bmspIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdLCBrID0gMCwgbGVuID0gYXJyYXkubGVuZ3RoO1xuICAgICAgICAvLyBzaG9ydGN1dFxuICAgICAgICBpZiAobGVuIDw9IGNodW5rKSB7XG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBhcnJheSk7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGsgPCBsZW4pIHtcbiAgICAgICAgICAgIGlmICh0eXBlID09PSBcImFycmF5XCIgfHwgdHlwZSA9PT0gXCJub2RlYnVmZmVyXCIpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGFycmF5LnNsaWNlKGssIE1hdGgubWluKGsgKyBjaHVuaywgbGVuKSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgYXJyYXkuc3ViYXJyYXkoaywgTWF0aC5taW4oayArIGNodW5rLCBsZW4pKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgayArPSBjaHVuaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0LmpvaW4oXCJcIik7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBDYWxsIFN0cmluZy5mcm9tQ2hhckNvZGUgb24gZXZlcnkgaXRlbSBpbiB0aGUgYXJyYXkuXG4gICAgICogVGhpcyBpcyB0aGUgbmFpdmUgaW1wbGVtZW50YXRpb24sIHdoaWNoIGdlbmVyYXRlIEEgTE9UIG9mIGludGVybWVkaWF0ZSBzdHJpbmcuXG4gICAgICogVGhpcyBzaG91bGQgYmUgdXNlZCB3aGVuIGV2ZXJ5dGhpbmcgZWxzZSBmYWlsLlxuICAgICAqIEBwYXJhbSB7QXJyYXl8QXJyYXlCdWZmZXJ8VWludDhBcnJheXxCdWZmZXJ9IGFycmF5IHRoZSBhcnJheSB0byB0cmFuc2Zvcm0uXG4gICAgICogQHJldHVybiB7U3RyaW5nfSB0aGUgcmVzdWx0LlxuICAgICAqL1xuICAgIHN0cmluZ2lmeUJ5Q2hhcjogZnVuY3Rpb24oYXJyYXkpe1xuICAgICAgICB2YXIgcmVzdWx0U3RyID0gXCJcIjtcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHRTdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShhcnJheVtpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdFN0cjtcbiAgICB9LFxuICAgIGFwcGx5Q2FuQmVVc2VkIDoge1xuICAgICAgICAvKipcbiAgICAgICAgICogdHJ1ZSBpZiB0aGUgYnJvd3NlciBhY2NlcHRzIHRvIHVzZSBTdHJpbmcuZnJvbUNoYXJDb2RlIG9uIFVpbnQ4QXJyYXlcbiAgICAgICAgICovXG4gICAgICAgIHVpbnQ4YXJyYXkgOiAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3VwcG9ydC51aW50OGFycmF5ICYmIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgbmV3IFVpbnQ4QXJyYXkoMSkpLmxlbmd0aCA9PT0gMTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKCksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiB0cnVlIGlmIHRoZSBicm93c2VyIGFjY2VwdHMgdG8gdXNlIFN0cmluZy5mcm9tQ2hhckNvZGUgb24gbm9kZWpzIEJ1ZmZlci5cbiAgICAgICAgICovXG4gICAgICAgIG5vZGVidWZmZXIgOiAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3VwcG9ydC5ub2RlYnVmZmVyICYmIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgbm9kZWpzVXRpbHMuYWxsb2NCdWZmZXIoMSkpLmxlbmd0aCA9PT0gMTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKClcbiAgICB9XG59O1xuXG4vKipcbiAqIFRyYW5zZm9ybSBhbiBhcnJheS1saWtlIG9iamVjdCB0byBhIHN0cmluZy5cbiAqIEBwYXJhbSB7QXJyYXl8QXJyYXlCdWZmZXJ8VWludDhBcnJheXxCdWZmZXJ9IGFycmF5IHRoZSBhcnJheSB0byB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHRoZSByZXN1bHQuXG4gKi9cbmZ1bmN0aW9uIGFycmF5TGlrZVRvU3RyaW5nKGFycmF5KSB7XG4gICAgLy8gUGVyZm9ybWFuY2VzIG5vdGVzIDpcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgYXJyYXkpIGlzIHRoZSBmYXN0ZXN0LCBzZWVcbiAgICAvLyBzZWUgaHR0cDovL2pzcGVyZi5jb20vY29udmVydGluZy1hLXVpbnQ4YXJyYXktdG8tYS1zdHJpbmcvMlxuICAgIC8vIGJ1dCB0aGUgc3RhY2sgaXMgbGltaXRlZCAoYW5kIHdlIGNhbiBnZXQgaHVnZSBhcnJheXMgISkuXG4gICAgLy9cbiAgICAvLyByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShhcnJheVtpXSk7IGdlbmVyYXRlIHRvbyBtYW55IHN0cmluZ3MgIVxuICAgIC8vXG4gICAgLy8gVGhpcyBjb2RlIGlzIGluc3BpcmVkIGJ5IGh0dHA6Ly9qc3BlcmYuY29tL2FycmF5YnVmZmVyLXRvLXN0cmluZy1hcHBseS1wZXJmb3JtYW5jZS8yXG4gICAgLy8gVE9ETyA6IHdlIG5vdyBoYXZlIHdvcmtlcnMgdGhhdCBzcGxpdCB0aGUgd29yay4gRG8gd2Ugc3RpbGwgbmVlZCB0aGF0ID9cbiAgICB2YXIgY2h1bmsgPSA2NTUzNixcbiAgICAgICAgdHlwZSA9IGV4cG9ydHMuZ2V0VHlwZU9mKGFycmF5KSxcbiAgICAgICAgY2FuVXNlQXBwbHkgPSB0cnVlO1xuICAgIGlmICh0eXBlID09PSBcInVpbnQ4YXJyYXlcIikge1xuICAgICAgICBjYW5Vc2VBcHBseSA9IGFycmF5VG9TdHJpbmdIZWxwZXIuYXBwbHlDYW5CZVVzZWQudWludDhhcnJheTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwibm9kZWJ1ZmZlclwiKSB7XG4gICAgICAgIGNhblVzZUFwcGx5ID0gYXJyYXlUb1N0cmluZ0hlbHBlci5hcHBseUNhbkJlVXNlZC5ub2RlYnVmZmVyO1xuICAgIH1cblxuICAgIGlmIChjYW5Vc2VBcHBseSkge1xuICAgICAgICB3aGlsZSAoY2h1bmsgPiAxKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhcnJheVRvU3RyaW5nSGVscGVyLnN0cmluZ2lmeUJ5Q2h1bmsoYXJyYXksIHR5cGUsIGNodW5rKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBjaHVuayA9IE1hdGguZmxvb3IoY2h1bmsgLyAyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIG5vIGFwcGx5IG9yIGNodW5rIGVycm9yIDogc2xvdyBhbmQgcGFpbmZ1bCBhbGdvcml0aG1cbiAgICAvLyBkZWZhdWx0IGJyb3dzZXIgb24gYW5kcm9pZCA0LipcbiAgICByZXR1cm4gYXJyYXlUb1N0cmluZ0hlbHBlci5zdHJpbmdpZnlCeUNoYXIoYXJyYXkpO1xufVxuXG5leHBvcnRzLmFwcGx5RnJvbUNoYXJDb2RlID0gYXJyYXlMaWtlVG9TdHJpbmc7XG5cblxuLyoqXG4gKiBDb3B5IHRoZSBkYXRhIGZyb20gYW4gYXJyYXktbGlrZSB0byBhbiBvdGhlciBhcnJheS1saWtlLlxuICogQHBhcmFtIHtBcnJheXxBcnJheUJ1ZmZlcnxVaW50OEFycmF5fEJ1ZmZlcn0gYXJyYXlGcm9tIHRoZSBvcmlnaW4gYXJyYXkuXG4gKiBAcGFyYW0ge0FycmF5fEFycmF5QnVmZmVyfFVpbnQ4QXJyYXl8QnVmZmVyfSBhcnJheVRvIHRoZSBkZXN0aW5hdGlvbiBhcnJheSB3aGljaCB3aWxsIGJlIG11dGF0ZWQuXG4gKiBAcmV0dXJuIHtBcnJheXxBcnJheUJ1ZmZlcnxVaW50OEFycmF5fEJ1ZmZlcn0gdGhlIHVwZGF0ZWQgZGVzdGluYXRpb24gYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGFycmF5TGlrZVRvQXJyYXlMaWtlKGFycmF5RnJvbSwgYXJyYXlUbykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXlGcm9tLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFycmF5VG9baV0gPSBhcnJheUZyb21baV07XG4gICAgfVxuICAgIHJldHVybiBhcnJheVRvO1xufVxuXG4vLyBhIG1hdHJpeCBjb250YWluaW5nIGZ1bmN0aW9ucyB0byB0cmFuc2Zvcm0gZXZlcnl0aGluZyBpbnRvIGV2ZXJ5dGhpbmcuXG52YXIgdHJhbnNmb3JtID0ge307XG5cbi8vIHN0cmluZyB0byA/XG50cmFuc2Zvcm1bXCJzdHJpbmdcIl0gPSB7XG4gICAgXCJzdHJpbmdcIjogaWRlbnRpdHksXG4gICAgXCJhcnJheVwiOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gc3RyaW5nVG9BcnJheUxpa2UoaW5wdXQsIG5ldyBBcnJheShpbnB1dC5sZW5ndGgpKTtcbiAgICB9LFxuICAgIFwiYXJyYXlidWZmZXJcIjogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybVtcInN0cmluZ1wiXVtcInVpbnQ4YXJyYXlcIl0oaW5wdXQpLmJ1ZmZlcjtcbiAgICB9LFxuICAgIFwidWludDhhcnJheVwiOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gc3RyaW5nVG9BcnJheUxpa2UoaW5wdXQsIG5ldyBVaW50OEFycmF5KGlucHV0Lmxlbmd0aCkpO1xuICAgIH0sXG4gICAgXCJub2RlYnVmZmVyXCI6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBzdHJpbmdUb0FycmF5TGlrZShpbnB1dCwgbm9kZWpzVXRpbHMuYWxsb2NCdWZmZXIoaW5wdXQubGVuZ3RoKSk7XG4gICAgfVxufTtcblxuLy8gYXJyYXkgdG8gP1xudHJhbnNmb3JtW1wiYXJyYXlcIl0gPSB7XG4gICAgXCJzdHJpbmdcIjogYXJyYXlMaWtlVG9TdHJpbmcsXG4gICAgXCJhcnJheVwiOiBpZGVudGl0eSxcbiAgICBcImFycmF5YnVmZmVyXCI6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiAobmV3IFVpbnQ4QXJyYXkoaW5wdXQpKS5idWZmZXI7XG4gICAgfSxcbiAgICBcInVpbnQ4YXJyYXlcIjogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGlucHV0KTtcbiAgICB9LFxuICAgIFwibm9kZWJ1ZmZlclwiOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gbm9kZWpzVXRpbHMubmV3QnVmZmVyRnJvbShpbnB1dCk7XG4gICAgfVxufTtcblxuLy8gYXJyYXlidWZmZXIgdG8gP1xudHJhbnNmb3JtW1wiYXJyYXlidWZmZXJcIl0gPSB7XG4gICAgXCJzdHJpbmdcIjogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5TGlrZVRvU3RyaW5nKG5ldyBVaW50OEFycmF5KGlucHV0KSk7XG4gICAgfSxcbiAgICBcImFycmF5XCI6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBhcnJheUxpa2VUb0FycmF5TGlrZShuZXcgVWludDhBcnJheShpbnB1dCksIG5ldyBBcnJheShpbnB1dC5ieXRlTGVuZ3RoKSk7XG4gICAgfSxcbiAgICBcImFycmF5YnVmZmVyXCI6IGlkZW50aXR5LFxuICAgIFwidWludDhhcnJheVwiOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoaW5wdXQpO1xuICAgIH0sXG4gICAgXCJub2RlYnVmZmVyXCI6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBub2RlanNVdGlscy5uZXdCdWZmZXJGcm9tKG5ldyBVaW50OEFycmF5KGlucHV0KSk7XG4gICAgfVxufTtcblxuLy8gdWludDhhcnJheSB0byA/XG50cmFuc2Zvcm1bXCJ1aW50OGFycmF5XCJdID0ge1xuICAgIFwic3RyaW5nXCI6IGFycmF5TGlrZVRvU3RyaW5nLFxuICAgIFwiYXJyYXlcIjogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5TGlrZVRvQXJyYXlMaWtlKGlucHV0LCBuZXcgQXJyYXkoaW5wdXQubGVuZ3RoKSk7XG4gICAgfSxcbiAgICBcImFycmF5YnVmZmVyXCI6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBpbnB1dC5idWZmZXI7XG4gICAgfSxcbiAgICBcInVpbnQ4YXJyYXlcIjogaWRlbnRpdHksXG4gICAgXCJub2RlYnVmZmVyXCI6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBub2RlanNVdGlscy5uZXdCdWZmZXJGcm9tKGlucHV0KTtcbiAgICB9XG59O1xuXG4vLyBub2RlYnVmZmVyIHRvID9cbnRyYW5zZm9ybVtcIm5vZGVidWZmZXJcIl0gPSB7XG4gICAgXCJzdHJpbmdcIjogYXJyYXlMaWtlVG9TdHJpbmcsXG4gICAgXCJhcnJheVwiOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gYXJyYXlMaWtlVG9BcnJheUxpa2UoaW5wdXQsIG5ldyBBcnJheShpbnB1dC5sZW5ndGgpKTtcbiAgICB9LFxuICAgIFwiYXJyYXlidWZmZXJcIjogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybVtcIm5vZGVidWZmZXJcIl1bXCJ1aW50OGFycmF5XCJdKGlucHV0KS5idWZmZXI7XG4gICAgfSxcbiAgICBcInVpbnQ4YXJyYXlcIjogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5TGlrZVRvQXJyYXlMaWtlKGlucHV0LCBuZXcgVWludDhBcnJheShpbnB1dC5sZW5ndGgpKTtcbiAgICB9LFxuICAgIFwibm9kZWJ1ZmZlclwiOiBpZGVudGl0eVxufTtcblxuLyoqXG4gKiBUcmFuc2Zvcm0gYW4gaW5wdXQgaW50byBhbnkgdHlwZS5cbiAqIFRoZSBzdXBwb3J0ZWQgb3V0cHV0IHR5cGUgYXJlIDogc3RyaW5nLCBhcnJheSwgdWludDhhcnJheSwgYXJyYXlidWZmZXIsIG5vZGVidWZmZXIuXG4gKiBJZiBubyBvdXRwdXQgdHlwZSBpcyBzcGVjaWZpZWQsIHRoZSB1bm1vZGlmaWVkIGlucHV0IHdpbGwgYmUgcmV0dXJuZWQuXG4gKiBAcGFyYW0ge1N0cmluZ30gb3V0cHV0VHlwZSB0aGUgb3V0cHV0IHR5cGUuXG4gKiBAcGFyYW0ge1N0cmluZ3xBcnJheXxBcnJheUJ1ZmZlcnxVaW50OEFycmF5fEJ1ZmZlcn0gaW5wdXQgdGhlIGlucHV0IHRvIGNvbnZlcnQuXG4gKiBAdGhyb3dzIHtFcnJvcn0gYW4gRXJyb3IgaWYgdGhlIGJyb3dzZXIgZG9lc24ndCBzdXBwb3J0IHRoZSByZXF1ZXN0ZWQgb3V0cHV0IHR5cGUuXG4gKi9cbmV4cG9ydHMudHJhbnNmb3JtVG8gPSBmdW5jdGlvbihvdXRwdXRUeXBlLCBpbnB1dCkge1xuICAgIGlmICghaW5wdXQpIHtcbiAgICAgICAgLy8gdW5kZWZpbmVkLCBudWxsLCBldGNcbiAgICAgICAgLy8gYW4gZW1wdHkgc3RyaW5nIHdvbid0IGhhcm0uXG4gICAgICAgIGlucHV0ID0gXCJcIjtcbiAgICB9XG4gICAgaWYgKCFvdXRwdXRUeXBlKSB7XG4gICAgICAgIHJldHVybiBpbnB1dDtcbiAgICB9XG4gICAgZXhwb3J0cy5jaGVja1N1cHBvcnQob3V0cHV0VHlwZSk7XG4gICAgdmFyIGlucHV0VHlwZSA9IGV4cG9ydHMuZ2V0VHlwZU9mKGlucHV0KTtcbiAgICB2YXIgcmVzdWx0ID0gdHJhbnNmb3JtW2lucHV0VHlwZV1bb3V0cHV0VHlwZV0oaW5wdXQpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIFJldHVybiB0aGUgdHlwZSBvZiB0aGUgaW5wdXQuXG4gKiBUaGUgdHlwZSB3aWxsIGJlIGluIGEgZm9ybWF0IHZhbGlkIGZvciBKU1ppcC51dGlscy50cmFuc2Zvcm1UbyA6IHN0cmluZywgYXJyYXksIHVpbnQ4YXJyYXksIGFycmF5YnVmZmVyLlxuICogQHBhcmFtIHtPYmplY3R9IGlucHV0IHRoZSBpbnB1dCB0byBpZGVudGlmeS5cbiAqIEByZXR1cm4ge1N0cmluZ30gdGhlIChsb3dlcmNhc2UpIHR5cGUgb2YgdGhlIGlucHV0LlxuICovXG5leHBvcnRzLmdldFR5cGVPZiA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gXCJzdHJpbmdcIjtcbiAgICB9XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dCkgPT09IFwiW29iamVjdCBBcnJheV1cIikge1xuICAgICAgICByZXR1cm4gXCJhcnJheVwiO1xuICAgIH1cbiAgICBpZiAoc3VwcG9ydC5ub2RlYnVmZmVyICYmIG5vZGVqc1V0aWxzLmlzQnVmZmVyKGlucHV0KSkge1xuICAgICAgICByZXR1cm4gXCJub2RlYnVmZmVyXCI7XG4gICAgfVxuICAgIGlmIChzdXBwb3J0LnVpbnQ4YXJyYXkgJiYgaW5wdXQgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgIHJldHVybiBcInVpbnQ4YXJyYXlcIjtcbiAgICB9XG4gICAgaWYgKHN1cHBvcnQuYXJyYXlidWZmZXIgJiYgaW5wdXQgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gXCJhcnJheWJ1ZmZlclwiO1xuICAgIH1cbn07XG5cbi8qKlxuICogVGhyb3cgYW4gZXhjZXB0aW9uIGlmIHRoZSB0eXBlIGlzIG5vdCBzdXBwb3J0ZWQuXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZSB0aGUgdHlwZSB0byBjaGVjay5cbiAqIEB0aHJvd3Mge0Vycm9yfSBhbiBFcnJvciBpZiB0aGUgYnJvd3NlciBkb2Vzbid0IHN1cHBvcnQgdGhlIHJlcXVlc3RlZCB0eXBlLlxuICovXG5leHBvcnRzLmNoZWNrU3VwcG9ydCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICB2YXIgc3VwcG9ydGVkID0gc3VwcG9ydFt0eXBlLnRvTG93ZXJDYXNlKCldO1xuICAgIGlmICghc3VwcG9ydGVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcih0eXBlICsgXCIgaXMgbm90IHN1cHBvcnRlZCBieSB0aGlzIHBsYXRmb3JtXCIpO1xuICAgIH1cbn07XG5cbmV4cG9ydHMuTUFYX1ZBTFVFXzE2QklUUyA9IDY1NTM1O1xuZXhwb3J0cy5NQVhfVkFMVUVfMzJCSVRTID0gLTE7IC8vIHdlbGwsIFwiXFx4RkZcXHhGRlxceEZGXFx4RkZcXHhGRlxceEZGXFx4RkZcXHhGRlwiIGlzIHBhcnNlZCBhcyAtMVxuXG4vKipcbiAqIFByZXR0aWZ5IGEgc3RyaW5nIHJlYWQgYXMgYmluYXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciB0aGUgc3RyaW5nIHRvIHByZXR0aWZ5LlxuICogQHJldHVybiB7c3RyaW5nfSBhIHByZXR0eSBzdHJpbmcuXG4gKi9cbmV4cG9ydHMucHJldHR5ID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgdmFyIHJlcyA9ICcnLFxuICAgICAgICBjb2RlLCBpO1xuICAgIGZvciAoaSA9IDA7IGkgPCAoc3RyIHx8IFwiXCIpLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvZGUgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgcmVzICs9ICdcXFxceCcgKyAoY29kZSA8IDE2ID8gXCIwXCIgOiBcIlwiKSArIGNvZGUudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59O1xuXG4vKipcbiAqIERlZmVyIHRoZSBjYWxsIG9mIGEgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayB0aGUgZnVuY3Rpb24gdG8gY2FsbCBhc3luY2hyb25vdXNseS5cbiAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgdGhlIGFyZ3VtZW50cyB0byBnaXZlIHRvIHRoZSBjYWxsYmFjay5cbiAqL1xuZXhwb3J0cy5kZWxheSA9IGZ1bmN0aW9uKGNhbGxiYWNrLCBhcmdzLCBzZWxmKSB7XG4gICAgc2V0SW1tZWRpYXRlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2FsbGJhY2suYXBwbHkoc2VsZiB8fCBudWxsLCBhcmdzIHx8IFtdKTtcbiAgICB9KTtcbn07XG5cbi8qKlxuICogRXh0ZW5kcyBhIHByb3RvdHlwZSB3aXRoIGFuIG90aGVyLCB3aXRob3V0IGNhbGxpbmcgYSBjb25zdHJ1Y3RvciB3aXRoXG4gKiBzaWRlIGVmZmVjdHMuIEluc3BpcmVkIGJ5IG5vZGVqcycgYHV0aWxzLmluaGVyaXRzYFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3RvciB0aGUgY29uc3RydWN0b3IgdG8gYXVnbWVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3VwZXJDdG9yIHRoZSBwYXJlbnQgY29uc3RydWN0b3IgdG8gdXNlXG4gKi9cbmV4cG9ydHMuaW5oZXJpdHMgPSBmdW5jdGlvbiAoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgdmFyIE9iaiA9IGZ1bmN0aW9uKCkge307XG4gICAgT2JqLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGU7XG4gICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgT2JqKCk7XG59O1xuXG4vKipcbiAqIE1lcmdlIHRoZSBvYmplY3RzIHBhc3NlZCBhcyBwYXJhbWV0ZXJzIGludG8gYSBuZXcgb25lLlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Li4uT2JqZWN0fSB2YXJfYXJncyBBbGwgb2JqZWN0cyB0byBtZXJnZS5cbiAqIEByZXR1cm4ge09iamVjdH0gYSBuZXcgb2JqZWN0IHdpdGggdGhlIGRhdGEgb2YgdGhlIG90aGVycy5cbiAqL1xuZXhwb3J0cy5leHRlbmQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcmVzdWx0ID0ge30sIGksIGF0dHI7XG4gICAgZm9yIChpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyAvLyBhcmd1bWVudHMgaXMgbm90IGVudW1lcmFibGUgaW4gc29tZSBicm93c2Vyc1xuICAgICAgICBmb3IgKGF0dHIgaW4gYXJndW1lbnRzW2ldKSB7XG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzW2ldLmhhc093blByb3BlcnR5KGF0dHIpICYmIHR5cGVvZiByZXN1bHRbYXR0cl0gPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRbYXR0cl0gPSBhcmd1bWVudHNbaV1bYXR0cl07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogVHJhbnNmb3JtIGFyYml0cmFyeSBjb250ZW50IGludG8gYSBQcm9taXNlLlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgYSBuYW1lIGZvciB0aGUgY29udGVudCBiZWluZyBwcm9jZXNzZWQuXG4gKiBAcGFyYW0ge09iamVjdH0gaW5wdXREYXRhIHRoZSBjb250ZW50IHRvIHByb2Nlc3MuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGlzQmluYXJ5IHRydWUgaWYgdGhlIGNvbnRlbnQgaXMgbm90IGFuIHVuaWNvZGUgc3RyaW5nXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGlzT3B0aW1pemVkQmluYXJ5U3RyaW5nIHRydWUgaWYgdGhlIHN0cmluZyBjb250ZW50IG9ubHkgaGFzIG9uZSBieXRlIHBlciBjaGFyYWN0ZXIuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGlzQmFzZTY0IHRydWUgaWYgdGhlIHN0cmluZyBjb250ZW50IGlzIGVuY29kZWQgd2l0aCBiYXNlNjQuXG4gKiBAcmV0dXJuIHtQcm9taXNlfSBhIHByb21pc2UgaW4gYSBmb3JtYXQgdXNhYmxlIGJ5IEpTWmlwLlxuICovXG5leHBvcnRzLnByZXBhcmVDb250ZW50ID0gZnVuY3Rpb24obmFtZSwgaW5wdXREYXRhLCBpc0JpbmFyeSwgaXNPcHRpbWl6ZWRCaW5hcnlTdHJpbmcsIGlzQmFzZTY0KSB7XG5cbiAgICAvLyBpZiBpbnB1dERhdGEgaXMgYWxyZWFkeSBhIHByb21pc2UsIHRoaXMgZmxhdHRlbiBpdC5cbiAgICB2YXIgcHJvbWlzZSA9IGV4dGVybmFsLlByb21pc2UucmVzb2x2ZShpbnB1dERhdGEpLnRoZW4oZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICBcbiAgICAgICAgXG4gICAgICAgIHZhciBpc0Jsb2IgPSBzdXBwb3J0LmJsb2IgJiYgKGRhdGEgaW5zdGFuY2VvZiBCbG9iIHx8IFsnW29iamVjdCBGaWxlXScsICdbb2JqZWN0IEJsb2JdJ10uaW5kZXhPZihPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZGF0YSkpICE9PSAtMSk7XG5cbiAgICAgICAgaWYgKGlzQmxvYiAmJiB0eXBlb2YgRmlsZVJlYWRlciAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBleHRlcm5hbC5Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcblxuICAgICAgICAgICAgICAgIHJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoZS50YXJnZXQucmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJlYWRlci5vbmVycm9yID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZS50YXJnZXQuZXJyb3IpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKGRhdGEpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHByb21pc2UudGhlbihmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHZhciBkYXRhVHlwZSA9IGV4cG9ydHMuZ2V0VHlwZU9mKGRhdGEpO1xuXG4gICAgICAgIGlmICghZGF0YVR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiBleHRlcm5hbC5Qcm9taXNlLnJlamVjdChcbiAgICAgICAgICAgICAgICBuZXcgRXJyb3IoXCJDYW4ndCByZWFkIHRoZSBkYXRhIG9mICdcIiArIG5hbWUgKyBcIicuIElzIGl0IFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJpbiBhIHN1cHBvcnRlZCBKYXZhU2NyaXB0IHR5cGUgKFN0cmluZywgQmxvYiwgQXJyYXlCdWZmZXIsIGV0YykgP1wiKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzcGVjaWFsIGNhc2UgOiBpdCdzIHdheSBlYXNpZXIgdG8gd29yayB3aXRoIFVpbnQ4QXJyYXkgdGhhbiB3aXRoIEFycmF5QnVmZmVyXG4gICAgICAgIGlmIChkYXRhVHlwZSA9PT0gXCJhcnJheWJ1ZmZlclwiKSB7XG4gICAgICAgICAgICBkYXRhID0gZXhwb3J0cy50cmFuc2Zvcm1UbyhcInVpbnQ4YXJyYXlcIiwgZGF0YSk7XG4gICAgICAgIH0gZWxzZSBpZiAoZGF0YVR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGlmIChpc0Jhc2U2NCkge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBiYXNlNjQuZGVjb2RlKGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNCaW5hcnkpIHtcbiAgICAgICAgICAgICAgICAvLyBvcHRpbWl6ZWRCaW5hcnlTdHJpbmcgPT09IHRydWUgbWVhbnMgdGhhdCB0aGUgZmlsZSBoYXMgYWxyZWFkeSBiZWVuIGZpbHRlcmVkIHdpdGggYSAweEZGIG1hc2tcbiAgICAgICAgICAgICAgICBpZiAoaXNPcHRpbWl6ZWRCaW5hcnlTdHJpbmcgIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBpcyBhIHN0cmluZywgbm90IGluIGEgYmFzZTY0IGZvcm1hdC5cbiAgICAgICAgICAgICAgICAgICAgLy8gQmUgc3VyZSB0aGF0IHRoaXMgaXMgYSBjb3JyZWN0IFwiYmluYXJ5IHN0cmluZ1wiXG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBzdHJpbmcyYmluYXJ5KGRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgcmVhZGVyRm9yID0gcmVxdWlyZSgnLi9yZWFkZXIvcmVhZGVyRm9yJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgc2lnID0gcmVxdWlyZSgnLi9zaWduYXR1cmUnKTtcbnZhciBaaXBFbnRyeSA9IHJlcXVpcmUoJy4vemlwRW50cnknKTtcbnZhciB1dGY4ID0gcmVxdWlyZSgnLi91dGY4Jyk7XG52YXIgc3VwcG9ydCA9IHJlcXVpcmUoJy4vc3VwcG9ydCcpO1xuLy8gIGNsYXNzIFppcEVudHJpZXMge3t7XG4vKipcbiAqIEFsbCB0aGUgZW50cmllcyBpbiB0aGUgemlwIGZpbGUuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBsb2FkT3B0aW9ucyBPcHRpb25zIGZvciBsb2FkaW5nIHRoZSBzdHJlYW0uXG4gKi9cbmZ1bmN0aW9uIFppcEVudHJpZXMobG9hZE9wdGlvbnMpIHtcbiAgICB0aGlzLmZpbGVzID0gW107XG4gICAgdGhpcy5sb2FkT3B0aW9ucyA9IGxvYWRPcHRpb25zO1xufVxuWmlwRW50cmllcy5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogQ2hlY2sgdGhhdCB0aGUgcmVhZGVyIGlzIG9uIHRoZSBzcGVjaWZpZWQgc2lnbmF0dXJlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBleHBlY3RlZFNpZ25hdHVyZSB0aGUgZXhwZWN0ZWQgc2lnbmF0dXJlLlxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBpZiBpdCBpcyBhbiBvdGhlciBzaWduYXR1cmUuXG4gICAgICovXG4gICAgY2hlY2tTaWduYXR1cmU6IGZ1bmN0aW9uKGV4cGVjdGVkU2lnbmF0dXJlKSB7XG4gICAgICAgIGlmICghdGhpcy5yZWFkZXIucmVhZEFuZENoZWNrU2lnbmF0dXJlKGV4cGVjdGVkU2lnbmF0dXJlKSkge1xuICAgICAgICAgICAgdGhpcy5yZWFkZXIuaW5kZXggLT0gNDtcbiAgICAgICAgICAgIHZhciBzaWduYXR1cmUgPSB0aGlzLnJlYWRlci5yZWFkU3RyaW5nKDQpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29ycnVwdGVkIHppcCBvciBidWc6IHVuZXhwZWN0ZWQgc2lnbmF0dXJlIFwiICsgXCIoXCIgKyB1dGlscy5wcmV0dHkoc2lnbmF0dXJlKSArIFwiLCBleHBlY3RlZCBcIiArIHV0aWxzLnByZXR0eShleHBlY3RlZFNpZ25hdHVyZSkgKyBcIilcIik7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoZSBnaXZlbiBzaWduYXR1cmUgaXMgYXQgdGhlIGdpdmVuIGluZGV4LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhc2tlZEluZGV4IHRoZSBpbmRleCB0byBjaGVjay5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXhwZWN0ZWRTaWduYXR1cmUgdGhlIHNpZ25hdHVyZSB0byBleHBlY3QuXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgc2lnbmF0dXJlIGlzIGhlcmUsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBpc1NpZ25hdHVyZTogZnVuY3Rpb24oYXNrZWRJbmRleCwgZXhwZWN0ZWRTaWduYXR1cmUpIHtcbiAgICAgICAgdmFyIGN1cnJlbnRJbmRleCA9IHRoaXMucmVhZGVyLmluZGV4O1xuICAgICAgICB0aGlzLnJlYWRlci5zZXRJbmRleChhc2tlZEluZGV4KTtcbiAgICAgICAgdmFyIHNpZ25hdHVyZSA9IHRoaXMucmVhZGVyLnJlYWRTdHJpbmcoNCk7XG4gICAgICAgIHZhciByZXN1bHQgPSBzaWduYXR1cmUgPT09IGV4cGVjdGVkU2lnbmF0dXJlO1xuICAgICAgICB0aGlzLnJlYWRlci5zZXRJbmRleChjdXJyZW50SW5kZXgpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogUmVhZCB0aGUgZW5kIG9mIHRoZSBjZW50cmFsIGRpcmVjdG9yeS5cbiAgICAgKi9cbiAgICByZWFkQmxvY2tFbmRPZkNlbnRyYWw6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmRpc2tOdW1iZXIgPSB0aGlzLnJlYWRlci5yZWFkSW50KDIpO1xuICAgICAgICB0aGlzLmRpc2tXaXRoQ2VudHJhbERpclN0YXJ0ID0gdGhpcy5yZWFkZXIucmVhZEludCgyKTtcbiAgICAgICAgdGhpcy5jZW50cmFsRGlyUmVjb3Jkc09uVGhpc0Rpc2sgPSB0aGlzLnJlYWRlci5yZWFkSW50KDIpO1xuICAgICAgICB0aGlzLmNlbnRyYWxEaXJSZWNvcmRzID0gdGhpcy5yZWFkZXIucmVhZEludCgyKTtcbiAgICAgICAgdGhpcy5jZW50cmFsRGlyU2l6ZSA9IHRoaXMucmVhZGVyLnJlYWRJbnQoNCk7XG4gICAgICAgIHRoaXMuY2VudHJhbERpck9mZnNldCA9IHRoaXMucmVhZGVyLnJlYWRJbnQoNCk7XG5cbiAgICAgICAgdGhpcy56aXBDb21tZW50TGVuZ3RoID0gdGhpcy5yZWFkZXIucmVhZEludCgyKTtcbiAgICAgICAgLy8gd2FybmluZyA6IHRoZSBlbmNvZGluZyBkZXBlbmRzIG9mIHRoZSBzeXN0ZW0gbG9jYWxlXG4gICAgICAgIC8vIE9uIGEgbGludXggbWFjaGluZSB3aXRoIExBTkc9ZW5fVVMudXRmOCwgdGhpcyBmaWVsZCBpcyB1dGY4IGVuY29kZWQuXG4gICAgICAgIC8vIE9uIGEgd2luZG93cyBtYWNoaW5lLCB0aGlzIGZpZWxkIGlzIGVuY29kZWQgd2l0aCB0aGUgbG9jYWxpemVkIHdpbmRvd3MgY29kZSBwYWdlLlxuICAgICAgICB2YXIgemlwQ29tbWVudCA9IHRoaXMucmVhZGVyLnJlYWREYXRhKHRoaXMuemlwQ29tbWVudExlbmd0aCk7XG4gICAgICAgIHZhciBkZWNvZGVQYXJhbVR5cGUgPSBzdXBwb3J0LnVpbnQ4YXJyYXkgPyBcInVpbnQ4YXJyYXlcIiA6IFwiYXJyYXlcIjtcbiAgICAgICAgLy8gVG8gZ2V0IGNvbnNpc3RlbnQgYmVoYXZpb3Igd2l0aCB0aGUgZ2VuZXJhdGlvbiBwYXJ0LCB3ZSB3aWxsIGFzc3VtZSB0aGF0XG4gICAgICAgIC8vIHRoaXMgaXMgdXRmOCBlbmNvZGVkIHVubGVzcyBzcGVjaWZpZWQgb3RoZXJ3aXNlLlxuICAgICAgICB2YXIgZGVjb2RlQ29udGVudCA9IHV0aWxzLnRyYW5zZm9ybVRvKGRlY29kZVBhcmFtVHlwZSwgemlwQ29tbWVudCk7XG4gICAgICAgIHRoaXMuemlwQ29tbWVudCA9IHRoaXMubG9hZE9wdGlvbnMuZGVjb2RlRmlsZU5hbWUoZGVjb2RlQ29udGVudCk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBSZWFkIHRoZSBlbmQgb2YgdGhlIFppcCA2NCBjZW50cmFsIGRpcmVjdG9yeS5cbiAgICAgKiBOb3QgbWVyZ2VkIHdpdGggdGhlIG1ldGhvZCByZWFkRW5kT2ZDZW50cmFsIDpcbiAgICAgKiBUaGUgZW5kIG9mIGNlbnRyYWwgY2FuIGNvZXhpc3Qgd2l0aCBpdHMgWmlwNjQgYnJvdGhlcixcbiAgICAgKiBJIGRvbid0IHdhbnQgdG8gcmVhZCB0aGUgd3JvbmcgbnVtYmVyIG9mIGJ5dGVzICFcbiAgICAgKi9cbiAgICByZWFkQmxvY2taaXA2NEVuZE9mQ2VudHJhbDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuemlwNjRFbmRPZkNlbnRyYWxTaXplID0gdGhpcy5yZWFkZXIucmVhZEludCg4KTtcbiAgICAgICAgdGhpcy5yZWFkZXIuc2tpcCg0KTtcbiAgICAgICAgLy8gdGhpcy52ZXJzaW9uTWFkZUJ5ID0gdGhpcy5yZWFkZXIucmVhZFN0cmluZygyKTtcbiAgICAgICAgLy8gdGhpcy52ZXJzaW9uTmVlZGVkID0gdGhpcy5yZWFkZXIucmVhZEludCgyKTtcbiAgICAgICAgdGhpcy5kaXNrTnVtYmVyID0gdGhpcy5yZWFkZXIucmVhZEludCg0KTtcbiAgICAgICAgdGhpcy5kaXNrV2l0aENlbnRyYWxEaXJTdGFydCA9IHRoaXMucmVhZGVyLnJlYWRJbnQoNCk7XG4gICAgICAgIHRoaXMuY2VudHJhbERpclJlY29yZHNPblRoaXNEaXNrID0gdGhpcy5yZWFkZXIucmVhZEludCg4KTtcbiAgICAgICAgdGhpcy5jZW50cmFsRGlyUmVjb3JkcyA9IHRoaXMucmVhZGVyLnJlYWRJbnQoOCk7XG4gICAgICAgIHRoaXMuY2VudHJhbERpclNpemUgPSB0aGlzLnJlYWRlci5yZWFkSW50KDgpO1xuICAgICAgICB0aGlzLmNlbnRyYWxEaXJPZmZzZXQgPSB0aGlzLnJlYWRlci5yZWFkSW50KDgpO1xuXG4gICAgICAgIHRoaXMuemlwNjRFeHRlbnNpYmxlRGF0YSA9IHt9O1xuICAgICAgICB2YXIgZXh0cmFEYXRhU2l6ZSA9IHRoaXMuemlwNjRFbmRPZkNlbnRyYWxTaXplIC0gNDQsXG4gICAgICAgICAgICBpbmRleCA9IDAsXG4gICAgICAgICAgICBleHRyYUZpZWxkSWQsXG4gICAgICAgICAgICBleHRyYUZpZWxkTGVuZ3RoLFxuICAgICAgICAgICAgZXh0cmFGaWVsZFZhbHVlO1xuICAgICAgICB3aGlsZSAoaW5kZXggPCBleHRyYURhdGFTaXplKSB7XG4gICAgICAgICAgICBleHRyYUZpZWxkSWQgPSB0aGlzLnJlYWRlci5yZWFkSW50KDIpO1xuICAgICAgICAgICAgZXh0cmFGaWVsZExlbmd0aCA9IHRoaXMucmVhZGVyLnJlYWRJbnQoNCk7XG4gICAgICAgICAgICBleHRyYUZpZWxkVmFsdWUgPSB0aGlzLnJlYWRlci5yZWFkRGF0YShleHRyYUZpZWxkTGVuZ3RoKTtcbiAgICAgICAgICAgIHRoaXMuemlwNjRFeHRlbnNpYmxlRGF0YVtleHRyYUZpZWxkSWRdID0ge1xuICAgICAgICAgICAgICAgIGlkOiBleHRyYUZpZWxkSWQsXG4gICAgICAgICAgICAgICAgbGVuZ3RoOiBleHRyYUZpZWxkTGVuZ3RoLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBleHRyYUZpZWxkVmFsdWVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJlYWQgdGhlIGVuZCBvZiB0aGUgWmlwIDY0IGNlbnRyYWwgZGlyZWN0b3J5IGxvY2F0b3IuXG4gICAgICovXG4gICAgcmVhZEJsb2NrWmlwNjRFbmRPZkNlbnRyYWxMb2NhdG9yOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5kaXNrV2l0aFppcDY0Q2VudHJhbERpclN0YXJ0ID0gdGhpcy5yZWFkZXIucmVhZEludCg0KTtcbiAgICAgICAgdGhpcy5yZWxhdGl2ZU9mZnNldEVuZE9mWmlwNjRDZW50cmFsRGlyID0gdGhpcy5yZWFkZXIucmVhZEludCg4KTtcbiAgICAgICAgdGhpcy5kaXNrc0NvdW50ID0gdGhpcy5yZWFkZXIucmVhZEludCg0KTtcbiAgICAgICAgaWYgKHRoaXMuZGlza3NDb3VudCA+IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11bHRpLXZvbHVtZXMgemlwIGFyZSBub3Qgc3VwcG9ydGVkXCIpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBSZWFkIHRoZSBsb2NhbCBmaWxlcywgYmFzZWQgb24gdGhlIG9mZnNldCByZWFkIGluIHRoZSBjZW50cmFsIHBhcnQuXG4gICAgICovXG4gICAgcmVhZExvY2FsRmlsZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaSwgZmlsZTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMuZmlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGZpbGUgPSB0aGlzLmZpbGVzW2ldO1xuICAgICAgICAgICAgdGhpcy5yZWFkZXIuc2V0SW5kZXgoZmlsZS5sb2NhbEhlYWRlck9mZnNldCk7XG4gICAgICAgICAgICB0aGlzLmNoZWNrU2lnbmF0dXJlKHNpZy5MT0NBTF9GSUxFX0hFQURFUik7XG4gICAgICAgICAgICBmaWxlLnJlYWRMb2NhbFBhcnQodGhpcy5yZWFkZXIpO1xuICAgICAgICAgICAgZmlsZS5oYW5kbGVVVEY4KCk7XG4gICAgICAgICAgICBmaWxlLnByb2Nlc3NBdHRyaWJ1dGVzKCk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJlYWQgdGhlIGNlbnRyYWwgZGlyZWN0b3J5LlxuICAgICAqL1xuICAgIHJlYWRDZW50cmFsRGlyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGZpbGU7XG5cbiAgICAgICAgdGhpcy5yZWFkZXIuc2V0SW5kZXgodGhpcy5jZW50cmFsRGlyT2Zmc2V0KTtcbiAgICAgICAgd2hpbGUgKHRoaXMucmVhZGVyLnJlYWRBbmRDaGVja1NpZ25hdHVyZShzaWcuQ0VOVFJBTF9GSUxFX0hFQURFUikpIHtcbiAgICAgICAgICAgIGZpbGUgPSBuZXcgWmlwRW50cnkoe1xuICAgICAgICAgICAgICAgIHppcDY0OiB0aGlzLnppcDY0XG4gICAgICAgICAgICB9LCB0aGlzLmxvYWRPcHRpb25zKTtcbiAgICAgICAgICAgIGZpbGUucmVhZENlbnRyYWxQYXJ0KHRoaXMucmVhZGVyKTtcbiAgICAgICAgICAgIHRoaXMuZmlsZXMucHVzaChmaWxlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmNlbnRyYWxEaXJSZWNvcmRzICE9PSB0aGlzLmZpbGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY2VudHJhbERpclJlY29yZHMgIT09IDAgJiYgdGhpcy5maWxlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBleHBlY3RlZCBzb21lIHJlY29yZHMgYnV0IGNvdWxkbid0IGZpbmQgQU5ZLlxuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgcmVhbGx5IHN1c3BpY2lvdXMsIGFzIGlmIHNvbWV0aGluZyB3ZW50IHdyb25nLlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvcnJ1cHRlZCB6aXAgb3IgYnVnOiBleHBlY3RlZCBcIiArIHRoaXMuY2VudHJhbERpclJlY29yZHMgKyBcIiByZWNvcmRzIGluIGNlbnRyYWwgZGlyLCBnb3QgXCIgKyB0aGlzLmZpbGVzLmxlbmd0aCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFdlIGZvdW5kIHNvbWUgcmVjb3JkcyBidXQgbm90IGFsbC5cbiAgICAgICAgICAgICAgICAvLyBTb21ldGhpbmcgaXMgd3JvbmcgYnV0IHdlIGdvdCBzb21ldGhpbmcgZm9yIHRoZSB1c2VyOiBubyBlcnJvciBoZXJlLlxuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybihcImV4cGVjdGVkXCIsIHRoaXMuY2VudHJhbERpclJlY29yZHMsIFwicmVjb3JkcyBpbiBjZW50cmFsIGRpciwgZ290XCIsIHRoaXMuZmlsZXMubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogUmVhZCB0aGUgZW5kIG9mIGNlbnRyYWwgZGlyZWN0b3J5LlxuICAgICAqL1xuICAgIHJlYWRFbmRPZkNlbnRyYWw6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5yZWFkZXIubGFzdEluZGV4T2ZTaWduYXR1cmUoc2lnLkNFTlRSQUxfRElSRUNUT1JZX0VORCk7XG4gICAgICAgIGlmIChvZmZzZXQgPCAwKSB7XG4gICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgY29udGVudCBpcyBhIHRydW5jYXRlZCB6aXAgb3IgY29tcGxldGUgZ2FyYmFnZS5cbiAgICAgICAgICAgIC8vIEEgXCJMT0NBTF9GSUxFX0hFQURFUlwiIGlzIG5vdCByZXF1aXJlZCBhdCB0aGUgYmVnaW5uaW5nIChhdXRvXG4gICAgICAgICAgICAvLyBleHRyYWN0aWJsZSB6aXAgZm9yIGV4YW1wbGUpIGJ1dCBpdCBjYW4gZ2l2ZSBhIGdvb2QgaGludC5cbiAgICAgICAgICAgIC8vIElmIGFuIGFqYXggcmVxdWVzdCB3YXMgdXNlZCB3aXRob3V0IHJlc3BvbnNlVHlwZSwgd2Ugd2lsbCBhbHNvXG4gICAgICAgICAgICAvLyBnZXQgdW5yZWFkYWJsZSBkYXRhLlxuICAgICAgICAgICAgdmFyIGlzR2FyYmFnZSA9ICF0aGlzLmlzU2lnbmF0dXJlKDAsIHNpZy5MT0NBTF9GSUxFX0hFQURFUik7XG5cbiAgICAgICAgICAgIGlmIChpc0dhcmJhZ2UpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBmaW5kIGVuZCBvZiBjZW50cmFsIGRpcmVjdG9yeSA6IGlzIHRoaXMgYSB6aXAgZmlsZSA/IFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJJZiBpdCBpcywgc2VlIGh0dHBzOi8vc3R1ay5naXRodWIuaW8vanN6aXAvZG9jdW1lbnRhdGlvbi9ob3d0by9yZWFkX3ppcC5odG1sXCIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3JydXB0ZWQgemlwOiBjYW4ndCBmaW5kIGVuZCBvZiBjZW50cmFsIGRpcmVjdG9yeVwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVhZGVyLnNldEluZGV4KG9mZnNldCk7XG4gICAgICAgIHZhciBlbmRPZkNlbnRyYWxEaXJPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgIHRoaXMuY2hlY2tTaWduYXR1cmUoc2lnLkNFTlRSQUxfRElSRUNUT1JZX0VORCk7XG4gICAgICAgIHRoaXMucmVhZEJsb2NrRW5kT2ZDZW50cmFsKCk7XG5cblxuICAgICAgICAvKiBleHRyYWN0IGZyb20gdGhlIHppcCBzcGVjIDpcbiAgICAgICAgICAgIDQpICBJZiBvbmUgb2YgdGhlIGZpZWxkcyBpbiB0aGUgZW5kIG9mIGNlbnRyYWwgZGlyZWN0b3J5XG4gICAgICAgICAgICAgICAgcmVjb3JkIGlzIHRvbyBzbWFsbCB0byBob2xkIHJlcXVpcmVkIGRhdGEsIHRoZSBmaWVsZFxuICAgICAgICAgICAgICAgIHNob3VsZCBiZSBzZXQgdG8gLTEgKDB4RkZGRiBvciAweEZGRkZGRkZGKSBhbmQgdGhlXG4gICAgICAgICAgICAgICAgWklQNjQgZm9ybWF0IHJlY29yZCBzaG91bGQgYmUgY3JlYXRlZC5cbiAgICAgICAgICAgIDUpICBUaGUgZW5kIG9mIGNlbnRyYWwgZGlyZWN0b3J5IHJlY29yZCBhbmQgdGhlXG4gICAgICAgICAgICAgICAgWmlwNjQgZW5kIG9mIGNlbnRyYWwgZGlyZWN0b3J5IGxvY2F0b3IgcmVjb3JkIG11c3RcbiAgICAgICAgICAgICAgICByZXNpZGUgb24gdGhlIHNhbWUgZGlzayB3aGVuIHNwbGl0dGluZyBvciBzcGFubmluZ1xuICAgICAgICAgICAgICAgIGFuIGFyY2hpdmUuXG4gICAgICAgICAqL1xuICAgICAgICBpZiAodGhpcy5kaXNrTnVtYmVyID09PSB1dGlscy5NQVhfVkFMVUVfMTZCSVRTIHx8IHRoaXMuZGlza1dpdGhDZW50cmFsRGlyU3RhcnQgPT09IHV0aWxzLk1BWF9WQUxVRV8xNkJJVFMgfHwgdGhpcy5jZW50cmFsRGlyUmVjb3Jkc09uVGhpc0Rpc2sgPT09IHV0aWxzLk1BWF9WQUxVRV8xNkJJVFMgfHwgdGhpcy5jZW50cmFsRGlyUmVjb3JkcyA9PT0gdXRpbHMuTUFYX1ZBTFVFXzE2QklUUyB8fCB0aGlzLmNlbnRyYWxEaXJTaXplID09PSB1dGlscy5NQVhfVkFMVUVfMzJCSVRTIHx8IHRoaXMuY2VudHJhbERpck9mZnNldCA9PT0gdXRpbHMuTUFYX1ZBTFVFXzMyQklUUykge1xuICAgICAgICAgICAgdGhpcy56aXA2NCA9IHRydWU7XG5cbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICBXYXJuaW5nIDogdGhlIHppcDY0IGV4dGVuc2lvbiBpcyBzdXBwb3J0ZWQsIGJ1dCBPTkxZIGlmIHRoZSA2NGJpdHMgaW50ZWdlciByZWFkIGZyb21cbiAgICAgICAgICAgIHRoZSB6aXAgZmlsZSBjYW4gZml0IGludG8gYSAzMmJpdHMgaW50ZWdlci4gVGhpcyBjYW5ub3QgYmUgc29sdmVkIDogSmF2YVNjcmlwdCByZXByZXNlbnRzXG4gICAgICAgICAgICBhbGwgbnVtYmVycyBhcyA2NC1iaXQgZG91YmxlIHByZWNpc2lvbiBJRUVFIDc1NCBmbG9hdGluZyBwb2ludCBudW1iZXJzLlxuICAgICAgICAgICAgU28sIHdlIGhhdmUgNTNiaXRzIGZvciBpbnRlZ2VycyBhbmQgYml0d2lzZSBvcGVyYXRpb25zIHRyZWF0IGV2ZXJ5dGhpbmcgYXMgMzJiaXRzLlxuICAgICAgICAgICAgc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvSmF2YVNjcmlwdC9SZWZlcmVuY2UvT3BlcmF0b3JzL0JpdHdpc2VfT3BlcmF0b3JzXG4gICAgICAgICAgICBhbmQgaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL3B1YmxpY2F0aW9ucy9maWxlcy9FQ01BLVNUL0VDTUEtMjYyLnBkZiBzZWN0aW9uIDguNVxuICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgLy8gc2hvdWxkIGxvb2sgZm9yIGEgemlwNjQgRU9DRCBsb2NhdG9yXG4gICAgICAgICAgICBvZmZzZXQgPSB0aGlzLnJlYWRlci5sYXN0SW5kZXhPZlNpZ25hdHVyZShzaWcuWklQNjRfQ0VOVFJBTF9ESVJFQ1RPUllfTE9DQVRPUik7XG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvcnJ1cHRlZCB6aXA6IGNhbid0IGZpbmQgdGhlIFpJUDY0IGVuZCBvZiBjZW50cmFsIGRpcmVjdG9yeSBsb2NhdG9yXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yZWFkZXIuc2V0SW5kZXgob2Zmc2V0KTtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tTaWduYXR1cmUoc2lnLlpJUDY0X0NFTlRSQUxfRElSRUNUT1JZX0xPQ0FUT1IpO1xuICAgICAgICAgICAgdGhpcy5yZWFkQmxvY2taaXA2NEVuZE9mQ2VudHJhbExvY2F0b3IoKTtcblxuICAgICAgICAgICAgLy8gbm93IHRoZSB6aXA2NCBFT0NEIHJlY29yZFxuICAgICAgICAgICAgaWYgKCF0aGlzLmlzU2lnbmF0dXJlKHRoaXMucmVsYXRpdmVPZmZzZXRFbmRPZlppcDY0Q2VudHJhbERpciwgc2lnLlpJUDY0X0NFTlRSQUxfRElSRUNUT1JZX0VORCkpIHtcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oXCJaSVA2NCBlbmQgb2YgY2VudHJhbCBkaXJlY3Rvcnkgbm90IHdoZXJlIGV4cGVjdGVkLlwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbGF0aXZlT2Zmc2V0RW5kT2ZaaXA2NENlbnRyYWxEaXIgPSB0aGlzLnJlYWRlci5sYXN0SW5kZXhPZlNpZ25hdHVyZShzaWcuWklQNjRfQ0VOVFJBTF9ESVJFQ1RPUllfRU5EKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yZWxhdGl2ZU9mZnNldEVuZE9mWmlwNjRDZW50cmFsRGlyIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3JydXB0ZWQgemlwOiBjYW4ndCBmaW5kIHRoZSBaSVA2NCBlbmQgb2YgY2VudHJhbCBkaXJlY3RvcnlcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yZWFkZXIuc2V0SW5kZXgodGhpcy5yZWxhdGl2ZU9mZnNldEVuZE9mWmlwNjRDZW50cmFsRGlyKTtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tTaWduYXR1cmUoc2lnLlpJUDY0X0NFTlRSQUxfRElSRUNUT1JZX0VORCk7XG4gICAgICAgICAgICB0aGlzLnJlYWRCbG9ja1ppcDY0RW5kT2ZDZW50cmFsKCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZXhwZWN0ZWRFbmRPZkNlbnRyYWxEaXJPZmZzZXQgPSB0aGlzLmNlbnRyYWxEaXJPZmZzZXQgKyB0aGlzLmNlbnRyYWxEaXJTaXplO1xuICAgICAgICBpZiAodGhpcy56aXA2NCkge1xuICAgICAgICAgICAgZXhwZWN0ZWRFbmRPZkNlbnRyYWxEaXJPZmZzZXQgKz0gMjA7IC8vIGVuZCBvZiBjZW50cmFsIGRpciA2NCBsb2NhdG9yXG4gICAgICAgICAgICBleHBlY3RlZEVuZE9mQ2VudHJhbERpck9mZnNldCArPSAxMiAvKiBzaG91bGQgbm90IGluY2x1ZGUgdGhlIGxlYWRpbmcgMTIgYnl0ZXMgKi8gKyB0aGlzLnppcDY0RW5kT2ZDZW50cmFsU2l6ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBleHRyYUJ5dGVzID0gZW5kT2ZDZW50cmFsRGlyT2Zmc2V0IC0gZXhwZWN0ZWRFbmRPZkNlbnRyYWxEaXJPZmZzZXQ7XG5cbiAgICAgICAgaWYgKGV4dHJhQnl0ZXMgPiAwKSB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oZXh0cmFCeXRlcywgXCJleHRyYSBieXRlcyBhdCBiZWdpbm5pbmcgb3Igd2l0aGluIHppcGZpbGVcIik7XG4gICAgICAgICAgICBpZiAodGhpcy5pc1NpZ25hdHVyZShlbmRPZkNlbnRyYWxEaXJPZmZzZXQsIHNpZy5DRU5UUkFMX0ZJTEVfSEVBREVSKSkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBvZmZzZXRzIHNlZW0gd3JvbmcsIGJ1dCB3ZSBoYXZlIHNvbWV0aGluZyBhdCB0aGUgc3BlY2lmaWVkIG9mZnNldC5cbiAgICAgICAgICAgICAgICAvLyBTb+KApiB3ZSBrZWVwIGl0LlxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyB0aGUgb2Zmc2V0IGlzIHdyb25nLCB1cGRhdGUgdGhlIFwiemVyb1wiIG9mIHRoZSByZWFkZXJcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGhhcHBlbnMgaWYgZGF0YSBoYXMgYmVlbiBwcmVwZW5kZWQgKGNyeCBmaWxlcyBmb3IgZXhhbXBsZSlcbiAgICAgICAgICAgICAgICB0aGlzLnJlYWRlci56ZXJvID0gZXh0cmFCeXRlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChleHRyYUJ5dGVzIDwgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29ycnVwdGVkIHppcDogbWlzc2luZyBcIiArIE1hdGguYWJzKGV4dHJhQnl0ZXMpICsgXCIgYnl0ZXMuXCIpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBwcmVwYXJlUmVhZGVyOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHRoaXMucmVhZGVyID0gcmVhZGVyRm9yKGRhdGEpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogUmVhZCBhIHppcCBmaWxlIGFuZCBjcmVhdGUgWmlwRW50cmllcy5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xBcnJheUJ1ZmZlcnxVaW50OEFycmF5fEJ1ZmZlcn0gZGF0YSB0aGUgYmluYXJ5IHN0cmluZyByZXByZXNlbnRpbmcgYSB6aXAgZmlsZS5cbiAgICAgKi9cbiAgICBsb2FkOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHRoaXMucHJlcGFyZVJlYWRlcihkYXRhKTtcbiAgICAgICAgdGhpcy5yZWFkRW5kT2ZDZW50cmFsKCk7XG4gICAgICAgIHRoaXMucmVhZENlbnRyYWxEaXIoKTtcbiAgICAgICAgdGhpcy5yZWFkTG9jYWxGaWxlcygpO1xuICAgIH1cbn07XG4vLyB9fX0gZW5kIG9mIFppcEVudHJpZXNcbm1vZHVsZS5leHBvcnRzID0gWmlwRW50cmllcztcbiIsIid1c2Ugc3RyaWN0JztcbnZhciByZWFkZXJGb3IgPSByZXF1aXJlKCcuL3JlYWRlci9yZWFkZXJGb3InKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbnZhciBDb21wcmVzc2VkT2JqZWN0ID0gcmVxdWlyZSgnLi9jb21wcmVzc2VkT2JqZWN0Jyk7XG52YXIgY3JjMzJmbiA9IHJlcXVpcmUoJy4vY3JjMzInKTtcbnZhciB1dGY4ID0gcmVxdWlyZSgnLi91dGY4Jyk7XG52YXIgY29tcHJlc3Npb25zID0gcmVxdWlyZSgnLi9jb21wcmVzc2lvbnMnKTtcbnZhciBzdXBwb3J0ID0gcmVxdWlyZSgnLi9zdXBwb3J0Jyk7XG5cbnZhciBNQURFX0JZX0RPUyA9IDB4MDA7XG52YXIgTUFERV9CWV9VTklYID0gMHgwMztcblxuLyoqXG4gKiBGaW5kIGEgY29tcHJlc3Npb24gcmVnaXN0ZXJlZCBpbiBKU1ppcC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBjb21wcmVzc2lvbk1ldGhvZCB0aGUgbWV0aG9kIG1hZ2ljIHRvIGZpbmQuXG4gKiBAcmV0dXJuIHtPYmplY3R8bnVsbH0gdGhlIEpTWmlwIGNvbXByZXNzaW9uIG9iamVjdCwgbnVsbCBpZiBub25lIGZvdW5kLlxuICovXG52YXIgZmluZENvbXByZXNzaW9uID0gZnVuY3Rpb24oY29tcHJlc3Npb25NZXRob2QpIHtcbiAgICBmb3IgKHZhciBtZXRob2QgaW4gY29tcHJlc3Npb25zKSB7XG4gICAgICAgIGlmICghY29tcHJlc3Npb25zLmhhc093blByb3BlcnR5KG1ldGhvZCkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb21wcmVzc2lvbnNbbWV0aG9kXS5tYWdpYyA9PT0gY29tcHJlc3Npb25NZXRob2QpIHtcbiAgICAgICAgICAgIHJldHVybiBjb21wcmVzc2lvbnNbbWV0aG9kXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn07XG5cbi8vIGNsYXNzIFppcEVudHJ5IHt7e1xuLyoqXG4gKiBBbiBlbnRyeSBpbiB0aGUgemlwIGZpbGUuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIE9wdGlvbnMgb2YgdGhlIGN1cnJlbnQgZmlsZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBsb2FkT3B0aW9ucyBPcHRpb25zIGZvciBsb2FkaW5nIHRoZSBzdHJlYW0uXG4gKi9cbmZ1bmN0aW9uIFppcEVudHJ5KG9wdGlvbnMsIGxvYWRPcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLmxvYWRPcHRpb25zID0gbG9hZE9wdGlvbnM7XG59XG5aaXBFbnRyeS5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogc2F5IGlmIHRoZSBmaWxlIGlzIGVuY3J5cHRlZC5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIHRoZSBmaWxlIGlzIGVuY3J5cHRlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIGlzRW5jcnlwdGVkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gYml0IDEgaXMgc2V0XG4gICAgICAgIHJldHVybiAodGhpcy5iaXRGbGFnICYgMHgwMDAxKSA9PT0gMHgwMDAxO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogc2F5IGlmIHRoZSBmaWxlIGhhcyB1dGYtOCBmaWxlbmFtZS9jb21tZW50LlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgdGhlIGZpbGVuYW1lL2NvbW1lbnQgaXMgaW4gdXRmLTgsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICB1c2VVVEY4OiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gYml0IDExIGlzIHNldFxuICAgICAgICByZXR1cm4gKHRoaXMuYml0RmxhZyAmIDB4MDgwMCkgPT09IDB4MDgwMDtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJlYWQgdGhlIGxvY2FsIHBhcnQgb2YgYSB6aXAgZmlsZSBhbmQgYWRkIHRoZSBpbmZvIGluIHRoaXMgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7RGF0YVJlYWRlcn0gcmVhZGVyIHRoZSByZWFkZXIgdG8gdXNlLlxuICAgICAqL1xuICAgIHJlYWRMb2NhbFBhcnQ6IGZ1bmN0aW9uKHJlYWRlcikge1xuICAgICAgICB2YXIgY29tcHJlc3Npb24sIGxvY2FsRXh0cmFGaWVsZHNMZW5ndGg7XG5cbiAgICAgICAgLy8gd2UgYWxyZWFkeSBrbm93IGV2ZXJ5dGhpbmcgZnJvbSB0aGUgY2VudHJhbCBkaXIgIVxuICAgICAgICAvLyBJZiB0aGUgY2VudHJhbCBkaXIgZGF0YSBhcmUgZmFsc2UsIHdlIGFyZSBkb29tZWQuXG4gICAgICAgIC8vIE9uIHRoZSBicmlnaHQgc2lkZSwgdGhlIGxvY2FsIHBhcnQgaXMgc2NhcnkgIDogemlwNjQsIGRhdGEgZGVzY3JpcHRvcnMsIGJvdGgsIGV0Yy5cbiAgICAgICAgLy8gVGhlIGxlc3MgZGF0YSB3ZSBnZXQgaGVyZSwgdGhlIG1vcmUgcmVsaWFibGUgdGhpcyBzaG91bGQgYmUuXG4gICAgICAgIC8vIExldCdzIHNraXAgdGhlIHdob2xlIGhlYWRlciBhbmQgZGFzaCB0byB0aGUgZGF0YSAhXG4gICAgICAgIHJlYWRlci5za2lwKDIyKTtcbiAgICAgICAgLy8gaW4gc29tZSB6aXAgY3JlYXRlZCBvbiB3aW5kb3dzLCB0aGUgZmlsZW5hbWUgc3RvcmVkIGluIHRoZSBjZW50cmFsIGRpciBjb250YWlucyBcXCBpbnN0ZWFkIG9mIC8uXG4gICAgICAgIC8vIFN0cmFuZ2VseSwgdGhlIGZpbGVuYW1lIGhlcmUgaXMgT0suXG4gICAgICAgIC8vIEkgd291bGQgbG92ZSB0byB0cmVhdCB0aGVzZSB6aXAgZmlsZXMgYXMgY29ycnVwdGVkIChzZWUgaHR0cDovL3d3dy5pbmZvLXppcC5vcmcvRkFRLmh0bWwjYmFja3NsYXNoZXNcbiAgICAgICAgLy8gb3IgQVBQTk9URSM0LjQuMTcuMSwgXCJBbGwgc2xhc2hlcyBNVVNUIGJlIGZvcndhcmQgc2xhc2hlcyAnLydcIikgYnV0IHRoZXJlIGFyZSBhIGxvdCBvZiBiYWQgemlwIGdlbmVyYXRvcnMuLi5cbiAgICAgICAgLy8gU2VhcmNoIFwidW56aXAgbWlzbWF0Y2hpbmcgXCJsb2NhbFwiIGZpbGVuYW1lIGNvbnRpbnVpbmcgd2l0aCBcImNlbnRyYWxcIiBmaWxlbmFtZSB2ZXJzaW9uXCIgb25cbiAgICAgICAgLy8gdGhlIGludGVybmV0LlxuICAgICAgICAvL1xuICAgICAgICAvLyBJIHRoaW5rIEkgc2VlIHRoZSBsb2dpYyBoZXJlIDogdGhlIGNlbnRyYWwgZGlyZWN0b3J5IGlzIHVzZWQgdG8gZGlzcGxheVxuICAgICAgICAvLyBjb250ZW50IGFuZCB0aGUgbG9jYWwgZGlyZWN0b3J5IGlzIHVzZWQgdG8gZXh0cmFjdCB0aGUgZmlsZXMuIE1peGluZyAvIGFuZCBcXFxuICAgICAgICAvLyBtYXkgYmUgdXNlZCB0byBkaXNwbGF5IFxcIHRvIHdpbmRvd3MgdXNlcnMgYW5kIHVzZSAvIHdoZW4gZXh0cmFjdGluZyB0aGUgZmlsZXMuXG4gICAgICAgIC8vIFVuZm9ydHVuYXRlbHksIHRoaXMgbGVhZCBhbHNvIHRvIHNvbWUgaXNzdWVzIDogaHR0cDovL3NlY2xpc3RzLm9yZy9mdWxsZGlzY2xvc3VyZS8yMDA5L1NlcC8zOTRcbiAgICAgICAgdGhpcy5maWxlTmFtZUxlbmd0aCA9IHJlYWRlci5yZWFkSW50KDIpO1xuICAgICAgICBsb2NhbEV4dHJhRmllbGRzTGVuZ3RoID0gcmVhZGVyLnJlYWRJbnQoMik7IC8vIGNhbid0IGJlIHN1cmUgdGhpcyB3aWxsIGJlIHRoZSBzYW1lIGFzIHRoZSBjZW50cmFsIGRpclxuICAgICAgICAvLyB0aGUgZmlsZU5hbWUgaXMgc3RvcmVkIGFzIGJpbmFyeSBkYXRhLCB0aGUgaGFuZGxlVVRGOCBtZXRob2Qgd2lsbCB0YWtlIGNhcmUgb2YgdGhlIGVuY29kaW5nLlxuICAgICAgICB0aGlzLmZpbGVOYW1lID0gcmVhZGVyLnJlYWREYXRhKHRoaXMuZmlsZU5hbWVMZW5ndGgpO1xuICAgICAgICByZWFkZXIuc2tpcChsb2NhbEV4dHJhRmllbGRzTGVuZ3RoKTtcblxuICAgICAgICBpZiAodGhpcy5jb21wcmVzc2VkU2l6ZSA9PT0gLTEgfHwgdGhpcy51bmNvbXByZXNzZWRTaXplID09PSAtMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQnVnIG9yIGNvcnJ1cHRlZCB6aXAgOiBkaWRuJ3QgZ2V0IGVub3VnaCBpbmZvcm1hdGlvbnMgZnJvbSB0aGUgY2VudHJhbCBkaXJlY3RvcnkgXCIgKyBcIihjb21wcmVzc2VkU2l6ZSA9PT0gLTEgfHwgdW5jb21wcmVzc2VkU2l6ZSA9PT0gLTEpXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29tcHJlc3Npb24gPSBmaW5kQ29tcHJlc3Npb24odGhpcy5jb21wcmVzc2lvbk1ldGhvZCk7XG4gICAgICAgIGlmIChjb21wcmVzc2lvbiA9PT0gbnVsbCkgeyAvLyBubyBjb21wcmVzc2lvbiBmb3VuZFxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29ycnVwdGVkIHppcCA6IGNvbXByZXNzaW9uIFwiICsgdXRpbHMucHJldHR5KHRoaXMuY29tcHJlc3Npb25NZXRob2QpICsgXCIgdW5rbm93biAoaW5uZXIgZmlsZSA6IFwiICsgdXRpbHMudHJhbnNmb3JtVG8oXCJzdHJpbmdcIiwgdGhpcy5maWxlTmFtZSkgKyBcIilcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZWNvbXByZXNzZWQgPSBuZXcgQ29tcHJlc3NlZE9iamVjdCh0aGlzLmNvbXByZXNzZWRTaXplLCB0aGlzLnVuY29tcHJlc3NlZFNpemUsIHRoaXMuY3JjMzIsIGNvbXByZXNzaW9uLCByZWFkZXIucmVhZERhdGEodGhpcy5jb21wcmVzc2VkU2l6ZSkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZWFkIHRoZSBjZW50cmFsIHBhcnQgb2YgYSB6aXAgZmlsZSBhbmQgYWRkIHRoZSBpbmZvIGluIHRoaXMgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7RGF0YVJlYWRlcn0gcmVhZGVyIHRoZSByZWFkZXIgdG8gdXNlLlxuICAgICAqL1xuICAgIHJlYWRDZW50cmFsUGFydDogZnVuY3Rpb24ocmVhZGVyKSB7XG4gICAgICAgIHRoaXMudmVyc2lvbk1hZGVCeSA9IHJlYWRlci5yZWFkSW50KDIpO1xuICAgICAgICByZWFkZXIuc2tpcCgyKTtcbiAgICAgICAgLy8gdGhpcy52ZXJzaW9uTmVlZGVkID0gcmVhZGVyLnJlYWRJbnQoMik7XG4gICAgICAgIHRoaXMuYml0RmxhZyA9IHJlYWRlci5yZWFkSW50KDIpO1xuICAgICAgICB0aGlzLmNvbXByZXNzaW9uTWV0aG9kID0gcmVhZGVyLnJlYWRTdHJpbmcoMik7XG4gICAgICAgIHRoaXMuZGF0ZSA9IHJlYWRlci5yZWFkRGF0ZSgpO1xuICAgICAgICB0aGlzLmNyYzMyID0gcmVhZGVyLnJlYWRJbnQoNCk7XG4gICAgICAgIHRoaXMuY29tcHJlc3NlZFNpemUgPSByZWFkZXIucmVhZEludCg0KTtcbiAgICAgICAgdGhpcy51bmNvbXByZXNzZWRTaXplID0gcmVhZGVyLnJlYWRJbnQoNCk7XG4gICAgICAgIHZhciBmaWxlTmFtZUxlbmd0aCA9IHJlYWRlci5yZWFkSW50KDIpO1xuICAgICAgICB0aGlzLmV4dHJhRmllbGRzTGVuZ3RoID0gcmVhZGVyLnJlYWRJbnQoMik7XG4gICAgICAgIHRoaXMuZmlsZUNvbW1lbnRMZW5ndGggPSByZWFkZXIucmVhZEludCgyKTtcbiAgICAgICAgdGhpcy5kaXNrTnVtYmVyU3RhcnQgPSByZWFkZXIucmVhZEludCgyKTtcbiAgICAgICAgdGhpcy5pbnRlcm5hbEZpbGVBdHRyaWJ1dGVzID0gcmVhZGVyLnJlYWRJbnQoMik7XG4gICAgICAgIHRoaXMuZXh0ZXJuYWxGaWxlQXR0cmlidXRlcyA9IHJlYWRlci5yZWFkSW50KDQpO1xuICAgICAgICB0aGlzLmxvY2FsSGVhZGVyT2Zmc2V0ID0gcmVhZGVyLnJlYWRJbnQoNCk7XG5cbiAgICAgICAgaWYgKHRoaXMuaXNFbmNyeXB0ZWQoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRW5jcnlwdGVkIHppcCBhcmUgbm90IHN1cHBvcnRlZFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHdpbGwgYmUgcmVhZCBpbiB0aGUgbG9jYWwgcGFydCwgc2VlIHRoZSBjb21tZW50cyB0aGVyZVxuICAgICAgICByZWFkZXIuc2tpcChmaWxlTmFtZUxlbmd0aCk7XG4gICAgICAgIHRoaXMucmVhZEV4dHJhRmllbGRzKHJlYWRlcik7XG4gICAgICAgIHRoaXMucGFyc2VaSVA2NEV4dHJhRmllbGQocmVhZGVyKTtcbiAgICAgICAgdGhpcy5maWxlQ29tbWVudCA9IHJlYWRlci5yZWFkRGF0YSh0aGlzLmZpbGVDb21tZW50TGVuZ3RoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUGFyc2UgdGhlIGV4dGVybmFsIGZpbGUgYXR0cmlidXRlcyBhbmQgZ2V0IHRoZSB1bml4L2RvcyBwZXJtaXNzaW9ucy5cbiAgICAgKi9cbiAgICBwcm9jZXNzQXR0cmlidXRlczogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnVuaXhQZXJtaXNzaW9ucyA9IG51bGw7XG4gICAgICAgIHRoaXMuZG9zUGVybWlzc2lvbnMgPSBudWxsO1xuICAgICAgICB2YXIgbWFkZUJ5ID0gdGhpcy52ZXJzaW9uTWFkZUJ5ID4+IDg7XG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgd2UgaGF2ZSB0aGUgRE9TIGRpcmVjdG9yeSBmbGFnIHNldC5cbiAgICAgICAgLy8gV2UgbG9vayBmb3IgaXQgaW4gdGhlIERPUyBhbmQgVU5JWCBwZXJtaXNzaW9uc1xuICAgICAgICAvLyBidXQgc29tZSB1bmtub3duIHBsYXRmb3JtIGNvdWxkIHNldCBpdCBhcyBhIGNvbXBhdGliaWxpdHkgZmxhZy5cbiAgICAgICAgdGhpcy5kaXIgPSB0aGlzLmV4dGVybmFsRmlsZUF0dHJpYnV0ZXMgJiAweDAwMTAgPyB0cnVlIDogZmFsc2U7XG5cbiAgICAgICAgaWYobWFkZUJ5ID09PSBNQURFX0JZX0RPUykge1xuICAgICAgICAgICAgLy8gZmlyc3QgNiBiaXRzICgwIHRvIDUpXG4gICAgICAgICAgICB0aGlzLmRvc1Blcm1pc3Npb25zID0gdGhpcy5leHRlcm5hbEZpbGVBdHRyaWJ1dGVzICYgMHgzRjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKG1hZGVCeSA9PT0gTUFERV9CWV9VTklYKSB7XG4gICAgICAgICAgICB0aGlzLnVuaXhQZXJtaXNzaW9ucyA9ICh0aGlzLmV4dGVybmFsRmlsZUF0dHJpYnV0ZXMgPj4gMTYpICYgMHhGRkZGO1xuICAgICAgICAgICAgLy8gdGhlIG9jdGFsIHBlcm1pc3Npb25zIGFyZSBpbiAodGhpcy51bml4UGVybWlzc2lvbnMgJiAweDAxRkYpLnRvU3RyaW5nKDgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZmFpbCBzYWZlIDogaWYgdGhlIG5hbWUgZW5kcyB3aXRoIGEgLyBpdCBwcm9iYWJseSBtZWFucyBhIGZvbGRlclxuICAgICAgICBpZiAoIXRoaXMuZGlyICYmIHRoaXMuZmlsZU5hbWVTdHIuc2xpY2UoLTEpID09PSAnLycpIHtcbiAgICAgICAgICAgIHRoaXMuZGlyID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQYXJzZSB0aGUgWklQNjQgZXh0cmEgZmllbGQgYW5kIG1lcmdlIHRoZSBpbmZvIGluIHRoZSBjdXJyZW50IFppcEVudHJ5LlxuICAgICAqIEBwYXJhbSB7RGF0YVJlYWRlcn0gcmVhZGVyIHRoZSByZWFkZXIgdG8gdXNlLlxuICAgICAqL1xuICAgIHBhcnNlWklQNjRFeHRyYUZpZWxkOiBmdW5jdGlvbihyZWFkZXIpIHtcblxuICAgICAgICBpZiAoIXRoaXMuZXh0cmFGaWVsZHNbMHgwMDAxXSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2hvdWxkIGJlIHNvbWV0aGluZywgcHJlcGFyaW5nIHRoZSBleHRyYSByZWFkZXJcbiAgICAgICAgdmFyIGV4dHJhUmVhZGVyID0gcmVhZGVyRm9yKHRoaXMuZXh0cmFGaWVsZHNbMHgwMDAxXS52YWx1ZSk7XG5cbiAgICAgICAgLy8gSSByZWFsbHkgaG9wZSB0aGF0IHRoZXNlIDY0Yml0cyBpbnRlZ2VyIGNhbiBmaXQgaW4gMzIgYml0cyBpbnRlZ2VyLCBiZWNhdXNlIGpzXG4gICAgICAgIC8vIHdvbid0IGxldCB1cyBoYXZlIG1vcmUuXG4gICAgICAgIGlmICh0aGlzLnVuY29tcHJlc3NlZFNpemUgPT09IHV0aWxzLk1BWF9WQUxVRV8zMkJJVFMpIHtcbiAgICAgICAgICAgIHRoaXMudW5jb21wcmVzc2VkU2l6ZSA9IGV4dHJhUmVhZGVyLnJlYWRJbnQoOCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY29tcHJlc3NlZFNpemUgPT09IHV0aWxzLk1BWF9WQUxVRV8zMkJJVFMpIHtcbiAgICAgICAgICAgIHRoaXMuY29tcHJlc3NlZFNpemUgPSBleHRyYVJlYWRlci5yZWFkSW50KDgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmxvY2FsSGVhZGVyT2Zmc2V0ID09PSB1dGlscy5NQVhfVkFMVUVfMzJCSVRTKSB7XG4gICAgICAgICAgICB0aGlzLmxvY2FsSGVhZGVyT2Zmc2V0ID0gZXh0cmFSZWFkZXIucmVhZEludCg4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5kaXNrTnVtYmVyU3RhcnQgPT09IHV0aWxzLk1BWF9WQUxVRV8zMkJJVFMpIHtcbiAgICAgICAgICAgIHRoaXMuZGlza051bWJlclN0YXJ0ID0gZXh0cmFSZWFkZXIucmVhZEludCg0KTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogUmVhZCB0aGUgY2VudHJhbCBwYXJ0IG9mIGEgemlwIGZpbGUgYW5kIGFkZCB0aGUgaW5mbyBpbiB0aGlzIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge0RhdGFSZWFkZXJ9IHJlYWRlciB0aGUgcmVhZGVyIHRvIHVzZS5cbiAgICAgKi9cbiAgICByZWFkRXh0cmFGaWVsZHM6IGZ1bmN0aW9uKHJlYWRlcikge1xuICAgICAgICB2YXIgZW5kID0gcmVhZGVyLmluZGV4ICsgdGhpcy5leHRyYUZpZWxkc0xlbmd0aCxcbiAgICAgICAgICAgIGV4dHJhRmllbGRJZCxcbiAgICAgICAgICAgIGV4dHJhRmllbGRMZW5ndGgsXG4gICAgICAgICAgICBleHRyYUZpZWxkVmFsdWU7XG5cbiAgICAgICAgaWYgKCF0aGlzLmV4dHJhRmllbGRzKSB7XG4gICAgICAgICAgICB0aGlzLmV4dHJhRmllbGRzID0ge307XG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSAocmVhZGVyLmluZGV4IDwgZW5kKSB7XG4gICAgICAgICAgICBleHRyYUZpZWxkSWQgPSByZWFkZXIucmVhZEludCgyKTtcbiAgICAgICAgICAgIGV4dHJhRmllbGRMZW5ndGggPSByZWFkZXIucmVhZEludCgyKTtcbiAgICAgICAgICAgIGV4dHJhRmllbGRWYWx1ZSA9IHJlYWRlci5yZWFkRGF0YShleHRyYUZpZWxkTGVuZ3RoKTtcblxuICAgICAgICAgICAgdGhpcy5leHRyYUZpZWxkc1tleHRyYUZpZWxkSWRdID0ge1xuICAgICAgICAgICAgICAgIGlkOiBleHRyYUZpZWxkSWQsXG4gICAgICAgICAgICAgICAgbGVuZ3RoOiBleHRyYUZpZWxkTGVuZ3RoLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBleHRyYUZpZWxkVmFsdWVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEFwcGx5IGFuIFVURjggdHJhbnNmb3JtYXRpb24gaWYgbmVlZGVkLlxuICAgICAqL1xuICAgIGhhbmRsZVVURjg6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZGVjb2RlUGFyYW1UeXBlID0gc3VwcG9ydC51aW50OGFycmF5ID8gXCJ1aW50OGFycmF5XCIgOiBcImFycmF5XCI7XG4gICAgICAgIGlmICh0aGlzLnVzZVVURjgoKSkge1xuICAgICAgICAgICAgdGhpcy5maWxlTmFtZVN0ciA9IHV0ZjgudXRmOGRlY29kZSh0aGlzLmZpbGVOYW1lKTtcbiAgICAgICAgICAgIHRoaXMuZmlsZUNvbW1lbnRTdHIgPSB1dGY4LnV0ZjhkZWNvZGUodGhpcy5maWxlQ29tbWVudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgdXBhdGggPSB0aGlzLmZpbmRFeHRyYUZpZWxkVW5pY29kZVBhdGgoKTtcbiAgICAgICAgICAgIGlmICh1cGF0aCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZmlsZU5hbWVTdHIgPSB1cGF0aDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gQVNDSUkgdGV4dCBvciB1bnN1cHBvcnRlZCBjb2RlIHBhZ2VcbiAgICAgICAgICAgICAgICB2YXIgZmlsZU5hbWVCeXRlQXJyYXkgPSAgdXRpbHMudHJhbnNmb3JtVG8oZGVjb2RlUGFyYW1UeXBlLCB0aGlzLmZpbGVOYW1lKTtcbiAgICAgICAgICAgICAgICB0aGlzLmZpbGVOYW1lU3RyID0gdGhpcy5sb2FkT3B0aW9ucy5kZWNvZGVGaWxlTmFtZShmaWxlTmFtZUJ5dGVBcnJheSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB1Y29tbWVudCA9IHRoaXMuZmluZEV4dHJhRmllbGRVbmljb2RlQ29tbWVudCgpO1xuICAgICAgICAgICAgaWYgKHVjb21tZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5maWxlQ29tbWVudFN0ciA9IHVjb21tZW50O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBBU0NJSSB0ZXh0IG9yIHVuc3VwcG9ydGVkIGNvZGUgcGFnZVxuICAgICAgICAgICAgICAgIHZhciBjb21tZW50Qnl0ZUFycmF5ID0gIHV0aWxzLnRyYW5zZm9ybVRvKGRlY29kZVBhcmFtVHlwZSwgdGhpcy5maWxlQ29tbWVudCk7XG4gICAgICAgICAgICAgICAgdGhpcy5maWxlQ29tbWVudFN0ciA9IHRoaXMubG9hZE9wdGlvbnMuZGVjb2RlRmlsZU5hbWUoY29tbWVudEJ5dGVBcnJheSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmluZCB0aGUgdW5pY29kZSBwYXRoIGRlY2xhcmVkIGluIHRoZSBleHRyYSBmaWVsZCwgaWYgYW55LlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gdGhlIHVuaWNvZGUgcGF0aCwgbnVsbCBvdGhlcndpc2UuXG4gICAgICovXG4gICAgZmluZEV4dHJhRmllbGRVbmljb2RlUGF0aDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB1cGF0aEZpZWxkID0gdGhpcy5leHRyYUZpZWxkc1sweDcwNzVdO1xuICAgICAgICBpZiAodXBhdGhGaWVsZCkge1xuICAgICAgICAgICAgdmFyIGV4dHJhUmVhZGVyID0gcmVhZGVyRm9yKHVwYXRoRmllbGQudmFsdWUpO1xuXG4gICAgICAgICAgICAvLyB3cm9uZyB2ZXJzaW9uXG4gICAgICAgICAgICBpZiAoZXh0cmFSZWFkZXIucmVhZEludCgxKSAhPT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyB0aGUgY3JjIG9mIHRoZSBmaWxlbmFtZSBjaGFuZ2VkLCB0aGlzIGZpZWxkIGlzIG91dCBvZiBkYXRlLlxuICAgICAgICAgICAgaWYgKGNyYzMyZm4odGhpcy5maWxlTmFtZSkgIT09IGV4dHJhUmVhZGVyLnJlYWRJbnQoNCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHV0ZjgudXRmOGRlY29kZShleHRyYVJlYWRlci5yZWFkRGF0YSh1cGF0aEZpZWxkLmxlbmd0aCAtIDUpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmluZCB0aGUgdW5pY29kZSBjb21tZW50IGRlY2xhcmVkIGluIHRoZSBleHRyYSBmaWVsZCwgaWYgYW55LlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gdGhlIHVuaWNvZGUgY29tbWVudCwgbnVsbCBvdGhlcndpc2UuXG4gICAgICovXG4gICAgZmluZEV4dHJhRmllbGRVbmljb2RlQ29tbWVudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB1Y29tbWVudEZpZWxkID0gdGhpcy5leHRyYUZpZWxkc1sweDYzNzVdO1xuICAgICAgICBpZiAodWNvbW1lbnRGaWVsZCkge1xuICAgICAgICAgICAgdmFyIGV4dHJhUmVhZGVyID0gcmVhZGVyRm9yKHVjb21tZW50RmllbGQudmFsdWUpO1xuXG4gICAgICAgICAgICAvLyB3cm9uZyB2ZXJzaW9uXG4gICAgICAgICAgICBpZiAoZXh0cmFSZWFkZXIucmVhZEludCgxKSAhPT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyB0aGUgY3JjIG9mIHRoZSBjb21tZW50IGNoYW5nZWQsIHRoaXMgZmllbGQgaXMgb3V0IG9mIGRhdGUuXG4gICAgICAgICAgICBpZiAoY3JjMzJmbih0aGlzLmZpbGVDb21tZW50KSAhPT0gZXh0cmFSZWFkZXIucmVhZEludCg0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdXRmOC51dGY4ZGVjb2RlKGV4dHJhUmVhZGVyLnJlYWREYXRhKHVjb21tZW50RmllbGQubGVuZ3RoIC0gNSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn07XG5tb2R1bGUuZXhwb3J0cyA9IFppcEVudHJ5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgU3RyZWFtSGVscGVyID0gcmVxdWlyZSgnLi9zdHJlYW0vU3RyZWFtSGVscGVyJyk7XG52YXIgRGF0YVdvcmtlciA9IHJlcXVpcmUoJy4vc3RyZWFtL0RhdGFXb3JrZXInKTtcbnZhciB1dGY4ID0gcmVxdWlyZSgnLi91dGY4Jyk7XG52YXIgQ29tcHJlc3NlZE9iamVjdCA9IHJlcXVpcmUoJy4vY29tcHJlc3NlZE9iamVjdCcpO1xudmFyIEdlbmVyaWNXb3JrZXIgPSByZXF1aXJlKCcuL3N0cmVhbS9HZW5lcmljV29ya2VyJyk7XG5cbi8qKlxuICogQSBzaW1wbGUgb2JqZWN0IHJlcHJlc2VudGluZyBhIGZpbGUgaW4gdGhlIHppcCBmaWxlLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSB0aGUgbmFtZSBvZiB0aGUgZmlsZVxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXlCdWZmZXJ8VWludDhBcnJheXxCdWZmZXJ9IGRhdGEgdGhlIGRhdGFcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIHRoZSBvcHRpb25zIG9mIHRoZSBmaWxlXG4gKi9cbnZhciBaaXBPYmplY3QgPSBmdW5jdGlvbihuYW1lLCBkYXRhLCBvcHRpb25zKSB7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLmRpciA9IG9wdGlvbnMuZGlyO1xuICAgIHRoaXMuZGF0ZSA9IG9wdGlvbnMuZGF0ZTtcbiAgICB0aGlzLmNvbW1lbnQgPSBvcHRpb25zLmNvbW1lbnQ7XG4gICAgdGhpcy51bml4UGVybWlzc2lvbnMgPSBvcHRpb25zLnVuaXhQZXJtaXNzaW9ucztcbiAgICB0aGlzLmRvc1Blcm1pc3Npb25zID0gb3B0aW9ucy5kb3NQZXJtaXNzaW9ucztcblxuICAgIHRoaXMuX2RhdGEgPSBkYXRhO1xuICAgIHRoaXMuX2RhdGFCaW5hcnkgPSBvcHRpb25zLmJpbmFyeTtcbiAgICAvLyBrZWVwIG9ubHkgdGhlIGNvbXByZXNzaW9uXG4gICAgdGhpcy5vcHRpb25zID0ge1xuICAgICAgICBjb21wcmVzc2lvbiA6IG9wdGlvbnMuY29tcHJlc3Npb24sXG4gICAgICAgIGNvbXByZXNzaW9uT3B0aW9ucyA6IG9wdGlvbnMuY29tcHJlc3Npb25PcHRpb25zXG4gICAgfTtcbn07XG5cblppcE9iamVjdC5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGFuIGludGVybmFsIHN0cmVhbSBmb3IgdGhlIGNvbnRlbnQgb2YgdGhpcyBvYmplY3QuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgdGhlIHR5cGUgb2YgZWFjaCBjaHVuay5cbiAgICAgKiBAcmV0dXJuIFN0cmVhbUhlbHBlciB0aGUgc3RyZWFtLlxuICAgICAqL1xuICAgIGludGVybmFsU3RyZWFtOiBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gbnVsbCwgb3V0cHV0VHlwZSA9IFwic3RyaW5nXCI7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoIXR5cGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBvdXRwdXQgdHlwZSBzcGVjaWZpZWQuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3V0cHV0VHlwZSA9IHR5cGUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIHZhciBhc2tVbmljb2RlU3RyaW5nID0gb3V0cHV0VHlwZSA9PT0gXCJzdHJpbmdcIiB8fCBvdXRwdXRUeXBlID09PSBcInRleHRcIjtcbiAgICAgICAgICAgIGlmIChvdXRwdXRUeXBlID09PSBcImJpbmFyeXN0cmluZ1wiIHx8IG91dHB1dFR5cGUgPT09IFwidGV4dFwiKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0VHlwZSA9IFwic3RyaW5nXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLl9kZWNvbXByZXNzV29ya2VyKCk7XG5cbiAgICAgICAgICAgIHZhciBpc1VuaWNvZGVTdHJpbmcgPSAhdGhpcy5fZGF0YUJpbmFyeTtcblxuICAgICAgICAgICAgaWYgKGlzVW5pY29kZVN0cmluZyAmJiAhYXNrVW5pY29kZVN0cmluZykge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5waXBlKG5ldyB1dGY4LlV0ZjhFbmNvZGVXb3JrZXIoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzVW5pY29kZVN0cmluZyAmJiBhc2tVbmljb2RlU3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnBpcGUobmV3IHV0ZjguVXRmOERlY29kZVdvcmtlcigpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gbmV3IEdlbmVyaWNXb3JrZXIoXCJlcnJvclwiKTtcbiAgICAgICAgICAgIHJlc3VsdC5lcnJvcihlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgU3RyZWFtSGVscGVyKHJlc3VsdCwgb3V0cHV0VHlwZSwgXCJcIik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFByZXBhcmUgdGhlIGNvbnRlbnQgaW4gdGhlIGFza2VkIHR5cGUuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgdGhlIHR5cGUgb2YgdGhlIHJlc3VsdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvblVwZGF0ZSBhIGZ1bmN0aW9uIHRvIGNhbGwgb24gZWFjaCBpbnRlcm5hbCB1cGRhdGUuXG4gICAgICogQHJldHVybiBQcm9taXNlIHRoZSBwcm9taXNlIG9mIHRoZSByZXN1bHQuXG4gICAgICovXG4gICAgYXN5bmM6IGZ1bmN0aW9uICh0eXBlLCBvblVwZGF0ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbFN0cmVhbSh0eXBlKS5hY2N1bXVsYXRlKG9uVXBkYXRlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUHJlcGFyZSB0aGUgY29udGVudCBhcyBhIG5vZGVqcyBzdHJlYW0uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgdGhlIHR5cGUgb2YgZWFjaCBjaHVuay5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvblVwZGF0ZSBhIGZ1bmN0aW9uIHRvIGNhbGwgb24gZWFjaCBpbnRlcm5hbCB1cGRhdGUuXG4gICAgICogQHJldHVybiBTdHJlYW0gdGhlIHN0cmVhbS5cbiAgICAgKi9cbiAgICBub2RlU3RyZWFtOiBmdW5jdGlvbiAodHlwZSwgb25VcGRhdGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxTdHJlYW0odHlwZSB8fCBcIm5vZGVidWZmZXJcIikudG9Ob2RlanNTdHJlYW0ob25VcGRhdGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSB3b3JrZXIgZm9yIHRoZSBjb21wcmVzc2VkIGNvbnRlbnQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29tcHJlc3Npb24gdGhlIGNvbXByZXNzaW9uIG9iamVjdCB0byB1c2UuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbXByZXNzaW9uT3B0aW9ucyB0aGUgb3B0aW9ucyB0byB1c2Ugd2hlbiBjb21wcmVzc2luZy5cbiAgICAgKiBAcmV0dXJuIFdvcmtlciB0aGUgd29ya2VyLlxuICAgICAqL1xuICAgIF9jb21wcmVzc1dvcmtlcjogZnVuY3Rpb24gKGNvbXByZXNzaW9uLCBjb21wcmVzc2lvbk9wdGlvbnMpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgdGhpcy5fZGF0YSBpbnN0YW5jZW9mIENvbXByZXNzZWRPYmplY3QgJiZcbiAgICAgICAgICAgIHRoaXMuX2RhdGEuY29tcHJlc3Npb24ubWFnaWMgPT09IGNvbXByZXNzaW9uLm1hZ2ljXG4gICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEuZ2V0Q29tcHJlc3NlZFdvcmtlcigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuX2RlY29tcHJlc3NXb3JrZXIoKTtcbiAgICAgICAgICAgIGlmKCF0aGlzLl9kYXRhQmluYXJ5KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnBpcGUobmV3IHV0ZjguVXRmOEVuY29kZVdvcmtlcigpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBDb21wcmVzc2VkT2JqZWN0LmNyZWF0ZVdvcmtlckZyb20ocmVzdWx0LCBjb21wcmVzc2lvbiwgY29tcHJlc3Npb25PcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgd29ya2VyIGZvciB0aGUgZGVjb21wcmVzc2VkIGNvbnRlbnQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJuIFdvcmtlciB0aGUgd29ya2VyLlxuICAgICAqL1xuICAgIF9kZWNvbXByZXNzV29ya2VyIDogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fZGF0YSBpbnN0YW5jZW9mIENvbXByZXNzZWRPYmplY3QpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLmdldENvbnRlbnRXb3JrZXIoKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9kYXRhIGluc3RhbmNlb2YgR2VuZXJpY1dvcmtlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGFXb3JrZXIodGhpcy5fZGF0YSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG52YXIgcmVtb3ZlZE1ldGhvZHMgPSBbXCJhc1RleHRcIiwgXCJhc0JpbmFyeVwiLCBcImFzTm9kZUJ1ZmZlclwiLCBcImFzVWludDhBcnJheVwiLCBcImFzQXJyYXlCdWZmZXJcIl07XG52YXIgcmVtb3ZlZEZuID0gZnVuY3Rpb24gKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlRoaXMgbWV0aG9kIGhhcyBiZWVuIHJlbW92ZWQgaW4gSlNaaXAgMy4wLCBwbGVhc2UgY2hlY2sgdGhlIHVwZ3JhZGUgZ3VpZGUuXCIpO1xufTtcblxuZm9yKHZhciBpID0gMDsgaSA8IHJlbW92ZWRNZXRob2RzLmxlbmd0aDsgaSsrKSB7XG4gICAgWmlwT2JqZWN0LnByb3RvdHlwZVtyZW1vdmVkTWV0aG9kc1tpXV0gPSByZW1vdmVkRm47XG59XG5tb2R1bGUuZXhwb3J0cyA9IFppcE9iamVjdDtcbiIsInJlcXVpcmUoJy4uL21vZHVsZXMvd2ViLmltbWVkaWF0ZScpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9tb2R1bGVzL19jb3JlJykuc2V0SW1tZWRpYXRlOyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICBpZih0eXBlb2YgaXQgIT0gJ2Z1bmN0aW9uJyl0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBhIGZ1bmN0aW9uIScpO1xuICByZXR1cm4gaXQ7XG59OyIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIGlmKCFpc09iamVjdChpdCkpdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYW4gb2JqZWN0IScpO1xuICByZXR1cm4gaXQ7XG59OyIsInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoaXQpLnNsaWNlKDgsIC0xKTtcbn07IiwidmFyIGNvcmUgPSBtb2R1bGUuZXhwb3J0cyA9IHt2ZXJzaW9uOiAnMi4zLjAnfTtcbmlmKHR5cGVvZiBfX2UgPT0gJ251bWJlcicpX19lID0gY29yZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZiIsIi8vIG9wdGlvbmFsIC8gc2ltcGxlIGNvbnRleHQgYmluZGluZ1xudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZm4sIHRoYXQsIGxlbmd0aCl7XG4gIGFGdW5jdGlvbihmbik7XG4gIGlmKHRoYXQgPT09IHVuZGVmaW5lZClyZXR1cm4gZm47XG4gIHN3aXRjaChsZW5ndGgpe1xuICAgIGNhc2UgMTogcmV0dXJuIGZ1bmN0aW9uKGEpe1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSk7XG4gICAgfTtcbiAgICBjYXNlIDI6IHJldHVybiBmdW5jdGlvbihhLCBiKXtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIpO1xuICAgIH07XG4gICAgY2FzZSAzOiByZXR1cm4gZnVuY3Rpb24oYSwgYiwgYyl7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiLCBjKTtcbiAgICB9O1xuICB9XG4gIHJldHVybiBmdW5jdGlvbigvKiAuLi5hcmdzICovKXtcbiAgICByZXR1cm4gZm4uYXBwbHkodGhhdCwgYXJndW1lbnRzKTtcbiAgfTtcbn07IiwiLy8gVGhhbmsncyBJRTggZm9yIGhpcyBmdW5ueSBkZWZpbmVQcm9wZXJ0eVxubW9kdWxlLmV4cG9ydHMgPSAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbigpe1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAnYScsIHtnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiA3OyB9fSkuYSAhPSA3O1xufSk7IiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0JylcbiAgLCBkb2N1bWVudCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLmRvY3VtZW50XG4gIC8vIGluIG9sZCBJRSB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCBpcyAnb2JqZWN0J1xuICAsIGlzID0gaXNPYmplY3QoZG9jdW1lbnQpICYmIGlzT2JqZWN0KGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBpcyA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoaXQpIDoge307XG59OyIsInZhciBnbG9iYWwgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIGNvcmUgICAgICA9IHJlcXVpcmUoJy4vX2NvcmUnKVxuICAsIGN0eCAgICAgICA9IHJlcXVpcmUoJy4vX2N0eCcpXG4gICwgaGlkZSAgICAgID0gcmVxdWlyZSgnLi9faGlkZScpXG4gICwgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG5cbnZhciAkZXhwb3J0ID0gZnVuY3Rpb24odHlwZSwgbmFtZSwgc291cmNlKXtcbiAgdmFyIElTX0ZPUkNFRCA9IHR5cGUgJiAkZXhwb3J0LkZcbiAgICAsIElTX0dMT0JBTCA9IHR5cGUgJiAkZXhwb3J0LkdcbiAgICAsIElTX1NUQVRJQyA9IHR5cGUgJiAkZXhwb3J0LlNcbiAgICAsIElTX1BST1RPICA9IHR5cGUgJiAkZXhwb3J0LlBcbiAgICAsIElTX0JJTkQgICA9IHR5cGUgJiAkZXhwb3J0LkJcbiAgICAsIElTX1dSQVAgICA9IHR5cGUgJiAkZXhwb3J0LldcbiAgICAsIGV4cG9ydHMgICA9IElTX0dMT0JBTCA/IGNvcmUgOiBjb3JlW25hbWVdIHx8IChjb3JlW25hbWVdID0ge30pXG4gICAgLCBleHBQcm90byAgPSBleHBvcnRzW1BST1RPVFlQRV1cbiAgICAsIHRhcmdldCAgICA9IElTX0dMT0JBTCA/IGdsb2JhbCA6IElTX1NUQVRJQyA/IGdsb2JhbFtuYW1lXSA6IChnbG9iYWxbbmFtZV0gfHwge30pW1BST1RPVFlQRV1cbiAgICAsIGtleSwgb3duLCBvdXQ7XG4gIGlmKElTX0dMT0JBTClzb3VyY2UgPSBuYW1lO1xuICBmb3Ioa2V5IGluIHNvdXJjZSl7XG4gICAgLy8gY29udGFpbnMgaW4gbmF0aXZlXG4gICAgb3duID0gIUlTX0ZPUkNFRCAmJiB0YXJnZXQgJiYgdGFyZ2V0W2tleV0gIT09IHVuZGVmaW5lZDtcbiAgICBpZihvd24gJiYga2V5IGluIGV4cG9ydHMpY29udGludWU7XG4gICAgLy8gZXhwb3J0IG5hdGl2ZSBvciBwYXNzZWRcbiAgICBvdXQgPSBvd24gPyB0YXJnZXRba2V5XSA6IHNvdXJjZVtrZXldO1xuICAgIC8vIHByZXZlbnQgZ2xvYmFsIHBvbGx1dGlvbiBmb3IgbmFtZXNwYWNlc1xuICAgIGV4cG9ydHNba2V5XSA9IElTX0dMT0JBTCAmJiB0eXBlb2YgdGFyZ2V0W2tleV0gIT0gJ2Z1bmN0aW9uJyA/IHNvdXJjZVtrZXldXG4gICAgLy8gYmluZCB0aW1lcnMgdG8gZ2xvYmFsIGZvciBjYWxsIGZyb20gZXhwb3J0IGNvbnRleHRcbiAgICA6IElTX0JJTkQgJiYgb3duID8gY3R4KG91dCwgZ2xvYmFsKVxuICAgIC8vIHdyYXAgZ2xvYmFsIGNvbnN0cnVjdG9ycyBmb3IgcHJldmVudCBjaGFuZ2UgdGhlbSBpbiBsaWJyYXJ5XG4gICAgOiBJU19XUkFQICYmIHRhcmdldFtrZXldID09IG91dCA/IChmdW5jdGlvbihDKXtcbiAgICAgIHZhciBGID0gZnVuY3Rpb24oYSwgYiwgYyl7XG4gICAgICAgIGlmKHRoaXMgaW5zdGFuY2VvZiBDKXtcbiAgICAgICAgICBzd2l0Y2goYXJndW1lbnRzLmxlbmd0aCl7XG4gICAgICAgICAgICBjYXNlIDA6IHJldHVybiBuZXcgQztcbiAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIG5ldyBDKGEpO1xuICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gbmV3IEMoYSwgYik7XG4gICAgICAgICAgfSByZXR1cm4gbmV3IEMoYSwgYiwgYyk7XG4gICAgICAgIH0gcmV0dXJuIEMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH07XG4gICAgICBGW1BST1RPVFlQRV0gPSBDW1BST1RPVFlQRV07XG4gICAgICByZXR1cm4gRjtcbiAgICAvLyBtYWtlIHN0YXRpYyB2ZXJzaW9ucyBmb3IgcHJvdG90eXBlIG1ldGhvZHNcbiAgICB9KShvdXQpIDogSVNfUFJPVE8gJiYgdHlwZW9mIG91dCA9PSAnZnVuY3Rpb24nID8gY3R4KEZ1bmN0aW9uLmNhbGwsIG91dCkgOiBvdXQ7XG4gICAgLy8gZXhwb3J0IHByb3RvIG1ldGhvZHMgdG8gY29yZS4lQ09OU1RSVUNUT1IlLm1ldGhvZHMuJU5BTUUlXG4gICAgaWYoSVNfUFJPVE8pe1xuICAgICAgKGV4cG9ydHMudmlydHVhbCB8fCAoZXhwb3J0cy52aXJ0dWFsID0ge30pKVtrZXldID0gb3V0O1xuICAgICAgLy8gZXhwb3J0IHByb3RvIG1ldGhvZHMgdG8gY29yZS4lQ09OU1RSVUNUT1IlLnByb3RvdHlwZS4lTkFNRSVcbiAgICAgIGlmKHR5cGUgJiAkZXhwb3J0LlIgJiYgZXhwUHJvdG8gJiYgIWV4cFByb3RvW2tleV0paGlkZShleHBQcm90bywga2V5LCBvdXQpO1xuICAgIH1cbiAgfVxufTtcbi8vIHR5cGUgYml0bWFwXG4kZXhwb3J0LkYgPSAxOyAgIC8vIGZvcmNlZFxuJGV4cG9ydC5HID0gMjsgICAvLyBnbG9iYWxcbiRleHBvcnQuUyA9IDQ7ICAgLy8gc3RhdGljXG4kZXhwb3J0LlAgPSA4OyAgIC8vIHByb3RvXG4kZXhwb3J0LkIgPSAxNjsgIC8vIGJpbmRcbiRleHBvcnQuVyA9IDMyOyAgLy8gd3JhcFxuJGV4cG9ydC5VID0gNjQ7ICAvLyBzYWZlXG4kZXhwb3J0LlIgPSAxMjg7IC8vIHJlYWwgcHJvdG8gbWV0aG9kIGZvciBgbGlicmFyeWAgXG5tb2R1bGUuZXhwb3J0cyA9ICRleHBvcnQ7IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihleGVjKXtcbiAgdHJ5IHtcbiAgICByZXR1cm4gISFleGVjKCk7XG4gIH0gY2F0Y2goZSl7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07IiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzg2I2lzc3VlY29tbWVudC0xMTU3NTkwMjhcbnZhciBnbG9iYWwgPSBtb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiB3aW5kb3cgIT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Lk1hdGggPT0gTWF0aFxuICA/IHdpbmRvdyA6IHR5cGVvZiBzZWxmICE9ICd1bmRlZmluZWQnICYmIHNlbGYuTWF0aCA9PSBNYXRoID8gc2VsZiA6IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5pZih0eXBlb2YgX19nID09ICdudW1iZXInKV9fZyA9IGdsb2JhbDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZiIsInZhciBkUCAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJylcbiAgLCBjcmVhdGVEZXNjID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gZnVuY3Rpb24ob2JqZWN0LCBrZXksIHZhbHVlKXtcbiAgcmV0dXJuIGRQLmYob2JqZWN0LCBrZXksIGNyZWF0ZURlc2MoMSwgdmFsdWUpKTtcbn0gOiBmdW5jdGlvbihvYmplY3QsIGtleSwgdmFsdWUpe1xuICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICByZXR1cm4gb2JqZWN0O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLmRvY3VtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDsiLCJtb2R1bGUuZXhwb3J0cyA9ICFyZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpICYmICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uKCl7XHJcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXF1aXJlKCcuL19kb20tY3JlYXRlJykoJ2RpdicpLCAnYScsIHtnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiA3OyB9fSkuYSAhPSA3O1xyXG59KTsiLCIvLyBmYXN0IGFwcGx5LCBodHRwOi8vanNwZXJmLmxua2l0LmNvbS9mYXN0LWFwcGx5LzVcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZm4sIGFyZ3MsIHRoYXQpe1xuICB2YXIgdW4gPSB0aGF0ID09PSB1bmRlZmluZWQ7XG4gIHN3aXRjaChhcmdzLmxlbmd0aCl7XG4gICAgY2FzZSAwOiByZXR1cm4gdW4gPyBmbigpXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQpO1xuICAgIGNhc2UgMTogcmV0dXJuIHVuID8gZm4oYXJnc1swXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSk7XG4gICAgY2FzZSAyOiByZXR1cm4gdW4gPyBmbihhcmdzWzBdLCBhcmdzWzFdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICBjYXNlIDM6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgIGNhc2UgNDogcmV0dXJuIHVuID8gZm4oYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSk7XG4gIH0gcmV0dXJuICAgICAgICAgICAgICBmbi5hcHBseSh0aGF0LCBhcmdzKTtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiB0eXBlb2YgaXQgPT09ICdvYmplY3QnID8gaXQgIT09IG51bGwgOiB0eXBlb2YgaXQgPT09ICdmdW5jdGlvbic7XG59OyIsInZhciBhbk9iamVjdCAgICAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgSUU4X0RPTV9ERUZJTkUgPSByZXF1aXJlKCcuL19pZTgtZG9tLWRlZmluZScpXG4gICwgdG9QcmltaXRpdmUgICAgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKVxuICAsIGRQICAgICAgICAgICAgID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXG5leHBvcnRzLmYgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gT2JqZWN0LmRlZmluZVByb3BlcnR5IDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcyl7XG4gIGFuT2JqZWN0KE8pO1xuICBQID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XG4gIGFuT2JqZWN0KEF0dHJpYnV0ZXMpO1xuICBpZihJRThfRE9NX0RFRklORSl0cnkge1xuICAgIHJldHVybiBkUChPLCBQLCBBdHRyaWJ1dGVzKTtcbiAgfSBjYXRjaChlKXsgLyogZW1wdHkgKi8gfVxuICBpZignZ2V0JyBpbiBBdHRyaWJ1dGVzIHx8ICdzZXQnIGluIEF0dHJpYnV0ZXMpdGhyb3cgVHlwZUVycm9yKCdBY2Nlc3NvcnMgbm90IHN1cHBvcnRlZCEnKTtcbiAgaWYoJ3ZhbHVlJyBpbiBBdHRyaWJ1dGVzKU9bUF0gPSBBdHRyaWJ1dGVzLnZhbHVlO1xuICByZXR1cm4gTztcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihiaXRtYXAsIHZhbHVlKXtcbiAgcmV0dXJuIHtcbiAgICBlbnVtZXJhYmxlICA6ICEoYml0bWFwICYgMSksXG4gICAgY29uZmlndXJhYmxlOiAhKGJpdG1hcCAmIDIpLFxuICAgIHdyaXRhYmxlICAgIDogIShiaXRtYXAgJiA0KSxcbiAgICB2YWx1ZSAgICAgICA6IHZhbHVlXG4gIH07XG59OyIsInZhciBjdHggICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19jdHgnKVxuICAsIGludm9rZSAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2ludm9rZScpXG4gICwgaHRtbCAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9faHRtbCcpXG4gICwgY2VsICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fZG9tLWNyZWF0ZScpXG4gICwgZ2xvYmFsICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBwcm9jZXNzICAgICAgICAgICAgPSBnbG9iYWwucHJvY2Vzc1xuICAsIHNldFRhc2sgICAgICAgICAgICA9IGdsb2JhbC5zZXRJbW1lZGlhdGVcbiAgLCBjbGVhclRhc2sgICAgICAgICAgPSBnbG9iYWwuY2xlYXJJbW1lZGlhdGVcbiAgLCBNZXNzYWdlQ2hhbm5lbCAgICAgPSBnbG9iYWwuTWVzc2FnZUNoYW5uZWxcbiAgLCBjb3VudGVyICAgICAgICAgICAgPSAwXG4gICwgcXVldWUgICAgICAgICAgICAgID0ge31cbiAgLCBPTlJFQURZU1RBVEVDSEFOR0UgPSAnb25yZWFkeXN0YXRlY2hhbmdlJ1xuICAsIGRlZmVyLCBjaGFubmVsLCBwb3J0O1xudmFyIHJ1biA9IGZ1bmN0aW9uKCl7XG4gIHZhciBpZCA9ICt0aGlzO1xuICBpZihxdWV1ZS5oYXNPd25Qcm9wZXJ0eShpZCkpe1xuICAgIHZhciBmbiA9IHF1ZXVlW2lkXTtcbiAgICBkZWxldGUgcXVldWVbaWRdO1xuICAgIGZuKCk7XG4gIH1cbn07XG52YXIgbGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCl7XG4gIHJ1bi5jYWxsKGV2ZW50LmRhdGEpO1xufTtcbi8vIE5vZGUuanMgMC45KyAmIElFMTArIGhhcyBzZXRJbW1lZGlhdGUsIG90aGVyd2lzZTpcbmlmKCFzZXRUYXNrIHx8ICFjbGVhclRhc2spe1xuICBzZXRUYXNrID0gZnVuY3Rpb24gc2V0SW1tZWRpYXRlKGZuKXtcbiAgICB2YXIgYXJncyA9IFtdLCBpID0gMTtcbiAgICB3aGlsZShhcmd1bWVudHMubGVuZ3RoID4gaSlhcmdzLnB1c2goYXJndW1lbnRzW2krK10pO1xuICAgIHF1ZXVlWysrY291bnRlcl0gPSBmdW5jdGlvbigpe1xuICAgICAgaW52b2tlKHR5cGVvZiBmbiA9PSAnZnVuY3Rpb24nID8gZm4gOiBGdW5jdGlvbihmbiksIGFyZ3MpO1xuICAgIH07XG4gICAgZGVmZXIoY291bnRlcik7XG4gICAgcmV0dXJuIGNvdW50ZXI7XG4gIH07XG4gIGNsZWFyVGFzayA9IGZ1bmN0aW9uIGNsZWFySW1tZWRpYXRlKGlkKXtcbiAgICBkZWxldGUgcXVldWVbaWRdO1xuICB9O1xuICAvLyBOb2RlLmpzIDAuOC1cbiAgaWYocmVxdWlyZSgnLi9fY29mJykocHJvY2VzcykgPT0gJ3Byb2Nlc3MnKXtcbiAgICBkZWZlciA9IGZ1bmN0aW9uKGlkKXtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soY3R4KHJ1biwgaWQsIDEpKTtcbiAgICB9O1xuICAvLyBCcm93c2VycyB3aXRoIE1lc3NhZ2VDaGFubmVsLCBpbmNsdWRlcyBXZWJXb3JrZXJzXG4gIH0gZWxzZSBpZihNZXNzYWdlQ2hhbm5lbCl7XG4gICAgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbDtcbiAgICBwb3J0ICAgID0gY2hhbm5lbC5wb3J0MjtcbiAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGxpc3RlbmVyO1xuICAgIGRlZmVyID0gY3R4KHBvcnQucG9zdE1lc3NhZ2UsIHBvcnQsIDEpO1xuICAvLyBCcm93c2VycyB3aXRoIHBvc3RNZXNzYWdlLCBza2lwIFdlYldvcmtlcnNcbiAgLy8gSUU4IGhhcyBwb3N0TWVzc2FnZSwgYnV0IGl0J3Mgc3luYyAmIHR5cGVvZiBpdHMgcG9zdE1lc3NhZ2UgaXMgJ29iamVjdCdcbiAgfSBlbHNlIGlmKGdsb2JhbC5hZGRFdmVudExpc3RlbmVyICYmIHR5cGVvZiBwb3N0TWVzc2FnZSA9PSAnZnVuY3Rpb24nICYmICFnbG9iYWwuaW1wb3J0U2NyaXB0cyl7XG4gICAgZGVmZXIgPSBmdW5jdGlvbihpZCl7XG4gICAgICBnbG9iYWwucG9zdE1lc3NhZ2UoaWQgKyAnJywgJyonKTtcbiAgICB9O1xuICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgbGlzdGVuZXIsIGZhbHNlKTtcbiAgLy8gSUU4LVxuICB9IGVsc2UgaWYoT05SRUFEWVNUQVRFQ0hBTkdFIGluIGNlbCgnc2NyaXB0Jykpe1xuICAgIGRlZmVyID0gZnVuY3Rpb24oaWQpe1xuICAgICAgaHRtbC5hcHBlbmRDaGlsZChjZWwoJ3NjcmlwdCcpKVtPTlJFQURZU1RBVEVDSEFOR0VdID0gZnVuY3Rpb24oKXtcbiAgICAgICAgaHRtbC5yZW1vdmVDaGlsZCh0aGlzKTtcbiAgICAgICAgcnVuLmNhbGwoaWQpO1xuICAgICAgfTtcbiAgICB9O1xuICAvLyBSZXN0IG9sZCBicm93c2Vyc1xuICB9IGVsc2Uge1xuICAgIGRlZmVyID0gZnVuY3Rpb24oaWQpe1xuICAgICAgc2V0VGltZW91dChjdHgocnVuLCBpZCwgMSksIDApO1xuICAgIH07XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0ge1xuICBzZXQ6ICAgc2V0VGFzayxcbiAgY2xlYXI6IGNsZWFyVGFza1xufTsiLCIvLyA3LjEuMSBUb1ByaW1pdGl2ZShpbnB1dCBbLCBQcmVmZXJyZWRUeXBlXSlcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xuLy8gaW5zdGVhZCBvZiB0aGUgRVM2IHNwZWMgdmVyc2lvbiwgd2UgZGlkbid0IGltcGxlbWVudCBAQHRvUHJpbWl0aXZlIGNhc2Vcbi8vIGFuZCB0aGUgc2Vjb25kIGFyZ3VtZW50IC0gZmxhZyAtIHByZWZlcnJlZCB0eXBlIGlzIGEgc3RyaW5nXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0LCBTKXtcbiAgaWYoIWlzT2JqZWN0KGl0KSlyZXR1cm4gaXQ7XG4gIHZhciBmbiwgdmFsO1xuICBpZihTICYmIHR5cGVvZiAoZm4gPSBpdC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKXJldHVybiB2YWw7XG4gIGlmKHR5cGVvZiAoZm4gPSBpdC52YWx1ZU9mKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpcmV0dXJuIHZhbDtcbiAgaWYoIVMgJiYgdHlwZW9mIChmbiA9IGl0LnRvU3RyaW5nKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpcmV0dXJuIHZhbDtcbiAgdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY29udmVydCBvYmplY3QgdG8gcHJpbWl0aXZlIHZhbHVlXCIpO1xufTsiLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJHRhc2sgICA9IHJlcXVpcmUoJy4vX3Rhc2snKTtcbiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5CLCB7XG4gIHNldEltbWVkaWF0ZTogICAkdGFzay5zZXQsXG4gIGNsZWFySW1tZWRpYXRlOiAkdGFzay5jbGVhclxufSk7IiwiJ3VzZSBzdHJpY3QnO1xudmFyIGltbWVkaWF0ZSA9IHJlcXVpcmUoJ2ltbWVkaWF0ZScpO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gSU5URVJOQUwoKSB7fVxuXG52YXIgaGFuZGxlcnMgPSB7fTtcblxudmFyIFJFSkVDVEVEID0gWydSRUpFQ1RFRCddO1xudmFyIEZVTEZJTExFRCA9IFsnRlVMRklMTEVEJ107XG52YXIgUEVORElORyA9IFsnUEVORElORyddO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFByb21pc2U7XG5cbmZ1bmN0aW9uIFByb21pc2UocmVzb2x2ZXIpIHtcbiAgaWYgKHR5cGVvZiByZXNvbHZlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3Jlc29sdmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICB9XG4gIHRoaXMuc3RhdGUgPSBQRU5ESU5HO1xuICB0aGlzLnF1ZXVlID0gW107XG4gIHRoaXMub3V0Y29tZSA9IHZvaWQgMDtcbiAgaWYgKHJlc29sdmVyICE9PSBJTlRFUk5BTCkge1xuICAgIHNhZmVseVJlc29sdmVUaGVuYWJsZSh0aGlzLCByZXNvbHZlcik7XG4gIH1cbn1cblxuUHJvbWlzZS5wcm90b3R5cGVbXCJjYXRjaFwiXSA9IGZ1bmN0aW9uIChvblJlamVjdGVkKSB7XG4gIHJldHVybiB0aGlzLnRoZW4obnVsbCwgb25SZWplY3RlZCk7XG59O1xuUHJvbWlzZS5wcm90b3R5cGUudGhlbiA9IGZ1bmN0aW9uIChvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuICBpZiAodHlwZW9mIG9uRnVsZmlsbGVkICE9PSAnZnVuY3Rpb24nICYmIHRoaXMuc3RhdGUgPT09IEZVTEZJTExFRCB8fFxuICAgIHR5cGVvZiBvblJlamVjdGVkICE9PSAnZnVuY3Rpb24nICYmIHRoaXMuc3RhdGUgPT09IFJFSkVDVEVEKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgdmFyIHByb21pc2UgPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcihJTlRFUk5BTCk7XG4gIGlmICh0aGlzLnN0YXRlICE9PSBQRU5ESU5HKSB7XG4gICAgdmFyIHJlc29sdmVyID0gdGhpcy5zdGF0ZSA9PT0gRlVMRklMTEVEID8gb25GdWxmaWxsZWQgOiBvblJlamVjdGVkO1xuICAgIHVud3JhcChwcm9taXNlLCByZXNvbHZlciwgdGhpcy5vdXRjb21lKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnF1ZXVlLnB1c2gobmV3IFF1ZXVlSXRlbShwcm9taXNlLCBvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkpO1xuICB9XG5cbiAgcmV0dXJuIHByb21pc2U7XG59O1xuZnVuY3Rpb24gUXVldWVJdGVtKHByb21pc2UsIG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gIHRoaXMucHJvbWlzZSA9IHByb21pc2U7XG4gIGlmICh0eXBlb2Ygb25GdWxmaWxsZWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aGlzLm9uRnVsZmlsbGVkID0gb25GdWxmaWxsZWQ7XG4gICAgdGhpcy5jYWxsRnVsZmlsbGVkID0gdGhpcy5vdGhlckNhbGxGdWxmaWxsZWQ7XG4gIH1cbiAgaWYgKHR5cGVvZiBvblJlamVjdGVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhpcy5vblJlamVjdGVkID0gb25SZWplY3RlZDtcbiAgICB0aGlzLmNhbGxSZWplY3RlZCA9IHRoaXMub3RoZXJDYWxsUmVqZWN0ZWQ7XG4gIH1cbn1cblF1ZXVlSXRlbS5wcm90b3R5cGUuY2FsbEZ1bGZpbGxlZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICBoYW5kbGVycy5yZXNvbHZlKHRoaXMucHJvbWlzZSwgdmFsdWUpO1xufTtcblF1ZXVlSXRlbS5wcm90b3R5cGUub3RoZXJDYWxsRnVsZmlsbGVkID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHVud3JhcCh0aGlzLnByb21pc2UsIHRoaXMub25GdWxmaWxsZWQsIHZhbHVlKTtcbn07XG5RdWV1ZUl0ZW0ucHJvdG90eXBlLmNhbGxSZWplY3RlZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICBoYW5kbGVycy5yZWplY3QodGhpcy5wcm9taXNlLCB2YWx1ZSk7XG59O1xuUXVldWVJdGVtLnByb3RvdHlwZS5vdGhlckNhbGxSZWplY3RlZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICB1bndyYXAodGhpcy5wcm9taXNlLCB0aGlzLm9uUmVqZWN0ZWQsIHZhbHVlKTtcbn07XG5cbmZ1bmN0aW9uIHVud3JhcChwcm9taXNlLCBmdW5jLCB2YWx1ZSkge1xuICBpbW1lZGlhdGUoZnVuY3Rpb24gKCkge1xuICAgIHZhciByZXR1cm5WYWx1ZTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuVmFsdWUgPSBmdW5jKHZhbHVlKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gaGFuZGxlcnMucmVqZWN0KHByb21pc2UsIGUpO1xuICAgIH1cbiAgICBpZiAocmV0dXJuVmFsdWUgPT09IHByb21pc2UpIHtcbiAgICAgIGhhbmRsZXJzLnJlamVjdChwcm9taXNlLCBuZXcgVHlwZUVycm9yKCdDYW5ub3QgcmVzb2x2ZSBwcm9taXNlIHdpdGggaXRzZWxmJykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBoYW5kbGVycy5yZXNvbHZlKHByb21pc2UsIHJldHVyblZhbHVlKTtcbiAgICB9XG4gIH0pO1xufVxuXG5oYW5kbGVycy5yZXNvbHZlID0gZnVuY3Rpb24gKHNlbGYsIHZhbHVlKSB7XG4gIHZhciByZXN1bHQgPSB0cnlDYXRjaChnZXRUaGVuLCB2YWx1ZSk7XG4gIGlmIChyZXN1bHQuc3RhdHVzID09PSAnZXJyb3InKSB7XG4gICAgcmV0dXJuIGhhbmRsZXJzLnJlamVjdChzZWxmLCByZXN1bHQudmFsdWUpO1xuICB9XG4gIHZhciB0aGVuYWJsZSA9IHJlc3VsdC52YWx1ZTtcblxuICBpZiAodGhlbmFibGUpIHtcbiAgICBzYWZlbHlSZXNvbHZlVGhlbmFibGUoc2VsZiwgdGhlbmFibGUpO1xuICB9IGVsc2Uge1xuICAgIHNlbGYuc3RhdGUgPSBGVUxGSUxMRUQ7XG4gICAgc2VsZi5vdXRjb21lID0gdmFsdWU7XG4gICAgdmFyIGkgPSAtMTtcbiAgICB2YXIgbGVuID0gc2VsZi5xdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUgKCsraSA8IGxlbikge1xuICAgICAgc2VsZi5xdWV1ZVtpXS5jYWxsRnVsZmlsbGVkKHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNlbGY7XG59O1xuaGFuZGxlcnMucmVqZWN0ID0gZnVuY3Rpb24gKHNlbGYsIGVycm9yKSB7XG4gIHNlbGYuc3RhdGUgPSBSRUpFQ1RFRDtcbiAgc2VsZi5vdXRjb21lID0gZXJyb3I7XG4gIHZhciBpID0gLTE7XG4gIHZhciBsZW4gPSBzZWxmLnF1ZXVlLmxlbmd0aDtcbiAgd2hpbGUgKCsraSA8IGxlbikge1xuICAgIHNlbGYucXVldWVbaV0uY2FsbFJlamVjdGVkKGVycm9yKTtcbiAgfVxuICByZXR1cm4gc2VsZjtcbn07XG5cbmZ1bmN0aW9uIGdldFRoZW4ob2JqKSB7XG4gIC8vIE1ha2Ugc3VyZSB3ZSBvbmx5IGFjY2VzcyB0aGUgYWNjZXNzb3Igb25jZSBhcyByZXF1aXJlZCBieSB0aGUgc3BlY1xuICB2YXIgdGhlbiA9IG9iaiAmJiBvYmoudGhlbjtcbiAgaWYgKG9iaiAmJiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJykgJiYgdHlwZW9mIHRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gYXBweVRoZW4oKSB7XG4gICAgICB0aGVuLmFwcGx5KG9iaiwgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG59XG5cbmZ1bmN0aW9uIHNhZmVseVJlc29sdmVUaGVuYWJsZShzZWxmLCB0aGVuYWJsZSkge1xuICAvLyBFaXRoZXIgZnVsZmlsbCwgcmVqZWN0IG9yIHJlamVjdCB3aXRoIGVycm9yXG4gIHZhciBjYWxsZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gb25FcnJvcih2YWx1ZSkge1xuICAgIGlmIChjYWxsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2FsbGVkID0gdHJ1ZTtcbiAgICBoYW5kbGVycy5yZWplY3Qoc2VsZiwgdmFsdWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gb25TdWNjZXNzKHZhbHVlKSB7XG4gICAgaWYgKGNhbGxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjYWxsZWQgPSB0cnVlO1xuICAgIGhhbmRsZXJzLnJlc29sdmUoc2VsZiwgdmFsdWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gdHJ5VG9VbndyYXAoKSB7XG4gICAgdGhlbmFibGUob25TdWNjZXNzLCBvbkVycm9yKTtcbiAgfVxuXG4gIHZhciByZXN1bHQgPSB0cnlDYXRjaCh0cnlUb1Vud3JhcCk7XG4gIGlmIChyZXN1bHQuc3RhdHVzID09PSAnZXJyb3InKSB7XG4gICAgb25FcnJvcihyZXN1bHQudmFsdWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHRyeUNhdGNoKGZ1bmMsIHZhbHVlKSB7XG4gIHZhciBvdXQgPSB7fTtcbiAgdHJ5IHtcbiAgICBvdXQudmFsdWUgPSBmdW5jKHZhbHVlKTtcbiAgICBvdXQuc3RhdHVzID0gJ3N1Y2Nlc3MnO1xuICB9IGNhdGNoIChlKSB7XG4gICAgb3V0LnN0YXR1cyA9ICdlcnJvcic7XG4gICAgb3V0LnZhbHVlID0gZTtcbiAgfVxuICByZXR1cm4gb3V0O1xufVxuXG5Qcm9taXNlLnJlc29sdmUgPSByZXNvbHZlO1xuZnVuY3Rpb24gcmVzb2x2ZSh2YWx1ZSkge1xuICBpZiAodmFsdWUgaW5zdGFuY2VvZiB0aGlzKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJldHVybiBoYW5kbGVycy5yZXNvbHZlKG5ldyB0aGlzKElOVEVSTkFMKSwgdmFsdWUpO1xufVxuXG5Qcm9taXNlLnJlamVjdCA9IHJlamVjdDtcbmZ1bmN0aW9uIHJlamVjdChyZWFzb24pIHtcbiAgdmFyIHByb21pc2UgPSBuZXcgdGhpcyhJTlRFUk5BTCk7XG4gIHJldHVybiBoYW5kbGVycy5yZWplY3QocHJvbWlzZSwgcmVhc29uKTtcbn1cblxuUHJvbWlzZS5hbGwgPSBhbGw7XG5mdW5jdGlvbiBhbGwoaXRlcmFibGUpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGl0ZXJhYmxlKSAhPT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgIHJldHVybiB0aGlzLnJlamVjdChuZXcgVHlwZUVycm9yKCdtdXN0IGJlIGFuIGFycmF5JykpO1xuICB9XG5cbiAgdmFyIGxlbiA9IGl0ZXJhYmxlLmxlbmd0aDtcbiAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuICBpZiAoIWxlbikge1xuICAgIHJldHVybiB0aGlzLnJlc29sdmUoW10pO1xuICB9XG5cbiAgdmFyIHZhbHVlcyA9IG5ldyBBcnJheShsZW4pO1xuICB2YXIgcmVzb2x2ZWQgPSAwO1xuICB2YXIgaSA9IC0xO1xuICB2YXIgcHJvbWlzZSA9IG5ldyB0aGlzKElOVEVSTkFMKTtcblxuICB3aGlsZSAoKytpIDwgbGVuKSB7XG4gICAgYWxsUmVzb2x2ZXIoaXRlcmFibGVbaV0sIGkpO1xuICB9XG4gIHJldHVybiBwcm9taXNlO1xuICBmdW5jdGlvbiBhbGxSZXNvbHZlcih2YWx1ZSwgaSkge1xuICAgIHNlbGYucmVzb2x2ZSh2YWx1ZSkudGhlbihyZXNvbHZlRnJvbUFsbCwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICBpZiAoIWNhbGxlZCkge1xuICAgICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgICBoYW5kbGVycy5yZWplY3QocHJvbWlzZSwgZXJyb3IpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGZ1bmN0aW9uIHJlc29sdmVGcm9tQWxsKG91dFZhbHVlKSB7XG4gICAgICB2YWx1ZXNbaV0gPSBvdXRWYWx1ZTtcbiAgICAgIGlmICgrK3Jlc29sdmVkID09PSBsZW4gJiYgIWNhbGxlZCkge1xuICAgICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgICBoYW5kbGVycy5yZXNvbHZlKHByb21pc2UsIHZhbHVlcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cblByb21pc2UucmFjZSA9IHJhY2U7XG5mdW5jdGlvbiByYWNlKGl0ZXJhYmxlKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpdGVyYWJsZSkgIT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICByZXR1cm4gdGhpcy5yZWplY3QobmV3IFR5cGVFcnJvcignbXVzdCBiZSBhbiBhcnJheScpKTtcbiAgfVxuXG4gIHZhciBsZW4gPSBpdGVyYWJsZS5sZW5ndGg7XG4gIHZhciBjYWxsZWQgPSBmYWxzZTtcbiAgaWYgKCFsZW4pIHtcbiAgICByZXR1cm4gdGhpcy5yZXNvbHZlKFtdKTtcbiAgfVxuXG4gIHZhciBpID0gLTE7XG4gIHZhciBwcm9taXNlID0gbmV3IHRoaXMoSU5URVJOQUwpO1xuXG4gIHdoaWxlICgrK2kgPCBsZW4pIHtcbiAgICByZXNvbHZlcihpdGVyYWJsZVtpXSk7XG4gIH1cbiAgcmV0dXJuIHByb21pc2U7XG4gIGZ1bmN0aW9uIHJlc29sdmVyKHZhbHVlKSB7XG4gICAgc2VsZi5yZXNvbHZlKHZhbHVlKS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgaWYgKCFjYWxsZWQpIHtcbiAgICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgaGFuZGxlcnMucmVzb2x2ZShwcm9taXNlLCByZXNwb25zZSk7XG4gICAgICB9XG4gICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICBpZiAoIWNhbGxlZCkge1xuICAgICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgICBoYW5kbGVycy5yZWplY3QocHJvbWlzZSwgZXJyb3IpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXI7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIGlzRW5jb2RpbmcgPSBCdWZmZXIuaXNFbmNvZGluZyB8fCBmdW5jdGlvbiAoZW5jb2RpbmcpIHtcbiAgZW5jb2RpbmcgPSAnJyArIGVuY29kaW5nO1xuICBzd2l0Y2ggKGVuY29kaW5nICYmIGVuY29kaW5nLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOmNhc2UgJ3V0ZjgnOmNhc2UgJ3V0Zi04JzpjYXNlICdhc2NpaSc6Y2FzZSAnYmluYXJ5JzpjYXNlICdiYXNlNjQnOmNhc2UgJ3VjczInOmNhc2UgJ3Vjcy0yJzpjYXNlICd1dGYxNmxlJzpjYXNlICd1dGYtMTZsZSc6Y2FzZSAncmF3JzpcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIF9ub3JtYWxpemVFbmNvZGluZyhlbmMpIHtcbiAgaWYgKCFlbmMpIHJldHVybiAndXRmOCc7XG4gIHZhciByZXRyaWVkO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jKSB7XG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuICd1dGY4JztcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiAndXRmMTZsZSc7XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuICdsYXRpbjEnO1xuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBlbmM7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAocmV0cmllZCkgcmV0dXJuOyAvLyB1bmRlZmluZWRcbiAgICAgICAgZW5jID0gKCcnICsgZW5jKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICByZXRyaWVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIERvIG5vdCBjYWNoZSBgQnVmZmVyLmlzRW5jb2RpbmdgIHdoZW4gY2hlY2tpbmcgZW5jb2RpbmcgbmFtZXMgYXMgc29tZVxuLy8gbW9kdWxlcyBtb25rZXktcGF0Y2ggaXQgdG8gc3VwcG9ydCBhZGRpdGlvbmFsIGVuY29kaW5nc1xuZnVuY3Rpb24gbm9ybWFsaXplRW5jb2RpbmcoZW5jKSB7XG4gIHZhciBuZW5jID0gX25vcm1hbGl6ZUVuY29kaW5nKGVuYyk7XG4gIGlmICh0eXBlb2YgbmVuYyAhPT0gJ3N0cmluZycgJiYgKEJ1ZmZlci5pc0VuY29kaW5nID09PSBpc0VuY29kaW5nIHx8ICFpc0VuY29kaW5nKGVuYykpKSB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmMpO1xuICByZXR1cm4gbmVuYyB8fCBlbmM7XG59XG5cbi8vIFN0cmluZ0RlY29kZXIgcHJvdmlkZXMgYW4gaW50ZXJmYWNlIGZvciBlZmZpY2llbnRseSBzcGxpdHRpbmcgYSBzZXJpZXMgb2Zcbi8vIGJ1ZmZlcnMgaW50byBhIHNlcmllcyBvZiBKUyBzdHJpbmdzIHdpdGhvdXQgYnJlYWtpbmcgYXBhcnQgbXVsdGktYnl0ZVxuLy8gY2hhcmFjdGVycy5cbmV4cG9ydHMuU3RyaW5nRGVjb2RlciA9IFN0cmluZ0RlY29kZXI7XG5mdW5jdGlvbiBTdHJpbmdEZWNvZGVyKGVuY29kaW5nKSB7XG4gIHRoaXMuZW5jb2RpbmcgPSBub3JtYWxpemVFbmNvZGluZyhlbmNvZGluZyk7XG4gIHZhciBuYjtcbiAgc3dpdGNoICh0aGlzLmVuY29kaW5nKSB7XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICB0aGlzLnRleHQgPSB1dGYxNlRleHQ7XG4gICAgICB0aGlzLmVuZCA9IHV0ZjE2RW5kO1xuICAgICAgbmIgPSA0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndXRmOCc6XG4gICAgICB0aGlzLmZpbGxMYXN0ID0gdXRmOEZpbGxMYXN0O1xuICAgICAgbmIgPSA0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIHRoaXMudGV4dCA9IGJhc2U2NFRleHQ7XG4gICAgICB0aGlzLmVuZCA9IGJhc2U2NEVuZDtcbiAgICAgIG5iID0gMztcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aGlzLndyaXRlID0gc2ltcGxlV3JpdGU7XG4gICAgICB0aGlzLmVuZCA9IHNpbXBsZUVuZDtcbiAgICAgIHJldHVybjtcbiAgfVxuICB0aGlzLmxhc3ROZWVkID0gMDtcbiAgdGhpcy5sYXN0VG90YWwgPSAwO1xuICB0aGlzLmxhc3RDaGFyID0gQnVmZmVyLmFsbG9jVW5zYWZlKG5iKTtcbn1cblxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoYnVmKSB7XG4gIGlmIChidWYubGVuZ3RoID09PSAwKSByZXR1cm4gJyc7XG4gIHZhciByO1xuICB2YXIgaTtcbiAgaWYgKHRoaXMubGFzdE5lZWQpIHtcbiAgICByID0gdGhpcy5maWxsTGFzdChidWYpO1xuICAgIGlmIChyID09PSB1bmRlZmluZWQpIHJldHVybiAnJztcbiAgICBpID0gdGhpcy5sYXN0TmVlZDtcbiAgICB0aGlzLmxhc3ROZWVkID0gMDtcbiAgfSBlbHNlIHtcbiAgICBpID0gMDtcbiAgfVxuICBpZiAoaSA8IGJ1Zi5sZW5ndGgpIHJldHVybiByID8gciArIHRoaXMudGV4dChidWYsIGkpIDogdGhpcy50ZXh0KGJ1ZiwgaSk7XG4gIHJldHVybiByIHx8ICcnO1xufTtcblxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUuZW5kID0gdXRmOEVuZDtcblxuLy8gUmV0dXJucyBvbmx5IGNvbXBsZXRlIGNoYXJhY3RlcnMgaW4gYSBCdWZmZXJcblN0cmluZ0RlY29kZXIucHJvdG90eXBlLnRleHQgPSB1dGY4VGV4dDtcblxuLy8gQXR0ZW1wdHMgdG8gY29tcGxldGUgYSBwYXJ0aWFsIG5vbi1VVEYtOCBjaGFyYWN0ZXIgdXNpbmcgYnl0ZXMgZnJvbSBhIEJ1ZmZlclxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUuZmlsbExhc3QgPSBmdW5jdGlvbiAoYnVmKSB7XG4gIGlmICh0aGlzLmxhc3ROZWVkIDw9IGJ1Zi5sZW5ndGgpIHtcbiAgICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQsIDAsIHRoaXMubGFzdE5lZWQpO1xuICAgIHJldHVybiB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcsIDAsIHRoaXMubGFzdFRvdGFsKTtcbiAgfVxuICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQsIDAsIGJ1Zi5sZW5ndGgpO1xuICB0aGlzLmxhc3ROZWVkIC09IGJ1Zi5sZW5ndGg7XG59O1xuXG4vLyBDaGVja3MgdGhlIHR5cGUgb2YgYSBVVEYtOCBieXRlLCB3aGV0aGVyIGl0J3MgQVNDSUksIGEgbGVhZGluZyBieXRlLCBvciBhXG4vLyBjb250aW51YXRpb24gYnl0ZS4gSWYgYW4gaW52YWxpZCBieXRlIGlzIGRldGVjdGVkLCAtMiBpcyByZXR1cm5lZC5cbmZ1bmN0aW9uIHV0ZjhDaGVja0J5dGUoYnl0ZSkge1xuICBpZiAoYnl0ZSA8PSAweDdGKSByZXR1cm4gMDtlbHNlIGlmIChieXRlID4+IDUgPT09IDB4MDYpIHJldHVybiAyO2Vsc2UgaWYgKGJ5dGUgPj4gNCA9PT0gMHgwRSkgcmV0dXJuIDM7ZWxzZSBpZiAoYnl0ZSA+PiAzID09PSAweDFFKSByZXR1cm4gNDtcbiAgcmV0dXJuIGJ5dGUgPj4gNiA9PT0gMHgwMiA/IC0xIDogLTI7XG59XG5cbi8vIENoZWNrcyBhdCBtb3N0IDMgYnl0ZXMgYXQgdGhlIGVuZCBvZiBhIEJ1ZmZlciBpbiBvcmRlciB0byBkZXRlY3QgYW5cbi8vIGluY29tcGxldGUgbXVsdGktYnl0ZSBVVEYtOCBjaGFyYWN0ZXIuIFRoZSB0b3RhbCBudW1iZXIgb2YgYnl0ZXMgKDIsIDMsIG9yIDQpXG4vLyBuZWVkZWQgdG8gY29tcGxldGUgdGhlIFVURi04IGNoYXJhY3RlciAoaWYgYXBwbGljYWJsZSkgYXJlIHJldHVybmVkLlxuZnVuY3Rpb24gdXRmOENoZWNrSW5jb21wbGV0ZShzZWxmLCBidWYsIGkpIHtcbiAgdmFyIGogPSBidWYubGVuZ3RoIC0gMTtcbiAgaWYgKGogPCBpKSByZXR1cm4gMDtcbiAgdmFyIG5iID0gdXRmOENoZWNrQnl0ZShidWZbal0pO1xuICBpZiAobmIgPj0gMCkge1xuICAgIGlmIChuYiA+IDApIHNlbGYubGFzdE5lZWQgPSBuYiAtIDE7XG4gICAgcmV0dXJuIG5iO1xuICB9XG4gIGlmICgtLWogPCBpIHx8IG5iID09PSAtMikgcmV0dXJuIDA7XG4gIG5iID0gdXRmOENoZWNrQnl0ZShidWZbal0pO1xuICBpZiAobmIgPj0gMCkge1xuICAgIGlmIChuYiA+IDApIHNlbGYubGFzdE5lZWQgPSBuYiAtIDI7XG4gICAgcmV0dXJuIG5iO1xuICB9XG4gIGlmICgtLWogPCBpIHx8IG5iID09PSAtMikgcmV0dXJuIDA7XG4gIG5iID0gdXRmOENoZWNrQnl0ZShidWZbal0pO1xuICBpZiAobmIgPj0gMCkge1xuICAgIGlmIChuYiA+IDApIHtcbiAgICAgIGlmIChuYiA9PT0gMikgbmIgPSAwO2Vsc2Ugc2VsZi5sYXN0TmVlZCA9IG5iIC0gMztcbiAgICB9XG4gICAgcmV0dXJuIG5iO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vLyBWYWxpZGF0ZXMgYXMgbWFueSBjb250aW51YXRpb24gYnl0ZXMgZm9yIGEgbXVsdGktYnl0ZSBVVEYtOCBjaGFyYWN0ZXIgYXNcbi8vIG5lZWRlZCBvciBhcmUgYXZhaWxhYmxlLiBJZiB3ZSBzZWUgYSBub24tY29udGludWF0aW9uIGJ5dGUgd2hlcmUgd2UgZXhwZWN0XG4vLyBvbmUsIHdlIFwicmVwbGFjZVwiIHRoZSB2YWxpZGF0ZWQgY29udGludWF0aW9uIGJ5dGVzIHdlJ3ZlIHNlZW4gc28gZmFyIHdpdGhcbi8vIGEgc2luZ2xlIFVURi04IHJlcGxhY2VtZW50IGNoYXJhY3RlciAoJ1xcdWZmZmQnKSwgdG8gbWF0Y2ggdjgncyBVVEYtOCBkZWNvZGluZ1xuLy8gYmVoYXZpb3IuIFRoZSBjb250aW51YXRpb24gYnl0ZSBjaGVjayBpcyBpbmNsdWRlZCB0aHJlZSB0aW1lcyBpbiB0aGUgY2FzZVxuLy8gd2hlcmUgYWxsIG9mIHRoZSBjb250aW51YXRpb24gYnl0ZXMgZm9yIGEgY2hhcmFjdGVyIGV4aXN0IGluIHRoZSBzYW1lIGJ1ZmZlci5cbi8vIEl0IGlzIGFsc28gZG9uZSB0aGlzIHdheSBhcyBhIHNsaWdodCBwZXJmb3JtYW5jZSBpbmNyZWFzZSBpbnN0ZWFkIG9mIHVzaW5nIGFcbi8vIGxvb3AuXG5mdW5jdGlvbiB1dGY4Q2hlY2tFeHRyYUJ5dGVzKHNlbGYsIGJ1ZiwgcCkge1xuICBpZiAoKGJ1ZlswXSAmIDB4QzApICE9PSAweDgwKSB7XG4gICAgc2VsZi5sYXN0TmVlZCA9IDA7XG4gICAgcmV0dXJuICdcXHVmZmZkJztcbiAgfVxuICBpZiAoc2VsZi5sYXN0TmVlZCA+IDEgJiYgYnVmLmxlbmd0aCA+IDEpIHtcbiAgICBpZiAoKGJ1ZlsxXSAmIDB4QzApICE9PSAweDgwKSB7XG4gICAgICBzZWxmLmxhc3ROZWVkID0gMTtcbiAgICAgIHJldHVybiAnXFx1ZmZmZCc7XG4gICAgfVxuICAgIGlmIChzZWxmLmxhc3ROZWVkID4gMiAmJiBidWYubGVuZ3RoID4gMikge1xuICAgICAgaWYgKChidWZbMl0gJiAweEMwKSAhPT0gMHg4MCkge1xuICAgICAgICBzZWxmLmxhc3ROZWVkID0gMjtcbiAgICAgICAgcmV0dXJuICdcXHVmZmZkJztcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLy8gQXR0ZW1wdHMgdG8gY29tcGxldGUgYSBtdWx0aS1ieXRlIFVURi04IGNoYXJhY3RlciB1c2luZyBieXRlcyBmcm9tIGEgQnVmZmVyLlxuZnVuY3Rpb24gdXRmOEZpbGxMYXN0KGJ1Zikge1xuICB2YXIgcCA9IHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZDtcbiAgdmFyIHIgPSB1dGY4Q2hlY2tFeHRyYUJ5dGVzKHRoaXMsIGJ1ZiwgcCk7XG4gIGlmIChyICE9PSB1bmRlZmluZWQpIHJldHVybiByO1xuICBpZiAodGhpcy5sYXN0TmVlZCA8PSBidWYubGVuZ3RoKSB7XG4gICAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgcCwgMCwgdGhpcy5sYXN0TmVlZCk7XG4gICAgcmV0dXJuIHRoaXMubGFzdENoYXIudG9TdHJpbmcodGhpcy5lbmNvZGluZywgMCwgdGhpcy5sYXN0VG90YWwpO1xuICB9XG4gIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIHAsIDAsIGJ1Zi5sZW5ndGgpO1xuICB0aGlzLmxhc3ROZWVkIC09IGJ1Zi5sZW5ndGg7XG59XG5cbi8vIFJldHVybnMgYWxsIGNvbXBsZXRlIFVURi04IGNoYXJhY3RlcnMgaW4gYSBCdWZmZXIuIElmIHRoZSBCdWZmZXIgZW5kZWQgb24gYVxuLy8gcGFydGlhbCBjaGFyYWN0ZXIsIHRoZSBjaGFyYWN0ZXIncyBieXRlcyBhcmUgYnVmZmVyZWQgdW50aWwgdGhlIHJlcXVpcmVkXG4vLyBudW1iZXIgb2YgYnl0ZXMgYXJlIGF2YWlsYWJsZS5cbmZ1bmN0aW9uIHV0ZjhUZXh0KGJ1ZiwgaSkge1xuICB2YXIgdG90YWwgPSB1dGY4Q2hlY2tJbmNvbXBsZXRlKHRoaXMsIGJ1ZiwgaSk7XG4gIGlmICghdGhpcy5sYXN0TmVlZCkgcmV0dXJuIGJ1Zi50b1N0cmluZygndXRmOCcsIGkpO1xuICB0aGlzLmxhc3RUb3RhbCA9IHRvdGFsO1xuICB2YXIgZW5kID0gYnVmLmxlbmd0aCAtICh0b3RhbCAtIHRoaXMubGFzdE5lZWQpO1xuICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCAwLCBlbmQpO1xuICByZXR1cm4gYnVmLnRvU3RyaW5nKCd1dGY4JywgaSwgZW5kKTtcbn1cblxuLy8gRm9yIFVURi04LCBhIHJlcGxhY2VtZW50IGNoYXJhY3RlciBpcyBhZGRlZCB3aGVuIGVuZGluZyBvbiBhIHBhcnRpYWxcbi8vIGNoYXJhY3Rlci5cbmZ1bmN0aW9uIHV0ZjhFbmQoYnVmKSB7XG4gIHZhciByID0gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJztcbiAgaWYgKHRoaXMubGFzdE5lZWQpIHJldHVybiByICsgJ1xcdWZmZmQnO1xuICByZXR1cm4gcjtcbn1cblxuLy8gVVRGLTE2TEUgdHlwaWNhbGx5IG5lZWRzIHR3byBieXRlcyBwZXIgY2hhcmFjdGVyLCBidXQgZXZlbiBpZiB3ZSBoYXZlIGFuIGV2ZW5cbi8vIG51bWJlciBvZiBieXRlcyBhdmFpbGFibGUsIHdlIG5lZWQgdG8gY2hlY2sgaWYgd2UgZW5kIG9uIGEgbGVhZGluZy9oaWdoXG4vLyBzdXJyb2dhdGUuIEluIHRoYXQgY2FzZSwgd2UgbmVlZCB0byB3YWl0IGZvciB0aGUgbmV4dCB0d28gYnl0ZXMgaW4gb3JkZXIgdG9cbi8vIGRlY29kZSB0aGUgbGFzdCBjaGFyYWN0ZXIgcHJvcGVybHkuXG5mdW5jdGlvbiB1dGYxNlRleHQoYnVmLCBpKSB7XG4gIGlmICgoYnVmLmxlbmd0aCAtIGkpICUgMiA9PT0gMCkge1xuICAgIHZhciByID0gYnVmLnRvU3RyaW5nKCd1dGYxNmxlJywgaSk7XG4gICAgaWYgKHIpIHtcbiAgICAgIHZhciBjID0gci5jaGFyQ29kZUF0KHIubGVuZ3RoIC0gMSk7XG4gICAgICBpZiAoYyA+PSAweEQ4MDAgJiYgYyA8PSAweERCRkYpIHtcbiAgICAgICAgdGhpcy5sYXN0TmVlZCA9IDI7XG4gICAgICAgIHRoaXMubGFzdFRvdGFsID0gNDtcbiAgICAgICAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMl07XG4gICAgICAgIHRoaXMubGFzdENoYXJbMV0gPSBidWZbYnVmLmxlbmd0aCAtIDFdO1xuICAgICAgICByZXR1cm4gci5zbGljZSgwLCAtMSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByO1xuICB9XG4gIHRoaXMubGFzdE5lZWQgPSAxO1xuICB0aGlzLmxhc3RUb3RhbCA9IDI7XG4gIHRoaXMubGFzdENoYXJbMF0gPSBidWZbYnVmLmxlbmd0aCAtIDFdO1xuICByZXR1cm4gYnVmLnRvU3RyaW5nKCd1dGYxNmxlJywgaSwgYnVmLmxlbmd0aCAtIDEpO1xufVxuXG4vLyBGb3IgVVRGLTE2TEUgd2UgZG8gbm90IGV4cGxpY2l0bHkgYXBwZW5kIHNwZWNpYWwgcmVwbGFjZW1lbnQgY2hhcmFjdGVycyBpZiB3ZVxuLy8gZW5kIG9uIGEgcGFydGlhbCBjaGFyYWN0ZXIsIHdlIHNpbXBseSBsZXQgdjggaGFuZGxlIHRoYXQuXG5mdW5jdGlvbiB1dGYxNkVuZChidWYpIHtcbiAgdmFyIHIgPSBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnO1xuICBpZiAodGhpcy5sYXN0TmVlZCkge1xuICAgIHZhciBlbmQgPSB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQ7XG4gICAgcmV0dXJuIHIgKyB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKCd1dGYxNmxlJywgMCwgZW5kKTtcbiAgfVxuICByZXR1cm4gcjtcbn1cblxuZnVuY3Rpb24gYmFzZTY0VGV4dChidWYsIGkpIHtcbiAgdmFyIG4gPSAoYnVmLmxlbmd0aCAtIGkpICUgMztcbiAgaWYgKG4gPT09IDApIHJldHVybiBidWYudG9TdHJpbmcoJ2Jhc2U2NCcsIGkpO1xuICB0aGlzLmxhc3ROZWVkID0gMyAtIG47XG4gIHRoaXMubGFzdFRvdGFsID0gMztcbiAgaWYgKG4gPT09IDEpIHtcbiAgICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAyXTtcbiAgICB0aGlzLmxhc3RDaGFyWzFdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcbiAgfVxuICByZXR1cm4gYnVmLnRvU3RyaW5nKCdiYXNlNjQnLCBpLCBidWYubGVuZ3RoIC0gbik7XG59XG5cbmZ1bmN0aW9uIGJhc2U2NEVuZChidWYpIHtcbiAgdmFyIHIgPSBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnO1xuICBpZiAodGhpcy5sYXN0TmVlZCkgcmV0dXJuIHIgKyB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKCdiYXNlNjQnLCAwLCAzIC0gdGhpcy5sYXN0TmVlZCk7XG4gIHJldHVybiByO1xufVxuXG4vLyBQYXNzIGJ5dGVzIG9uIHRocm91Z2ggZm9yIHNpbmdsZS1ieXRlIGVuY29kaW5ncyAoZS5nLiBhc2NpaSwgbGF0aW4xLCBoZXgpXG5mdW5jdGlvbiBzaW1wbGVXcml0ZShidWYpIHtcbiAgcmV0dXJuIGJ1Zi50b1N0cmluZyh0aGlzLmVuY29kaW5nKTtcbn1cblxuZnVuY3Rpb24gc2ltcGxlRW5kKGJ1Zikge1xuICByZXR1cm4gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJztcbn0iLCIvLyBUb3AgbGV2ZWwgZmlsZSBpcyBqdXN0IGEgbWl4aW4gb2Ygc3VibW9kdWxlcyAmIGNvbnN0YW50c1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgYXNzaWduICAgID0gcmVxdWlyZSgnLi9saWIvdXRpbHMvY29tbW9uJykuYXNzaWduO1xuXG52YXIgZGVmbGF0ZSAgID0gcmVxdWlyZSgnLi9saWIvZGVmbGF0ZScpO1xudmFyIGluZmxhdGUgICA9IHJlcXVpcmUoJy4vbGliL2luZmxhdGUnKTtcbnZhciBjb25zdGFudHMgPSByZXF1aXJlKCcuL2xpYi96bGliL2NvbnN0YW50cycpO1xuXG52YXIgcGFrbyA9IHt9O1xuXG5hc3NpZ24ocGFrbywgZGVmbGF0ZSwgaW5mbGF0ZSwgY29uc3RhbnRzKTtcblxubW9kdWxlLmV4cG9ydHMgPSBwYWtvO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciB6bGliX2RlZmxhdGUgPSByZXF1aXJlKCcuL3psaWIvZGVmbGF0ZScpO1xudmFyIHV0aWxzICAgICAgICA9IHJlcXVpcmUoJy4vdXRpbHMvY29tbW9uJyk7XG52YXIgc3RyaW5ncyAgICAgID0gcmVxdWlyZSgnLi91dGlscy9zdHJpbmdzJyk7XG52YXIgbXNnICAgICAgICAgID0gcmVxdWlyZSgnLi96bGliL21lc3NhZ2VzJyk7XG52YXIgWlN0cmVhbSAgICAgID0gcmVxdWlyZSgnLi96bGliL3pzdHJlYW0nKTtcblxudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuLyogUHVibGljIGNvbnN0YW50cyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cbnZhciBaX05PX0ZMVVNIICAgICAgPSAwO1xudmFyIFpfRklOSVNIICAgICAgICA9IDQ7XG5cbnZhciBaX09LICAgICAgICAgICAgPSAwO1xudmFyIFpfU1RSRUFNX0VORCAgICA9IDE7XG52YXIgWl9TWU5DX0ZMVVNIICAgID0gMjtcblxudmFyIFpfREVGQVVMVF9DT01QUkVTU0lPTiA9IC0xO1xuXG52YXIgWl9ERUZBVUxUX1NUUkFURUdZICAgID0gMDtcblxudmFyIFpfREVGTEFURUQgID0gODtcblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG4vKipcbiAqIGNsYXNzIERlZmxhdGVcbiAqXG4gKiBHZW5lcmljIEpTLXN0eWxlIHdyYXBwZXIgZm9yIHpsaWIgY2FsbHMuIElmIHlvdSBkb24ndCBuZWVkXG4gKiBzdHJlYW1pbmcgYmVoYXZpb3VyIC0gdXNlIG1vcmUgc2ltcGxlIGZ1bmN0aW9uczogW1tkZWZsYXRlXV0sXG4gKiBbW2RlZmxhdGVSYXddXSBhbmQgW1tnemlwXV0uXG4gKiovXG5cbi8qIGludGVybmFsXG4gKiBEZWZsYXRlLmNodW5rcyAtPiBBcnJheVxuICpcbiAqIENodW5rcyBvZiBvdXRwdXQgZGF0YSwgaWYgW1tEZWZsYXRlI29uRGF0YV1dIG5vdCBvdmVycmlkZGVuLlxuICoqL1xuXG4vKipcbiAqIERlZmxhdGUucmVzdWx0IC0+IFVpbnQ4QXJyYXl8QXJyYXlcbiAqXG4gKiBDb21wcmVzc2VkIHJlc3VsdCwgZ2VuZXJhdGVkIGJ5IGRlZmF1bHQgW1tEZWZsYXRlI29uRGF0YV1dXG4gKiBhbmQgW1tEZWZsYXRlI29uRW5kXV0gaGFuZGxlcnMuIEZpbGxlZCBhZnRlciB5b3UgcHVzaCBsYXN0IGNodW5rXG4gKiAoY2FsbCBbW0RlZmxhdGUjcHVzaF1dIHdpdGggYFpfRklOSVNIYCAvIGB0cnVlYCBwYXJhbSkgIG9yIGlmIHlvdVxuICogcHVzaCBhIGNodW5rIHdpdGggZXhwbGljaXQgZmx1c2ggKGNhbGwgW1tEZWZsYXRlI3B1c2hdXSB3aXRoXG4gKiBgWl9TWU5DX0ZMVVNIYCBwYXJhbSkuXG4gKiovXG5cbi8qKlxuICogRGVmbGF0ZS5lcnIgLT4gTnVtYmVyXG4gKlxuICogRXJyb3IgY29kZSBhZnRlciBkZWZsYXRlIGZpbmlzaGVkLiAwIChaX09LKSBvbiBzdWNjZXNzLlxuICogWW91IHdpbGwgbm90IG5lZWQgaXQgaW4gcmVhbCBsaWZlLCBiZWNhdXNlIGRlZmxhdGUgZXJyb3JzXG4gKiBhcmUgcG9zc2libGUgb25seSBvbiB3cm9uZyBvcHRpb25zIG9yIGJhZCBgb25EYXRhYCAvIGBvbkVuZGBcbiAqIGN1c3RvbSBoYW5kbGVycy5cbiAqKi9cblxuLyoqXG4gKiBEZWZsYXRlLm1zZyAtPiBTdHJpbmdcbiAqXG4gKiBFcnJvciBtZXNzYWdlLCBpZiBbW0RlZmxhdGUuZXJyXV0gIT0gMFxuICoqL1xuXG5cbi8qKlxuICogbmV3IERlZmxhdGUob3B0aW9ucylcbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBkZWZsYXRlIG9wdGlvbnMuXG4gKlxuICogQ3JlYXRlcyBuZXcgZGVmbGF0b3IgaW5zdGFuY2Ugd2l0aCBzcGVjaWZpZWQgcGFyYW1zLiBUaHJvd3MgZXhjZXB0aW9uXG4gKiBvbiBiYWQgcGFyYW1zLiBTdXBwb3J0ZWQgb3B0aW9uczpcbiAqXG4gKiAtIGBsZXZlbGBcbiAqIC0gYHdpbmRvd0JpdHNgXG4gKiAtIGBtZW1MZXZlbGBcbiAqIC0gYHN0cmF0ZWd5YFxuICogLSBgZGljdGlvbmFyeWBcbiAqXG4gKiBbaHR0cDovL3psaWIubmV0L21hbnVhbC5odG1sI0FkdmFuY2VkXShodHRwOi8vemxpYi5uZXQvbWFudWFsLmh0bWwjQWR2YW5jZWQpXG4gKiBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiB0aGVzZS5cbiAqXG4gKiBBZGRpdGlvbmFsIG9wdGlvbnMsIGZvciBpbnRlcm5hbCBuZWVkczpcbiAqXG4gKiAtIGBjaHVua1NpemVgIC0gc2l6ZSBvZiBnZW5lcmF0ZWQgZGF0YSBjaHVua3MgKDE2SyBieSBkZWZhdWx0KVxuICogLSBgcmF3YCAoQm9vbGVhbikgLSBkbyByYXcgZGVmbGF0ZVxuICogLSBgZ3ppcGAgKEJvb2xlYW4pIC0gY3JlYXRlIGd6aXAgd3JhcHBlclxuICogLSBgdG9gIChTdHJpbmcpIC0gaWYgZXF1YWwgdG8gJ3N0cmluZycsIHRoZW4gcmVzdWx0IHdpbGwgYmUgXCJiaW5hcnkgc3RyaW5nXCJcbiAqICAgIChlYWNoIGNoYXIgY29kZSBbMC4uMjU1XSlcbiAqIC0gYGhlYWRlcmAgKE9iamVjdCkgLSBjdXN0b20gaGVhZGVyIGZvciBnemlwXG4gKiAgIC0gYHRleHRgIChCb29sZWFuKSAtIHRydWUgaWYgY29tcHJlc3NlZCBkYXRhIGJlbGlldmVkIHRvIGJlIHRleHRcbiAqICAgLSBgdGltZWAgKE51bWJlcikgLSBtb2RpZmljYXRpb24gdGltZSwgdW5peCB0aW1lc3RhbXBcbiAqICAgLSBgb3NgIChOdW1iZXIpIC0gb3BlcmF0aW9uIHN5c3RlbSBjb2RlXG4gKiAgIC0gYGV4dHJhYCAoQXJyYXkpIC0gYXJyYXkgb2YgYnl0ZXMgd2l0aCBleHRyYSBkYXRhIChtYXggNjU1MzYpXG4gKiAgIC0gYG5hbWVgIChTdHJpbmcpIC0gZmlsZSBuYW1lIChiaW5hcnkgc3RyaW5nKVxuICogICAtIGBjb21tZW50YCAoU3RyaW5nKSAtIGNvbW1lbnQgKGJpbmFyeSBzdHJpbmcpXG4gKiAgIC0gYGhjcmNgIChCb29sZWFuKSAtIHRydWUgaWYgaGVhZGVyIGNyYyBzaG91bGQgYmUgYWRkZWRcbiAqXG4gKiAjIyMjIyBFeGFtcGxlOlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHZhciBwYWtvID0gcmVxdWlyZSgncGFrbycpXG4gKiAgICwgY2h1bmsxID0gVWludDhBcnJheShbMSwyLDMsNCw1LDYsNyw4LDldKVxuICogICAsIGNodW5rMiA9IFVpbnQ4QXJyYXkoWzEwLDExLDEyLDEzLDE0LDE1LDE2LDE3LDE4LDE5XSk7XG4gKlxuICogdmFyIGRlZmxhdGUgPSBuZXcgcGFrby5EZWZsYXRlKHsgbGV2ZWw6IDN9KTtcbiAqXG4gKiBkZWZsYXRlLnB1c2goY2h1bmsxLCBmYWxzZSk7XG4gKiBkZWZsYXRlLnB1c2goY2h1bmsyLCB0cnVlKTsgIC8vIHRydWUgLT4gbGFzdCBjaHVua1xuICpcbiAqIGlmIChkZWZsYXRlLmVycikgeyB0aHJvdyBuZXcgRXJyb3IoZGVmbGF0ZS5lcnIpOyB9XG4gKlxuICogY29uc29sZS5sb2coZGVmbGF0ZS5yZXN1bHQpO1xuICogYGBgXG4gKiovXG5mdW5jdGlvbiBEZWZsYXRlKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIERlZmxhdGUpKSByZXR1cm4gbmV3IERlZmxhdGUob3B0aW9ucyk7XG5cbiAgdGhpcy5vcHRpb25zID0gdXRpbHMuYXNzaWduKHtcbiAgICBsZXZlbDogWl9ERUZBVUxUX0NPTVBSRVNTSU9OLFxuICAgIG1ldGhvZDogWl9ERUZMQVRFRCxcbiAgICBjaHVua1NpemU6IDE2Mzg0LFxuICAgIHdpbmRvd0JpdHM6IDE1LFxuICAgIG1lbUxldmVsOiA4LFxuICAgIHN0cmF0ZWd5OiBaX0RFRkFVTFRfU1RSQVRFR1ksXG4gICAgdG86ICcnXG4gIH0sIG9wdGlvbnMgfHwge30pO1xuXG4gIHZhciBvcHQgPSB0aGlzLm9wdGlvbnM7XG5cbiAgaWYgKG9wdC5yYXcgJiYgKG9wdC53aW5kb3dCaXRzID4gMCkpIHtcbiAgICBvcHQud2luZG93Qml0cyA9IC1vcHQud2luZG93Qml0cztcbiAgfVxuXG4gIGVsc2UgaWYgKG9wdC5nemlwICYmIChvcHQud2luZG93Qml0cyA+IDApICYmIChvcHQud2luZG93Qml0cyA8IDE2KSkge1xuICAgIG9wdC53aW5kb3dCaXRzICs9IDE2O1xuICB9XG5cbiAgdGhpcy5lcnIgICAgPSAwOyAgICAgIC8vIGVycm9yIGNvZGUsIGlmIGhhcHBlbnMgKDAgPSBaX09LKVxuICB0aGlzLm1zZyAgICA9ICcnOyAgICAgLy8gZXJyb3IgbWVzc2FnZVxuICB0aGlzLmVuZGVkICA9IGZhbHNlOyAgLy8gdXNlZCB0byBhdm9pZCBtdWx0aXBsZSBvbkVuZCgpIGNhbGxzXG4gIHRoaXMuY2h1bmtzID0gW107ICAgICAvLyBjaHVua3Mgb2YgY29tcHJlc3NlZCBkYXRhXG5cbiAgdGhpcy5zdHJtID0gbmV3IFpTdHJlYW0oKTtcbiAgdGhpcy5zdHJtLmF2YWlsX291dCA9IDA7XG5cbiAgdmFyIHN0YXR1cyA9IHpsaWJfZGVmbGF0ZS5kZWZsYXRlSW5pdDIoXG4gICAgdGhpcy5zdHJtLFxuICAgIG9wdC5sZXZlbCxcbiAgICBvcHQubWV0aG9kLFxuICAgIG9wdC53aW5kb3dCaXRzLFxuICAgIG9wdC5tZW1MZXZlbCxcbiAgICBvcHQuc3RyYXRlZ3lcbiAgKTtcblxuICBpZiAoc3RhdHVzICE9PSBaX09LKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1zZ1tzdGF0dXNdKTtcbiAgfVxuXG4gIGlmIChvcHQuaGVhZGVyKSB7XG4gICAgemxpYl9kZWZsYXRlLmRlZmxhdGVTZXRIZWFkZXIodGhpcy5zdHJtLCBvcHQuaGVhZGVyKTtcbiAgfVxuXG4gIGlmIChvcHQuZGljdGlvbmFyeSkge1xuICAgIHZhciBkaWN0O1xuICAgIC8vIENvbnZlcnQgZGF0YSBpZiBuZWVkZWRcbiAgICBpZiAodHlwZW9mIG9wdC5kaWN0aW9uYXJ5ID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gSWYgd2UgbmVlZCB0byBjb21wcmVzcyB0ZXh0LCBjaGFuZ2UgZW5jb2RpbmcgdG8gdXRmOC5cbiAgICAgIGRpY3QgPSBzdHJpbmdzLnN0cmluZzJidWYob3B0LmRpY3Rpb25hcnkpO1xuICAgIH0gZWxzZSBpZiAodG9TdHJpbmcuY2FsbChvcHQuZGljdGlvbmFyeSkgPT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXScpIHtcbiAgICAgIGRpY3QgPSBuZXcgVWludDhBcnJheShvcHQuZGljdGlvbmFyeSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRpY3QgPSBvcHQuZGljdGlvbmFyeTtcbiAgICB9XG5cbiAgICBzdGF0dXMgPSB6bGliX2RlZmxhdGUuZGVmbGF0ZVNldERpY3Rpb25hcnkodGhpcy5zdHJtLCBkaWN0KTtcblxuICAgIGlmIChzdGF0dXMgIT09IFpfT0spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihtc2dbc3RhdHVzXSk7XG4gICAgfVxuXG4gICAgdGhpcy5fZGljdF9zZXQgPSB0cnVlO1xuICB9XG59XG5cbi8qKlxuICogRGVmbGF0ZSNwdXNoKGRhdGFbLCBtb2RlXSkgLT4gQm9vbGVhblxuICogLSBkYXRhIChVaW50OEFycmF5fEFycmF5fEFycmF5QnVmZmVyfFN0cmluZyk6IGlucHV0IGRhdGEuIFN0cmluZ3Mgd2lsbCBiZVxuICogICBjb252ZXJ0ZWQgdG8gdXRmOCBieXRlIHNlcXVlbmNlLlxuICogLSBtb2RlIChOdW1iZXJ8Qm9vbGVhbik6IDAuLjYgZm9yIGNvcnJlc3BvbmRpbmcgWl9OT19GTFVTSC4uWl9UUkVFIG1vZGVzLlxuICogICBTZWUgY29uc3RhbnRzLiBTa2lwcGVkIG9yIGBmYWxzZWAgbWVhbnMgWl9OT19GTFVTSCwgYHRydWVgIG1lYW5zIFpfRklOSVNILlxuICpcbiAqIFNlbmRzIGlucHV0IGRhdGEgdG8gZGVmbGF0ZSBwaXBlLCBnZW5lcmF0aW5nIFtbRGVmbGF0ZSNvbkRhdGFdXSBjYWxscyB3aXRoXG4gKiBuZXcgY29tcHJlc3NlZCBjaHVua3MuIFJldHVybnMgYHRydWVgIG9uIHN1Y2Nlc3MuIFRoZSBsYXN0IGRhdGEgYmxvY2sgbXVzdCBoYXZlXG4gKiBtb2RlIFpfRklOSVNIIChvciBgdHJ1ZWApLiBUaGF0IHdpbGwgZmx1c2ggaW50ZXJuYWwgcGVuZGluZyBidWZmZXJzIGFuZCBjYWxsXG4gKiBbW0RlZmxhdGUjb25FbmRdXS4gRm9yIGludGVyaW0gZXhwbGljaXQgZmx1c2hlcyAod2l0aG91dCBlbmRpbmcgdGhlIHN0cmVhbSkgeW91XG4gKiBjYW4gdXNlIG1vZGUgWl9TWU5DX0ZMVVNILCBrZWVwaW5nIHRoZSBjb21wcmVzc2lvbiBjb250ZXh0LlxuICpcbiAqIE9uIGZhaWwgY2FsbCBbW0RlZmxhdGUjb25FbmRdXSB3aXRoIGVycm9yIGNvZGUgYW5kIHJldHVybiBmYWxzZS5cbiAqXG4gKiBXZSBzdHJvbmdseSByZWNvbW1lbmQgdG8gdXNlIGBVaW50OEFycmF5YCBvbiBpbnB1dCBmb3IgYmVzdCBzcGVlZCAob3V0cHV0XG4gKiBhcnJheSBmb3JtYXQgaXMgZGV0ZWN0ZWQgYXV0b21hdGljYWxseSkuIEFsc28sIGRvbid0IHNraXAgbGFzdCBwYXJhbSBhbmQgYWx3YXlzXG4gKiB1c2UgdGhlIHNhbWUgdHlwZSBpbiB5b3VyIGNvZGUgKGJvb2xlYW4gb3IgbnVtYmVyKS4gVGhhdCB3aWxsIGltcHJvdmUgSlMgc3BlZWQuXG4gKlxuICogRm9yIHJlZ3VsYXIgYEFycmF5YC1zIG1ha2Ugc3VyZSBhbGwgZWxlbWVudHMgYXJlIFswLi4yNTVdLlxuICpcbiAqICMjIyMjIEV4YW1wbGVcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBwdXNoKGNodW5rLCBmYWxzZSk7IC8vIHB1c2ggb25lIG9mIGRhdGEgY2h1bmtzXG4gKiAuLi5cbiAqIHB1c2goY2h1bmssIHRydWUpOyAgLy8gcHVzaCBsYXN0IGNodW5rXG4gKiBgYGBcbiAqKi9cbkRlZmxhdGUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoZGF0YSwgbW9kZSkge1xuICB2YXIgc3RybSA9IHRoaXMuc3RybTtcbiAgdmFyIGNodW5rU2l6ZSA9IHRoaXMub3B0aW9ucy5jaHVua1NpemU7XG4gIHZhciBzdGF0dXMsIF9tb2RlO1xuXG4gIGlmICh0aGlzLmVuZGVkKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIF9tb2RlID0gKG1vZGUgPT09IH5+bW9kZSkgPyBtb2RlIDogKChtb2RlID09PSB0cnVlKSA/IFpfRklOSVNIIDogWl9OT19GTFVTSCk7XG5cbiAgLy8gQ29udmVydCBkYXRhIGlmIG5lZWRlZFxuICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgLy8gSWYgd2UgbmVlZCB0byBjb21wcmVzcyB0ZXh0LCBjaGFuZ2UgZW5jb2RpbmcgdG8gdXRmOC5cbiAgICBzdHJtLmlucHV0ID0gc3RyaW5ncy5zdHJpbmcyYnVmKGRhdGEpO1xuICB9IGVsc2UgaWYgKHRvU3RyaW5nLmNhbGwoZGF0YSkgPT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXScpIHtcbiAgICBzdHJtLmlucHV0ID0gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7XG4gIH0gZWxzZSB7XG4gICAgc3RybS5pbnB1dCA9IGRhdGE7XG4gIH1cblxuICBzdHJtLm5leHRfaW4gPSAwO1xuICBzdHJtLmF2YWlsX2luID0gc3RybS5pbnB1dC5sZW5ndGg7XG5cbiAgZG8ge1xuICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgc3RybS5vdXRwdXQgPSBuZXcgdXRpbHMuQnVmOChjaHVua1NpemUpO1xuICAgICAgc3RybS5uZXh0X291dCA9IDA7XG4gICAgICBzdHJtLmF2YWlsX291dCA9IGNodW5rU2l6ZTtcbiAgICB9XG4gICAgc3RhdHVzID0gemxpYl9kZWZsYXRlLmRlZmxhdGUoc3RybSwgX21vZGUpOyAgICAvKiBubyBiYWQgcmV0dXJuIHZhbHVlICovXG5cbiAgICBpZiAoc3RhdHVzICE9PSBaX1NUUkVBTV9FTkQgJiYgc3RhdHVzICE9PSBaX09LKSB7XG4gICAgICB0aGlzLm9uRW5kKHN0YXR1cyk7XG4gICAgICB0aGlzLmVuZGVkID0gdHJ1ZTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwIHx8IChzdHJtLmF2YWlsX2luID09PSAwICYmIChfbW9kZSA9PT0gWl9GSU5JU0ggfHwgX21vZGUgPT09IFpfU1lOQ19GTFVTSCkpKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnRvID09PSAnc3RyaW5nJykge1xuICAgICAgICB0aGlzLm9uRGF0YShzdHJpbmdzLmJ1ZjJiaW5zdHJpbmcodXRpbHMuc2hyaW5rQnVmKHN0cm0ub3V0cHV0LCBzdHJtLm5leHRfb3V0KSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5vbkRhdGEodXRpbHMuc2hyaW5rQnVmKHN0cm0ub3V0cHV0LCBzdHJtLm5leHRfb3V0KSk7XG4gICAgICB9XG4gICAgfVxuICB9IHdoaWxlICgoc3RybS5hdmFpbF9pbiA+IDAgfHwgc3RybS5hdmFpbF9vdXQgPT09IDApICYmIHN0YXR1cyAhPT0gWl9TVFJFQU1fRU5EKTtcblxuICAvLyBGaW5hbGl6ZSBvbiB0aGUgbGFzdCBjaHVuay5cbiAgaWYgKF9tb2RlID09PSBaX0ZJTklTSCkge1xuICAgIHN0YXR1cyA9IHpsaWJfZGVmbGF0ZS5kZWZsYXRlRW5kKHRoaXMuc3RybSk7XG4gICAgdGhpcy5vbkVuZChzdGF0dXMpO1xuICAgIHRoaXMuZW5kZWQgPSB0cnVlO1xuICAgIHJldHVybiBzdGF0dXMgPT09IFpfT0s7XG4gIH1cblxuICAvLyBjYWxsYmFjayBpbnRlcmltIHJlc3VsdHMgaWYgWl9TWU5DX0ZMVVNILlxuICBpZiAoX21vZGUgPT09IFpfU1lOQ19GTFVTSCkge1xuICAgIHRoaXMub25FbmQoWl9PSyk7XG4gICAgc3RybS5hdmFpbF9vdXQgPSAwO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cbi8qKlxuICogRGVmbGF0ZSNvbkRhdGEoY2h1bmspIC0+IFZvaWRcbiAqIC0gY2h1bmsgKFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nKTogb3V0cHV0IGRhdGEuIFR5cGUgb2YgYXJyYXkgZGVwZW5kc1xuICogICBvbiBqcyBlbmdpbmUgc3VwcG9ydC4gV2hlbiBzdHJpbmcgb3V0cHV0IHJlcXVlc3RlZCwgZWFjaCBjaHVua1xuICogICB3aWxsIGJlIHN0cmluZy5cbiAqXG4gKiBCeSBkZWZhdWx0LCBzdG9yZXMgZGF0YSBibG9ja3MgaW4gYGNodW5rc1tdYCBwcm9wZXJ0eSBhbmQgZ2x1ZVxuICogdGhvc2UgaW4gYG9uRW5kYC4gT3ZlcnJpZGUgdGhpcyBoYW5kbGVyLCBpZiB5b3UgbmVlZCBhbm90aGVyIGJlaGF2aW91ci5cbiAqKi9cbkRlZmxhdGUucHJvdG90eXBlLm9uRGF0YSA9IGZ1bmN0aW9uIChjaHVuaykge1xuICB0aGlzLmNodW5rcy5wdXNoKGNodW5rKTtcbn07XG5cblxuLyoqXG4gKiBEZWZsYXRlI29uRW5kKHN0YXR1cykgLT4gVm9pZFxuICogLSBzdGF0dXMgKE51bWJlcik6IGRlZmxhdGUgc3RhdHVzLiAwIChaX09LKSBvbiBzdWNjZXNzLFxuICogICBvdGhlciBpZiBub3QuXG4gKlxuICogQ2FsbGVkIG9uY2UgYWZ0ZXIgeW91IHRlbGwgZGVmbGF0ZSB0aGF0IHRoZSBpbnB1dCBzdHJlYW0gaXNcbiAqIGNvbXBsZXRlIChaX0ZJTklTSCkgb3Igc2hvdWxkIGJlIGZsdXNoZWQgKFpfU1lOQ19GTFVTSClcbiAqIG9yIGlmIGFuIGVycm9yIGhhcHBlbmVkLiBCeSBkZWZhdWx0IC0gam9pbiBjb2xsZWN0ZWQgY2h1bmtzLFxuICogZnJlZSBtZW1vcnkgYW5kIGZpbGwgYHJlc3VsdHNgIC8gYGVycmAgcHJvcGVydGllcy5cbiAqKi9cbkRlZmxhdGUucHJvdG90eXBlLm9uRW5kID0gZnVuY3Rpb24gKHN0YXR1cykge1xuICAvLyBPbiBzdWNjZXNzIC0gam9pblxuICBpZiAoc3RhdHVzID09PSBaX09LKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy50byA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMucmVzdWx0ID0gdGhpcy5jaHVua3Muam9pbignJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVzdWx0ID0gdXRpbHMuZmxhdHRlbkNodW5rcyh0aGlzLmNodW5rcyk7XG4gICAgfVxuICB9XG4gIHRoaXMuY2h1bmtzID0gW107XG4gIHRoaXMuZXJyID0gc3RhdHVzO1xuICB0aGlzLm1zZyA9IHRoaXMuc3RybS5tc2c7XG59O1xuXG5cbi8qKlxuICogZGVmbGF0ZShkYXRhWywgb3B0aW9uc10pIC0+IFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nXG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nKTogaW5wdXQgZGF0YSB0byBjb21wcmVzcy5cbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBkZWZsYXRlIG9wdGlvbnMuXG4gKlxuICogQ29tcHJlc3MgYGRhdGFgIHdpdGggZGVmbGF0ZSBhbGdvcml0aG0gYW5kIGBvcHRpb25zYC5cbiAqXG4gKiBTdXBwb3J0ZWQgb3B0aW9ucyBhcmU6XG4gKlxuICogLSBsZXZlbFxuICogLSB3aW5kb3dCaXRzXG4gKiAtIG1lbUxldmVsXG4gKiAtIHN0cmF0ZWd5XG4gKiAtIGRpY3Rpb25hcnlcbiAqXG4gKiBbaHR0cDovL3psaWIubmV0L21hbnVhbC5odG1sI0FkdmFuY2VkXShodHRwOi8vemxpYi5uZXQvbWFudWFsLmh0bWwjQWR2YW5jZWQpXG4gKiBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiB0aGVzZS5cbiAqXG4gKiBTdWdhciAob3B0aW9ucyk6XG4gKlxuICogLSBgcmF3YCAoQm9vbGVhbikgLSBzYXkgdGhhdCB3ZSB3b3JrIHdpdGggcmF3IHN0cmVhbSwgaWYgeW91IGRvbid0IHdpc2ggdG8gc3BlY2lmeVxuICogICBuZWdhdGl2ZSB3aW5kb3dCaXRzIGltcGxpY2l0bHkuXG4gKiAtIGB0b2AgKFN0cmluZykgLSBpZiBlcXVhbCB0byAnc3RyaW5nJywgdGhlbiByZXN1bHQgd2lsbCBiZSBcImJpbmFyeSBzdHJpbmdcIlxuICogICAgKGVhY2ggY2hhciBjb2RlIFswLi4yNTVdKVxuICpcbiAqICMjIyMjIEV4YW1wbGU6XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogdmFyIHBha28gPSByZXF1aXJlKCdwYWtvJylcbiAqICAgLCBkYXRhID0gVWludDhBcnJheShbMSwyLDMsNCw1LDYsNyw4LDldKTtcbiAqXG4gKiBjb25zb2xlLmxvZyhwYWtvLmRlZmxhdGUoZGF0YSkpO1xuICogYGBgXG4gKiovXG5mdW5jdGlvbiBkZWZsYXRlKGlucHV0LCBvcHRpb25zKSB7XG4gIHZhciBkZWZsYXRvciA9IG5ldyBEZWZsYXRlKG9wdGlvbnMpO1xuXG4gIGRlZmxhdG9yLnB1c2goaW5wdXQsIHRydWUpO1xuXG4gIC8vIFRoYXQgd2lsbCBuZXZlciBoYXBwZW5zLCBpZiB5b3UgZG9uJ3QgY2hlYXQgd2l0aCBvcHRpb25zIDopXG4gIGlmIChkZWZsYXRvci5lcnIpIHsgdGhyb3cgZGVmbGF0b3IubXNnIHx8IG1zZ1tkZWZsYXRvci5lcnJdOyB9XG5cbiAgcmV0dXJuIGRlZmxhdG9yLnJlc3VsdDtcbn1cblxuXG4vKipcbiAqIGRlZmxhdGVSYXcoZGF0YVssIG9wdGlvbnNdKSAtPiBVaW50OEFycmF5fEFycmF5fFN0cmluZ1xuICogLSBkYXRhIChVaW50OEFycmF5fEFycmF5fFN0cmluZyk6IGlucHV0IGRhdGEgdG8gY29tcHJlc3MuXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHpsaWIgZGVmbGF0ZSBvcHRpb25zLlxuICpcbiAqIFRoZSBzYW1lIGFzIFtbZGVmbGF0ZV1dLCBidXQgY3JlYXRlcyByYXcgZGF0YSwgd2l0aG91dCB3cmFwcGVyXG4gKiAoaGVhZGVyIGFuZCBhZGxlcjMyIGNyYykuXG4gKiovXG5mdW5jdGlvbiBkZWZsYXRlUmF3KGlucHV0LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBvcHRpb25zLnJhdyA9IHRydWU7XG4gIHJldHVybiBkZWZsYXRlKGlucHV0LCBvcHRpb25zKTtcbn1cblxuXG4vKipcbiAqIGd6aXAoZGF0YVssIG9wdGlvbnNdKSAtPiBVaW50OEFycmF5fEFycmF5fFN0cmluZ1xuICogLSBkYXRhIChVaW50OEFycmF5fEFycmF5fFN0cmluZyk6IGlucHV0IGRhdGEgdG8gY29tcHJlc3MuXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHpsaWIgZGVmbGF0ZSBvcHRpb25zLlxuICpcbiAqIFRoZSBzYW1lIGFzIFtbZGVmbGF0ZV1dLCBidXQgY3JlYXRlIGd6aXAgd3JhcHBlciBpbnN0ZWFkIG9mXG4gKiBkZWZsYXRlIG9uZS5cbiAqKi9cbmZ1bmN0aW9uIGd6aXAoaW5wdXQsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIG9wdGlvbnMuZ3ppcCA9IHRydWU7XG4gIHJldHVybiBkZWZsYXRlKGlucHV0LCBvcHRpb25zKTtcbn1cblxuXG5leHBvcnRzLkRlZmxhdGUgPSBEZWZsYXRlO1xuZXhwb3J0cy5kZWZsYXRlID0gZGVmbGF0ZTtcbmV4cG9ydHMuZGVmbGF0ZVJhdyA9IGRlZmxhdGVSYXc7XG5leHBvcnRzLmd6aXAgPSBnemlwO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciB6bGliX2luZmxhdGUgPSByZXF1aXJlKCcuL3psaWIvaW5mbGF0ZScpO1xudmFyIHV0aWxzICAgICAgICA9IHJlcXVpcmUoJy4vdXRpbHMvY29tbW9uJyk7XG52YXIgc3RyaW5ncyAgICAgID0gcmVxdWlyZSgnLi91dGlscy9zdHJpbmdzJyk7XG52YXIgYyAgICAgICAgICAgID0gcmVxdWlyZSgnLi96bGliL2NvbnN0YW50cycpO1xudmFyIG1zZyAgICAgICAgICA9IHJlcXVpcmUoJy4vemxpYi9tZXNzYWdlcycpO1xudmFyIFpTdHJlYW0gICAgICA9IHJlcXVpcmUoJy4vemxpYi96c3RyZWFtJyk7XG52YXIgR1poZWFkZXIgICAgID0gcmVxdWlyZSgnLi96bGliL2d6aGVhZGVyJyk7XG5cbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8qKlxuICogY2xhc3MgSW5mbGF0ZVxuICpcbiAqIEdlbmVyaWMgSlMtc3R5bGUgd3JhcHBlciBmb3IgemxpYiBjYWxscy4gSWYgeW91IGRvbid0IG5lZWRcbiAqIHN0cmVhbWluZyBiZWhhdmlvdXIgLSB1c2UgbW9yZSBzaW1wbGUgZnVuY3Rpb25zOiBbW2luZmxhdGVdXVxuICogYW5kIFtbaW5mbGF0ZVJhd11dLlxuICoqL1xuXG4vKiBpbnRlcm5hbFxuICogaW5mbGF0ZS5jaHVua3MgLT4gQXJyYXlcbiAqXG4gKiBDaHVua3Mgb2Ygb3V0cHV0IGRhdGEsIGlmIFtbSW5mbGF0ZSNvbkRhdGFdXSBub3Qgb3ZlcnJpZGRlbi5cbiAqKi9cblxuLyoqXG4gKiBJbmZsYXRlLnJlc3VsdCAtPiBVaW50OEFycmF5fEFycmF5fFN0cmluZ1xuICpcbiAqIFVuY29tcHJlc3NlZCByZXN1bHQsIGdlbmVyYXRlZCBieSBkZWZhdWx0IFtbSW5mbGF0ZSNvbkRhdGFdXVxuICogYW5kIFtbSW5mbGF0ZSNvbkVuZF1dIGhhbmRsZXJzLiBGaWxsZWQgYWZ0ZXIgeW91IHB1c2ggbGFzdCBjaHVua1xuICogKGNhbGwgW1tJbmZsYXRlI3B1c2hdXSB3aXRoIGBaX0ZJTklTSGAgLyBgdHJ1ZWAgcGFyYW0pIG9yIGlmIHlvdVxuICogcHVzaCBhIGNodW5rIHdpdGggZXhwbGljaXQgZmx1c2ggKGNhbGwgW1tJbmZsYXRlI3B1c2hdXSB3aXRoXG4gKiBgWl9TWU5DX0ZMVVNIYCBwYXJhbSkuXG4gKiovXG5cbi8qKlxuICogSW5mbGF0ZS5lcnIgLT4gTnVtYmVyXG4gKlxuICogRXJyb3IgY29kZSBhZnRlciBpbmZsYXRlIGZpbmlzaGVkLiAwIChaX09LKSBvbiBzdWNjZXNzLlxuICogU2hvdWxkIGJlIGNoZWNrZWQgaWYgYnJva2VuIGRhdGEgcG9zc2libGUuXG4gKiovXG5cbi8qKlxuICogSW5mbGF0ZS5tc2cgLT4gU3RyaW5nXG4gKlxuICogRXJyb3IgbWVzc2FnZSwgaWYgW1tJbmZsYXRlLmVycl1dICE9IDBcbiAqKi9cblxuXG4vKipcbiAqIG5ldyBJbmZsYXRlKG9wdGlvbnMpXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHpsaWIgaW5mbGF0ZSBvcHRpb25zLlxuICpcbiAqIENyZWF0ZXMgbmV3IGluZmxhdG9yIGluc3RhbmNlIHdpdGggc3BlY2lmaWVkIHBhcmFtcy4gVGhyb3dzIGV4Y2VwdGlvblxuICogb24gYmFkIHBhcmFtcy4gU3VwcG9ydGVkIG9wdGlvbnM6XG4gKlxuICogLSBgd2luZG93Qml0c2BcbiAqIC0gYGRpY3Rpb25hcnlgXG4gKlxuICogW2h0dHA6Ly96bGliLm5ldC9tYW51YWwuaHRtbCNBZHZhbmNlZF0oaHR0cDovL3psaWIubmV0L21hbnVhbC5odG1sI0FkdmFuY2VkKVxuICogZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gdGhlc2UuXG4gKlxuICogQWRkaXRpb25hbCBvcHRpb25zLCBmb3IgaW50ZXJuYWwgbmVlZHM6XG4gKlxuICogLSBgY2h1bmtTaXplYCAtIHNpemUgb2YgZ2VuZXJhdGVkIGRhdGEgY2h1bmtzICgxNksgYnkgZGVmYXVsdClcbiAqIC0gYHJhd2AgKEJvb2xlYW4pIC0gZG8gcmF3IGluZmxhdGVcbiAqIC0gYHRvYCAoU3RyaW5nKSAtIGlmIGVxdWFsIHRvICdzdHJpbmcnLCB0aGVuIHJlc3VsdCB3aWxsIGJlIGNvbnZlcnRlZFxuICogICBmcm9tIHV0ZjggdG8gdXRmMTYgKGphdmFzY3JpcHQpIHN0cmluZy4gV2hlbiBzdHJpbmcgb3V0cHV0IHJlcXVlc3RlZCxcbiAqICAgY2h1bmsgbGVuZ3RoIGNhbiBkaWZmZXIgZnJvbSBgY2h1bmtTaXplYCwgZGVwZW5kaW5nIG9uIGNvbnRlbnQuXG4gKlxuICogQnkgZGVmYXVsdCwgd2hlbiBubyBvcHRpb25zIHNldCwgYXV0b2RldGVjdCBkZWZsYXRlL2d6aXAgZGF0YSBmb3JtYXQgdmlhXG4gKiB3cmFwcGVyIGhlYWRlci5cbiAqXG4gKiAjIyMjIyBFeGFtcGxlOlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHZhciBwYWtvID0gcmVxdWlyZSgncGFrbycpXG4gKiAgICwgY2h1bmsxID0gVWludDhBcnJheShbMSwyLDMsNCw1LDYsNyw4LDldKVxuICogICAsIGNodW5rMiA9IFVpbnQ4QXJyYXkoWzEwLDExLDEyLDEzLDE0LDE1LDE2LDE3LDE4LDE5XSk7XG4gKlxuICogdmFyIGluZmxhdGUgPSBuZXcgcGFrby5JbmZsYXRlKHsgbGV2ZWw6IDN9KTtcbiAqXG4gKiBpbmZsYXRlLnB1c2goY2h1bmsxLCBmYWxzZSk7XG4gKiBpbmZsYXRlLnB1c2goY2h1bmsyLCB0cnVlKTsgIC8vIHRydWUgLT4gbGFzdCBjaHVua1xuICpcbiAqIGlmIChpbmZsYXRlLmVycikgeyB0aHJvdyBuZXcgRXJyb3IoaW5mbGF0ZS5lcnIpOyB9XG4gKlxuICogY29uc29sZS5sb2coaW5mbGF0ZS5yZXN1bHQpO1xuICogYGBgXG4gKiovXG5mdW5jdGlvbiBJbmZsYXRlKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEluZmxhdGUpKSByZXR1cm4gbmV3IEluZmxhdGUob3B0aW9ucyk7XG5cbiAgdGhpcy5vcHRpb25zID0gdXRpbHMuYXNzaWduKHtcbiAgICBjaHVua1NpemU6IDE2Mzg0LFxuICAgIHdpbmRvd0JpdHM6IDAsXG4gICAgdG86ICcnXG4gIH0sIG9wdGlvbnMgfHwge30pO1xuXG4gIHZhciBvcHQgPSB0aGlzLm9wdGlvbnM7XG5cbiAgLy8gRm9yY2Ugd2luZG93IHNpemUgZm9yIGByYXdgIGRhdGEsIGlmIG5vdCBzZXQgZGlyZWN0bHksXG4gIC8vIGJlY2F1c2Ugd2UgaGF2ZSBubyBoZWFkZXIgZm9yIGF1dG9kZXRlY3QuXG4gIGlmIChvcHQucmF3ICYmIChvcHQud2luZG93Qml0cyA+PSAwKSAmJiAob3B0LndpbmRvd0JpdHMgPCAxNikpIHtcbiAgICBvcHQud2luZG93Qml0cyA9IC1vcHQud2luZG93Qml0cztcbiAgICBpZiAob3B0LndpbmRvd0JpdHMgPT09IDApIHsgb3B0LndpbmRvd0JpdHMgPSAtMTU7IH1cbiAgfVxuXG4gIC8vIElmIGB3aW5kb3dCaXRzYCBub3QgZGVmaW5lZCAoYW5kIG1vZGUgbm90IHJhdykgLSBzZXQgYXV0b2RldGVjdCBmbGFnIGZvciBnemlwL2RlZmxhdGVcbiAgaWYgKChvcHQud2luZG93Qml0cyA+PSAwKSAmJiAob3B0LndpbmRvd0JpdHMgPCAxNikgJiZcbiAgICAgICEob3B0aW9ucyAmJiBvcHRpb25zLndpbmRvd0JpdHMpKSB7XG4gICAgb3B0LndpbmRvd0JpdHMgKz0gMzI7XG4gIH1cblxuICAvLyBHemlwIGhlYWRlciBoYXMgbm8gaW5mbyBhYm91dCB3aW5kb3dzIHNpemUsIHdlIGNhbiBkbyBhdXRvZGV0ZWN0IG9ubHlcbiAgLy8gZm9yIGRlZmxhdGUuIFNvLCBpZiB3aW5kb3cgc2l6ZSBub3Qgc2V0LCBmb3JjZSBpdCB0byBtYXggd2hlbiBnemlwIHBvc3NpYmxlXG4gIGlmICgob3B0LndpbmRvd0JpdHMgPiAxNSkgJiYgKG9wdC53aW5kb3dCaXRzIDwgNDgpKSB7XG4gICAgLy8gYml0IDMgKDE2KSAtPiBnemlwcGVkIGRhdGFcbiAgICAvLyBiaXQgNCAoMzIpIC0+IGF1dG9kZXRlY3QgZ3ppcC9kZWZsYXRlXG4gICAgaWYgKChvcHQud2luZG93Qml0cyAmIDE1KSA9PT0gMCkge1xuICAgICAgb3B0LndpbmRvd0JpdHMgfD0gMTU7XG4gICAgfVxuICB9XG5cbiAgdGhpcy5lcnIgICAgPSAwOyAgICAgIC8vIGVycm9yIGNvZGUsIGlmIGhhcHBlbnMgKDAgPSBaX09LKVxuICB0aGlzLm1zZyAgICA9ICcnOyAgICAgLy8gZXJyb3IgbWVzc2FnZVxuICB0aGlzLmVuZGVkICA9IGZhbHNlOyAgLy8gdXNlZCB0byBhdm9pZCBtdWx0aXBsZSBvbkVuZCgpIGNhbGxzXG4gIHRoaXMuY2h1bmtzID0gW107ICAgICAvLyBjaHVua3Mgb2YgY29tcHJlc3NlZCBkYXRhXG5cbiAgdGhpcy5zdHJtICAgPSBuZXcgWlN0cmVhbSgpO1xuICB0aGlzLnN0cm0uYXZhaWxfb3V0ID0gMDtcblxuICB2YXIgc3RhdHVzICA9IHpsaWJfaW5mbGF0ZS5pbmZsYXRlSW5pdDIoXG4gICAgdGhpcy5zdHJtLFxuICAgIG9wdC53aW5kb3dCaXRzXG4gICk7XG5cbiAgaWYgKHN0YXR1cyAhPT0gYy5aX09LKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1zZ1tzdGF0dXNdKTtcbiAgfVxuXG4gIHRoaXMuaGVhZGVyID0gbmV3IEdaaGVhZGVyKCk7XG5cbiAgemxpYl9pbmZsYXRlLmluZmxhdGVHZXRIZWFkZXIodGhpcy5zdHJtLCB0aGlzLmhlYWRlcik7XG59XG5cbi8qKlxuICogSW5mbGF0ZSNwdXNoKGRhdGFbLCBtb2RlXSkgLT4gQm9vbGVhblxuICogLSBkYXRhIChVaW50OEFycmF5fEFycmF5fEFycmF5QnVmZmVyfFN0cmluZyk6IGlucHV0IGRhdGFcbiAqIC0gbW9kZSAoTnVtYmVyfEJvb2xlYW4pOiAwLi42IGZvciBjb3JyZXNwb25kaW5nIFpfTk9fRkxVU0guLlpfVFJFRSBtb2Rlcy5cbiAqICAgU2VlIGNvbnN0YW50cy4gU2tpcHBlZCBvciBgZmFsc2VgIG1lYW5zIFpfTk9fRkxVU0gsIGB0cnVlYCBtZWFucyBaX0ZJTklTSC5cbiAqXG4gKiBTZW5kcyBpbnB1dCBkYXRhIHRvIGluZmxhdGUgcGlwZSwgZ2VuZXJhdGluZyBbW0luZmxhdGUjb25EYXRhXV0gY2FsbHMgd2l0aFxuICogbmV3IG91dHB1dCBjaHVua3MuIFJldHVybnMgYHRydWVgIG9uIHN1Y2Nlc3MuIFRoZSBsYXN0IGRhdGEgYmxvY2sgbXVzdCBoYXZlXG4gKiBtb2RlIFpfRklOSVNIIChvciBgdHJ1ZWApLiBUaGF0IHdpbGwgZmx1c2ggaW50ZXJuYWwgcGVuZGluZyBidWZmZXJzIGFuZCBjYWxsXG4gKiBbW0luZmxhdGUjb25FbmRdXS4gRm9yIGludGVyaW0gZXhwbGljaXQgZmx1c2hlcyAod2l0aG91dCBlbmRpbmcgdGhlIHN0cmVhbSkgeW91XG4gKiBjYW4gdXNlIG1vZGUgWl9TWU5DX0ZMVVNILCBrZWVwaW5nIHRoZSBkZWNvbXByZXNzaW9uIGNvbnRleHQuXG4gKlxuICogT24gZmFpbCBjYWxsIFtbSW5mbGF0ZSNvbkVuZF1dIHdpdGggZXJyb3IgY29kZSBhbmQgcmV0dXJuIGZhbHNlLlxuICpcbiAqIFdlIHN0cm9uZ2x5IHJlY29tbWVuZCB0byB1c2UgYFVpbnQ4QXJyYXlgIG9uIGlucHV0IGZvciBiZXN0IHNwZWVkIChvdXRwdXRcbiAqIGZvcm1hdCBpcyBkZXRlY3RlZCBhdXRvbWF0aWNhbGx5KS4gQWxzbywgZG9uJ3Qgc2tpcCBsYXN0IHBhcmFtIGFuZCBhbHdheXNcbiAqIHVzZSB0aGUgc2FtZSB0eXBlIGluIHlvdXIgY29kZSAoYm9vbGVhbiBvciBudW1iZXIpLiBUaGF0IHdpbGwgaW1wcm92ZSBKUyBzcGVlZC5cbiAqXG4gKiBGb3IgcmVndWxhciBgQXJyYXlgLXMgbWFrZSBzdXJlIGFsbCBlbGVtZW50cyBhcmUgWzAuLjI1NV0uXG4gKlxuICogIyMjIyMgRXhhbXBsZVxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHB1c2goY2h1bmssIGZhbHNlKTsgLy8gcHVzaCBvbmUgb2YgZGF0YSBjaHVua3NcbiAqIC4uLlxuICogcHVzaChjaHVuaywgdHJ1ZSk7ICAvLyBwdXNoIGxhc3QgY2h1bmtcbiAqIGBgYFxuICoqL1xuSW5mbGF0ZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChkYXRhLCBtb2RlKSB7XG4gIHZhciBzdHJtID0gdGhpcy5zdHJtO1xuICB2YXIgY2h1bmtTaXplID0gdGhpcy5vcHRpb25zLmNodW5rU2l6ZTtcbiAgdmFyIGRpY3Rpb25hcnkgPSB0aGlzLm9wdGlvbnMuZGljdGlvbmFyeTtcbiAgdmFyIHN0YXR1cywgX21vZGU7XG4gIHZhciBuZXh0X291dF91dGY4LCB0YWlsLCB1dGY4c3RyO1xuICB2YXIgZGljdDtcblxuICAvLyBGbGFnIHRvIHByb3Blcmx5IHByb2Nlc3MgWl9CVUZfRVJST1Igb24gdGVzdGluZyBpbmZsYXRlIGNhbGxcbiAgLy8gd2hlbiB3ZSBjaGVjayB0aGF0IGFsbCBvdXRwdXQgZGF0YSB3YXMgZmx1c2hlZC5cbiAgdmFyIGFsbG93QnVmRXJyb3IgPSBmYWxzZTtcblxuICBpZiAodGhpcy5lbmRlZCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgX21vZGUgPSAobW9kZSA9PT0gfn5tb2RlKSA/IG1vZGUgOiAoKG1vZGUgPT09IHRydWUpID8gYy5aX0ZJTklTSCA6IGMuWl9OT19GTFVTSCk7XG5cbiAgLy8gQ29udmVydCBkYXRhIGlmIG5lZWRlZFxuICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgLy8gT25seSBiaW5hcnkgc3RyaW5ncyBjYW4gYmUgZGVjb21wcmVzc2VkIG9uIHByYWN0aWNlXG4gICAgc3RybS5pbnB1dCA9IHN0cmluZ3MuYmluc3RyaW5nMmJ1ZihkYXRhKTtcbiAgfSBlbHNlIGlmICh0b1N0cmluZy5jYWxsKGRhdGEpID09PSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nKSB7XG4gICAgc3RybS5pbnB1dCA9IG5ldyBVaW50OEFycmF5KGRhdGEpO1xuICB9IGVsc2Uge1xuICAgIHN0cm0uaW5wdXQgPSBkYXRhO1xuICB9XG5cbiAgc3RybS5uZXh0X2luID0gMDtcbiAgc3RybS5hdmFpbF9pbiA9IHN0cm0uaW5wdXQubGVuZ3RoO1xuXG4gIGRvIHtcbiAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHN0cm0ub3V0cHV0ID0gbmV3IHV0aWxzLkJ1ZjgoY2h1bmtTaXplKTtcbiAgICAgIHN0cm0ubmV4dF9vdXQgPSAwO1xuICAgICAgc3RybS5hdmFpbF9vdXQgPSBjaHVua1NpemU7XG4gICAgfVxuXG4gICAgc3RhdHVzID0gemxpYl9pbmZsYXRlLmluZmxhdGUoc3RybSwgYy5aX05PX0ZMVVNIKTsgICAgLyogbm8gYmFkIHJldHVybiB2YWx1ZSAqL1xuXG4gICAgaWYgKHN0YXR1cyA9PT0gYy5aX05FRURfRElDVCAmJiBkaWN0aW9uYXJ5KSB7XG4gICAgICAvLyBDb252ZXJ0IGRhdGEgaWYgbmVlZGVkXG4gICAgICBpZiAodHlwZW9mIGRpY3Rpb25hcnkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGRpY3QgPSBzdHJpbmdzLnN0cmluZzJidWYoZGljdGlvbmFyeSk7XG4gICAgICB9IGVsc2UgaWYgKHRvU3RyaW5nLmNhbGwoZGljdGlvbmFyeSkgPT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXScpIHtcbiAgICAgICAgZGljdCA9IG5ldyBVaW50OEFycmF5KGRpY3Rpb25hcnkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGljdCA9IGRpY3Rpb25hcnk7XG4gICAgICB9XG5cbiAgICAgIHN0YXR1cyA9IHpsaWJfaW5mbGF0ZS5pbmZsYXRlU2V0RGljdGlvbmFyeSh0aGlzLnN0cm0sIGRpY3QpO1xuXG4gICAgfVxuXG4gICAgaWYgKHN0YXR1cyA9PT0gYy5aX0JVRl9FUlJPUiAmJiBhbGxvd0J1ZkVycm9yID09PSB0cnVlKSB7XG4gICAgICBzdGF0dXMgPSBjLlpfT0s7XG4gICAgICBhbGxvd0J1ZkVycm9yID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHN0YXR1cyAhPT0gYy5aX1NUUkVBTV9FTkQgJiYgc3RhdHVzICE9PSBjLlpfT0spIHtcbiAgICAgIHRoaXMub25FbmQoc3RhdHVzKTtcbiAgICAgIHRoaXMuZW5kZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChzdHJtLm5leHRfb3V0KSB7XG4gICAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDAgfHwgc3RhdHVzID09PSBjLlpfU1RSRUFNX0VORCB8fCAoc3RybS5hdmFpbF9pbiA9PT0gMCAmJiAoX21vZGUgPT09IGMuWl9GSU5JU0ggfHwgX21vZGUgPT09IGMuWl9TWU5DX0ZMVVNIKSkpIHtcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnRvID09PSAnc3RyaW5nJykge1xuXG4gICAgICAgICAgbmV4dF9vdXRfdXRmOCA9IHN0cmluZ3MudXRmOGJvcmRlcihzdHJtLm91dHB1dCwgc3RybS5uZXh0X291dCk7XG5cbiAgICAgICAgICB0YWlsID0gc3RybS5uZXh0X291dCAtIG5leHRfb3V0X3V0Zjg7XG4gICAgICAgICAgdXRmOHN0ciA9IHN0cmluZ3MuYnVmMnN0cmluZyhzdHJtLm91dHB1dCwgbmV4dF9vdXRfdXRmOCk7XG5cbiAgICAgICAgICAvLyBtb3ZlIHRhaWxcbiAgICAgICAgICBzdHJtLm5leHRfb3V0ID0gdGFpbDtcbiAgICAgICAgICBzdHJtLmF2YWlsX291dCA9IGNodW5rU2l6ZSAtIHRhaWw7XG4gICAgICAgICAgaWYgKHRhaWwpIHsgdXRpbHMuYXJyYXlTZXQoc3RybS5vdXRwdXQsIHN0cm0ub3V0cHV0LCBuZXh0X291dF91dGY4LCB0YWlsLCAwKTsgfVxuXG4gICAgICAgICAgdGhpcy5vbkRhdGEodXRmOHN0cik7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLm9uRGF0YSh1dGlscy5zaHJpbmtCdWYoc3RybS5vdXRwdXQsIHN0cm0ubmV4dF9vdXQpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFdoZW4gbm8gbW9yZSBpbnB1dCBkYXRhLCB3ZSBzaG91bGQgY2hlY2sgdGhhdCBpbnRlcm5hbCBpbmZsYXRlIGJ1ZmZlcnNcbiAgICAvLyBhcmUgZmx1c2hlZC4gVGhlIG9ubHkgd2F5IHRvIGRvIGl0IHdoZW4gYXZhaWxfb3V0ID0gMCAtIHJ1biBvbmUgbW9yZVxuICAgIC8vIGluZmxhdGUgcGFzcy4gQnV0IGlmIG91dHB1dCBkYXRhIG5vdCBleGlzdHMsIGluZmxhdGUgcmV0dXJuIFpfQlVGX0VSUk9SLlxuICAgIC8vIEhlcmUgd2Ugc2V0IGZsYWcgdG8gcHJvY2VzcyB0aGlzIGVycm9yIHByb3Blcmx5LlxuICAgIC8vXG4gICAgLy8gTk9URS4gRGVmbGF0ZSBkb2VzIG5vdCByZXR1cm4gZXJyb3IgaW4gdGhpcyBjYXNlIGFuZCBkb2VzIG5vdCBuZWVkcyBzdWNoXG4gICAgLy8gbG9naWMuXG4gICAgaWYgKHN0cm0uYXZhaWxfaW4gPT09IDAgJiYgc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIGFsbG93QnVmRXJyb3IgPSB0cnVlO1xuICAgIH1cblxuICB9IHdoaWxlICgoc3RybS5hdmFpbF9pbiA+IDAgfHwgc3RybS5hdmFpbF9vdXQgPT09IDApICYmIHN0YXR1cyAhPT0gYy5aX1NUUkVBTV9FTkQpO1xuXG4gIGlmIChzdGF0dXMgPT09IGMuWl9TVFJFQU1fRU5EKSB7XG4gICAgX21vZGUgPSBjLlpfRklOSVNIO1xuICB9XG5cbiAgLy8gRmluYWxpemUgb24gdGhlIGxhc3QgY2h1bmsuXG4gIGlmIChfbW9kZSA9PT0gYy5aX0ZJTklTSCkge1xuICAgIHN0YXR1cyA9IHpsaWJfaW5mbGF0ZS5pbmZsYXRlRW5kKHRoaXMuc3RybSk7XG4gICAgdGhpcy5vbkVuZChzdGF0dXMpO1xuICAgIHRoaXMuZW5kZWQgPSB0cnVlO1xuICAgIHJldHVybiBzdGF0dXMgPT09IGMuWl9PSztcbiAgfVxuXG4gIC8vIGNhbGxiYWNrIGludGVyaW0gcmVzdWx0cyBpZiBaX1NZTkNfRkxVU0guXG4gIGlmIChfbW9kZSA9PT0gYy5aX1NZTkNfRkxVU0gpIHtcbiAgICB0aGlzLm9uRW5kKGMuWl9PSyk7XG4gICAgc3RybS5hdmFpbF9vdXQgPSAwO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cbi8qKlxuICogSW5mbGF0ZSNvbkRhdGEoY2h1bmspIC0+IFZvaWRcbiAqIC0gY2h1bmsgKFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nKTogb3V0cHV0IGRhdGEuIFR5cGUgb2YgYXJyYXkgZGVwZW5kc1xuICogICBvbiBqcyBlbmdpbmUgc3VwcG9ydC4gV2hlbiBzdHJpbmcgb3V0cHV0IHJlcXVlc3RlZCwgZWFjaCBjaHVua1xuICogICB3aWxsIGJlIHN0cmluZy5cbiAqXG4gKiBCeSBkZWZhdWx0LCBzdG9yZXMgZGF0YSBibG9ja3MgaW4gYGNodW5rc1tdYCBwcm9wZXJ0eSBhbmQgZ2x1ZVxuICogdGhvc2UgaW4gYG9uRW5kYC4gT3ZlcnJpZGUgdGhpcyBoYW5kbGVyLCBpZiB5b3UgbmVlZCBhbm90aGVyIGJlaGF2aW91ci5cbiAqKi9cbkluZmxhdGUucHJvdG90eXBlLm9uRGF0YSA9IGZ1bmN0aW9uIChjaHVuaykge1xuICB0aGlzLmNodW5rcy5wdXNoKGNodW5rKTtcbn07XG5cblxuLyoqXG4gKiBJbmZsYXRlI29uRW5kKHN0YXR1cykgLT4gVm9pZFxuICogLSBzdGF0dXMgKE51bWJlcik6IGluZmxhdGUgc3RhdHVzLiAwIChaX09LKSBvbiBzdWNjZXNzLFxuICogICBvdGhlciBpZiBub3QuXG4gKlxuICogQ2FsbGVkIGVpdGhlciBhZnRlciB5b3UgdGVsbCBpbmZsYXRlIHRoYXQgdGhlIGlucHV0IHN0cmVhbSBpc1xuICogY29tcGxldGUgKFpfRklOSVNIKSBvciBzaG91bGQgYmUgZmx1c2hlZCAoWl9TWU5DX0ZMVVNIKVxuICogb3IgaWYgYW4gZXJyb3IgaGFwcGVuZWQuIEJ5IGRlZmF1bHQgLSBqb2luIGNvbGxlY3RlZCBjaHVua3MsXG4gKiBmcmVlIG1lbW9yeSBhbmQgZmlsbCBgcmVzdWx0c2AgLyBgZXJyYCBwcm9wZXJ0aWVzLlxuICoqL1xuSW5mbGF0ZS5wcm90b3R5cGUub25FbmQgPSBmdW5jdGlvbiAoc3RhdHVzKSB7XG4gIC8vIE9uIHN1Y2Nlc3MgLSBqb2luXG4gIGlmIChzdGF0dXMgPT09IGMuWl9PSykge1xuICAgIGlmICh0aGlzLm9wdGlvbnMudG8gPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBHbHVlICYgY29udmVydCBoZXJlLCB1bnRpbCB3ZSB0ZWFjaCBwYWtvIHRvIHNlbmRcbiAgICAgIC8vIHV0ZjggYWxpZ25lZCBzdHJpbmdzIHRvIG9uRGF0YVxuICAgICAgdGhpcy5yZXN1bHQgPSB0aGlzLmNodW5rcy5qb2luKCcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZXN1bHQgPSB1dGlscy5mbGF0dGVuQ2h1bmtzKHRoaXMuY2h1bmtzKTtcbiAgICB9XG4gIH1cbiAgdGhpcy5jaHVua3MgPSBbXTtcbiAgdGhpcy5lcnIgPSBzdGF0dXM7XG4gIHRoaXMubXNnID0gdGhpcy5zdHJtLm1zZztcbn07XG5cblxuLyoqXG4gKiBpbmZsYXRlKGRhdGFbLCBvcHRpb25zXSkgLT4gVWludDhBcnJheXxBcnJheXxTdHJpbmdcbiAqIC0gZGF0YSAoVWludDhBcnJheXxBcnJheXxTdHJpbmcpOiBpbnB1dCBkYXRhIHRvIGRlY29tcHJlc3MuXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHpsaWIgaW5mbGF0ZSBvcHRpb25zLlxuICpcbiAqIERlY29tcHJlc3MgYGRhdGFgIHdpdGggaW5mbGF0ZS91bmd6aXAgYW5kIGBvcHRpb25zYC4gQXV0b2RldGVjdFxuICogZm9ybWF0IHZpYSB3cmFwcGVyIGhlYWRlciBieSBkZWZhdWx0LiBUaGF0J3Mgd2h5IHdlIGRvbid0IHByb3ZpZGVcbiAqIHNlcGFyYXRlIGB1bmd6aXBgIG1ldGhvZC5cbiAqXG4gKiBTdXBwb3J0ZWQgb3B0aW9ucyBhcmU6XG4gKlxuICogLSB3aW5kb3dCaXRzXG4gKlxuICogW2h0dHA6Ly96bGliLm5ldC9tYW51YWwuaHRtbCNBZHZhbmNlZF0oaHR0cDovL3psaWIubmV0L21hbnVhbC5odG1sI0FkdmFuY2VkKVxuICogZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKlxuICogU3VnYXIgKG9wdGlvbnMpOlxuICpcbiAqIC0gYHJhd2AgKEJvb2xlYW4pIC0gc2F5IHRoYXQgd2Ugd29yayB3aXRoIHJhdyBzdHJlYW0sIGlmIHlvdSBkb24ndCB3aXNoIHRvIHNwZWNpZnlcbiAqICAgbmVnYXRpdmUgd2luZG93Qml0cyBpbXBsaWNpdGx5LlxuICogLSBgdG9gIChTdHJpbmcpIC0gaWYgZXF1YWwgdG8gJ3N0cmluZycsIHRoZW4gcmVzdWx0IHdpbGwgYmUgY29udmVydGVkXG4gKiAgIGZyb20gdXRmOCB0byB1dGYxNiAoamF2YXNjcmlwdCkgc3RyaW5nLiBXaGVuIHN0cmluZyBvdXRwdXQgcmVxdWVzdGVkLFxuICogICBjaHVuayBsZW5ndGggY2FuIGRpZmZlciBmcm9tIGBjaHVua1NpemVgLCBkZXBlbmRpbmcgb24gY29udGVudC5cbiAqXG4gKlxuICogIyMjIyMgRXhhbXBsZTpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiB2YXIgcGFrbyA9IHJlcXVpcmUoJ3Bha28nKVxuICogICAsIGlucHV0ID0gcGFrby5kZWZsYXRlKFsxLDIsMyw0LDUsNiw3LDgsOV0pXG4gKiAgICwgb3V0cHV0O1xuICpcbiAqIHRyeSB7XG4gKiAgIG91dHB1dCA9IHBha28uaW5mbGF0ZShpbnB1dCk7XG4gKiB9IGNhdGNoIChlcnIpXG4gKiAgIGNvbnNvbGUubG9nKGVycik7XG4gKiB9XG4gKiBgYGBcbiAqKi9cbmZ1bmN0aW9uIGluZmxhdGUoaW5wdXQsIG9wdGlvbnMpIHtcbiAgdmFyIGluZmxhdG9yID0gbmV3IEluZmxhdGUob3B0aW9ucyk7XG5cbiAgaW5mbGF0b3IucHVzaChpbnB1dCwgdHJ1ZSk7XG5cbiAgLy8gVGhhdCB3aWxsIG5ldmVyIGhhcHBlbnMsIGlmIHlvdSBkb24ndCBjaGVhdCB3aXRoIG9wdGlvbnMgOilcbiAgaWYgKGluZmxhdG9yLmVycikgeyB0aHJvdyBpbmZsYXRvci5tc2cgfHwgbXNnW2luZmxhdG9yLmVycl07IH1cblxuICByZXR1cm4gaW5mbGF0b3IucmVzdWx0O1xufVxuXG5cbi8qKlxuICogaW5mbGF0ZVJhdyhkYXRhWywgb3B0aW9uc10pIC0+IFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nXG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nKTogaW5wdXQgZGF0YSB0byBkZWNvbXByZXNzLlxuICogLSBvcHRpb25zIChPYmplY3QpOiB6bGliIGluZmxhdGUgb3B0aW9ucy5cbiAqXG4gKiBUaGUgc2FtZSBhcyBbW2luZmxhdGVdXSwgYnV0IGNyZWF0ZXMgcmF3IGRhdGEsIHdpdGhvdXQgd3JhcHBlclxuICogKGhlYWRlciBhbmQgYWRsZXIzMiBjcmMpLlxuICoqL1xuZnVuY3Rpb24gaW5mbGF0ZVJhdyhpbnB1dCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgb3B0aW9ucy5yYXcgPSB0cnVlO1xuICByZXR1cm4gaW5mbGF0ZShpbnB1dCwgb3B0aW9ucyk7XG59XG5cblxuLyoqXG4gKiB1bmd6aXAoZGF0YVssIG9wdGlvbnNdKSAtPiBVaW50OEFycmF5fEFycmF5fFN0cmluZ1xuICogLSBkYXRhIChVaW50OEFycmF5fEFycmF5fFN0cmluZyk6IGlucHV0IGRhdGEgdG8gZGVjb21wcmVzcy5cbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBpbmZsYXRlIG9wdGlvbnMuXG4gKlxuICogSnVzdCBzaG9ydGN1dCB0byBbW2luZmxhdGVdXSwgYmVjYXVzZSBpdCBhdXRvZGV0ZWN0cyBmb3JtYXRcbiAqIGJ5IGhlYWRlci5jb250ZW50LiBEb25lIGZvciBjb252ZW5pZW5jZS5cbiAqKi9cblxuXG5leHBvcnRzLkluZmxhdGUgPSBJbmZsYXRlO1xuZXhwb3J0cy5pbmZsYXRlID0gaW5mbGF0ZTtcbmV4cG9ydHMuaW5mbGF0ZVJhdyA9IGluZmxhdGVSYXc7XG5leHBvcnRzLnVuZ3ppcCAgPSBpbmZsYXRlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBUWVBFRF9PSyA9ICAodHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnKSAmJlxuICAgICAgICAgICAgICAgICh0eXBlb2YgVWludDE2QXJyYXkgIT09ICd1bmRlZmluZWQnKSAmJlxuICAgICAgICAgICAgICAgICh0eXBlb2YgSW50MzJBcnJheSAhPT0gJ3VuZGVmaW5lZCcpO1xuXG5mdW5jdGlvbiBfaGFzKG9iaiwga2V5KSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpO1xufVxuXG5leHBvcnRzLmFzc2lnbiA9IGZ1bmN0aW9uIChvYmogLypmcm9tMSwgZnJvbTIsIGZyb20zLCAuLi4qLykge1xuICB2YXIgc291cmNlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gIHdoaWxlIChzb3VyY2VzLmxlbmd0aCkge1xuICAgIHZhciBzb3VyY2UgPSBzb3VyY2VzLnNoaWZ0KCk7XG4gICAgaWYgKCFzb3VyY2UpIHsgY29udGludWU7IH1cblxuICAgIGlmICh0eXBlb2Ygc291cmNlICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzb3VyY2UgKyAnbXVzdCBiZSBub24tb2JqZWN0Jyk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgcCBpbiBzb3VyY2UpIHtcbiAgICAgIGlmIChfaGFzKHNvdXJjZSwgcCkpIHtcbiAgICAgICAgb2JqW3BdID0gc291cmNlW3BdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmo7XG59O1xuXG5cbi8vIHJlZHVjZSBidWZmZXIgc2l6ZSwgYXZvaWRpbmcgbWVtIGNvcHlcbmV4cG9ydHMuc2hyaW5rQnVmID0gZnVuY3Rpb24gKGJ1Ziwgc2l6ZSkge1xuICBpZiAoYnVmLmxlbmd0aCA9PT0gc2l6ZSkgeyByZXR1cm4gYnVmOyB9XG4gIGlmIChidWYuc3ViYXJyYXkpIHsgcmV0dXJuIGJ1Zi5zdWJhcnJheSgwLCBzaXplKTsgfVxuICBidWYubGVuZ3RoID0gc2l6ZTtcbiAgcmV0dXJuIGJ1Zjtcbn07XG5cblxudmFyIGZuVHlwZWQgPSB7XG4gIGFycmF5U2V0OiBmdW5jdGlvbiAoZGVzdCwgc3JjLCBzcmNfb2ZmcywgbGVuLCBkZXN0X29mZnMpIHtcbiAgICBpZiAoc3JjLnN1YmFycmF5ICYmIGRlc3Quc3ViYXJyYXkpIHtcbiAgICAgIGRlc3Quc2V0KHNyYy5zdWJhcnJheShzcmNfb2Zmcywgc3JjX29mZnMgKyBsZW4pLCBkZXN0X29mZnMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBGYWxsYmFjayB0byBvcmRpbmFyeSBhcnJheVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGRlc3RbZGVzdF9vZmZzICsgaV0gPSBzcmNbc3JjX29mZnMgKyBpXTtcbiAgICB9XG4gIH0sXG4gIC8vIEpvaW4gYXJyYXkgb2YgY2h1bmtzIHRvIHNpbmdsZSBhcnJheS5cbiAgZmxhdHRlbkNodW5rczogZnVuY3Rpb24gKGNodW5rcykge1xuICAgIHZhciBpLCBsLCBsZW4sIHBvcywgY2h1bmssIHJlc3VsdDtcblxuICAgIC8vIGNhbGN1bGF0ZSBkYXRhIGxlbmd0aFxuICAgIGxlbiA9IDA7XG4gICAgZm9yIChpID0gMCwgbCA9IGNodW5rcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGxlbiArPSBjaHVua3NbaV0ubGVuZ3RoO1xuICAgIH1cblxuICAgIC8vIGpvaW4gY2h1bmtzXG4gICAgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkobGVuKTtcbiAgICBwb3MgPSAwO1xuICAgIGZvciAoaSA9IDAsIGwgPSBjaHVua3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBjaHVuayA9IGNodW5rc1tpXTtcbiAgICAgIHJlc3VsdC5zZXQoY2h1bmssIHBvcyk7XG4gICAgICBwb3MgKz0gY2h1bmsubGVuZ3RoO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn07XG5cbnZhciBmblVudHlwZWQgPSB7XG4gIGFycmF5U2V0OiBmdW5jdGlvbiAoZGVzdCwgc3JjLCBzcmNfb2ZmcywgbGVuLCBkZXN0X29mZnMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBkZXN0W2Rlc3Rfb2ZmcyArIGldID0gc3JjW3NyY19vZmZzICsgaV07XG4gICAgfVxuICB9LFxuICAvLyBKb2luIGFycmF5IG9mIGNodW5rcyB0byBzaW5nbGUgYXJyYXkuXG4gIGZsYXR0ZW5DaHVua3M6IGZ1bmN0aW9uIChjaHVua3MpIHtcbiAgICByZXR1cm4gW10uY29uY2F0LmFwcGx5KFtdLCBjaHVua3MpO1xuICB9XG59O1xuXG5cbi8vIEVuYWJsZS9EaXNhYmxlIHR5cGVkIGFycmF5cyB1c2UsIGZvciB0ZXN0aW5nXG4vL1xuZXhwb3J0cy5zZXRUeXBlZCA9IGZ1bmN0aW9uIChvbikge1xuICBpZiAob24pIHtcbiAgICBleHBvcnRzLkJ1ZjggID0gVWludDhBcnJheTtcbiAgICBleHBvcnRzLkJ1ZjE2ID0gVWludDE2QXJyYXk7XG4gICAgZXhwb3J0cy5CdWYzMiA9IEludDMyQXJyYXk7XG4gICAgZXhwb3J0cy5hc3NpZ24oZXhwb3J0cywgZm5UeXBlZCk7XG4gIH0gZWxzZSB7XG4gICAgZXhwb3J0cy5CdWY4ICA9IEFycmF5O1xuICAgIGV4cG9ydHMuQnVmMTYgPSBBcnJheTtcbiAgICBleHBvcnRzLkJ1ZjMyID0gQXJyYXk7XG4gICAgZXhwb3J0cy5hc3NpZ24oZXhwb3J0cywgZm5VbnR5cGVkKTtcbiAgfVxufTtcblxuZXhwb3J0cy5zZXRUeXBlZChUWVBFRF9PSyk7XG4iLCIvLyBTdHJpbmcgZW5jb2RlL2RlY29kZSBoZWxwZXJzXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi9jb21tb24nKTtcblxuXG4vLyBRdWljayBjaGVjayBpZiB3ZSBjYW4gdXNlIGZhc3QgYXJyYXkgdG8gYmluIHN0cmluZyBjb252ZXJzaW9uXG4vL1xuLy8gLSBhcHBseShBcnJheSkgY2FuIGZhaWwgb24gQW5kcm9pZCAyLjJcbi8vIC0gYXBwbHkoVWludDhBcnJheSkgY2FuIGZhaWwgb24gaU9TIDUuMSBTYWZhcmlcbi8vXG52YXIgU1RSX0FQUExZX09LID0gdHJ1ZTtcbnZhciBTVFJfQVBQTFlfVUlBX09LID0gdHJ1ZTtcblxudHJ5IHsgU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBbIDAgXSk7IH0gY2F0Y2ggKF9fKSB7IFNUUl9BUFBMWV9PSyA9IGZhbHNlOyB9XG50cnkgeyBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIG5ldyBVaW50OEFycmF5KDEpKTsgfSBjYXRjaCAoX18pIHsgU1RSX0FQUExZX1VJQV9PSyA9IGZhbHNlOyB9XG5cblxuLy8gVGFibGUgd2l0aCB1dGY4IGxlbmd0aHMgKGNhbGN1bGF0ZWQgYnkgZmlyc3QgYnl0ZSBvZiBzZXF1ZW5jZSlcbi8vIE5vdGUsIHRoYXQgNSAmIDYtYnl0ZSB2YWx1ZXMgYW5kIHNvbWUgNC1ieXRlIHZhbHVlcyBjYW4gbm90IGJlIHJlcHJlc2VudGVkIGluIEpTLFxuLy8gYmVjYXVzZSBtYXggcG9zc2libGUgY29kZXBvaW50IGlzIDB4MTBmZmZmXG52YXIgX3V0ZjhsZW4gPSBuZXcgdXRpbHMuQnVmOCgyNTYpO1xuZm9yICh2YXIgcSA9IDA7IHEgPCAyNTY7IHErKykge1xuICBfdXRmOGxlbltxXSA9IChxID49IDI1MiA/IDYgOiBxID49IDI0OCA/IDUgOiBxID49IDI0MCA/IDQgOiBxID49IDIyNCA/IDMgOiBxID49IDE5MiA/IDIgOiAxKTtcbn1cbl91dGY4bGVuWzI1NF0gPSBfdXRmOGxlblsyNTRdID0gMTsgLy8gSW52YWxpZCBzZXF1ZW5jZSBzdGFydFxuXG5cbi8vIGNvbnZlcnQgc3RyaW5nIHRvIGFycmF5ICh0eXBlZCwgd2hlbiBwb3NzaWJsZSlcbmV4cG9ydHMuc3RyaW5nMmJ1ZiA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgdmFyIGJ1ZiwgYywgYzIsIG1fcG9zLCBpLCBzdHJfbGVuID0gc3RyLmxlbmd0aCwgYnVmX2xlbiA9IDA7XG5cbiAgLy8gY291bnQgYmluYXJ5IHNpemVcbiAgZm9yIChtX3BvcyA9IDA7IG1fcG9zIDwgc3RyX2xlbjsgbV9wb3MrKykge1xuICAgIGMgPSBzdHIuY2hhckNvZGVBdChtX3Bvcyk7XG4gICAgaWYgKChjICYgMHhmYzAwKSA9PT0gMHhkODAwICYmIChtX3BvcyArIDEgPCBzdHJfbGVuKSkge1xuICAgICAgYzIgPSBzdHIuY2hhckNvZGVBdChtX3BvcyArIDEpO1xuICAgICAgaWYgKChjMiAmIDB4ZmMwMCkgPT09IDB4ZGMwMCkge1xuICAgICAgICBjID0gMHgxMDAwMCArICgoYyAtIDB4ZDgwMCkgPDwgMTApICsgKGMyIC0gMHhkYzAwKTtcbiAgICAgICAgbV9wb3MrKztcbiAgICAgIH1cbiAgICB9XG4gICAgYnVmX2xlbiArPSBjIDwgMHg4MCA/IDEgOiBjIDwgMHg4MDAgPyAyIDogYyA8IDB4MTAwMDAgPyAzIDogNDtcbiAgfVxuXG4gIC8vIGFsbG9jYXRlIGJ1ZmZlclxuICBidWYgPSBuZXcgdXRpbHMuQnVmOChidWZfbGVuKTtcblxuICAvLyBjb252ZXJ0XG4gIGZvciAoaSA9IDAsIG1fcG9zID0gMDsgaSA8IGJ1Zl9sZW47IG1fcG9zKyspIHtcbiAgICBjID0gc3RyLmNoYXJDb2RlQXQobV9wb3MpO1xuICAgIGlmICgoYyAmIDB4ZmMwMCkgPT09IDB4ZDgwMCAmJiAobV9wb3MgKyAxIDwgc3RyX2xlbikpIHtcbiAgICAgIGMyID0gc3RyLmNoYXJDb2RlQXQobV9wb3MgKyAxKTtcbiAgICAgIGlmICgoYzIgJiAweGZjMDApID09PSAweGRjMDApIHtcbiAgICAgICAgYyA9IDB4MTAwMDAgKyAoKGMgLSAweGQ4MDApIDw8IDEwKSArIChjMiAtIDB4ZGMwMCk7XG4gICAgICAgIG1fcG9zKys7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjIDwgMHg4MCkge1xuICAgICAgLyogb25lIGJ5dGUgKi9cbiAgICAgIGJ1ZltpKytdID0gYztcbiAgICB9IGVsc2UgaWYgKGMgPCAweDgwMCkge1xuICAgICAgLyogdHdvIGJ5dGVzICovXG4gICAgICBidWZbaSsrXSA9IDB4QzAgfCAoYyA+Pj4gNik7XG4gICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyAmIDB4M2YpO1xuICAgIH0gZWxzZSBpZiAoYyA8IDB4MTAwMDApIHtcbiAgICAgIC8qIHRocmVlIGJ5dGVzICovXG4gICAgICBidWZbaSsrXSA9IDB4RTAgfCAoYyA+Pj4gMTIpO1xuICAgICAgYnVmW2krK10gPSAweDgwIHwgKGMgPj4+IDYgJiAweDNmKTtcbiAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjICYgMHgzZik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qIGZvdXIgYnl0ZXMgKi9cbiAgICAgIGJ1ZltpKytdID0gMHhmMCB8IChjID4+PiAxOCk7XG4gICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyA+Pj4gMTIgJiAweDNmKTtcbiAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjID4+PiA2ICYgMHgzZik7XG4gICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyAmIDB4M2YpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBidWY7XG59O1xuXG4vLyBIZWxwZXIgKHVzZWQgaW4gMiBwbGFjZXMpXG5mdW5jdGlvbiBidWYyYmluc3RyaW5nKGJ1ZiwgbGVuKSB7XG4gIC8vIHVzZSBmYWxsYmFjayBmb3IgYmlnIGFycmF5cyB0byBhdm9pZCBzdGFjayBvdmVyZmxvd1xuICBpZiAobGVuIDwgNjU1MzcpIHtcbiAgICBpZiAoKGJ1Zi5zdWJhcnJheSAmJiBTVFJfQVBQTFlfVUlBX09LKSB8fCAoIWJ1Zi5zdWJhcnJheSAmJiBTVFJfQVBQTFlfT0spKSB7XG4gICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCB1dGlscy5zaHJpbmtCdWYoYnVmLCBsZW4pKTtcbiAgICB9XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gJyc7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cblxuLy8gQ29udmVydCBieXRlIGFycmF5IHRvIGJpbmFyeSBzdHJpbmdcbmV4cG9ydHMuYnVmMmJpbnN0cmluZyA9IGZ1bmN0aW9uIChidWYpIHtcbiAgcmV0dXJuIGJ1ZjJiaW5zdHJpbmcoYnVmLCBidWYubGVuZ3RoKTtcbn07XG5cblxuLy8gQ29udmVydCBiaW5hcnkgc3RyaW5nICh0eXBlZCwgd2hlbiBwb3NzaWJsZSlcbmV4cG9ydHMuYmluc3RyaW5nMmJ1ZiA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgdmFyIGJ1ZiA9IG5ldyB1dGlscy5CdWY4KHN0ci5sZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMCwgbGVuID0gYnVmLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgYnVmW2ldID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gIH1cbiAgcmV0dXJuIGJ1Zjtcbn07XG5cblxuLy8gY29udmVydCBhcnJheSB0byBzdHJpbmdcbmV4cG9ydHMuYnVmMnN0cmluZyA9IGZ1bmN0aW9uIChidWYsIG1heCkge1xuICB2YXIgaSwgb3V0LCBjLCBjX2xlbjtcbiAgdmFyIGxlbiA9IG1heCB8fCBidWYubGVuZ3RoO1xuXG4gIC8vIFJlc2VydmUgbWF4IHBvc3NpYmxlIGxlbmd0aCAoMiB3b3JkcyBwZXIgY2hhcilcbiAgLy8gTkI6IGJ5IHVua25vd24gcmVhc29ucywgQXJyYXkgaXMgc2lnbmlmaWNhbnRseSBmYXN0ZXIgZm9yXG4gIC8vICAgICBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5IHRoYW4gVWludDE2QXJyYXkuXG4gIHZhciB1dGYxNmJ1ZiA9IG5ldyBBcnJheShsZW4gKiAyKTtcblxuICBmb3IgKG91dCA9IDAsIGkgPSAwOyBpIDwgbGVuOykge1xuICAgIGMgPSBidWZbaSsrXTtcbiAgICAvLyBxdWljayBwcm9jZXNzIGFzY2lpXG4gICAgaWYgKGMgPCAweDgwKSB7IHV0ZjE2YnVmW291dCsrXSA9IGM7IGNvbnRpbnVlOyB9XG5cbiAgICBjX2xlbiA9IF91dGY4bGVuW2NdO1xuICAgIC8vIHNraXAgNSAmIDYgYnl0ZSBjb2Rlc1xuICAgIGlmIChjX2xlbiA+IDQpIHsgdXRmMTZidWZbb3V0KytdID0gMHhmZmZkOyBpICs9IGNfbGVuIC0gMTsgY29udGludWU7IH1cblxuICAgIC8vIGFwcGx5IG1hc2sgb24gZmlyc3QgYnl0ZVxuICAgIGMgJj0gY19sZW4gPT09IDIgPyAweDFmIDogY19sZW4gPT09IDMgPyAweDBmIDogMHgwNztcbiAgICAvLyBqb2luIHRoZSByZXN0XG4gICAgd2hpbGUgKGNfbGVuID4gMSAmJiBpIDwgbGVuKSB7XG4gICAgICBjID0gKGMgPDwgNikgfCAoYnVmW2krK10gJiAweDNmKTtcbiAgICAgIGNfbGVuLS07XG4gICAgfVxuXG4gICAgLy8gdGVybWluYXRlZCBieSBlbmQgb2Ygc3RyaW5nP1xuICAgIGlmIChjX2xlbiA+IDEpIHsgdXRmMTZidWZbb3V0KytdID0gMHhmZmZkOyBjb250aW51ZTsgfVxuXG4gICAgaWYgKGMgPCAweDEwMDAwKSB7XG4gICAgICB1dGYxNmJ1ZltvdXQrK10gPSBjO1xuICAgIH0gZWxzZSB7XG4gICAgICBjIC09IDB4MTAwMDA7XG4gICAgICB1dGYxNmJ1ZltvdXQrK10gPSAweGQ4MDAgfCAoKGMgPj4gMTApICYgMHgzZmYpO1xuICAgICAgdXRmMTZidWZbb3V0KytdID0gMHhkYzAwIHwgKGMgJiAweDNmZik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ1ZjJiaW5zdHJpbmcodXRmMTZidWYsIG91dCk7XG59O1xuXG5cbi8vIENhbGN1bGF0ZSBtYXggcG9zc2libGUgcG9zaXRpb24gaW4gdXRmOCBidWZmZXIsXG4vLyB0aGF0IHdpbGwgbm90IGJyZWFrIHNlcXVlbmNlLiBJZiB0aGF0J3Mgbm90IHBvc3NpYmxlXG4vLyAtICh2ZXJ5IHNtYWxsIGxpbWl0cykgcmV0dXJuIG1heCBzaXplIGFzIGlzLlxuLy9cbi8vIGJ1ZltdIC0gdXRmOCBieXRlcyBhcnJheVxuLy8gbWF4ICAgLSBsZW5ndGggbGltaXQgKG1hbmRhdG9yeSk7XG5leHBvcnRzLnV0Zjhib3JkZXIgPSBmdW5jdGlvbiAoYnVmLCBtYXgpIHtcbiAgdmFyIHBvcztcblxuICBtYXggPSBtYXggfHwgYnVmLmxlbmd0aDtcbiAgaWYgKG1heCA+IGJ1Zi5sZW5ndGgpIHsgbWF4ID0gYnVmLmxlbmd0aDsgfVxuXG4gIC8vIGdvIGJhY2sgZnJvbSBsYXN0IHBvc2l0aW9uLCB1bnRpbCBzdGFydCBvZiBzZXF1ZW5jZSBmb3VuZFxuICBwb3MgPSBtYXggLSAxO1xuICB3aGlsZSAocG9zID49IDAgJiYgKGJ1Zltwb3NdICYgMHhDMCkgPT09IDB4ODApIHsgcG9zLS07IH1cblxuICAvLyBWZXJ5IHNtYWxsIGFuZCBicm9rZW4gc2VxdWVuY2UsXG4gIC8vIHJldHVybiBtYXgsIGJlY2F1c2Ugd2Ugc2hvdWxkIHJldHVybiBzb21ldGhpbmcgYW55d2F5LlxuICBpZiAocG9zIDwgMCkgeyByZXR1cm4gbWF4OyB9XG5cbiAgLy8gSWYgd2UgY2FtZSB0byBzdGFydCBvZiBidWZmZXIgLSB0aGF0IG1lYW5zIGJ1ZmZlciBpcyB0b28gc21hbGwsXG4gIC8vIHJldHVybiBtYXggdG9vLlxuICBpZiAocG9zID09PSAwKSB7IHJldHVybiBtYXg7IH1cblxuICByZXR1cm4gKHBvcyArIF91dGY4bGVuW2J1Zltwb3NdXSA+IG1heCkgPyBwb3MgOiBtYXg7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBOb3RlOiBhZGxlcjMyIHRha2VzIDEyJSBmb3IgbGV2ZWwgMCBhbmQgMiUgZm9yIGxldmVsIDYuXG4vLyBJdCBpc24ndCB3b3J0aCBpdCB0byBtYWtlIGFkZGl0aW9uYWwgb3B0aW1pemF0aW9ucyBhcyBpbiBvcmlnaW5hbC5cbi8vIFNtYWxsIHNpemUgaXMgcHJlZmVyYWJsZS5cblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG5mdW5jdGlvbiBhZGxlcjMyKGFkbGVyLCBidWYsIGxlbiwgcG9zKSB7XG4gIHZhciBzMSA9IChhZGxlciAmIDB4ZmZmZikgfDAsXG4gICAgICBzMiA9ICgoYWRsZXIgPj4+IDE2KSAmIDB4ZmZmZikgfDAsXG4gICAgICBuID0gMDtcblxuICB3aGlsZSAobGVuICE9PSAwKSB7XG4gICAgLy8gU2V0IGxpbWl0IH4gdHdpY2UgbGVzcyB0aGFuIDU1NTIsIHRvIGtlZXBcbiAgICAvLyBzMiBpbiAzMS1iaXRzLCBiZWNhdXNlIHdlIGZvcmNlIHNpZ25lZCBpbnRzLlxuICAgIC8vIGluIG90aGVyIGNhc2UgJT0gd2lsbCBmYWlsLlxuICAgIG4gPSBsZW4gPiAyMDAwID8gMjAwMCA6IGxlbjtcbiAgICBsZW4gLT0gbjtcblxuICAgIGRvIHtcbiAgICAgIHMxID0gKHMxICsgYnVmW3BvcysrXSkgfDA7XG4gICAgICBzMiA9IChzMiArIHMxKSB8MDtcbiAgICB9IHdoaWxlICgtLW4pO1xuXG4gICAgczEgJT0gNjU1MjE7XG4gICAgczIgJT0gNjU1MjE7XG4gIH1cblxuICByZXR1cm4gKHMxIHwgKHMyIDw8IDE2KSkgfDA7XG59XG5cblxubW9kdWxlLmV4cG9ydHMgPSBhZGxlcjMyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXG4gIC8qIEFsbG93ZWQgZmx1c2ggdmFsdWVzOyBzZWUgZGVmbGF0ZSgpIGFuZCBpbmZsYXRlKCkgYmVsb3cgZm9yIGRldGFpbHMgKi9cbiAgWl9OT19GTFVTSDogICAgICAgICAwLFxuICBaX1BBUlRJQUxfRkxVU0g6ICAgIDEsXG4gIFpfU1lOQ19GTFVTSDogICAgICAgMixcbiAgWl9GVUxMX0ZMVVNIOiAgICAgICAzLFxuICBaX0ZJTklTSDogICAgICAgICAgIDQsXG4gIFpfQkxPQ0s6ICAgICAgICAgICAgNSxcbiAgWl9UUkVFUzogICAgICAgICAgICA2LFxuXG4gIC8qIFJldHVybiBjb2RlcyBmb3IgdGhlIGNvbXByZXNzaW9uL2RlY29tcHJlc3Npb24gZnVuY3Rpb25zLiBOZWdhdGl2ZSB2YWx1ZXNcbiAgKiBhcmUgZXJyb3JzLCBwb3NpdGl2ZSB2YWx1ZXMgYXJlIHVzZWQgZm9yIHNwZWNpYWwgYnV0IG5vcm1hbCBldmVudHMuXG4gICovXG4gIFpfT0s6ICAgICAgICAgICAgICAgMCxcbiAgWl9TVFJFQU1fRU5EOiAgICAgICAxLFxuICBaX05FRURfRElDVDogICAgICAgIDIsXG4gIFpfRVJSTk86ICAgICAgICAgICAtMSxcbiAgWl9TVFJFQU1fRVJST1I6ICAgIC0yLFxuICBaX0RBVEFfRVJST1I6ICAgICAgLTMsXG4gIC8vWl9NRU1fRVJST1I6ICAgICAtNCxcbiAgWl9CVUZfRVJST1I6ICAgICAgIC01LFxuICAvL1pfVkVSU0lPTl9FUlJPUjogLTYsXG5cbiAgLyogY29tcHJlc3Npb24gbGV2ZWxzICovXG4gIFpfTk9fQ09NUFJFU1NJT046ICAgICAgICAgMCxcbiAgWl9CRVNUX1NQRUVEOiAgICAgICAgICAgICAxLFxuICBaX0JFU1RfQ09NUFJFU1NJT046ICAgICAgIDksXG4gIFpfREVGQVVMVF9DT01QUkVTU0lPTjogICAtMSxcblxuXG4gIFpfRklMVEVSRUQ6ICAgICAgICAgICAgICAgMSxcbiAgWl9IVUZGTUFOX09OTFk6ICAgICAgICAgICAyLFxuICBaX1JMRTogICAgICAgICAgICAgICAgICAgIDMsXG4gIFpfRklYRUQ6ICAgICAgICAgICAgICAgICAgNCxcbiAgWl9ERUZBVUxUX1NUUkFURUdZOiAgICAgICAwLFxuXG4gIC8qIFBvc3NpYmxlIHZhbHVlcyBvZiB0aGUgZGF0YV90eXBlIGZpZWxkICh0aG91Z2ggc2VlIGluZmxhdGUoKSkgKi9cbiAgWl9CSU5BUlk6ICAgICAgICAgICAgICAgICAwLFxuICBaX1RFWFQ6ICAgICAgICAgICAgICAgICAgIDEsXG4gIC8vWl9BU0NJSTogICAgICAgICAgICAgICAgMSwgLy8gPSBaX1RFWFQgKGRlcHJlY2F0ZWQpXG4gIFpfVU5LTk9XTjogICAgICAgICAgICAgICAgMixcblxuICAvKiBUaGUgZGVmbGF0ZSBjb21wcmVzc2lvbiBtZXRob2QgKi9cbiAgWl9ERUZMQVRFRDogICAgICAgICAgICAgICA4XG4gIC8vWl9OVUxMOiAgICAgICAgICAgICAgICAgbnVsbCAvLyBVc2UgLTEgb3IgbnVsbCBpbmxpbmUsIGRlcGVuZGluZyBvbiB2YXIgdHlwZVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gTm90ZTogd2UgY2FuJ3QgZ2V0IHNpZ25pZmljYW50IHNwZWVkIGJvb3N0IGhlcmUuXG4vLyBTbyB3cml0ZSBjb2RlIHRvIG1pbmltaXplIHNpemUgLSBubyBwcmVnZW5lcmF0ZWQgdGFibGVzXG4vLyBhbmQgYXJyYXkgdG9vbHMgZGVwZW5kZW5jaWVzLlxuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbi8vIFVzZSBvcmRpbmFyeSBhcnJheSwgc2luY2UgdW50eXBlZCBtYWtlcyBubyBib29zdCBoZXJlXG5mdW5jdGlvbiBtYWtlVGFibGUoKSB7XG4gIHZhciBjLCB0YWJsZSA9IFtdO1xuXG4gIGZvciAodmFyIG4gPSAwOyBuIDwgMjU2OyBuKyspIHtcbiAgICBjID0gbjtcbiAgICBmb3IgKHZhciBrID0gMDsgayA8IDg7IGsrKykge1xuICAgICAgYyA9ICgoYyAmIDEpID8gKDB4RURCODgzMjAgXiAoYyA+Pj4gMSkpIDogKGMgPj4+IDEpKTtcbiAgICB9XG4gICAgdGFibGVbbl0gPSBjO1xuICB9XG5cbiAgcmV0dXJuIHRhYmxlO1xufVxuXG4vLyBDcmVhdGUgdGFibGUgb24gbG9hZC4gSnVzdCAyNTUgc2lnbmVkIGxvbmdzLiBOb3QgYSBwcm9ibGVtLlxudmFyIGNyY1RhYmxlID0gbWFrZVRhYmxlKCk7XG5cblxuZnVuY3Rpb24gY3JjMzIoY3JjLCBidWYsIGxlbiwgcG9zKSB7XG4gIHZhciB0ID0gY3JjVGFibGUsXG4gICAgICBlbmQgPSBwb3MgKyBsZW47XG5cbiAgY3JjIF49IC0xO1xuXG4gIGZvciAodmFyIGkgPSBwb3M7IGkgPCBlbmQ7IGkrKykge1xuICAgIGNyYyA9IChjcmMgPj4+IDgpIF4gdFsoY3JjIF4gYnVmW2ldKSAmIDB4RkZdO1xuICB9XG5cbiAgcmV0dXJuIChjcmMgXiAoLTEpKTsgLy8gPj4+IDA7XG59XG5cblxubW9kdWxlLmV4cG9ydHMgPSBjcmMzMjtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG52YXIgdXRpbHMgICA9IHJlcXVpcmUoJy4uL3V0aWxzL2NvbW1vbicpO1xudmFyIHRyZWVzICAgPSByZXF1aXJlKCcuL3RyZWVzJyk7XG52YXIgYWRsZXIzMiA9IHJlcXVpcmUoJy4vYWRsZXIzMicpO1xudmFyIGNyYzMyICAgPSByZXF1aXJlKCcuL2NyYzMyJyk7XG52YXIgbXNnICAgICA9IHJlcXVpcmUoJy4vbWVzc2FnZXMnKTtcblxuLyogUHVibGljIGNvbnN0YW50cyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxuLyogQWxsb3dlZCBmbHVzaCB2YWx1ZXM7IHNlZSBkZWZsYXRlKCkgYW5kIGluZmxhdGUoKSBiZWxvdyBmb3IgZGV0YWlscyAqL1xudmFyIFpfTk9fRkxVU0ggICAgICA9IDA7XG52YXIgWl9QQVJUSUFMX0ZMVVNIID0gMTtcbi8vdmFyIFpfU1lOQ19GTFVTSCAgICA9IDI7XG52YXIgWl9GVUxMX0ZMVVNIICAgID0gMztcbnZhciBaX0ZJTklTSCAgICAgICAgPSA0O1xudmFyIFpfQkxPQ0sgICAgICAgICA9IDU7XG4vL3ZhciBaX1RSRUVTICAgICAgICAgPSA2O1xuXG5cbi8qIFJldHVybiBjb2RlcyBmb3IgdGhlIGNvbXByZXNzaW9uL2RlY29tcHJlc3Npb24gZnVuY3Rpb25zLiBOZWdhdGl2ZSB2YWx1ZXNcbiAqIGFyZSBlcnJvcnMsIHBvc2l0aXZlIHZhbHVlcyBhcmUgdXNlZCBmb3Igc3BlY2lhbCBidXQgbm9ybWFsIGV2ZW50cy5cbiAqL1xudmFyIFpfT0sgICAgICAgICAgICA9IDA7XG52YXIgWl9TVFJFQU1fRU5EICAgID0gMTtcbi8vdmFyIFpfTkVFRF9ESUNUICAgICA9IDI7XG4vL3ZhciBaX0VSUk5PICAgICAgICAgPSAtMTtcbnZhciBaX1NUUkVBTV9FUlJPUiAgPSAtMjtcbnZhciBaX0RBVEFfRVJST1IgICAgPSAtMztcbi8vdmFyIFpfTUVNX0VSUk9SICAgICA9IC00O1xudmFyIFpfQlVGX0VSUk9SICAgICA9IC01O1xuLy92YXIgWl9WRVJTSU9OX0VSUk9SID0gLTY7XG5cblxuLyogY29tcHJlc3Npb24gbGV2ZWxzICovXG4vL3ZhciBaX05PX0NPTVBSRVNTSU9OICAgICAgPSAwO1xuLy92YXIgWl9CRVNUX1NQRUVEICAgICAgICAgID0gMTtcbi8vdmFyIFpfQkVTVF9DT01QUkVTU0lPTiAgICA9IDk7XG52YXIgWl9ERUZBVUxUX0NPTVBSRVNTSU9OID0gLTE7XG5cblxudmFyIFpfRklMVEVSRUQgICAgICAgICAgICA9IDE7XG52YXIgWl9IVUZGTUFOX09OTFkgICAgICAgID0gMjtcbnZhciBaX1JMRSAgICAgICAgICAgICAgICAgPSAzO1xudmFyIFpfRklYRUQgICAgICAgICAgICAgICA9IDQ7XG52YXIgWl9ERUZBVUxUX1NUUkFURUdZICAgID0gMDtcblxuLyogUG9zc2libGUgdmFsdWVzIG9mIHRoZSBkYXRhX3R5cGUgZmllbGQgKHRob3VnaCBzZWUgaW5mbGF0ZSgpKSAqL1xuLy92YXIgWl9CSU5BUlkgICAgICAgICAgICAgID0gMDtcbi8vdmFyIFpfVEVYVCAgICAgICAgICAgICAgICA9IDE7XG4vL3ZhciBaX0FTQ0lJICAgICAgICAgICAgICAgPSAxOyAvLyA9IFpfVEVYVFxudmFyIFpfVU5LTk9XTiAgICAgICAgICAgICA9IDI7XG5cblxuLyogVGhlIGRlZmxhdGUgY29tcHJlc3Npb24gbWV0aG9kICovXG52YXIgWl9ERUZMQVRFRCAgPSA4O1xuXG4vKj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cbnZhciBNQVhfTUVNX0xFVkVMID0gOTtcbi8qIE1heGltdW0gdmFsdWUgZm9yIG1lbUxldmVsIGluIGRlZmxhdGVJbml0MiAqL1xudmFyIE1BWF9XQklUUyA9IDE1O1xuLyogMzJLIExaNzcgd2luZG93ICovXG52YXIgREVGX01FTV9MRVZFTCA9IDg7XG5cblxudmFyIExFTkdUSF9DT0RFUyAgPSAyOTtcbi8qIG51bWJlciBvZiBsZW5ndGggY29kZXMsIG5vdCBjb3VudGluZyB0aGUgc3BlY2lhbCBFTkRfQkxPQ0sgY29kZSAqL1xudmFyIExJVEVSQUxTICAgICAgPSAyNTY7XG4vKiBudW1iZXIgb2YgbGl0ZXJhbCBieXRlcyAwLi4yNTUgKi9cbnZhciBMX0NPREVTICAgICAgID0gTElURVJBTFMgKyAxICsgTEVOR1RIX0NPREVTO1xuLyogbnVtYmVyIG9mIExpdGVyYWwgb3IgTGVuZ3RoIGNvZGVzLCBpbmNsdWRpbmcgdGhlIEVORF9CTE9DSyBjb2RlICovXG52YXIgRF9DT0RFUyAgICAgICA9IDMwO1xuLyogbnVtYmVyIG9mIGRpc3RhbmNlIGNvZGVzICovXG52YXIgQkxfQ09ERVMgICAgICA9IDE5O1xuLyogbnVtYmVyIG9mIGNvZGVzIHVzZWQgdG8gdHJhbnNmZXIgdGhlIGJpdCBsZW5ndGhzICovXG52YXIgSEVBUF9TSVpFICAgICA9IDIgKiBMX0NPREVTICsgMTtcbi8qIG1heGltdW0gaGVhcCBzaXplICovXG52YXIgTUFYX0JJVFMgID0gMTU7XG4vKiBBbGwgY29kZXMgbXVzdCBub3QgZXhjZWVkIE1BWF9CSVRTIGJpdHMgKi9cblxudmFyIE1JTl9NQVRDSCA9IDM7XG52YXIgTUFYX01BVENIID0gMjU4O1xudmFyIE1JTl9MT09LQUhFQUQgPSAoTUFYX01BVENIICsgTUlOX01BVENIICsgMSk7XG5cbnZhciBQUkVTRVRfRElDVCA9IDB4MjA7XG5cbnZhciBJTklUX1NUQVRFID0gNDI7XG52YXIgRVhUUkFfU1RBVEUgPSA2OTtcbnZhciBOQU1FX1NUQVRFID0gNzM7XG52YXIgQ09NTUVOVF9TVEFURSA9IDkxO1xudmFyIEhDUkNfU1RBVEUgPSAxMDM7XG52YXIgQlVTWV9TVEFURSA9IDExMztcbnZhciBGSU5JU0hfU1RBVEUgPSA2NjY7XG5cbnZhciBCU19ORUVEX01PUkUgICAgICA9IDE7IC8qIGJsb2NrIG5vdCBjb21wbGV0ZWQsIG5lZWQgbW9yZSBpbnB1dCBvciBtb3JlIG91dHB1dCAqL1xudmFyIEJTX0JMT0NLX0RPTkUgICAgID0gMjsgLyogYmxvY2sgZmx1c2ggcGVyZm9ybWVkICovXG52YXIgQlNfRklOSVNIX1NUQVJURUQgPSAzOyAvKiBmaW5pc2ggc3RhcnRlZCwgbmVlZCBvbmx5IG1vcmUgb3V0cHV0IGF0IG5leHQgZGVmbGF0ZSAqL1xudmFyIEJTX0ZJTklTSF9ET05FICAgID0gNDsgLyogZmluaXNoIGRvbmUsIGFjY2VwdCBubyBtb3JlIGlucHV0IG9yIG91dHB1dCAqL1xuXG52YXIgT1NfQ09ERSA9IDB4MDM7IC8vIFVuaXggOikgLiBEb24ndCBkZXRlY3QsIHVzZSB0aGlzIGRlZmF1bHQuXG5cbmZ1bmN0aW9uIGVycihzdHJtLCBlcnJvckNvZGUpIHtcbiAgc3RybS5tc2cgPSBtc2dbZXJyb3JDb2RlXTtcbiAgcmV0dXJuIGVycm9yQ29kZTtcbn1cblxuZnVuY3Rpb24gcmFuayhmKSB7XG4gIHJldHVybiAoKGYpIDw8IDEpIC0gKChmKSA+IDQgPyA5IDogMCk7XG59XG5cbmZ1bmN0aW9uIHplcm8oYnVmKSB7IHZhciBsZW4gPSBidWYubGVuZ3RoOyB3aGlsZSAoLS1sZW4gPj0gMCkgeyBidWZbbGVuXSA9IDA7IH0gfVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEZsdXNoIGFzIG11Y2ggcGVuZGluZyBvdXRwdXQgYXMgcG9zc2libGUuIEFsbCBkZWZsYXRlKCkgb3V0cHV0IGdvZXNcbiAqIHRocm91Z2ggdGhpcyBmdW5jdGlvbiBzbyBzb21lIGFwcGxpY2F0aW9ucyBtYXkgd2lzaCB0byBtb2RpZnkgaXRcbiAqIHRvIGF2b2lkIGFsbG9jYXRpbmcgYSBsYXJnZSBzdHJtLT5vdXRwdXQgYnVmZmVyIGFuZCBjb3B5aW5nIGludG8gaXQuXG4gKiAoU2VlIGFsc28gcmVhZF9idWYoKSkuXG4gKi9cbmZ1bmN0aW9uIGZsdXNoX3BlbmRpbmcoc3RybSkge1xuICB2YXIgcyA9IHN0cm0uc3RhdGU7XG5cbiAgLy9fdHJfZmx1c2hfYml0cyhzKTtcbiAgdmFyIGxlbiA9IHMucGVuZGluZztcbiAgaWYgKGxlbiA+IHN0cm0uYXZhaWxfb3V0KSB7XG4gICAgbGVuID0gc3RybS5hdmFpbF9vdXQ7XG4gIH1cbiAgaWYgKGxlbiA9PT0gMCkgeyByZXR1cm47IH1cblxuICB1dGlscy5hcnJheVNldChzdHJtLm91dHB1dCwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nX291dCwgbGVuLCBzdHJtLm5leHRfb3V0KTtcbiAgc3RybS5uZXh0X291dCArPSBsZW47XG4gIHMucGVuZGluZ19vdXQgKz0gbGVuO1xuICBzdHJtLnRvdGFsX291dCArPSBsZW47XG4gIHN0cm0uYXZhaWxfb3V0IC09IGxlbjtcbiAgcy5wZW5kaW5nIC09IGxlbjtcbiAgaWYgKHMucGVuZGluZyA9PT0gMCkge1xuICAgIHMucGVuZGluZ19vdXQgPSAwO1xuICB9XG59XG5cblxuZnVuY3Rpb24gZmx1c2hfYmxvY2tfb25seShzLCBsYXN0KSB7XG4gIHRyZWVzLl90cl9mbHVzaF9ibG9jayhzLCAocy5ibG9ja19zdGFydCA+PSAwID8gcy5ibG9ja19zdGFydCA6IC0xKSwgcy5zdHJzdGFydCAtIHMuYmxvY2tfc3RhcnQsIGxhc3QpO1xuICBzLmJsb2NrX3N0YXJ0ID0gcy5zdHJzdGFydDtcbiAgZmx1c2hfcGVuZGluZyhzLnN0cm0pO1xufVxuXG5cbmZ1bmN0aW9uIHB1dF9ieXRlKHMsIGIpIHtcbiAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSBiO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFB1dCBhIHNob3J0IGluIHRoZSBwZW5kaW5nIGJ1ZmZlci4gVGhlIDE2LWJpdCB2YWx1ZSBpcyBwdXQgaW4gTVNCIG9yZGVyLlxuICogSU4gYXNzZXJ0aW9uOiB0aGUgc3RyZWFtIHN0YXRlIGlzIGNvcnJlY3QgYW5kIHRoZXJlIGlzIGVub3VnaCByb29tIGluXG4gKiBwZW5kaW5nX2J1Zi5cbiAqL1xuZnVuY3Rpb24gcHV0U2hvcnRNU0IocywgYikge1xuLy8gIHB1dF9ieXRlKHMsIChCeXRlKShiID4+IDgpKTtcbi8vICBwdXRfYnl0ZShzLCAoQnl0ZSkoYiAmIDB4ZmYpKTtcbiAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSAoYiA+Pj4gOCkgJiAweGZmO1xuICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9IGIgJiAweGZmO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogUmVhZCBhIG5ldyBidWZmZXIgZnJvbSB0aGUgY3VycmVudCBpbnB1dCBzdHJlYW0sIHVwZGF0ZSB0aGUgYWRsZXIzMlxuICogYW5kIHRvdGFsIG51bWJlciBvZiBieXRlcyByZWFkLiAgQWxsIGRlZmxhdGUoKSBpbnB1dCBnb2VzIHRocm91Z2hcbiAqIHRoaXMgZnVuY3Rpb24gc28gc29tZSBhcHBsaWNhdGlvbnMgbWF5IHdpc2ggdG8gbW9kaWZ5IGl0IHRvIGF2b2lkXG4gKiBhbGxvY2F0aW5nIGEgbGFyZ2Ugc3RybS0+aW5wdXQgYnVmZmVyIGFuZCBjb3B5aW5nIGZyb20gaXQuXG4gKiAoU2VlIGFsc28gZmx1c2hfcGVuZGluZygpKS5cbiAqL1xuZnVuY3Rpb24gcmVhZF9idWYoc3RybSwgYnVmLCBzdGFydCwgc2l6ZSkge1xuICB2YXIgbGVuID0gc3RybS5hdmFpbF9pbjtcblxuICBpZiAobGVuID4gc2l6ZSkgeyBsZW4gPSBzaXplOyB9XG4gIGlmIChsZW4gPT09IDApIHsgcmV0dXJuIDA7IH1cblxuICBzdHJtLmF2YWlsX2luIC09IGxlbjtcblxuICAvLyB6bWVtY3B5KGJ1Ziwgc3RybS0+bmV4dF9pbiwgbGVuKTtcbiAgdXRpbHMuYXJyYXlTZXQoYnVmLCBzdHJtLmlucHV0LCBzdHJtLm5leHRfaW4sIGxlbiwgc3RhcnQpO1xuICBpZiAoc3RybS5zdGF0ZS53cmFwID09PSAxKSB7XG4gICAgc3RybS5hZGxlciA9IGFkbGVyMzIoc3RybS5hZGxlciwgYnVmLCBsZW4sIHN0YXJ0KTtcbiAgfVxuXG4gIGVsc2UgaWYgKHN0cm0uc3RhdGUud3JhcCA9PT0gMikge1xuICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBidWYsIGxlbiwgc3RhcnQpO1xuICB9XG5cbiAgc3RybS5uZXh0X2luICs9IGxlbjtcbiAgc3RybS50b3RhbF9pbiArPSBsZW47XG5cbiAgcmV0dXJuIGxlbjtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNldCBtYXRjaF9zdGFydCB0byB0aGUgbG9uZ2VzdCBtYXRjaCBzdGFydGluZyBhdCB0aGUgZ2l2ZW4gc3RyaW5nIGFuZFxuICogcmV0dXJuIGl0cyBsZW5ndGguIE1hdGNoZXMgc2hvcnRlciBvciBlcXVhbCB0byBwcmV2X2xlbmd0aCBhcmUgZGlzY2FyZGVkLFxuICogaW4gd2hpY2ggY2FzZSB0aGUgcmVzdWx0IGlzIGVxdWFsIHRvIHByZXZfbGVuZ3RoIGFuZCBtYXRjaF9zdGFydCBpc1xuICogZ2FyYmFnZS5cbiAqIElOIGFzc2VydGlvbnM6IGN1cl9tYXRjaCBpcyB0aGUgaGVhZCBvZiB0aGUgaGFzaCBjaGFpbiBmb3IgdGhlIGN1cnJlbnRcbiAqICAgc3RyaW5nIChzdHJzdGFydCkgYW5kIGl0cyBkaXN0YW5jZSBpcyA8PSBNQVhfRElTVCwgYW5kIHByZXZfbGVuZ3RoID49IDFcbiAqIE9VVCBhc3NlcnRpb246IHRoZSBtYXRjaCBsZW5ndGggaXMgbm90IGdyZWF0ZXIgdGhhbiBzLT5sb29rYWhlYWQuXG4gKi9cbmZ1bmN0aW9uIGxvbmdlc3RfbWF0Y2gocywgY3VyX21hdGNoKSB7XG4gIHZhciBjaGFpbl9sZW5ndGggPSBzLm1heF9jaGFpbl9sZW5ndGg7ICAgICAgLyogbWF4IGhhc2ggY2hhaW4gbGVuZ3RoICovXG4gIHZhciBzY2FuID0gcy5zdHJzdGFydDsgLyogY3VycmVudCBzdHJpbmcgKi9cbiAgdmFyIG1hdGNoOyAgICAgICAgICAgICAgICAgICAgICAgLyogbWF0Y2hlZCBzdHJpbmcgKi9cbiAgdmFyIGxlbjsgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBsZW5ndGggb2YgY3VycmVudCBtYXRjaCAqL1xuICB2YXIgYmVzdF9sZW4gPSBzLnByZXZfbGVuZ3RoOyAgICAgICAgICAgICAgLyogYmVzdCBtYXRjaCBsZW5ndGggc28gZmFyICovXG4gIHZhciBuaWNlX21hdGNoID0gcy5uaWNlX21hdGNoOyAgICAgICAgICAgICAvKiBzdG9wIGlmIG1hdGNoIGxvbmcgZW5vdWdoICovXG4gIHZhciBsaW1pdCA9IChzLnN0cnN0YXJ0ID4gKHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkpID9cbiAgICAgIHMuc3Ryc3RhcnQgLSAocy53X3NpemUgLSBNSU5fTE9PS0FIRUFEKSA6IDAvKk5JTCovO1xuXG4gIHZhciBfd2luID0gcy53aW5kb3c7IC8vIHNob3J0Y3V0XG5cbiAgdmFyIHdtYXNrID0gcy53X21hc2s7XG4gIHZhciBwcmV2ICA9IHMucHJldjtcblxuICAvKiBTdG9wIHdoZW4gY3VyX21hdGNoIGJlY29tZXMgPD0gbGltaXQuIFRvIHNpbXBsaWZ5IHRoZSBjb2RlLFxuICAgKiB3ZSBwcmV2ZW50IG1hdGNoZXMgd2l0aCB0aGUgc3RyaW5nIG9mIHdpbmRvdyBpbmRleCAwLlxuICAgKi9cblxuICB2YXIgc3RyZW5kID0gcy5zdHJzdGFydCArIE1BWF9NQVRDSDtcbiAgdmFyIHNjYW5fZW5kMSAgPSBfd2luW3NjYW4gKyBiZXN0X2xlbiAtIDFdO1xuICB2YXIgc2Nhbl9lbmQgICA9IF93aW5bc2NhbiArIGJlc3RfbGVuXTtcblxuICAvKiBUaGUgY29kZSBpcyBvcHRpbWl6ZWQgZm9yIEhBU0hfQklUUyA+PSA4IGFuZCBNQVhfTUFUQ0gtMiBtdWx0aXBsZSBvZiAxNi5cbiAgICogSXQgaXMgZWFzeSB0byBnZXQgcmlkIG9mIHRoaXMgb3B0aW1pemF0aW9uIGlmIG5lY2Vzc2FyeS5cbiAgICovXG4gIC8vIEFzc2VydChzLT5oYXNoX2JpdHMgPj0gOCAmJiBNQVhfTUFUQ0ggPT0gMjU4LCBcIkNvZGUgdG9vIGNsZXZlclwiKTtcblxuICAvKiBEbyBub3Qgd2FzdGUgdG9vIG11Y2ggdGltZSBpZiB3ZSBhbHJlYWR5IGhhdmUgYSBnb29kIG1hdGNoOiAqL1xuICBpZiAocy5wcmV2X2xlbmd0aCA+PSBzLmdvb2RfbWF0Y2gpIHtcbiAgICBjaGFpbl9sZW5ndGggPj49IDI7XG4gIH1cbiAgLyogRG8gbm90IGxvb2sgZm9yIG1hdGNoZXMgYmV5b25kIHRoZSBlbmQgb2YgdGhlIGlucHV0LiBUaGlzIGlzIG5lY2Vzc2FyeVxuICAgKiB0byBtYWtlIGRlZmxhdGUgZGV0ZXJtaW5pc3RpYy5cbiAgICovXG4gIGlmIChuaWNlX21hdGNoID4gcy5sb29rYWhlYWQpIHsgbmljZV9tYXRjaCA9IHMubG9va2FoZWFkOyB9XG5cbiAgLy8gQXNzZXJ0KCh1bGcpcy0+c3Ryc3RhcnQgPD0gcy0+d2luZG93X3NpemUtTUlOX0xPT0tBSEVBRCwgXCJuZWVkIGxvb2thaGVhZFwiKTtcblxuICBkbyB7XG4gICAgLy8gQXNzZXJ0KGN1cl9tYXRjaCA8IHMtPnN0cnN0YXJ0LCBcIm5vIGZ1dHVyZVwiKTtcbiAgICBtYXRjaCA9IGN1cl9tYXRjaDtcblxuICAgIC8qIFNraXAgdG8gbmV4dCBtYXRjaCBpZiB0aGUgbWF0Y2ggbGVuZ3RoIGNhbm5vdCBpbmNyZWFzZVxuICAgICAqIG9yIGlmIHRoZSBtYXRjaCBsZW5ndGggaXMgbGVzcyB0aGFuIDIuICBOb3RlIHRoYXQgdGhlIGNoZWNrcyBiZWxvd1xuICAgICAqIGZvciBpbnN1ZmZpY2llbnQgbG9va2FoZWFkIG9ubHkgb2NjdXIgb2NjYXNpb25hbGx5IGZvciBwZXJmb3JtYW5jZVxuICAgICAqIHJlYXNvbnMuICBUaGVyZWZvcmUgdW5pbml0aWFsaXplZCBtZW1vcnkgd2lsbCBiZSBhY2Nlc3NlZCwgYW5kXG4gICAgICogY29uZGl0aW9uYWwganVtcHMgd2lsbCBiZSBtYWRlIHRoYXQgZGVwZW5kIG9uIHRob3NlIHZhbHVlcy5cbiAgICAgKiBIb3dldmVyIHRoZSBsZW5ndGggb2YgdGhlIG1hdGNoIGlzIGxpbWl0ZWQgdG8gdGhlIGxvb2thaGVhZCwgc29cbiAgICAgKiB0aGUgb3V0cHV0IG9mIGRlZmxhdGUgaXMgbm90IGFmZmVjdGVkIGJ5IHRoZSB1bmluaXRpYWxpemVkIHZhbHVlcy5cbiAgICAgKi9cblxuICAgIGlmIChfd2luW21hdGNoICsgYmVzdF9sZW5dICAgICAhPT0gc2Nhbl9lbmQgIHx8XG4gICAgICAgIF93aW5bbWF0Y2ggKyBiZXN0X2xlbiAtIDFdICE9PSBzY2FuX2VuZDEgfHxcbiAgICAgICAgX3dpblttYXRjaF0gICAgICAgICAgICAgICAgIT09IF93aW5bc2Nhbl0gfHxcbiAgICAgICAgX3dpblsrK21hdGNoXSAgICAgICAgICAgICAgIT09IF93aW5bc2NhbiArIDFdKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvKiBUaGUgY2hlY2sgYXQgYmVzdF9sZW4tMSBjYW4gYmUgcmVtb3ZlZCBiZWNhdXNlIGl0IHdpbGwgYmUgbWFkZVxuICAgICAqIGFnYWluIGxhdGVyLiAoVGhpcyBoZXVyaXN0aWMgaXMgbm90IGFsd2F5cyBhIHdpbi4pXG4gICAgICogSXQgaXMgbm90IG5lY2Vzc2FyeSB0byBjb21wYXJlIHNjYW5bMl0gYW5kIG1hdGNoWzJdIHNpbmNlIHRoZXlcbiAgICAgKiBhcmUgYWx3YXlzIGVxdWFsIHdoZW4gdGhlIG90aGVyIGJ5dGVzIG1hdGNoLCBnaXZlbiB0aGF0XG4gICAgICogdGhlIGhhc2gga2V5cyBhcmUgZXF1YWwgYW5kIHRoYXQgSEFTSF9CSVRTID49IDguXG4gICAgICovXG4gICAgc2NhbiArPSAyO1xuICAgIG1hdGNoKys7XG4gICAgLy8gQXNzZXJ0KCpzY2FuID09ICptYXRjaCwgXCJtYXRjaFsyXT9cIik7XG5cbiAgICAvKiBXZSBjaGVjayBmb3IgaW5zdWZmaWNpZW50IGxvb2thaGVhZCBvbmx5IGV2ZXJ5IDh0aCBjb21wYXJpc29uO1xuICAgICAqIHRoZSAyNTZ0aCBjaGVjayB3aWxsIGJlIG1hZGUgYXQgc3Ryc3RhcnQrMjU4LlxuICAgICAqL1xuICAgIGRvIHtcbiAgICAgIC8qanNoaW50IG5vZW1wdHk6ZmFsc2UqL1xuICAgIH0gd2hpbGUgKF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJiBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiZcbiAgICAgICAgICAgICBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiYgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmXG4gICAgICAgICAgICAgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJlxuICAgICAgICAgICAgIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJiBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiZcbiAgICAgICAgICAgICBzY2FuIDwgc3RyZW5kKTtcblxuICAgIC8vIEFzc2VydChzY2FuIDw9IHMtPndpbmRvdysodW5zaWduZWQpKHMtPndpbmRvd19zaXplLTEpLCBcIndpbGQgc2NhblwiKTtcblxuICAgIGxlbiA9IE1BWF9NQVRDSCAtIChzdHJlbmQgLSBzY2FuKTtcbiAgICBzY2FuID0gc3RyZW5kIC0gTUFYX01BVENIO1xuXG4gICAgaWYgKGxlbiA+IGJlc3RfbGVuKSB7XG4gICAgICBzLm1hdGNoX3N0YXJ0ID0gY3VyX21hdGNoO1xuICAgICAgYmVzdF9sZW4gPSBsZW47XG4gICAgICBpZiAobGVuID49IG5pY2VfbWF0Y2gpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBzY2FuX2VuZDEgID0gX3dpbltzY2FuICsgYmVzdF9sZW4gLSAxXTtcbiAgICAgIHNjYW5fZW5kICAgPSBfd2luW3NjYW4gKyBiZXN0X2xlbl07XG4gICAgfVxuICB9IHdoaWxlICgoY3VyX21hdGNoID0gcHJldltjdXJfbWF0Y2ggJiB3bWFza10pID4gbGltaXQgJiYgLS1jaGFpbl9sZW5ndGggIT09IDApO1xuXG4gIGlmIChiZXN0X2xlbiA8PSBzLmxvb2thaGVhZCkge1xuICAgIHJldHVybiBiZXN0X2xlbjtcbiAgfVxuICByZXR1cm4gcy5sb29rYWhlYWQ7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBGaWxsIHRoZSB3aW5kb3cgd2hlbiB0aGUgbG9va2FoZWFkIGJlY29tZXMgaW5zdWZmaWNpZW50LlxuICogVXBkYXRlcyBzdHJzdGFydCBhbmQgbG9va2FoZWFkLlxuICpcbiAqIElOIGFzc2VydGlvbjogbG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRFxuICogT1VUIGFzc2VydGlvbnM6IHN0cnN0YXJ0IDw9IHdpbmRvd19zaXplLU1JTl9MT09LQUhFQURcbiAqICAgIEF0IGxlYXN0IG9uZSBieXRlIGhhcyBiZWVuIHJlYWQsIG9yIGF2YWlsX2luID09IDA7IHJlYWRzIGFyZVxuICogICAgcGVyZm9ybWVkIGZvciBhdCBsZWFzdCB0d28gYnl0ZXMgKHJlcXVpcmVkIGZvciB0aGUgemlwIHRyYW5zbGF0ZV9lb2xcbiAqICAgIG9wdGlvbiAtLSBub3Qgc3VwcG9ydGVkIGhlcmUpLlxuICovXG5mdW5jdGlvbiBmaWxsX3dpbmRvdyhzKSB7XG4gIHZhciBfd19zaXplID0gcy53X3NpemU7XG4gIHZhciBwLCBuLCBtLCBtb3JlLCBzdHI7XG5cbiAgLy9Bc3NlcnQocy0+bG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCwgXCJhbHJlYWR5IGVub3VnaCBsb29rYWhlYWRcIik7XG5cbiAgZG8ge1xuICAgIG1vcmUgPSBzLndpbmRvd19zaXplIC0gcy5sb29rYWhlYWQgLSBzLnN0cnN0YXJ0O1xuXG4gICAgLy8gSlMgaW50cyBoYXZlIDMyIGJpdCwgYmxvY2sgYmVsb3cgbm90IG5lZWRlZFxuICAgIC8qIERlYWwgd2l0aCAhQCMkJSA2NEsgbGltaXQ6ICovXG4gICAgLy9pZiAoc2l6ZW9mKGludCkgPD0gMikge1xuICAgIC8vICAgIGlmIChtb3JlID09IDAgJiYgcy0+c3Ryc3RhcnQgPT0gMCAmJiBzLT5sb29rYWhlYWQgPT0gMCkge1xuICAgIC8vICAgICAgICBtb3JlID0gd3NpemU7XG4gICAgLy9cbiAgICAvLyAgfSBlbHNlIGlmIChtb3JlID09ICh1bnNpZ25lZCkoLTEpKSB7XG4gICAgLy8gICAgICAgIC8qIFZlcnkgdW5saWtlbHksIGJ1dCBwb3NzaWJsZSBvbiAxNiBiaXQgbWFjaGluZSBpZlxuICAgIC8vICAgICAgICAgKiBzdHJzdGFydCA9PSAwICYmIGxvb2thaGVhZCA9PSAxIChpbnB1dCBkb25lIGEgYnl0ZSBhdCB0aW1lKVxuICAgIC8vICAgICAgICAgKi9cbiAgICAvLyAgICAgICAgbW9yZS0tO1xuICAgIC8vICAgIH1cbiAgICAvL31cblxuXG4gICAgLyogSWYgdGhlIHdpbmRvdyBpcyBhbG1vc3QgZnVsbCBhbmQgdGhlcmUgaXMgaW5zdWZmaWNpZW50IGxvb2thaGVhZCxcbiAgICAgKiBtb3ZlIHRoZSB1cHBlciBoYWxmIHRvIHRoZSBsb3dlciBvbmUgdG8gbWFrZSByb29tIGluIHRoZSB1cHBlciBoYWxmLlxuICAgICAqL1xuICAgIGlmIChzLnN0cnN0YXJ0ID49IF93X3NpemUgKyAoX3dfc2l6ZSAtIE1JTl9MT09LQUhFQUQpKSB7XG5cbiAgICAgIHV0aWxzLmFycmF5U2V0KHMud2luZG93LCBzLndpbmRvdywgX3dfc2l6ZSwgX3dfc2l6ZSwgMCk7XG4gICAgICBzLm1hdGNoX3N0YXJ0IC09IF93X3NpemU7XG4gICAgICBzLnN0cnN0YXJ0IC09IF93X3NpemU7XG4gICAgICAvKiB3ZSBub3cgaGF2ZSBzdHJzdGFydCA+PSBNQVhfRElTVCAqL1xuICAgICAgcy5ibG9ja19zdGFydCAtPSBfd19zaXplO1xuXG4gICAgICAvKiBTbGlkZSB0aGUgaGFzaCB0YWJsZSAoY291bGQgYmUgYXZvaWRlZCB3aXRoIDMyIGJpdCB2YWx1ZXNcbiAgICAgICBhdCB0aGUgZXhwZW5zZSBvZiBtZW1vcnkgdXNhZ2UpLiBXZSBzbGlkZSBldmVuIHdoZW4gbGV2ZWwgPT0gMFxuICAgICAgIHRvIGtlZXAgdGhlIGhhc2ggdGFibGUgY29uc2lzdGVudCBpZiB3ZSBzd2l0Y2ggYmFjayB0byBsZXZlbCA+IDBcbiAgICAgICBsYXRlci4gKFVzaW5nIGxldmVsIDAgcGVybWFuZW50bHkgaXMgbm90IGFuIG9wdGltYWwgdXNhZ2Ugb2ZcbiAgICAgICB6bGliLCBzbyB3ZSBkb24ndCBjYXJlIGFib3V0IHRoaXMgcGF0aG9sb2dpY2FsIGNhc2UuKVxuICAgICAgICovXG5cbiAgICAgIG4gPSBzLmhhc2hfc2l6ZTtcbiAgICAgIHAgPSBuO1xuICAgICAgZG8ge1xuICAgICAgICBtID0gcy5oZWFkWy0tcF07XG4gICAgICAgIHMuaGVhZFtwXSA9IChtID49IF93X3NpemUgPyBtIC0gX3dfc2l6ZSA6IDApO1xuICAgICAgfSB3aGlsZSAoLS1uKTtcblxuICAgICAgbiA9IF93X3NpemU7XG4gICAgICBwID0gbjtcbiAgICAgIGRvIHtcbiAgICAgICAgbSA9IHMucHJldlstLXBdO1xuICAgICAgICBzLnByZXZbcF0gPSAobSA+PSBfd19zaXplID8gbSAtIF93X3NpemUgOiAwKTtcbiAgICAgICAgLyogSWYgbiBpcyBub3Qgb24gYW55IGhhc2ggY2hhaW4sIHByZXZbbl0gaXMgZ2FyYmFnZSBidXRcbiAgICAgICAgICogaXRzIHZhbHVlIHdpbGwgbmV2ZXIgYmUgdXNlZC5cbiAgICAgICAgICovXG4gICAgICB9IHdoaWxlICgtLW4pO1xuXG4gICAgICBtb3JlICs9IF93X3NpemU7XG4gICAgfVxuICAgIGlmIChzLnN0cm0uYXZhaWxfaW4gPT09IDApIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8qIElmIHRoZXJlIHdhcyBubyBzbGlkaW5nOlxuICAgICAqICAgIHN0cnN0YXJ0IDw9IFdTSVpFK01BWF9ESVNULTEgJiYgbG9va2FoZWFkIDw9IE1JTl9MT09LQUhFQUQgLSAxICYmXG4gICAgICogICAgbW9yZSA9PSB3aW5kb3dfc2l6ZSAtIGxvb2thaGVhZCAtIHN0cnN0YXJ0XG4gICAgICogPT4gbW9yZSA+PSB3aW5kb3dfc2l6ZSAtIChNSU5fTE9PS0FIRUFELTEgKyBXU0laRSArIE1BWF9ESVNULTEpXG4gICAgICogPT4gbW9yZSA+PSB3aW5kb3dfc2l6ZSAtIDIqV1NJWkUgKyAyXG4gICAgICogSW4gdGhlIEJJR19NRU0gb3IgTU1BUCBjYXNlIChub3QgeWV0IHN1cHBvcnRlZCksXG4gICAgICogICB3aW5kb3dfc2l6ZSA9PSBpbnB1dF9zaXplICsgTUlOX0xPT0tBSEVBRCAgJiZcbiAgICAgKiAgIHN0cnN0YXJ0ICsgcy0+bG9va2FoZWFkIDw9IGlucHV0X3NpemUgPT4gbW9yZSA+PSBNSU5fTE9PS0FIRUFELlxuICAgICAqIE90aGVyd2lzZSwgd2luZG93X3NpemUgPT0gMipXU0laRSBzbyBtb3JlID49IDIuXG4gICAgICogSWYgdGhlcmUgd2FzIHNsaWRpbmcsIG1vcmUgPj0gV1NJWkUuIFNvIGluIGFsbCBjYXNlcywgbW9yZSA+PSAyLlxuICAgICAqL1xuICAgIC8vQXNzZXJ0KG1vcmUgPj0gMiwgXCJtb3JlIDwgMlwiKTtcbiAgICBuID0gcmVhZF9idWYocy5zdHJtLCBzLndpbmRvdywgcy5zdHJzdGFydCArIHMubG9va2FoZWFkLCBtb3JlKTtcbiAgICBzLmxvb2thaGVhZCArPSBuO1xuXG4gICAgLyogSW5pdGlhbGl6ZSB0aGUgaGFzaCB2YWx1ZSBub3cgdGhhdCB3ZSBoYXZlIHNvbWUgaW5wdXQ6ICovXG4gICAgaWYgKHMubG9va2FoZWFkICsgcy5pbnNlcnQgPj0gTUlOX01BVENIKSB7XG4gICAgICBzdHIgPSBzLnN0cnN0YXJ0IC0gcy5pbnNlcnQ7XG4gICAgICBzLmluc19oID0gcy53aW5kb3dbc3RyXTtcblxuICAgICAgLyogVVBEQVRFX0hBU0gocywgcy0+aW5zX2gsIHMtPndpbmRvd1tzdHIgKyAxXSk7ICovXG4gICAgICBzLmluc19oID0gKChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCkgXiBzLndpbmRvd1tzdHIgKyAxXSkgJiBzLmhhc2hfbWFzaztcbi8vI2lmIE1JTl9NQVRDSCAhPSAzXG4vLyAgICAgICAgQ2FsbCB1cGRhdGVfaGFzaCgpIE1JTl9NQVRDSC0zIG1vcmUgdGltZXNcbi8vI2VuZGlmXG4gICAgICB3aGlsZSAocy5pbnNlcnQpIHtcbiAgICAgICAgLyogVVBEQVRFX0hBU0gocywgcy0+aW5zX2gsIHMtPndpbmRvd1tzdHIgKyBNSU5fTUFUQ0gtMV0pOyAqL1xuICAgICAgICBzLmluc19oID0gKChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCkgXiBzLndpbmRvd1tzdHIgKyBNSU5fTUFUQ0ggLSAxXSkgJiBzLmhhc2hfbWFzaztcblxuICAgICAgICBzLnByZXZbc3RyICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdO1xuICAgICAgICBzLmhlYWRbcy5pbnNfaF0gPSBzdHI7XG4gICAgICAgIHN0cisrO1xuICAgICAgICBzLmluc2VydC0tO1xuICAgICAgICBpZiAocy5sb29rYWhlYWQgKyBzLmluc2VydCA8IE1JTl9NQVRDSCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qIElmIHRoZSB3aG9sZSBpbnB1dCBoYXMgbGVzcyB0aGFuIE1JTl9NQVRDSCBieXRlcywgaW5zX2ggaXMgZ2FyYmFnZSxcbiAgICAgKiBidXQgdGhpcyBpcyBub3QgaW1wb3J0YW50IHNpbmNlIG9ubHkgbGl0ZXJhbCBieXRlcyB3aWxsIGJlIGVtaXR0ZWQuXG4gICAgICovXG5cbiAgfSB3aGlsZSAocy5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEICYmIHMuc3RybS5hdmFpbF9pbiAhPT0gMCk7XG5cbiAgLyogSWYgdGhlIFdJTl9JTklUIGJ5dGVzIGFmdGVyIHRoZSBlbmQgb2YgdGhlIGN1cnJlbnQgZGF0YSBoYXZlIG5ldmVyIGJlZW5cbiAgICogd3JpdHRlbiwgdGhlbiB6ZXJvIHRob3NlIGJ5dGVzIGluIG9yZGVyIHRvIGF2b2lkIG1lbW9yeSBjaGVjayByZXBvcnRzIG9mXG4gICAqIHRoZSB1c2Ugb2YgdW5pbml0aWFsaXplZCAob3IgdW5pbml0aWFsaXNlZCBhcyBKdWxpYW4gd3JpdGVzKSBieXRlcyBieVxuICAgKiB0aGUgbG9uZ2VzdCBtYXRjaCByb3V0aW5lcy4gIFVwZGF0ZSB0aGUgaGlnaCB3YXRlciBtYXJrIGZvciB0aGUgbmV4dFxuICAgKiB0aW1lIHRocm91Z2ggaGVyZS4gIFdJTl9JTklUIGlzIHNldCB0byBNQVhfTUFUQ0ggc2luY2UgdGhlIGxvbmdlc3QgbWF0Y2hcbiAgICogcm91dGluZXMgYWxsb3cgc2Nhbm5pbmcgdG8gc3Ryc3RhcnQgKyBNQVhfTUFUQ0gsIGlnbm9yaW5nIGxvb2thaGVhZC5cbiAgICovXG4vLyAgaWYgKHMuaGlnaF93YXRlciA8IHMud2luZG93X3NpemUpIHtcbi8vICAgIHZhciBjdXJyID0gcy5zdHJzdGFydCArIHMubG9va2FoZWFkO1xuLy8gICAgdmFyIGluaXQgPSAwO1xuLy9cbi8vICAgIGlmIChzLmhpZ2hfd2F0ZXIgPCBjdXJyKSB7XG4vLyAgICAgIC8qIFByZXZpb3VzIGhpZ2ggd2F0ZXIgbWFyayBiZWxvdyBjdXJyZW50IGRhdGEgLS0gemVybyBXSU5fSU5JVFxuLy8gICAgICAgKiBieXRlcyBvciB1cCB0byBlbmQgb2Ygd2luZG93LCB3aGljaGV2ZXIgaXMgbGVzcy5cbi8vICAgICAgICovXG4vLyAgICAgIGluaXQgPSBzLndpbmRvd19zaXplIC0gY3Vycjtcbi8vICAgICAgaWYgKGluaXQgPiBXSU5fSU5JVClcbi8vICAgICAgICBpbml0ID0gV0lOX0lOSVQ7XG4vLyAgICAgIHptZW16ZXJvKHMtPndpbmRvdyArIGN1cnIsICh1bnNpZ25lZClpbml0KTtcbi8vICAgICAgcy0+aGlnaF93YXRlciA9IGN1cnIgKyBpbml0O1xuLy8gICAgfVxuLy8gICAgZWxzZSBpZiAocy0+aGlnaF93YXRlciA8ICh1bGcpY3VyciArIFdJTl9JTklUKSB7XG4vLyAgICAgIC8qIEhpZ2ggd2F0ZXIgbWFyayBhdCBvciBhYm92ZSBjdXJyZW50IGRhdGEsIGJ1dCBiZWxvdyBjdXJyZW50IGRhdGFcbi8vICAgICAgICogcGx1cyBXSU5fSU5JVCAtLSB6ZXJvIG91dCB0byBjdXJyZW50IGRhdGEgcGx1cyBXSU5fSU5JVCwgb3IgdXBcbi8vICAgICAgICogdG8gZW5kIG9mIHdpbmRvdywgd2hpY2hldmVyIGlzIGxlc3MuXG4vLyAgICAgICAqL1xuLy8gICAgICBpbml0ID0gKHVsZyljdXJyICsgV0lOX0lOSVQgLSBzLT5oaWdoX3dhdGVyO1xuLy8gICAgICBpZiAoaW5pdCA+IHMtPndpbmRvd19zaXplIC0gcy0+aGlnaF93YXRlcilcbi8vICAgICAgICBpbml0ID0gcy0+d2luZG93X3NpemUgLSBzLT5oaWdoX3dhdGVyO1xuLy8gICAgICB6bWVtemVybyhzLT53aW5kb3cgKyBzLT5oaWdoX3dhdGVyLCAodW5zaWduZWQpaW5pdCk7XG4vLyAgICAgIHMtPmhpZ2hfd2F0ZXIgKz0gaW5pdDtcbi8vICAgIH1cbi8vICB9XG4vL1xuLy8gIEFzc2VydCgodWxnKXMtPnN0cnN0YXJ0IDw9IHMtPndpbmRvd19zaXplIC0gTUlOX0xPT0tBSEVBRCxcbi8vICAgIFwibm90IGVub3VnaCByb29tIGZvciBzZWFyY2hcIik7XG59XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29weSB3aXRob3V0IGNvbXByZXNzaW9uIGFzIG11Y2ggYXMgcG9zc2libGUgZnJvbSB0aGUgaW5wdXQgc3RyZWFtLCByZXR1cm5cbiAqIHRoZSBjdXJyZW50IGJsb2NrIHN0YXRlLlxuICogVGhpcyBmdW5jdGlvbiBkb2VzIG5vdCBpbnNlcnQgbmV3IHN0cmluZ3MgaW4gdGhlIGRpY3Rpb25hcnkgc2luY2VcbiAqIHVuY29tcHJlc3NpYmxlIGRhdGEgaXMgcHJvYmFibHkgbm90IHVzZWZ1bC4gVGhpcyBmdW5jdGlvbiBpcyB1c2VkXG4gKiBvbmx5IGZvciB0aGUgbGV2ZWw9MCBjb21wcmVzc2lvbiBvcHRpb24uXG4gKiBOT1RFOiB0aGlzIGZ1bmN0aW9uIHNob3VsZCBiZSBvcHRpbWl6ZWQgdG8gYXZvaWQgZXh0cmEgY29weWluZyBmcm9tXG4gKiB3aW5kb3cgdG8gcGVuZGluZ19idWYuXG4gKi9cbmZ1bmN0aW9uIGRlZmxhdGVfc3RvcmVkKHMsIGZsdXNoKSB7XG4gIC8qIFN0b3JlZCBibG9ja3MgYXJlIGxpbWl0ZWQgdG8gMHhmZmZmIGJ5dGVzLCBwZW5kaW5nX2J1ZiBpcyBsaW1pdGVkXG4gICAqIHRvIHBlbmRpbmdfYnVmX3NpemUsIGFuZCBlYWNoIHN0b3JlZCBibG9jayBoYXMgYSA1IGJ5dGUgaGVhZGVyOlxuICAgKi9cbiAgdmFyIG1heF9ibG9ja19zaXplID0gMHhmZmZmO1xuXG4gIGlmIChtYXhfYmxvY2tfc2l6ZSA+IHMucGVuZGluZ19idWZfc2l6ZSAtIDUpIHtcbiAgICBtYXhfYmxvY2tfc2l6ZSA9IHMucGVuZGluZ19idWZfc2l6ZSAtIDU7XG4gIH1cblxuICAvKiBDb3B5IGFzIG11Y2ggYXMgcG9zc2libGUgZnJvbSBpbnB1dCB0byBvdXRwdXQ6ICovXG4gIGZvciAoOzspIHtcbiAgICAvKiBGaWxsIHRoZSB3aW5kb3cgYXMgbXVjaCBhcyBwb3NzaWJsZTogKi9cbiAgICBpZiAocy5sb29rYWhlYWQgPD0gMSkge1xuXG4gICAgICAvL0Fzc2VydChzLT5zdHJzdGFydCA8IHMtPndfc2l6ZStNQVhfRElTVChzKSB8fFxuICAgICAgLy8gIHMtPmJsb2NrX3N0YXJ0ID49IChsb25nKXMtPndfc2l6ZSwgXCJzbGlkZSB0b28gbGF0ZVwiKTtcbi8vICAgICAgaWYgKCEocy5zdHJzdGFydCA8IHMud19zaXplICsgKHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkgfHxcbi8vICAgICAgICBzLmJsb2NrX3N0YXJ0ID49IHMud19zaXplKSkge1xuLy8gICAgICAgIHRocm93ICBuZXcgRXJyb3IoXCJzbGlkZSB0b28gbGF0ZVwiKTtcbi8vICAgICAgfVxuXG4gICAgICBmaWxsX3dpbmRvdyhzKTtcbiAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCAmJiBmbHVzaCA9PT0gWl9OT19GTFVTSCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuXG4gICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICAvKiBmbHVzaCB0aGUgY3VycmVudCBibG9jayAqL1xuICAgIH1cbiAgICAvL0Fzc2VydChzLT5ibG9ja19zdGFydCA+PSAwTCwgXCJibG9jayBnb25lXCIpO1xuLy8gICAgaWYgKHMuYmxvY2tfc3RhcnQgPCAwKSB0aHJvdyBuZXcgRXJyb3IoXCJibG9jayBnb25lXCIpO1xuXG4gICAgcy5zdHJzdGFydCArPSBzLmxvb2thaGVhZDtcbiAgICBzLmxvb2thaGVhZCA9IDA7XG5cbiAgICAvKiBFbWl0IGEgc3RvcmVkIGJsb2NrIGlmIHBlbmRpbmdfYnVmIHdpbGwgYmUgZnVsbDogKi9cbiAgICB2YXIgbWF4X3N0YXJ0ID0gcy5ibG9ja19zdGFydCArIG1heF9ibG9ja19zaXplO1xuXG4gICAgaWYgKHMuc3Ryc3RhcnQgPT09IDAgfHwgcy5zdHJzdGFydCA+PSBtYXhfc3RhcnQpIHtcbiAgICAgIC8qIHN0cnN0YXJ0ID09IDAgaXMgcG9zc2libGUgd2hlbiB3cmFwYXJvdW5kIG9uIDE2LWJpdCBtYWNoaW5lICovXG4gICAgICBzLmxvb2thaGVhZCA9IHMuc3Ryc3RhcnQgLSBtYXhfc3RhcnQ7XG4gICAgICBzLnN0cnN0YXJ0ID0gbWF4X3N0YXJ0O1xuICAgICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgLyoqKi9cblxuXG4gICAgfVxuICAgIC8qIEZsdXNoIGlmIHdlIG1heSBoYXZlIHRvIHNsaWRlLCBvdGhlcndpc2UgYmxvY2tfc3RhcnQgbWF5IGJlY29tZVxuICAgICAqIG5lZ2F0aXZlIGFuZCB0aGUgZGF0YSB3aWxsIGJlIGdvbmU6XG4gICAgICovXG4gICAgaWYgKHMuc3Ryc3RhcnQgLSBzLmJsb2NrX3N0YXJ0ID49IChzLndfc2l6ZSAtIE1JTl9MT09LQUhFQUQpKSB7XG4gICAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICAvKioqL1xuICAgIH1cbiAgfVxuXG4gIHMuaW5zZXJ0ID0gMDtcblxuICBpZiAoZmx1c2ggPT09IFpfRklOSVNIKSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAxKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgdHJ1ZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19GSU5JU0hfU1RBUlRFRDtcbiAgICB9XG4gICAgLyoqKi9cbiAgICByZXR1cm4gQlNfRklOSVNIX0RPTkU7XG4gIH1cblxuICBpZiAocy5zdHJzdGFydCA+IHMuYmxvY2tfc3RhcnQpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgfVxuICAgIC8qKiovXG4gIH1cblxuICByZXR1cm4gQlNfTkVFRF9NT1JFO1xufVxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvbXByZXNzIGFzIG11Y2ggYXMgcG9zc2libGUgZnJvbSB0aGUgaW5wdXQgc3RyZWFtLCByZXR1cm4gdGhlIGN1cnJlbnRcbiAqIGJsb2NrIHN0YXRlLlxuICogVGhpcyBmdW5jdGlvbiBkb2VzIG5vdCBwZXJmb3JtIGxhenkgZXZhbHVhdGlvbiBvZiBtYXRjaGVzIGFuZCBpbnNlcnRzXG4gKiBuZXcgc3RyaW5ncyBpbiB0aGUgZGljdGlvbmFyeSBvbmx5IGZvciB1bm1hdGNoZWQgc3RyaW5ncyBvciBmb3Igc2hvcnRcbiAqIG1hdGNoZXMuIEl0IGlzIHVzZWQgb25seSBmb3IgdGhlIGZhc3QgY29tcHJlc3Npb24gb3B0aW9ucy5cbiAqL1xuZnVuY3Rpb24gZGVmbGF0ZV9mYXN0KHMsIGZsdXNoKSB7XG4gIHZhciBoYXNoX2hlYWQ7ICAgICAgICAvKiBoZWFkIG9mIHRoZSBoYXNoIGNoYWluICovXG4gIHZhciBiZmx1c2g7ICAgICAgICAgICAvKiBzZXQgaWYgY3VycmVudCBibG9jayBtdXN0IGJlIGZsdXNoZWQgKi9cblxuICBmb3IgKDs7KSB7XG4gICAgLyogTWFrZSBzdXJlIHRoYXQgd2UgYWx3YXlzIGhhdmUgZW5vdWdoIGxvb2thaGVhZCwgZXhjZXB0XG4gICAgICogYXQgdGhlIGVuZCBvZiB0aGUgaW5wdXQgZmlsZS4gV2UgbmVlZCBNQVhfTUFUQ0ggYnl0ZXNcbiAgICAgKiBmb3IgdGhlIG5leHQgbWF0Y2gsIHBsdXMgTUlOX01BVENIIGJ5dGVzIHRvIGluc2VydCB0aGVcbiAgICAgKiBzdHJpbmcgZm9sbG93aW5nIHRoZSBuZXh0IG1hdGNoLlxuICAgICAqL1xuICAgIGlmIChzLmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQpIHtcbiAgICAgIGZpbGxfd2luZG93KHMpO1xuICAgICAgaWYgKHMubG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCAmJiBmbHVzaCA9PT0gWl9OT19GTFVTSCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7XG4gICAgICAgIGJyZWFrOyAvKiBmbHVzaCB0aGUgY3VycmVudCBibG9jayAqL1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qIEluc2VydCB0aGUgc3RyaW5nIHdpbmRvd1tzdHJzdGFydCAuLiBzdHJzdGFydCsyXSBpbiB0aGVcbiAgICAgKiBkaWN0aW9uYXJ5LCBhbmQgc2V0IGhhc2hfaGVhZCB0byB0aGUgaGVhZCBvZiB0aGUgaGFzaCBjaGFpbjpcbiAgICAgKi9cbiAgICBoYXNoX2hlYWQgPSAwLypOSUwqLztcbiAgICBpZiAocy5sb29rYWhlYWQgPj0gTUlOX01BVENIKSB7XG4gICAgICAvKioqIElOU0VSVF9TVFJJTkcocywgcy5zdHJzdGFydCwgaGFzaF9oZWFkKTsgKioqL1xuICAgICAgcy5pbnNfaCA9ICgocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQpIF4gcy53aW5kb3dbcy5zdHJzdGFydCArIE1JTl9NQVRDSCAtIDFdKSAmIHMuaGFzaF9tYXNrO1xuICAgICAgaGFzaF9oZWFkID0gcy5wcmV2W3Muc3Ryc3RhcnQgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07XG4gICAgICBzLmhlYWRbcy5pbnNfaF0gPSBzLnN0cnN0YXJ0O1xuICAgICAgLyoqKi9cbiAgICB9XG5cbiAgICAvKiBGaW5kIHRoZSBsb25nZXN0IG1hdGNoLCBkaXNjYXJkaW5nIHRob3NlIDw9IHByZXZfbGVuZ3RoLlxuICAgICAqIEF0IHRoaXMgcG9pbnQgd2UgaGF2ZSBhbHdheXMgbWF0Y2hfbGVuZ3RoIDwgTUlOX01BVENIXG4gICAgICovXG4gICAgaWYgKGhhc2hfaGVhZCAhPT0gMC8qTklMKi8gJiYgKChzLnN0cnN0YXJ0IC0gaGFzaF9oZWFkKSA8PSAocy53X3NpemUgLSBNSU5fTE9PS0FIRUFEKSkpIHtcbiAgICAgIC8qIFRvIHNpbXBsaWZ5IHRoZSBjb2RlLCB3ZSBwcmV2ZW50IG1hdGNoZXMgd2l0aCB0aGUgc3RyaW5nXG4gICAgICAgKiBvZiB3aW5kb3cgaW5kZXggMCAoaW4gcGFydGljdWxhciB3ZSBoYXZlIHRvIGF2b2lkIGEgbWF0Y2hcbiAgICAgICAqIG9mIHRoZSBzdHJpbmcgd2l0aCBpdHNlbGYgYXQgdGhlIHN0YXJ0IG9mIHRoZSBpbnB1dCBmaWxlKS5cbiAgICAgICAqL1xuICAgICAgcy5tYXRjaF9sZW5ndGggPSBsb25nZXN0X21hdGNoKHMsIGhhc2hfaGVhZCk7XG4gICAgICAvKiBsb25nZXN0X21hdGNoKCkgc2V0cyBtYXRjaF9zdGFydCAqL1xuICAgIH1cbiAgICBpZiAocy5tYXRjaF9sZW5ndGggPj0gTUlOX01BVENIKSB7XG4gICAgICAvLyBjaGVja19tYXRjaChzLCBzLnN0cnN0YXJ0LCBzLm1hdGNoX3N0YXJ0LCBzLm1hdGNoX2xlbmd0aCk7IC8vIGZvciBkZWJ1ZyBvbmx5XG5cbiAgICAgIC8qKiogX3RyX3RhbGx5X2Rpc3Qocywgcy5zdHJzdGFydCAtIHMubWF0Y2hfc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICBzLm1hdGNoX2xlbmd0aCAtIE1JTl9NQVRDSCwgYmZsdXNoKTsgKioqL1xuICAgICAgYmZsdXNoID0gdHJlZXMuX3RyX3RhbGx5KHMsIHMuc3Ryc3RhcnQgLSBzLm1hdGNoX3N0YXJ0LCBzLm1hdGNoX2xlbmd0aCAtIE1JTl9NQVRDSCk7XG5cbiAgICAgIHMubG9va2FoZWFkIC09IHMubWF0Y2hfbGVuZ3RoO1xuXG4gICAgICAvKiBJbnNlcnQgbmV3IHN0cmluZ3MgaW4gdGhlIGhhc2ggdGFibGUgb25seSBpZiB0aGUgbWF0Y2ggbGVuZ3RoXG4gICAgICAgKiBpcyBub3QgdG9vIGxhcmdlLiBUaGlzIHNhdmVzIHRpbWUgYnV0IGRlZ3JhZGVzIGNvbXByZXNzaW9uLlxuICAgICAgICovXG4gICAgICBpZiAocy5tYXRjaF9sZW5ndGggPD0gcy5tYXhfbGF6eV9tYXRjaC8qbWF4X2luc2VydF9sZW5ndGgqLyAmJiBzLmxvb2thaGVhZCA+PSBNSU5fTUFUQ0gpIHtcbiAgICAgICAgcy5tYXRjaF9sZW5ndGgtLTsgLyogc3RyaW5nIGF0IHN0cnN0YXJ0IGFscmVhZHkgaW4gdGFibGUgKi9cbiAgICAgICAgZG8ge1xuICAgICAgICAgIHMuc3Ryc3RhcnQrKztcbiAgICAgICAgICAvKioqIElOU0VSVF9TVFJJTkcocywgcy5zdHJzdGFydCwgaGFzaF9oZWFkKTsgKioqL1xuICAgICAgICAgIHMuaW5zX2ggPSAoKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0KSBeIHMud2luZG93W3Muc3Ryc3RhcnQgKyBNSU5fTUFUQ0ggLSAxXSkgJiBzLmhhc2hfbWFzaztcbiAgICAgICAgICBoYXNoX2hlYWQgPSBzLnByZXZbcy5zdHJzdGFydCAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTtcbiAgICAgICAgICBzLmhlYWRbcy5pbnNfaF0gPSBzLnN0cnN0YXJ0O1xuICAgICAgICAgIC8qKiovXG4gICAgICAgICAgLyogc3Ryc3RhcnQgbmV2ZXIgZXhjZWVkcyBXU0laRS1NQVhfTUFUQ0gsIHNvIHRoZXJlIGFyZVxuICAgICAgICAgICAqIGFsd2F5cyBNSU5fTUFUQ0ggYnl0ZXMgYWhlYWQuXG4gICAgICAgICAgICovXG4gICAgICAgIH0gd2hpbGUgKC0tcy5tYXRjaF9sZW5ndGggIT09IDApO1xuICAgICAgICBzLnN0cnN0YXJ0Kys7XG4gICAgICB9IGVsc2VcbiAgICAgIHtcbiAgICAgICAgcy5zdHJzdGFydCArPSBzLm1hdGNoX2xlbmd0aDtcbiAgICAgICAgcy5tYXRjaF9sZW5ndGggPSAwO1xuICAgICAgICBzLmluc19oID0gcy53aW5kb3dbcy5zdHJzdGFydF07XG4gICAgICAgIC8qIFVQREFURV9IQVNIKHMsIHMuaW5zX2gsIHMud2luZG93W3Muc3Ryc3RhcnQrMV0pOyAqL1xuICAgICAgICBzLmluc19oID0gKChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCkgXiBzLndpbmRvd1tzLnN0cnN0YXJ0ICsgMV0pICYgcy5oYXNoX21hc2s7XG5cbi8vI2lmIE1JTl9NQVRDSCAhPSAzXG4vLyAgICAgICAgICAgICAgICBDYWxsIFVQREFURV9IQVNIKCkgTUlOX01BVENILTMgbW9yZSB0aW1lc1xuLy8jZW5kaWZcbiAgICAgICAgLyogSWYgbG9va2FoZWFkIDwgTUlOX01BVENILCBpbnNfaCBpcyBnYXJiYWdlLCBidXQgaXQgZG9lcyBub3RcbiAgICAgICAgICogbWF0dGVyIHNpbmNlIGl0IHdpbGwgYmUgcmVjb21wdXRlZCBhdCBuZXh0IGRlZmxhdGUgY2FsbC5cbiAgICAgICAgICovXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qIE5vIG1hdGNoLCBvdXRwdXQgYSBsaXRlcmFsIGJ5dGUgKi9cbiAgICAgIC8vVHJhY2V2digoc3RkZXJyLFwiJWNcIiwgcy53aW5kb3dbcy5zdHJzdGFydF0pKTtcbiAgICAgIC8qKiogX3RyX3RhbGx5X2xpdChzLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSwgYmZsdXNoKTsgKioqL1xuICAgICAgYmZsdXNoID0gdHJlZXMuX3RyX3RhbGx5KHMsIDAsIHMud2luZG93W3Muc3Ryc3RhcnRdKTtcblxuICAgICAgcy5sb29rYWhlYWQtLTtcbiAgICAgIHMuc3Ryc3RhcnQrKztcbiAgICB9XG4gICAgaWYgKGJmbHVzaCkge1xuICAgICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgLyoqKi9cbiAgICB9XG4gIH1cbiAgcy5pbnNlcnQgPSAoKHMuc3Ryc3RhcnQgPCAoTUlOX01BVENIIC0gMSkpID8gcy5zdHJzdGFydCA6IE1JTl9NQVRDSCAtIDEpO1xuICBpZiAoZmx1c2ggPT09IFpfRklOSVNIKSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAxKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgdHJ1ZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19GSU5JU0hfU1RBUlRFRDtcbiAgICB9XG4gICAgLyoqKi9cbiAgICByZXR1cm4gQlNfRklOSVNIX0RPTkU7XG4gIH1cbiAgaWYgKHMubGFzdF9saXQpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgfVxuICAgIC8qKiovXG4gIH1cbiAgcmV0dXJuIEJTX0JMT0NLX0RPTkU7XG59XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2FtZSBhcyBhYm92ZSwgYnV0IGFjaGlldmVzIGJldHRlciBjb21wcmVzc2lvbi4gV2UgdXNlIGEgbGF6eVxuICogZXZhbHVhdGlvbiBmb3IgbWF0Y2hlczogYSBtYXRjaCBpcyBmaW5hbGx5IGFkb3B0ZWQgb25seSBpZiB0aGVyZSBpc1xuICogbm8gYmV0dGVyIG1hdGNoIGF0IHRoZSBuZXh0IHdpbmRvdyBwb3NpdGlvbi5cbiAqL1xuZnVuY3Rpb24gZGVmbGF0ZV9zbG93KHMsIGZsdXNoKSB7XG4gIHZhciBoYXNoX2hlYWQ7ICAgICAgICAgIC8qIGhlYWQgb2YgaGFzaCBjaGFpbiAqL1xuICB2YXIgYmZsdXNoOyAgICAgICAgICAgICAgLyogc2V0IGlmIGN1cnJlbnQgYmxvY2sgbXVzdCBiZSBmbHVzaGVkICovXG5cbiAgdmFyIG1heF9pbnNlcnQ7XG5cbiAgLyogUHJvY2VzcyB0aGUgaW5wdXQgYmxvY2suICovXG4gIGZvciAoOzspIHtcbiAgICAvKiBNYWtlIHN1cmUgdGhhdCB3ZSBhbHdheXMgaGF2ZSBlbm91Z2ggbG9va2FoZWFkLCBleGNlcHRcbiAgICAgKiBhdCB0aGUgZW5kIG9mIHRoZSBpbnB1dCBmaWxlLiBXZSBuZWVkIE1BWF9NQVRDSCBieXRlc1xuICAgICAqIGZvciB0aGUgbmV4dCBtYXRjaCwgcGx1cyBNSU5fTUFUQ0ggYnl0ZXMgdG8gaW5zZXJ0IHRoZVxuICAgICAqIHN0cmluZyBmb2xsb3dpbmcgdGhlIG5leHQgbWF0Y2guXG4gICAgICovXG4gICAgaWYgKHMubG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCkge1xuICAgICAgZmlsbF93aW5kb3cocyk7XG4gICAgICBpZiAocy5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEICYmIGZsdXNoID09PSBaX05PX0ZMVVNIKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHsgYnJlYWs7IH0gLyogZmx1c2ggdGhlIGN1cnJlbnQgYmxvY2sgKi9cbiAgICB9XG5cbiAgICAvKiBJbnNlcnQgdGhlIHN0cmluZyB3aW5kb3dbc3Ryc3RhcnQgLi4gc3Ryc3RhcnQrMl0gaW4gdGhlXG4gICAgICogZGljdGlvbmFyeSwgYW5kIHNldCBoYXNoX2hlYWQgdG8gdGhlIGhlYWQgb2YgdGhlIGhhc2ggY2hhaW46XG4gICAgICovXG4gICAgaGFzaF9oZWFkID0gMC8qTklMKi87XG4gICAgaWYgKHMubG9va2FoZWFkID49IE1JTl9NQVRDSCkge1xuICAgICAgLyoqKiBJTlNFUlRfU1RSSU5HKHMsIHMuc3Ryc3RhcnQsIGhhc2hfaGVhZCk7ICoqKi9cbiAgICAgIHMuaW5zX2ggPSAoKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0KSBeIHMud2luZG93W3Muc3Ryc3RhcnQgKyBNSU5fTUFUQ0ggLSAxXSkgJiBzLmhhc2hfbWFzaztcbiAgICAgIGhhc2hfaGVhZCA9IHMucHJldltzLnN0cnN0YXJ0ICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdO1xuICAgICAgcy5oZWFkW3MuaW5zX2hdID0gcy5zdHJzdGFydDtcbiAgICAgIC8qKiovXG4gICAgfVxuXG4gICAgLyogRmluZCB0aGUgbG9uZ2VzdCBtYXRjaCwgZGlzY2FyZGluZyB0aG9zZSA8PSBwcmV2X2xlbmd0aC5cbiAgICAgKi9cbiAgICBzLnByZXZfbGVuZ3RoID0gcy5tYXRjaF9sZW5ndGg7XG4gICAgcy5wcmV2X21hdGNoID0gcy5tYXRjaF9zdGFydDtcbiAgICBzLm1hdGNoX2xlbmd0aCA9IE1JTl9NQVRDSCAtIDE7XG5cbiAgICBpZiAoaGFzaF9oZWFkICE9PSAwLypOSUwqLyAmJiBzLnByZXZfbGVuZ3RoIDwgcy5tYXhfbGF6eV9tYXRjaCAmJlxuICAgICAgICBzLnN0cnN0YXJ0IC0gaGFzaF9oZWFkIDw9IChzLndfc2l6ZSAtIE1JTl9MT09LQUhFQUQpLypNQVhfRElTVChzKSovKSB7XG4gICAgICAvKiBUbyBzaW1wbGlmeSB0aGUgY29kZSwgd2UgcHJldmVudCBtYXRjaGVzIHdpdGggdGhlIHN0cmluZ1xuICAgICAgICogb2Ygd2luZG93IGluZGV4IDAgKGluIHBhcnRpY3VsYXIgd2UgaGF2ZSB0byBhdm9pZCBhIG1hdGNoXG4gICAgICAgKiBvZiB0aGUgc3RyaW5nIHdpdGggaXRzZWxmIGF0IHRoZSBzdGFydCBvZiB0aGUgaW5wdXQgZmlsZSkuXG4gICAgICAgKi9cbiAgICAgIHMubWF0Y2hfbGVuZ3RoID0gbG9uZ2VzdF9tYXRjaChzLCBoYXNoX2hlYWQpO1xuICAgICAgLyogbG9uZ2VzdF9tYXRjaCgpIHNldHMgbWF0Y2hfc3RhcnQgKi9cblxuICAgICAgaWYgKHMubWF0Y2hfbGVuZ3RoIDw9IDUgJiZcbiAgICAgICAgIChzLnN0cmF0ZWd5ID09PSBaX0ZJTFRFUkVEIHx8IChzLm1hdGNoX2xlbmd0aCA9PT0gTUlOX01BVENIICYmIHMuc3Ryc3RhcnQgLSBzLm1hdGNoX3N0YXJ0ID4gNDA5Ni8qVE9PX0ZBUiovKSkpIHtcblxuICAgICAgICAvKiBJZiBwcmV2X21hdGNoIGlzIGFsc28gTUlOX01BVENILCBtYXRjaF9zdGFydCBpcyBnYXJiYWdlXG4gICAgICAgICAqIGJ1dCB3ZSB3aWxsIGlnbm9yZSB0aGUgY3VycmVudCBtYXRjaCBhbnl3YXkuXG4gICAgICAgICAqL1xuICAgICAgICBzLm1hdGNoX2xlbmd0aCA9IE1JTl9NQVRDSCAtIDE7XG4gICAgICB9XG4gICAgfVxuICAgIC8qIElmIHRoZXJlIHdhcyBhIG1hdGNoIGF0IHRoZSBwcmV2aW91cyBzdGVwIGFuZCB0aGUgY3VycmVudFxuICAgICAqIG1hdGNoIGlzIG5vdCBiZXR0ZXIsIG91dHB1dCB0aGUgcHJldmlvdXMgbWF0Y2g6XG4gICAgICovXG4gICAgaWYgKHMucHJldl9sZW5ndGggPj0gTUlOX01BVENIICYmIHMubWF0Y2hfbGVuZ3RoIDw9IHMucHJldl9sZW5ndGgpIHtcbiAgICAgIG1heF9pbnNlcnQgPSBzLnN0cnN0YXJ0ICsgcy5sb29rYWhlYWQgLSBNSU5fTUFUQ0g7XG4gICAgICAvKiBEbyBub3QgaW5zZXJ0IHN0cmluZ3MgaW4gaGFzaCB0YWJsZSBiZXlvbmQgdGhpcy4gKi9cblxuICAgICAgLy9jaGVja19tYXRjaChzLCBzLnN0cnN0YXJ0LTEsIHMucHJldl9tYXRjaCwgcy5wcmV2X2xlbmd0aCk7XG5cbiAgICAgIC8qKipfdHJfdGFsbHlfZGlzdChzLCBzLnN0cnN0YXJ0IC0gMSAtIHMucHJldl9tYXRjaCxcbiAgICAgICAgICAgICAgICAgICAgIHMucHJldl9sZW5ndGggLSBNSU5fTUFUQ0gsIGJmbHVzaCk7KioqL1xuICAgICAgYmZsdXNoID0gdHJlZXMuX3RyX3RhbGx5KHMsIHMuc3Ryc3RhcnQgLSAxIC0gcy5wcmV2X21hdGNoLCBzLnByZXZfbGVuZ3RoIC0gTUlOX01BVENIKTtcbiAgICAgIC8qIEluc2VydCBpbiBoYXNoIHRhYmxlIGFsbCBzdHJpbmdzIHVwIHRvIHRoZSBlbmQgb2YgdGhlIG1hdGNoLlxuICAgICAgICogc3Ryc3RhcnQtMSBhbmQgc3Ryc3RhcnQgYXJlIGFscmVhZHkgaW5zZXJ0ZWQuIElmIHRoZXJlIGlzIG5vdFxuICAgICAgICogZW5vdWdoIGxvb2thaGVhZCwgdGhlIGxhc3QgdHdvIHN0cmluZ3MgYXJlIG5vdCBpbnNlcnRlZCBpblxuICAgICAgICogdGhlIGhhc2ggdGFibGUuXG4gICAgICAgKi9cbiAgICAgIHMubG9va2FoZWFkIC09IHMucHJldl9sZW5ndGggLSAxO1xuICAgICAgcy5wcmV2X2xlbmd0aCAtPSAyO1xuICAgICAgZG8ge1xuICAgICAgICBpZiAoKytzLnN0cnN0YXJ0IDw9IG1heF9pbnNlcnQpIHtcbiAgICAgICAgICAvKioqIElOU0VSVF9TVFJJTkcocywgcy5zdHJzdGFydCwgaGFzaF9oZWFkKTsgKioqL1xuICAgICAgICAgIHMuaW5zX2ggPSAoKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0KSBeIHMud2luZG93W3Muc3Ryc3RhcnQgKyBNSU5fTUFUQ0ggLSAxXSkgJiBzLmhhc2hfbWFzaztcbiAgICAgICAgICBoYXNoX2hlYWQgPSBzLnByZXZbcy5zdHJzdGFydCAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTtcbiAgICAgICAgICBzLmhlYWRbcy5pbnNfaF0gPSBzLnN0cnN0YXJ0O1xuICAgICAgICAgIC8qKiovXG4gICAgICAgIH1cbiAgICAgIH0gd2hpbGUgKC0tcy5wcmV2X2xlbmd0aCAhPT0gMCk7XG4gICAgICBzLm1hdGNoX2F2YWlsYWJsZSA9IDA7XG4gICAgICBzLm1hdGNoX2xlbmd0aCA9IE1JTl9NQVRDSCAtIDE7XG4gICAgICBzLnN0cnN0YXJ0Kys7XG5cbiAgICAgIGlmIChiZmx1c2gpIHtcbiAgICAgICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgICB9XG4gICAgICAgIC8qKiovXG4gICAgICB9XG5cbiAgICB9IGVsc2UgaWYgKHMubWF0Y2hfYXZhaWxhYmxlKSB7XG4gICAgICAvKiBJZiB0aGVyZSB3YXMgbm8gbWF0Y2ggYXQgdGhlIHByZXZpb3VzIHBvc2l0aW9uLCBvdXRwdXQgYVxuICAgICAgICogc2luZ2xlIGxpdGVyYWwuIElmIHRoZXJlIHdhcyBhIG1hdGNoIGJ1dCB0aGUgY3VycmVudCBtYXRjaFxuICAgICAgICogaXMgbG9uZ2VyLCB0cnVuY2F0ZSB0aGUgcHJldmlvdXMgbWF0Y2ggdG8gYSBzaW5nbGUgbGl0ZXJhbC5cbiAgICAgICAqL1xuICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsXCIlY1wiLCBzLT53aW5kb3dbcy0+c3Ryc3RhcnQtMV0pKTtcbiAgICAgIC8qKiogX3RyX3RhbGx5X2xpdChzLCBzLndpbmRvd1tzLnN0cnN0YXJ0LTFdLCBiZmx1c2gpOyAqKiovXG4gICAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgMCwgcy53aW5kb3dbcy5zdHJzdGFydCAtIDFdKTtcblxuICAgICAgaWYgKGJmbHVzaCkge1xuICAgICAgICAvKioqIEZMVVNIX0JMT0NLX09OTFkocywgMCkgKioqL1xuICAgICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICAgICAgLyoqKi9cbiAgICAgIH1cbiAgICAgIHMuc3Ryc3RhcnQrKztcbiAgICAgIHMubG9va2FoZWFkLS07XG4gICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvKiBUaGVyZSBpcyBubyBwcmV2aW91cyBtYXRjaCB0byBjb21wYXJlIHdpdGgsIHdhaXQgZm9yXG4gICAgICAgKiB0aGUgbmV4dCBzdGVwIHRvIGRlY2lkZS5cbiAgICAgICAqL1xuICAgICAgcy5tYXRjaF9hdmFpbGFibGUgPSAxO1xuICAgICAgcy5zdHJzdGFydCsrO1xuICAgICAgcy5sb29rYWhlYWQtLTtcbiAgICB9XG4gIH1cbiAgLy9Bc3NlcnQgKGZsdXNoICE9IFpfTk9fRkxVU0gsIFwibm8gZmx1c2g/XCIpO1xuICBpZiAocy5tYXRjaF9hdmFpbGFibGUpIHtcbiAgICAvL1RyYWNldnYoKHN0ZGVycixcIiVjXCIsIHMtPndpbmRvd1tzLT5zdHJzdGFydC0xXSkpO1xuICAgIC8qKiogX3RyX3RhbGx5X2xpdChzLCBzLndpbmRvd1tzLnN0cnN0YXJ0LTFdLCBiZmx1c2gpOyAqKiovXG4gICAgYmZsdXNoID0gdHJlZXMuX3RyX3RhbGx5KHMsIDAsIHMud2luZG93W3Muc3Ryc3RhcnQgLSAxXSk7XG5cbiAgICBzLm1hdGNoX2F2YWlsYWJsZSA9IDA7XG4gIH1cbiAgcy5pbnNlcnQgPSBzLnN0cnN0YXJ0IDwgTUlOX01BVENIIC0gMSA/IHMuc3Ryc3RhcnQgOiBNSU5fTUFUQ0ggLSAxO1xuICBpZiAoZmx1c2ggPT09IFpfRklOSVNIKSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAxKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgdHJ1ZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19GSU5JU0hfU1RBUlRFRDtcbiAgICB9XG4gICAgLyoqKi9cbiAgICByZXR1cm4gQlNfRklOSVNIX0RPTkU7XG4gIH1cbiAgaWYgKHMubGFzdF9saXQpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgfVxuICAgIC8qKiovXG4gIH1cblxuICByZXR1cm4gQlNfQkxPQ0tfRE9ORTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEZvciBaX1JMRSwgc2ltcGx5IGxvb2sgZm9yIHJ1bnMgb2YgYnl0ZXMsIGdlbmVyYXRlIG1hdGNoZXMgb25seSBvZiBkaXN0YW5jZVxuICogb25lLiAgRG8gbm90IG1haW50YWluIGEgaGFzaCB0YWJsZS4gIChJdCB3aWxsIGJlIHJlZ2VuZXJhdGVkIGlmIHRoaXMgcnVuIG9mXG4gKiBkZWZsYXRlIHN3aXRjaGVzIGF3YXkgZnJvbSBaX1JMRS4pXG4gKi9cbmZ1bmN0aW9uIGRlZmxhdGVfcmxlKHMsIGZsdXNoKSB7XG4gIHZhciBiZmx1c2g7ICAgICAgICAgICAgLyogc2V0IGlmIGN1cnJlbnQgYmxvY2sgbXVzdCBiZSBmbHVzaGVkICovXG4gIHZhciBwcmV2OyAgICAgICAgICAgICAgLyogYnl0ZSBhdCBkaXN0YW5jZSBvbmUgdG8gbWF0Y2ggKi9cbiAgdmFyIHNjYW4sIHN0cmVuZDsgICAgICAvKiBzY2FuIGdvZXMgdXAgdG8gc3RyZW5kIGZvciBsZW5ndGggb2YgcnVuICovXG5cbiAgdmFyIF93aW4gPSBzLndpbmRvdztcblxuICBmb3IgKDs7KSB7XG4gICAgLyogTWFrZSBzdXJlIHRoYXQgd2UgYWx3YXlzIGhhdmUgZW5vdWdoIGxvb2thaGVhZCwgZXhjZXB0XG4gICAgICogYXQgdGhlIGVuZCBvZiB0aGUgaW5wdXQgZmlsZS4gV2UgbmVlZCBNQVhfTUFUQ0ggYnl0ZXNcbiAgICAgKiBmb3IgdGhlIGxvbmdlc3QgcnVuLCBwbHVzIG9uZSBmb3IgdGhlIHVucm9sbGVkIGxvb3AuXG4gICAgICovXG4gICAgaWYgKHMubG9va2FoZWFkIDw9IE1BWF9NQVRDSCkge1xuICAgICAgZmlsbF93aW5kb3cocyk7XG4gICAgICBpZiAocy5sb29rYWhlYWQgPD0gTUFYX01BVENIICYmIGZsdXNoID09PSBaX05PX0ZMVVNIKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHsgYnJlYWs7IH0gLyogZmx1c2ggdGhlIGN1cnJlbnQgYmxvY2sgKi9cbiAgICB9XG5cbiAgICAvKiBTZWUgaG93IG1hbnkgdGltZXMgdGhlIHByZXZpb3VzIGJ5dGUgcmVwZWF0cyAqL1xuICAgIHMubWF0Y2hfbGVuZ3RoID0gMDtcbiAgICBpZiAocy5sb29rYWhlYWQgPj0gTUlOX01BVENIICYmIHMuc3Ryc3RhcnQgPiAwKSB7XG4gICAgICBzY2FuID0gcy5zdHJzdGFydCAtIDE7XG4gICAgICBwcmV2ID0gX3dpbltzY2FuXTtcbiAgICAgIGlmIChwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSkge1xuICAgICAgICBzdHJlbmQgPSBzLnN0cnN0YXJ0ICsgTUFYX01BVENIO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgLypqc2hpbnQgbm9lbXB0eTpmYWxzZSovXG4gICAgICAgIH0gd2hpbGUgKHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiZcbiAgICAgICAgICAgICAgICAgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSAmJlxuICAgICAgICAgICAgICAgICBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmXG4gICAgICAgICAgICAgICAgIHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiZcbiAgICAgICAgICAgICAgICAgc2NhbiA8IHN0cmVuZCk7XG4gICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gTUFYX01BVENIIC0gKHN0cmVuZCAtIHNjYW4pO1xuICAgICAgICBpZiAocy5tYXRjaF9sZW5ndGggPiBzLmxvb2thaGVhZCkge1xuICAgICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gcy5sb29rYWhlYWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vQXNzZXJ0KHNjYW4gPD0gcy0+d2luZG93Kyh1SW50KShzLT53aW5kb3dfc2l6ZS0xKSwgXCJ3aWxkIHNjYW5cIik7XG4gICAgfVxuXG4gICAgLyogRW1pdCBtYXRjaCBpZiBoYXZlIHJ1biBvZiBNSU5fTUFUQ0ggb3IgbG9uZ2VyLCBlbHNlIGVtaXQgbGl0ZXJhbCAqL1xuICAgIGlmIChzLm1hdGNoX2xlbmd0aCA+PSBNSU5fTUFUQ0gpIHtcbiAgICAgIC8vY2hlY2tfbWF0Y2gocywgcy5zdHJzdGFydCwgcy5zdHJzdGFydCAtIDEsIHMubWF0Y2hfbGVuZ3RoKTtcblxuICAgICAgLyoqKiBfdHJfdGFsbHlfZGlzdChzLCAxLCBzLm1hdGNoX2xlbmd0aCAtIE1JTl9NQVRDSCwgYmZsdXNoKTsgKioqL1xuICAgICAgYmZsdXNoID0gdHJlZXMuX3RyX3RhbGx5KHMsIDEsIHMubWF0Y2hfbGVuZ3RoIC0gTUlOX01BVENIKTtcblxuICAgICAgcy5sb29rYWhlYWQgLT0gcy5tYXRjaF9sZW5ndGg7XG4gICAgICBzLnN0cnN0YXJ0ICs9IHMubWF0Y2hfbGVuZ3RoO1xuICAgICAgcy5tYXRjaF9sZW5ndGggPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICAvKiBObyBtYXRjaCwgb3V0cHV0IGEgbGl0ZXJhbCBieXRlICovXG4gICAgICAvL1RyYWNldnYoKHN0ZGVycixcIiVjXCIsIHMtPndpbmRvd1tzLT5zdHJzdGFydF0pKTtcbiAgICAgIC8qKiogX3RyX3RhbGx5X2xpdChzLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSwgYmZsdXNoKTsgKioqL1xuICAgICAgYmZsdXNoID0gdHJlZXMuX3RyX3RhbGx5KHMsIDAsIHMud2luZG93W3Muc3Ryc3RhcnRdKTtcblxuICAgICAgcy5sb29rYWhlYWQtLTtcbiAgICAgIHMuc3Ryc3RhcnQrKztcbiAgICB9XG4gICAgaWYgKGJmbHVzaCkge1xuICAgICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgLyoqKi9cbiAgICB9XG4gIH1cbiAgcy5pbnNlcnQgPSAwO1xuICBpZiAoZmx1c2ggPT09IFpfRklOSVNIKSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAxKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgdHJ1ZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19GSU5JU0hfU1RBUlRFRDtcbiAgICB9XG4gICAgLyoqKi9cbiAgICByZXR1cm4gQlNfRklOSVNIX0RPTkU7XG4gIH1cbiAgaWYgKHMubGFzdF9saXQpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgfVxuICAgIC8qKiovXG4gIH1cbiAgcmV0dXJuIEJTX0JMT0NLX0RPTkU7XG59XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRm9yIFpfSFVGRk1BTl9PTkxZLCBkbyBub3QgbG9vayBmb3IgbWF0Y2hlcy4gIERvIG5vdCBtYWludGFpbiBhIGhhc2ggdGFibGUuXG4gKiAoSXQgd2lsbCBiZSByZWdlbmVyYXRlZCBpZiB0aGlzIHJ1biBvZiBkZWZsYXRlIHN3aXRjaGVzIGF3YXkgZnJvbSBIdWZmbWFuLilcbiAqL1xuZnVuY3Rpb24gZGVmbGF0ZV9odWZmKHMsIGZsdXNoKSB7XG4gIHZhciBiZmx1c2g7ICAgICAgICAgICAgIC8qIHNldCBpZiBjdXJyZW50IGJsb2NrIG11c3QgYmUgZmx1c2hlZCAqL1xuXG4gIGZvciAoOzspIHtcbiAgICAvKiBNYWtlIHN1cmUgdGhhdCB3ZSBoYXZlIGEgbGl0ZXJhbCB0byB3cml0ZS4gKi9cbiAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHtcbiAgICAgIGZpbGxfd2luZG93KHMpO1xuICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7XG4gICAgICAgIGlmIChmbHVzaCA9PT0gWl9OT19GTFVTSCkge1xuICAgICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7ICAgICAgLyogZmx1c2ggdGhlIGN1cnJlbnQgYmxvY2sgKi9cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKiBPdXRwdXQgYSBsaXRlcmFsIGJ5dGUgKi9cbiAgICBzLm1hdGNoX2xlbmd0aCA9IDA7XG4gICAgLy9UcmFjZXZ2KChzdGRlcnIsXCIlY1wiLCBzLT53aW5kb3dbcy0+c3Ryc3RhcnRdKSk7XG4gICAgLyoqKiBfdHJfdGFsbHlfbGl0KHMsIHMud2luZG93W3Muc3Ryc3RhcnRdLCBiZmx1c2gpOyAqKiovXG4gICAgYmZsdXNoID0gdHJlZXMuX3RyX3RhbGx5KHMsIDAsIHMud2luZG93W3Muc3Ryc3RhcnRdKTtcbiAgICBzLmxvb2thaGVhZC0tO1xuICAgIHMuc3Ryc3RhcnQrKztcbiAgICBpZiAoYmZsdXNoKSB7XG4gICAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICAvKioqL1xuICAgIH1cbiAgfVxuICBzLmluc2VydCA9IDA7XG4gIGlmIChmbHVzaCA9PT0gWl9GSU5JU0gpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDEpOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCB0cnVlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX0ZJTklTSF9TVEFSVEVEO1xuICAgIH1cbiAgICAvKioqL1xuICAgIHJldHVybiBCU19GSU5JU0hfRE9ORTtcbiAgfVxuICBpZiAocy5sYXN0X2xpdCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICB9XG4gICAgLyoqKi9cbiAgfVxuICByZXR1cm4gQlNfQkxPQ0tfRE9ORTtcbn1cblxuLyogVmFsdWVzIGZvciBtYXhfbGF6eV9tYXRjaCwgZ29vZF9tYXRjaCBhbmQgbWF4X2NoYWluX2xlbmd0aCwgZGVwZW5kaW5nIG9uXG4gKiB0aGUgZGVzaXJlZCBwYWNrIGxldmVsICgwLi45KS4gVGhlIHZhbHVlcyBnaXZlbiBiZWxvdyBoYXZlIGJlZW4gdHVuZWQgdG9cbiAqIGV4Y2x1ZGUgd29yc3QgY2FzZSBwZXJmb3JtYW5jZSBmb3IgcGF0aG9sb2dpY2FsIGZpbGVzLiBCZXR0ZXIgdmFsdWVzIG1heSBiZVxuICogZm91bmQgZm9yIHNwZWNpZmljIGZpbGVzLlxuICovXG5mdW5jdGlvbiBDb25maWcoZ29vZF9sZW5ndGgsIG1heF9sYXp5LCBuaWNlX2xlbmd0aCwgbWF4X2NoYWluLCBmdW5jKSB7XG4gIHRoaXMuZ29vZF9sZW5ndGggPSBnb29kX2xlbmd0aDtcbiAgdGhpcy5tYXhfbGF6eSA9IG1heF9sYXp5O1xuICB0aGlzLm5pY2VfbGVuZ3RoID0gbmljZV9sZW5ndGg7XG4gIHRoaXMubWF4X2NoYWluID0gbWF4X2NoYWluO1xuICB0aGlzLmZ1bmMgPSBmdW5jO1xufVxuXG52YXIgY29uZmlndXJhdGlvbl90YWJsZTtcblxuY29uZmlndXJhdGlvbl90YWJsZSA9IFtcbiAgLyogICAgICBnb29kIGxhenkgbmljZSBjaGFpbiAqL1xuICBuZXcgQ29uZmlnKDAsIDAsIDAsIDAsIGRlZmxhdGVfc3RvcmVkKSwgICAgICAgICAgLyogMCBzdG9yZSBvbmx5ICovXG4gIG5ldyBDb25maWcoNCwgNCwgOCwgNCwgZGVmbGF0ZV9mYXN0KSwgICAgICAgICAgICAvKiAxIG1heCBzcGVlZCwgbm8gbGF6eSBtYXRjaGVzICovXG4gIG5ldyBDb25maWcoNCwgNSwgMTYsIDgsIGRlZmxhdGVfZmFzdCksICAgICAgICAgICAvKiAyICovXG4gIG5ldyBDb25maWcoNCwgNiwgMzIsIDMyLCBkZWZsYXRlX2Zhc3QpLCAgICAgICAgICAvKiAzICovXG5cbiAgbmV3IENvbmZpZyg0LCA0LCAxNiwgMTYsIGRlZmxhdGVfc2xvdyksICAgICAgICAgIC8qIDQgbGF6eSBtYXRjaGVzICovXG4gIG5ldyBDb25maWcoOCwgMTYsIDMyLCAzMiwgZGVmbGF0ZV9zbG93KSwgICAgICAgICAvKiA1ICovXG4gIG5ldyBDb25maWcoOCwgMTYsIDEyOCwgMTI4LCBkZWZsYXRlX3Nsb3cpLCAgICAgICAvKiA2ICovXG4gIG5ldyBDb25maWcoOCwgMzIsIDEyOCwgMjU2LCBkZWZsYXRlX3Nsb3cpLCAgICAgICAvKiA3ICovXG4gIG5ldyBDb25maWcoMzIsIDEyOCwgMjU4LCAxMDI0LCBkZWZsYXRlX3Nsb3cpLCAgICAvKiA4ICovXG4gIG5ldyBDb25maWcoMzIsIDI1OCwgMjU4LCA0MDk2LCBkZWZsYXRlX3Nsb3cpICAgICAvKiA5IG1heCBjb21wcmVzc2lvbiAqL1xuXTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEluaXRpYWxpemUgdGhlIFwibG9uZ2VzdCBtYXRjaFwiIHJvdXRpbmVzIGZvciBhIG5ldyB6bGliIHN0cmVhbVxuICovXG5mdW5jdGlvbiBsbV9pbml0KHMpIHtcbiAgcy53aW5kb3dfc2l6ZSA9IDIgKiBzLndfc2l6ZTtcblxuICAvKioqIENMRUFSX0hBU0gocyk7ICoqKi9cbiAgemVybyhzLmhlYWQpOyAvLyBGaWxsIHdpdGggTklMICg9IDApO1xuXG4gIC8qIFNldCB0aGUgZGVmYXVsdCBjb25maWd1cmF0aW9uIHBhcmFtZXRlcnM6XG4gICAqL1xuICBzLm1heF9sYXp5X21hdGNoID0gY29uZmlndXJhdGlvbl90YWJsZVtzLmxldmVsXS5tYXhfbGF6eTtcbiAgcy5nb29kX21hdGNoID0gY29uZmlndXJhdGlvbl90YWJsZVtzLmxldmVsXS5nb29kX2xlbmd0aDtcbiAgcy5uaWNlX21hdGNoID0gY29uZmlndXJhdGlvbl90YWJsZVtzLmxldmVsXS5uaWNlX2xlbmd0aDtcbiAgcy5tYXhfY2hhaW5fbGVuZ3RoID0gY29uZmlndXJhdGlvbl90YWJsZVtzLmxldmVsXS5tYXhfY2hhaW47XG5cbiAgcy5zdHJzdGFydCA9IDA7XG4gIHMuYmxvY2tfc3RhcnQgPSAwO1xuICBzLmxvb2thaGVhZCA9IDA7XG4gIHMuaW5zZXJ0ID0gMDtcbiAgcy5tYXRjaF9sZW5ndGggPSBzLnByZXZfbGVuZ3RoID0gTUlOX01BVENIIC0gMTtcbiAgcy5tYXRjaF9hdmFpbGFibGUgPSAwO1xuICBzLmluc19oID0gMDtcbn1cblxuXG5mdW5jdGlvbiBEZWZsYXRlU3RhdGUoKSB7XG4gIHRoaXMuc3RybSA9IG51bGw7ICAgICAgICAgICAgLyogcG9pbnRlciBiYWNrIHRvIHRoaXMgemxpYiBzdHJlYW0gKi9cbiAgdGhpcy5zdGF0dXMgPSAwOyAgICAgICAgICAgIC8qIGFzIHRoZSBuYW1lIGltcGxpZXMgKi9cbiAgdGhpcy5wZW5kaW5nX2J1ZiA9IG51bGw7ICAgICAgLyogb3V0cHV0IHN0aWxsIHBlbmRpbmcgKi9cbiAgdGhpcy5wZW5kaW5nX2J1Zl9zaXplID0gMDsgIC8qIHNpemUgb2YgcGVuZGluZ19idWYgKi9cbiAgdGhpcy5wZW5kaW5nX291dCA9IDA7ICAgICAgIC8qIG5leHQgcGVuZGluZyBieXRlIHRvIG91dHB1dCB0byB0aGUgc3RyZWFtICovXG4gIHRoaXMucGVuZGluZyA9IDA7ICAgICAgICAgICAvKiBuYiBvZiBieXRlcyBpbiB0aGUgcGVuZGluZyBidWZmZXIgKi9cbiAgdGhpcy53cmFwID0gMDsgICAgICAgICAgICAgIC8qIGJpdCAwIHRydWUgZm9yIHpsaWIsIGJpdCAxIHRydWUgZm9yIGd6aXAgKi9cbiAgdGhpcy5nemhlYWQgPSBudWxsOyAgICAgICAgIC8qIGd6aXAgaGVhZGVyIGluZm9ybWF0aW9uIHRvIHdyaXRlICovXG4gIHRoaXMuZ3ppbmRleCA9IDA7ICAgICAgICAgICAvKiB3aGVyZSBpbiBleHRyYSwgbmFtZSwgb3IgY29tbWVudCAqL1xuICB0aGlzLm1ldGhvZCA9IFpfREVGTEFURUQ7IC8qIGNhbiBvbmx5IGJlIERFRkxBVEVEICovXG4gIHRoaXMubGFzdF9mbHVzaCA9IC0xOyAgIC8qIHZhbHVlIG9mIGZsdXNoIHBhcmFtIGZvciBwcmV2aW91cyBkZWZsYXRlIGNhbGwgKi9cblxuICB0aGlzLndfc2l6ZSA9IDA7ICAvKiBMWjc3IHdpbmRvdyBzaXplICgzMksgYnkgZGVmYXVsdCkgKi9cbiAgdGhpcy53X2JpdHMgPSAwOyAgLyogbG9nMih3X3NpemUpICAoOC4uMTYpICovXG4gIHRoaXMud19tYXNrID0gMDsgIC8qIHdfc2l6ZSAtIDEgKi9cblxuICB0aGlzLndpbmRvdyA9IG51bGw7XG4gIC8qIFNsaWRpbmcgd2luZG93LiBJbnB1dCBieXRlcyBhcmUgcmVhZCBpbnRvIHRoZSBzZWNvbmQgaGFsZiBvZiB0aGUgd2luZG93LFxuICAgKiBhbmQgbW92ZSB0byB0aGUgZmlyc3QgaGFsZiBsYXRlciB0byBrZWVwIGEgZGljdGlvbmFyeSBvZiBhdCBsZWFzdCB3U2l6ZVxuICAgKiBieXRlcy4gV2l0aCB0aGlzIG9yZ2FuaXphdGlvbiwgbWF0Y2hlcyBhcmUgbGltaXRlZCB0byBhIGRpc3RhbmNlIG9mXG4gICAqIHdTaXplLU1BWF9NQVRDSCBieXRlcywgYnV0IHRoaXMgZW5zdXJlcyB0aGF0IElPIGlzIGFsd2F5c1xuICAgKiBwZXJmb3JtZWQgd2l0aCBhIGxlbmd0aCBtdWx0aXBsZSBvZiB0aGUgYmxvY2sgc2l6ZS5cbiAgICovXG5cbiAgdGhpcy53aW5kb3dfc2l6ZSA9IDA7XG4gIC8qIEFjdHVhbCBzaXplIG9mIHdpbmRvdzogMip3U2l6ZSwgZXhjZXB0IHdoZW4gdGhlIHVzZXIgaW5wdXQgYnVmZmVyXG4gICAqIGlzIGRpcmVjdGx5IHVzZWQgYXMgc2xpZGluZyB3aW5kb3cuXG4gICAqL1xuXG4gIHRoaXMucHJldiA9IG51bGw7XG4gIC8qIExpbmsgdG8gb2xkZXIgc3RyaW5nIHdpdGggc2FtZSBoYXNoIGluZGV4LiBUbyBsaW1pdCB0aGUgc2l6ZSBvZiB0aGlzXG4gICAqIGFycmF5IHRvIDY0SywgdGhpcyBsaW5rIGlzIG1haW50YWluZWQgb25seSBmb3IgdGhlIGxhc3QgMzJLIHN0cmluZ3MuXG4gICAqIEFuIGluZGV4IGluIHRoaXMgYXJyYXkgaXMgdGh1cyBhIHdpbmRvdyBpbmRleCBtb2R1bG8gMzJLLlxuICAgKi9cblxuICB0aGlzLmhlYWQgPSBudWxsOyAgIC8qIEhlYWRzIG9mIHRoZSBoYXNoIGNoYWlucyBvciBOSUwuICovXG5cbiAgdGhpcy5pbnNfaCA9IDA7ICAgICAgIC8qIGhhc2ggaW5kZXggb2Ygc3RyaW5nIHRvIGJlIGluc2VydGVkICovXG4gIHRoaXMuaGFzaF9zaXplID0gMDsgICAvKiBudW1iZXIgb2YgZWxlbWVudHMgaW4gaGFzaCB0YWJsZSAqL1xuICB0aGlzLmhhc2hfYml0cyA9IDA7ICAgLyogbG9nMihoYXNoX3NpemUpICovXG4gIHRoaXMuaGFzaF9tYXNrID0gMDsgICAvKiBoYXNoX3NpemUtMSAqL1xuXG4gIHRoaXMuaGFzaF9zaGlmdCA9IDA7XG4gIC8qIE51bWJlciBvZiBiaXRzIGJ5IHdoaWNoIGluc19oIG11c3QgYmUgc2hpZnRlZCBhdCBlYWNoIGlucHV0XG4gICAqIHN0ZXAuIEl0IG11c3QgYmUgc3VjaCB0aGF0IGFmdGVyIE1JTl9NQVRDSCBzdGVwcywgdGhlIG9sZGVzdFxuICAgKiBieXRlIG5vIGxvbmdlciB0YWtlcyBwYXJ0IGluIHRoZSBoYXNoIGtleSwgdGhhdCBpczpcbiAgICogICBoYXNoX3NoaWZ0ICogTUlOX01BVENIID49IGhhc2hfYml0c1xuICAgKi9cblxuICB0aGlzLmJsb2NrX3N0YXJ0ID0gMDtcbiAgLyogV2luZG93IHBvc2l0aW9uIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGN1cnJlbnQgb3V0cHV0IGJsb2NrLiBHZXRzXG4gICAqIG5lZ2F0aXZlIHdoZW4gdGhlIHdpbmRvdyBpcyBtb3ZlZCBiYWNrd2FyZHMuXG4gICAqL1xuXG4gIHRoaXMubWF0Y2hfbGVuZ3RoID0gMDsgICAgICAvKiBsZW5ndGggb2YgYmVzdCBtYXRjaCAqL1xuICB0aGlzLnByZXZfbWF0Y2ggPSAwOyAgICAgICAgLyogcHJldmlvdXMgbWF0Y2ggKi9cbiAgdGhpcy5tYXRjaF9hdmFpbGFibGUgPSAwOyAgIC8qIHNldCBpZiBwcmV2aW91cyBtYXRjaCBleGlzdHMgKi9cbiAgdGhpcy5zdHJzdGFydCA9IDA7ICAgICAgICAgIC8qIHN0YXJ0IG9mIHN0cmluZyB0byBpbnNlcnQgKi9cbiAgdGhpcy5tYXRjaF9zdGFydCA9IDA7ICAgICAgIC8qIHN0YXJ0IG9mIG1hdGNoaW5nIHN0cmluZyAqL1xuICB0aGlzLmxvb2thaGVhZCA9IDA7ICAgICAgICAgLyogbnVtYmVyIG9mIHZhbGlkIGJ5dGVzIGFoZWFkIGluIHdpbmRvdyAqL1xuXG4gIHRoaXMucHJldl9sZW5ndGggPSAwO1xuICAvKiBMZW5ndGggb2YgdGhlIGJlc3QgbWF0Y2ggYXQgcHJldmlvdXMgc3RlcC4gTWF0Y2hlcyBub3QgZ3JlYXRlciB0aGFuIHRoaXNcbiAgICogYXJlIGRpc2NhcmRlZC4gVGhpcyBpcyB1c2VkIGluIHRoZSBsYXp5IG1hdGNoIGV2YWx1YXRpb24uXG4gICAqL1xuXG4gIHRoaXMubWF4X2NoYWluX2xlbmd0aCA9IDA7XG4gIC8qIFRvIHNwZWVkIHVwIGRlZmxhdGlvbiwgaGFzaCBjaGFpbnMgYXJlIG5ldmVyIHNlYXJjaGVkIGJleW9uZCB0aGlzXG4gICAqIGxlbmd0aC4gIEEgaGlnaGVyIGxpbWl0IGltcHJvdmVzIGNvbXByZXNzaW9uIHJhdGlvIGJ1dCBkZWdyYWRlcyB0aGVcbiAgICogc3BlZWQuXG4gICAqL1xuXG4gIHRoaXMubWF4X2xhenlfbWF0Y2ggPSAwO1xuICAvKiBBdHRlbXB0IHRvIGZpbmQgYSBiZXR0ZXIgbWF0Y2ggb25seSB3aGVuIHRoZSBjdXJyZW50IG1hdGNoIGlzIHN0cmljdGx5XG4gICAqIHNtYWxsZXIgdGhhbiB0aGlzIHZhbHVlLiBUaGlzIG1lY2hhbmlzbSBpcyB1c2VkIG9ubHkgZm9yIGNvbXByZXNzaW9uXG4gICAqIGxldmVscyA+PSA0LlxuICAgKi9cbiAgLy8gVGhhdCdzIGFsaWFzIHRvIG1heF9sYXp5X21hdGNoLCBkb24ndCB1c2UgZGlyZWN0bHlcbiAgLy90aGlzLm1heF9pbnNlcnRfbGVuZ3RoID0gMDtcbiAgLyogSW5zZXJ0IG5ldyBzdHJpbmdzIGluIHRoZSBoYXNoIHRhYmxlIG9ubHkgaWYgdGhlIG1hdGNoIGxlbmd0aCBpcyBub3RcbiAgICogZ3JlYXRlciB0aGFuIHRoaXMgbGVuZ3RoLiBUaGlzIHNhdmVzIHRpbWUgYnV0IGRlZ3JhZGVzIGNvbXByZXNzaW9uLlxuICAgKiBtYXhfaW5zZXJ0X2xlbmd0aCBpcyB1c2VkIG9ubHkgZm9yIGNvbXByZXNzaW9uIGxldmVscyA8PSAzLlxuICAgKi9cblxuICB0aGlzLmxldmVsID0gMDsgICAgIC8qIGNvbXByZXNzaW9uIGxldmVsICgxLi45KSAqL1xuICB0aGlzLnN0cmF0ZWd5ID0gMDsgIC8qIGZhdm9yIG9yIGZvcmNlIEh1ZmZtYW4gY29kaW5nKi9cblxuICB0aGlzLmdvb2RfbWF0Y2ggPSAwO1xuICAvKiBVc2UgYSBmYXN0ZXIgc2VhcmNoIHdoZW4gdGhlIHByZXZpb3VzIG1hdGNoIGlzIGxvbmdlciB0aGFuIHRoaXMgKi9cblxuICB0aGlzLm5pY2VfbWF0Y2ggPSAwOyAvKiBTdG9wIHNlYXJjaGluZyB3aGVuIGN1cnJlbnQgbWF0Y2ggZXhjZWVkcyB0aGlzICovXG5cbiAgICAgICAgICAgICAgLyogdXNlZCBieSB0cmVlcy5jOiAqL1xuXG4gIC8qIERpZG4ndCB1c2UgY3RfZGF0YSB0eXBlZGVmIGJlbG93IHRvIHN1cHByZXNzIGNvbXBpbGVyIHdhcm5pbmcgKi9cblxuICAvLyBzdHJ1Y3QgY3RfZGF0YV9zIGR5bl9sdHJlZVtIRUFQX1NJWkVdOyAgIC8qIGxpdGVyYWwgYW5kIGxlbmd0aCB0cmVlICovXG4gIC8vIHN0cnVjdCBjdF9kYXRhX3MgZHluX2R0cmVlWzIqRF9DT0RFUysxXTsgLyogZGlzdGFuY2UgdHJlZSAqL1xuICAvLyBzdHJ1Y3QgY3RfZGF0YV9zIGJsX3RyZWVbMipCTF9DT0RFUysxXTsgIC8qIEh1ZmZtYW4gdHJlZSBmb3IgYml0IGxlbmd0aHMgKi9cblxuICAvLyBVc2UgZmxhdCBhcnJheSBvZiBET1VCTEUgc2l6ZSwgd2l0aCBpbnRlcmxlYXZlZCBmYXRhLFxuICAvLyBiZWNhdXNlIEpTIGRvZXMgbm90IHN1cHBvcnQgZWZmZWN0aXZlXG4gIHRoaXMuZHluX2x0cmVlICA9IG5ldyB1dGlscy5CdWYxNihIRUFQX1NJWkUgKiAyKTtcbiAgdGhpcy5keW5fZHRyZWUgID0gbmV3IHV0aWxzLkJ1ZjE2KCgyICogRF9DT0RFUyArIDEpICogMik7XG4gIHRoaXMuYmxfdHJlZSAgICA9IG5ldyB1dGlscy5CdWYxNigoMiAqIEJMX0NPREVTICsgMSkgKiAyKTtcbiAgemVybyh0aGlzLmR5bl9sdHJlZSk7XG4gIHplcm8odGhpcy5keW5fZHRyZWUpO1xuICB6ZXJvKHRoaXMuYmxfdHJlZSk7XG5cbiAgdGhpcy5sX2Rlc2MgICA9IG51bGw7ICAgICAgICAgLyogZGVzYy4gZm9yIGxpdGVyYWwgdHJlZSAqL1xuICB0aGlzLmRfZGVzYyAgID0gbnVsbDsgICAgICAgICAvKiBkZXNjLiBmb3IgZGlzdGFuY2UgdHJlZSAqL1xuICB0aGlzLmJsX2Rlc2MgID0gbnVsbDsgICAgICAgICAvKiBkZXNjLiBmb3IgYml0IGxlbmd0aCB0cmVlICovXG5cbiAgLy91c2ggYmxfY291bnRbTUFYX0JJVFMrMV07XG4gIHRoaXMuYmxfY291bnQgPSBuZXcgdXRpbHMuQnVmMTYoTUFYX0JJVFMgKyAxKTtcbiAgLyogbnVtYmVyIG9mIGNvZGVzIGF0IGVhY2ggYml0IGxlbmd0aCBmb3IgYW4gb3B0aW1hbCB0cmVlICovXG5cbiAgLy9pbnQgaGVhcFsyKkxfQ09ERVMrMV07ICAgICAgLyogaGVhcCB1c2VkIHRvIGJ1aWxkIHRoZSBIdWZmbWFuIHRyZWVzICovXG4gIHRoaXMuaGVhcCA9IG5ldyB1dGlscy5CdWYxNigyICogTF9DT0RFUyArIDEpOyAgLyogaGVhcCB1c2VkIHRvIGJ1aWxkIHRoZSBIdWZmbWFuIHRyZWVzICovXG4gIHplcm8odGhpcy5oZWFwKTtcblxuICB0aGlzLmhlYXBfbGVuID0gMDsgICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIGhlYXAgKi9cbiAgdGhpcy5oZWFwX21heCA9IDA7ICAgICAgICAgICAgICAgLyogZWxlbWVudCBvZiBsYXJnZXN0IGZyZXF1ZW5jeSAqL1xuICAvKiBUaGUgc29ucyBvZiBoZWFwW25dIGFyZSBoZWFwWzIqbl0gYW5kIGhlYXBbMipuKzFdLiBoZWFwWzBdIGlzIG5vdCB1c2VkLlxuICAgKiBUaGUgc2FtZSBoZWFwIGFycmF5IGlzIHVzZWQgdG8gYnVpbGQgYWxsIHRyZWVzLlxuICAgKi9cblxuICB0aGlzLmRlcHRoID0gbmV3IHV0aWxzLkJ1ZjE2KDIgKiBMX0NPREVTICsgMSk7IC8vdWNoIGRlcHRoWzIqTF9DT0RFUysxXTtcbiAgemVybyh0aGlzLmRlcHRoKTtcbiAgLyogRGVwdGggb2YgZWFjaCBzdWJ0cmVlIHVzZWQgYXMgdGllIGJyZWFrZXIgZm9yIHRyZWVzIG9mIGVxdWFsIGZyZXF1ZW5jeVxuICAgKi9cblxuICB0aGlzLmxfYnVmID0gMDsgICAgICAgICAgLyogYnVmZmVyIGluZGV4IGZvciBsaXRlcmFscyBvciBsZW5ndGhzICovXG5cbiAgdGhpcy5saXRfYnVmc2l6ZSA9IDA7XG4gIC8qIFNpemUgb2YgbWF0Y2ggYnVmZmVyIGZvciBsaXRlcmFscy9sZW5ndGhzLiAgVGhlcmUgYXJlIDQgcmVhc29ucyBmb3JcbiAgICogbGltaXRpbmcgbGl0X2J1ZnNpemUgdG8gNjRLOlxuICAgKiAgIC0gZnJlcXVlbmNpZXMgY2FuIGJlIGtlcHQgaW4gMTYgYml0IGNvdW50ZXJzXG4gICAqICAgLSBpZiBjb21wcmVzc2lvbiBpcyBub3Qgc3VjY2Vzc2Z1bCBmb3IgdGhlIGZpcnN0IGJsb2NrLCBhbGwgaW5wdXRcbiAgICogICAgIGRhdGEgaXMgc3RpbGwgaW4gdGhlIHdpbmRvdyBzbyB3ZSBjYW4gc3RpbGwgZW1pdCBhIHN0b3JlZCBibG9jayBldmVuXG4gICAqICAgICB3aGVuIGlucHV0IGNvbWVzIGZyb20gc3RhbmRhcmQgaW5wdXQuICAoVGhpcyBjYW4gYWxzbyBiZSBkb25lIGZvclxuICAgKiAgICAgYWxsIGJsb2NrcyBpZiBsaXRfYnVmc2l6ZSBpcyBub3QgZ3JlYXRlciB0aGFuIDMySy4pXG4gICAqICAgLSBpZiBjb21wcmVzc2lvbiBpcyBub3Qgc3VjY2Vzc2Z1bCBmb3IgYSBmaWxlIHNtYWxsZXIgdGhhbiA2NEssIHdlIGNhblxuICAgKiAgICAgZXZlbiBlbWl0IGEgc3RvcmVkIGZpbGUgaW5zdGVhZCBvZiBhIHN0b3JlZCBibG9jayAoc2F2aW5nIDUgYnl0ZXMpLlxuICAgKiAgICAgVGhpcyBpcyBhcHBsaWNhYmxlIG9ubHkgZm9yIHppcCAobm90IGd6aXAgb3IgemxpYikuXG4gICAqICAgLSBjcmVhdGluZyBuZXcgSHVmZm1hbiB0cmVlcyBsZXNzIGZyZXF1ZW50bHkgbWF5IG5vdCBwcm92aWRlIGZhc3RcbiAgICogICAgIGFkYXB0YXRpb24gdG8gY2hhbmdlcyBpbiB0aGUgaW5wdXQgZGF0YSBzdGF0aXN0aWNzLiAoVGFrZSBmb3JcbiAgICogICAgIGV4YW1wbGUgYSBiaW5hcnkgZmlsZSB3aXRoIHBvb3JseSBjb21wcmVzc2libGUgY29kZSBmb2xsb3dlZCBieVxuICAgKiAgICAgYSBoaWdobHkgY29tcHJlc3NpYmxlIHN0cmluZyB0YWJsZS4pIFNtYWxsZXIgYnVmZmVyIHNpemVzIGdpdmVcbiAgICogICAgIGZhc3QgYWRhcHRhdGlvbiBidXQgaGF2ZSBvZiBjb3Vyc2UgdGhlIG92ZXJoZWFkIG9mIHRyYW5zbWl0dGluZ1xuICAgKiAgICAgdHJlZXMgbW9yZSBmcmVxdWVudGx5LlxuICAgKiAgIC0gSSBjYW4ndCBjb3VudCBhYm92ZSA0XG4gICAqL1xuXG4gIHRoaXMubGFzdF9saXQgPSAwOyAgICAgIC8qIHJ1bm5pbmcgaW5kZXggaW4gbF9idWYgKi9cblxuICB0aGlzLmRfYnVmID0gMDtcbiAgLyogQnVmZmVyIGluZGV4IGZvciBkaXN0YW5jZXMuIFRvIHNpbXBsaWZ5IHRoZSBjb2RlLCBkX2J1ZiBhbmQgbF9idWYgaGF2ZVxuICAgKiB0aGUgc2FtZSBudW1iZXIgb2YgZWxlbWVudHMuIFRvIHVzZSBkaWZmZXJlbnQgbGVuZ3RocywgYW4gZXh0cmEgZmxhZ1xuICAgKiBhcnJheSB3b3VsZCBiZSBuZWNlc3NhcnkuXG4gICAqL1xuXG4gIHRoaXMub3B0X2xlbiA9IDA7ICAgICAgIC8qIGJpdCBsZW5ndGggb2YgY3VycmVudCBibG9jayB3aXRoIG9wdGltYWwgdHJlZXMgKi9cbiAgdGhpcy5zdGF0aWNfbGVuID0gMDsgICAgLyogYml0IGxlbmd0aCBvZiBjdXJyZW50IGJsb2NrIHdpdGggc3RhdGljIHRyZWVzICovXG4gIHRoaXMubWF0Y2hlcyA9IDA7ICAgICAgIC8qIG51bWJlciBvZiBzdHJpbmcgbWF0Y2hlcyBpbiBjdXJyZW50IGJsb2NrICovXG4gIHRoaXMuaW5zZXJ0ID0gMDsgICAgICAgIC8qIGJ5dGVzIGF0IGVuZCBvZiB3aW5kb3cgbGVmdCB0byBpbnNlcnQgKi9cblxuXG4gIHRoaXMuYmlfYnVmID0gMDtcbiAgLyogT3V0cHV0IGJ1ZmZlci4gYml0cyBhcmUgaW5zZXJ0ZWQgc3RhcnRpbmcgYXQgdGhlIGJvdHRvbSAobGVhc3RcbiAgICogc2lnbmlmaWNhbnQgYml0cykuXG4gICAqL1xuICB0aGlzLmJpX3ZhbGlkID0gMDtcbiAgLyogTnVtYmVyIG9mIHZhbGlkIGJpdHMgaW4gYmlfYnVmLiAgQWxsIGJpdHMgYWJvdmUgdGhlIGxhc3QgdmFsaWQgYml0XG4gICAqIGFyZSBhbHdheXMgemVyby5cbiAgICovXG5cbiAgLy8gVXNlZCBmb3Igd2luZG93IG1lbW9yeSBpbml0LiBXZSBzYWZlbHkgaWdub3JlIGl0IGZvciBKUy4gVGhhdCBtYWtlc1xuICAvLyBzZW5zZSBvbmx5IGZvciBwb2ludGVycyBhbmQgbWVtb3J5IGNoZWNrIHRvb2xzLlxuICAvL3RoaXMuaGlnaF93YXRlciA9IDA7XG4gIC8qIEhpZ2ggd2F0ZXIgbWFyayBvZmZzZXQgaW4gd2luZG93IGZvciBpbml0aWFsaXplZCBieXRlcyAtLSBieXRlcyBhYm92ZVxuICAgKiB0aGlzIGFyZSBzZXQgdG8gemVybyBpbiBvcmRlciB0byBhdm9pZCBtZW1vcnkgY2hlY2sgd2FybmluZ3Mgd2hlblxuICAgKiBsb25nZXN0IG1hdGNoIHJvdXRpbmVzIGFjY2VzcyBieXRlcyBwYXN0IHRoZSBpbnB1dC4gIFRoaXMgaXMgdGhlblxuICAgKiB1cGRhdGVkIHRvIHRoZSBuZXcgaGlnaCB3YXRlciBtYXJrLlxuICAgKi9cbn1cblxuXG5mdW5jdGlvbiBkZWZsYXRlUmVzZXRLZWVwKHN0cm0pIHtcbiAgdmFyIHM7XG5cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7XG4gICAgcmV0dXJuIGVycihzdHJtLCBaX1NUUkVBTV9FUlJPUik7XG4gIH1cblxuICBzdHJtLnRvdGFsX2luID0gc3RybS50b3RhbF9vdXQgPSAwO1xuICBzdHJtLmRhdGFfdHlwZSA9IFpfVU5LTk9XTjtcblxuICBzID0gc3RybS5zdGF0ZTtcbiAgcy5wZW5kaW5nID0gMDtcbiAgcy5wZW5kaW5nX291dCA9IDA7XG5cbiAgaWYgKHMud3JhcCA8IDApIHtcbiAgICBzLndyYXAgPSAtcy53cmFwO1xuICAgIC8qIHdhcyBtYWRlIG5lZ2F0aXZlIGJ5IGRlZmxhdGUoLi4uLCBaX0ZJTklTSCk7ICovXG4gIH1cbiAgcy5zdGF0dXMgPSAocy53cmFwID8gSU5JVF9TVEFURSA6IEJVU1lfU1RBVEUpO1xuICBzdHJtLmFkbGVyID0gKHMud3JhcCA9PT0gMikgP1xuICAgIDAgIC8vIGNyYzMyKDAsIFpfTlVMTCwgMClcbiAgOlxuICAgIDE7IC8vIGFkbGVyMzIoMCwgWl9OVUxMLCAwKVxuICBzLmxhc3RfZmx1c2ggPSBaX05PX0ZMVVNIO1xuICB0cmVlcy5fdHJfaW5pdChzKTtcbiAgcmV0dXJuIFpfT0s7XG59XG5cblxuZnVuY3Rpb24gZGVmbGF0ZVJlc2V0KHN0cm0pIHtcbiAgdmFyIHJldCA9IGRlZmxhdGVSZXNldEtlZXAoc3RybSk7XG4gIGlmIChyZXQgPT09IFpfT0spIHtcbiAgICBsbV9pbml0KHN0cm0uc3RhdGUpO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cblxuZnVuY3Rpb24gZGVmbGF0ZVNldEhlYWRlcihzdHJtLCBoZWFkKSB7XG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkgeyByZXR1cm4gWl9TVFJFQU1fRVJST1I7IH1cbiAgaWYgKHN0cm0uc3RhdGUud3JhcCAhPT0gMikgeyByZXR1cm4gWl9TVFJFQU1fRVJST1I7IH1cbiAgc3RybS5zdGF0ZS5nemhlYWQgPSBoZWFkO1xuICByZXR1cm4gWl9PSztcbn1cblxuXG5mdW5jdGlvbiBkZWZsYXRlSW5pdDIoc3RybSwgbGV2ZWwsIG1ldGhvZCwgd2luZG93Qml0cywgbWVtTGV2ZWwsIHN0cmF0ZWd5KSB7XG4gIGlmICghc3RybSkgeyAvLyA9PT0gWl9OVUxMXG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICB9XG4gIHZhciB3cmFwID0gMTtcblxuICBpZiAobGV2ZWwgPT09IFpfREVGQVVMVF9DT01QUkVTU0lPTikge1xuICAgIGxldmVsID0gNjtcbiAgfVxuXG4gIGlmICh3aW5kb3dCaXRzIDwgMCkgeyAvKiBzdXBwcmVzcyB6bGliIHdyYXBwZXIgKi9cbiAgICB3cmFwID0gMDtcbiAgICB3aW5kb3dCaXRzID0gLXdpbmRvd0JpdHM7XG4gIH1cblxuICBlbHNlIGlmICh3aW5kb3dCaXRzID4gMTUpIHtcbiAgICB3cmFwID0gMjsgICAgICAgICAgIC8qIHdyaXRlIGd6aXAgd3JhcHBlciBpbnN0ZWFkICovXG4gICAgd2luZG93Qml0cyAtPSAxNjtcbiAgfVxuXG5cbiAgaWYgKG1lbUxldmVsIDwgMSB8fCBtZW1MZXZlbCA+IE1BWF9NRU1fTEVWRUwgfHwgbWV0aG9kICE9PSBaX0RFRkxBVEVEIHx8XG4gICAgd2luZG93Qml0cyA8IDggfHwgd2luZG93Qml0cyA+IDE1IHx8IGxldmVsIDwgMCB8fCBsZXZlbCA+IDkgfHxcbiAgICBzdHJhdGVneSA8IDAgfHwgc3RyYXRlZ3kgPiBaX0ZJWEVEKSB7XG4gICAgcmV0dXJuIGVycihzdHJtLCBaX1NUUkVBTV9FUlJPUik7XG4gIH1cblxuXG4gIGlmICh3aW5kb3dCaXRzID09PSA4KSB7XG4gICAgd2luZG93Qml0cyA9IDk7XG4gIH1cbiAgLyogdW50aWwgMjU2LWJ5dGUgd2luZG93IGJ1ZyBmaXhlZCAqL1xuXG4gIHZhciBzID0gbmV3IERlZmxhdGVTdGF0ZSgpO1xuXG4gIHN0cm0uc3RhdGUgPSBzO1xuICBzLnN0cm0gPSBzdHJtO1xuXG4gIHMud3JhcCA9IHdyYXA7XG4gIHMuZ3poZWFkID0gbnVsbDtcbiAgcy53X2JpdHMgPSB3aW5kb3dCaXRzO1xuICBzLndfc2l6ZSA9IDEgPDwgcy53X2JpdHM7XG4gIHMud19tYXNrID0gcy53X3NpemUgLSAxO1xuXG4gIHMuaGFzaF9iaXRzID0gbWVtTGV2ZWwgKyA3O1xuICBzLmhhc2hfc2l6ZSA9IDEgPDwgcy5oYXNoX2JpdHM7XG4gIHMuaGFzaF9tYXNrID0gcy5oYXNoX3NpemUgLSAxO1xuICBzLmhhc2hfc2hpZnQgPSB+figocy5oYXNoX2JpdHMgKyBNSU5fTUFUQ0ggLSAxKSAvIE1JTl9NQVRDSCk7XG5cbiAgcy53aW5kb3cgPSBuZXcgdXRpbHMuQnVmOChzLndfc2l6ZSAqIDIpO1xuICBzLmhlYWQgPSBuZXcgdXRpbHMuQnVmMTYocy5oYXNoX3NpemUpO1xuICBzLnByZXYgPSBuZXcgdXRpbHMuQnVmMTYocy53X3NpemUpO1xuXG4gIC8vIERvbid0IG5lZWQgbWVtIGluaXQgbWFnaWMgZm9yIEpTLlxuICAvL3MuaGlnaF93YXRlciA9IDA7ICAvKiBub3RoaW5nIHdyaXR0ZW4gdG8gcy0+d2luZG93IHlldCAqL1xuXG4gIHMubGl0X2J1ZnNpemUgPSAxIDw8IChtZW1MZXZlbCArIDYpOyAvKiAxNksgZWxlbWVudHMgYnkgZGVmYXVsdCAqL1xuXG4gIHMucGVuZGluZ19idWZfc2l6ZSA9IHMubGl0X2J1ZnNpemUgKiA0O1xuXG4gIC8vb3ZlcmxheSA9ICh1c2hmICopIFpBTExPQyhzdHJtLCBzLT5saXRfYnVmc2l6ZSwgc2l6ZW9mKHVzaCkrMik7XG4gIC8vcy0+cGVuZGluZ19idWYgPSAodWNoZiAqKSBvdmVybGF5O1xuICBzLnBlbmRpbmdfYnVmID0gbmV3IHV0aWxzLkJ1Zjgocy5wZW5kaW5nX2J1Zl9zaXplKTtcblxuICAvLyBJdCBpcyBvZmZzZXQgZnJvbSBgcy5wZW5kaW5nX2J1ZmAgKHNpemUgaXMgYHMubGl0X2J1ZnNpemUgKiAyYClcbiAgLy9zLT5kX2J1ZiA9IG92ZXJsYXkgKyBzLT5saXRfYnVmc2l6ZS9zaXplb2YodXNoKTtcbiAgcy5kX2J1ZiA9IDEgKiBzLmxpdF9idWZzaXplO1xuXG4gIC8vcy0+bF9idWYgPSBzLT5wZW5kaW5nX2J1ZiArICgxK3NpemVvZih1c2gpKSpzLT5saXRfYnVmc2l6ZTtcbiAgcy5sX2J1ZiA9ICgxICsgMikgKiBzLmxpdF9idWZzaXplO1xuXG4gIHMubGV2ZWwgPSBsZXZlbDtcbiAgcy5zdHJhdGVneSA9IHN0cmF0ZWd5O1xuICBzLm1ldGhvZCA9IG1ldGhvZDtcblxuICByZXR1cm4gZGVmbGF0ZVJlc2V0KHN0cm0pO1xufVxuXG5mdW5jdGlvbiBkZWZsYXRlSW5pdChzdHJtLCBsZXZlbCkge1xuICByZXR1cm4gZGVmbGF0ZUluaXQyKHN0cm0sIGxldmVsLCBaX0RFRkxBVEVELCBNQVhfV0JJVFMsIERFRl9NRU1fTEVWRUwsIFpfREVGQVVMVF9TVFJBVEVHWSk7XG59XG5cblxuZnVuY3Rpb24gZGVmbGF0ZShzdHJtLCBmbHVzaCkge1xuICB2YXIgb2xkX2ZsdXNoLCBzO1xuICB2YXIgYmVnLCB2YWw7IC8vIGZvciBnemlwIGhlYWRlciB3cml0ZSBvbmx5XG5cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlIHx8XG4gICAgZmx1c2ggPiBaX0JMT0NLIHx8IGZsdXNoIDwgMCkge1xuICAgIHJldHVybiBzdHJtID8gZXJyKHN0cm0sIFpfU1RSRUFNX0VSUk9SKSA6IFpfU1RSRUFNX0VSUk9SO1xuICB9XG5cbiAgcyA9IHN0cm0uc3RhdGU7XG5cbiAgaWYgKCFzdHJtLm91dHB1dCB8fFxuICAgICAgKCFzdHJtLmlucHV0ICYmIHN0cm0uYXZhaWxfaW4gIT09IDApIHx8XG4gICAgICAocy5zdGF0dXMgPT09IEZJTklTSF9TVEFURSAmJiBmbHVzaCAhPT0gWl9GSU5JU0gpKSB7XG4gICAgcmV0dXJuIGVycihzdHJtLCAoc3RybS5hdmFpbF9vdXQgPT09IDApID8gWl9CVUZfRVJST1IgOiBaX1NUUkVBTV9FUlJPUik7XG4gIH1cblxuICBzLnN0cm0gPSBzdHJtOyAvKiBqdXN0IGluIGNhc2UgKi9cbiAgb2xkX2ZsdXNoID0gcy5sYXN0X2ZsdXNoO1xuICBzLmxhc3RfZmx1c2ggPSBmbHVzaDtcblxuICAvKiBXcml0ZSB0aGUgaGVhZGVyICovXG4gIGlmIChzLnN0YXR1cyA9PT0gSU5JVF9TVEFURSkge1xuXG4gICAgaWYgKHMud3JhcCA9PT0gMikgeyAvLyBHWklQIGhlYWRlclxuICAgICAgc3RybS5hZGxlciA9IDA7ICAvL2NyYzMyKDBMLCBaX05VTEwsIDApO1xuICAgICAgcHV0X2J5dGUocywgMzEpO1xuICAgICAgcHV0X2J5dGUocywgMTM5KTtcbiAgICAgIHB1dF9ieXRlKHMsIDgpO1xuICAgICAgaWYgKCFzLmd6aGVhZCkgeyAvLyBzLT5nemhlYWQgPT0gWl9OVUxMXG4gICAgICAgIHB1dF9ieXRlKHMsIDApO1xuICAgICAgICBwdXRfYnl0ZShzLCAwKTtcbiAgICAgICAgcHV0X2J5dGUocywgMCk7XG4gICAgICAgIHB1dF9ieXRlKHMsIDApO1xuICAgICAgICBwdXRfYnl0ZShzLCAwKTtcbiAgICAgICAgcHV0X2J5dGUocywgcy5sZXZlbCA9PT0gOSA/IDIgOlxuICAgICAgICAgICAgICAgICAgICAocy5zdHJhdGVneSA+PSBaX0hVRkZNQU5fT05MWSB8fCBzLmxldmVsIDwgMiA/XG4gICAgICAgICAgICAgICAgICAgICA0IDogMCkpO1xuICAgICAgICBwdXRfYnl0ZShzLCBPU19DT0RFKTtcbiAgICAgICAgcy5zdGF0dXMgPSBCVVNZX1NUQVRFO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHB1dF9ieXRlKHMsIChzLmd6aGVhZC50ZXh0ID8gMSA6IDApICtcbiAgICAgICAgICAgICAgICAgICAgKHMuZ3poZWFkLmhjcmMgPyAyIDogMCkgK1xuICAgICAgICAgICAgICAgICAgICAoIXMuZ3poZWFkLmV4dHJhID8gMCA6IDQpICtcbiAgICAgICAgICAgICAgICAgICAgKCFzLmd6aGVhZC5uYW1lID8gMCA6IDgpICtcbiAgICAgICAgICAgICAgICAgICAgKCFzLmd6aGVhZC5jb21tZW50ID8gMCA6IDE2KVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgIHB1dF9ieXRlKHMsIHMuZ3poZWFkLnRpbWUgJiAweGZmKTtcbiAgICAgICAgcHV0X2J5dGUocywgKHMuZ3poZWFkLnRpbWUgPj4gOCkgJiAweGZmKTtcbiAgICAgICAgcHV0X2J5dGUocywgKHMuZ3poZWFkLnRpbWUgPj4gMTYpICYgMHhmZik7XG4gICAgICAgIHB1dF9ieXRlKHMsIChzLmd6aGVhZC50aW1lID4+IDI0KSAmIDB4ZmYpO1xuICAgICAgICBwdXRfYnl0ZShzLCBzLmxldmVsID09PSA5ID8gMiA6XG4gICAgICAgICAgICAgICAgICAgIChzLnN0cmF0ZWd5ID49IFpfSFVGRk1BTl9PTkxZIHx8IHMubGV2ZWwgPCAyID9cbiAgICAgICAgICAgICAgICAgICAgIDQgOiAwKSk7XG4gICAgICAgIHB1dF9ieXRlKHMsIHMuZ3poZWFkLm9zICYgMHhmZik7XG4gICAgICAgIGlmIChzLmd6aGVhZC5leHRyYSAmJiBzLmd6aGVhZC5leHRyYS5sZW5ndGgpIHtcbiAgICAgICAgICBwdXRfYnl0ZShzLCBzLmd6aGVhZC5leHRyYS5sZW5ndGggJiAweGZmKTtcbiAgICAgICAgICBwdXRfYnl0ZShzLCAocy5nemhlYWQuZXh0cmEubGVuZ3RoID4+IDgpICYgMHhmZik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHMuZ3poZWFkLmhjcmMpIHtcbiAgICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nLCAwKTtcbiAgICAgICAgfVxuICAgICAgICBzLmd6aW5kZXggPSAwO1xuICAgICAgICBzLnN0YXR1cyA9IEVYVFJBX1NUQVRFO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIC8vIERFRkxBVEUgaGVhZGVyXG4gICAge1xuICAgICAgdmFyIGhlYWRlciA9IChaX0RFRkxBVEVEICsgKChzLndfYml0cyAtIDgpIDw8IDQpKSA8PCA4O1xuICAgICAgdmFyIGxldmVsX2ZsYWdzID0gLTE7XG5cbiAgICAgIGlmIChzLnN0cmF0ZWd5ID49IFpfSFVGRk1BTl9PTkxZIHx8IHMubGV2ZWwgPCAyKSB7XG4gICAgICAgIGxldmVsX2ZsYWdzID0gMDtcbiAgICAgIH0gZWxzZSBpZiAocy5sZXZlbCA8IDYpIHtcbiAgICAgICAgbGV2ZWxfZmxhZ3MgPSAxO1xuICAgICAgfSBlbHNlIGlmIChzLmxldmVsID09PSA2KSB7XG4gICAgICAgIGxldmVsX2ZsYWdzID0gMjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldmVsX2ZsYWdzID0gMztcbiAgICAgIH1cbiAgICAgIGhlYWRlciB8PSAobGV2ZWxfZmxhZ3MgPDwgNik7XG4gICAgICBpZiAocy5zdHJzdGFydCAhPT0gMCkgeyBoZWFkZXIgfD0gUFJFU0VUX0RJQ1Q7IH1cbiAgICAgIGhlYWRlciArPSAzMSAtIChoZWFkZXIgJSAzMSk7XG5cbiAgICAgIHMuc3RhdHVzID0gQlVTWV9TVEFURTtcbiAgICAgIHB1dFNob3J0TVNCKHMsIGhlYWRlcik7XG5cbiAgICAgIC8qIFNhdmUgdGhlIGFkbGVyMzIgb2YgdGhlIHByZXNldCBkaWN0aW9uYXJ5OiAqL1xuICAgICAgaWYgKHMuc3Ryc3RhcnQgIT09IDApIHtcbiAgICAgICAgcHV0U2hvcnRNU0Iocywgc3RybS5hZGxlciA+Pj4gMTYpO1xuICAgICAgICBwdXRTaG9ydE1TQihzLCBzdHJtLmFkbGVyICYgMHhmZmZmKTtcbiAgICAgIH1cbiAgICAgIHN0cm0uYWRsZXIgPSAxOyAvLyBhZGxlcjMyKDBMLCBaX05VTEwsIDApO1xuICAgIH1cbiAgfVxuXG4vLyNpZmRlZiBHWklQXG4gIGlmIChzLnN0YXR1cyA9PT0gRVhUUkFfU1RBVEUpIHtcbiAgICBpZiAocy5nemhlYWQuZXh0cmEvKiAhPSBaX05VTEwqLykge1xuICAgICAgYmVnID0gcy5wZW5kaW5nOyAgLyogc3RhcnQgb2YgYnl0ZXMgdG8gdXBkYXRlIGNyYyAqL1xuXG4gICAgICB3aGlsZSAocy5nemluZGV4IDwgKHMuZ3poZWFkLmV4dHJhLmxlbmd0aCAmIDB4ZmZmZikpIHtcbiAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7XG4gICAgICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAgICAgICAgIGJlZyA9IHMucGVuZGluZztcbiAgICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwdXRfYnl0ZShzLCBzLmd6aGVhZC5leHRyYVtzLmd6aW5kZXhdICYgMHhmZik7XG4gICAgICAgIHMuZ3ppbmRleCsrO1xuICAgICAgfVxuICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7XG4gICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7XG4gICAgICB9XG4gICAgICBpZiAocy5nemluZGV4ID09PSBzLmd6aGVhZC5leHRyYS5sZW5ndGgpIHtcbiAgICAgICAgcy5nemluZGV4ID0gMDtcbiAgICAgICAgcy5zdGF0dXMgPSBOQU1FX1NUQVRFO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHMuc3RhdHVzID0gTkFNRV9TVEFURTtcbiAgICB9XG4gIH1cbiAgaWYgKHMuc3RhdHVzID09PSBOQU1FX1NUQVRFKSB7XG4gICAgaWYgKHMuZ3poZWFkLm5hbWUvKiAhPSBaX05VTEwqLykge1xuICAgICAgYmVnID0gcy5wZW5kaW5nOyAgLyogc3RhcnQgb2YgYnl0ZXMgdG8gdXBkYXRlIGNyYyAqL1xuICAgICAgLy9pbnQgdmFsO1xuXG4gICAgICBkbyB7XG4gICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykge1xuICAgICAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgICAgICAgICBiZWcgPSBzLnBlbmRpbmc7XG4gICAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgICAgICB2YWwgPSAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEpTIHNwZWNpZmljOiBsaXR0bGUgbWFnaWMgdG8gYWRkIHplcm8gdGVybWluYXRvciB0byBlbmQgb2Ygc3RyaW5nXG4gICAgICAgIGlmIChzLmd6aW5kZXggPCBzLmd6aGVhZC5uYW1lLmxlbmd0aCkge1xuICAgICAgICAgIHZhbCA9IHMuZ3poZWFkLm5hbWUuY2hhckNvZGVBdChzLmd6aW5kZXgrKykgJiAweGZmO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcHV0X2J5dGUocywgdmFsKTtcbiAgICAgIH0gd2hpbGUgKHZhbCAhPT0gMCk7XG5cbiAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykge1xuICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpO1xuICAgICAgfVxuICAgICAgaWYgKHZhbCA9PT0gMCkge1xuICAgICAgICBzLmd6aW5kZXggPSAwO1xuICAgICAgICBzLnN0YXR1cyA9IENPTU1FTlRfU1RBVEU7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcy5zdGF0dXMgPSBDT01NRU5UX1NUQVRFO1xuICAgIH1cbiAgfVxuICBpZiAocy5zdGF0dXMgPT09IENPTU1FTlRfU1RBVEUpIHtcbiAgICBpZiAocy5nemhlYWQuY29tbWVudC8qICE9IFpfTlVMTCovKSB7XG4gICAgICBiZWcgPSBzLnBlbmRpbmc7ICAvKiBzdGFydCBvZiBieXRlcyB0byB1cGRhdGUgY3JjICovXG4gICAgICAvL2ludCB2YWw7XG5cbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7XG4gICAgICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAgICAgICAgIGJlZyA9IHMucGVuZGluZztcbiAgICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgICAgIHZhbCA9IDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSlMgc3BlY2lmaWM6IGxpdHRsZSBtYWdpYyB0byBhZGQgemVybyB0ZXJtaW5hdG9yIHRvIGVuZCBvZiBzdHJpbmdcbiAgICAgICAgaWYgKHMuZ3ppbmRleCA8IHMuZ3poZWFkLmNvbW1lbnQubGVuZ3RoKSB7XG4gICAgICAgICAgdmFsID0gcy5nemhlYWQuY29tbWVudC5jaGFyQ29kZUF0KHMuZ3ppbmRleCsrKSAmIDB4ZmY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsID0gMDtcbiAgICAgICAgfVxuICAgICAgICBwdXRfYnl0ZShzLCB2YWwpO1xuICAgICAgfSB3aGlsZSAodmFsICE9PSAwKTtcblxuICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7XG4gICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7XG4gICAgICB9XG4gICAgICBpZiAodmFsID09PSAwKSB7XG4gICAgICAgIHMuc3RhdHVzID0gSENSQ19TVEFURTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBzLnN0YXR1cyA9IEhDUkNfU1RBVEU7XG4gICAgfVxuICB9XG4gIGlmIChzLnN0YXR1cyA9PT0gSENSQ19TVEFURSkge1xuICAgIGlmIChzLmd6aGVhZC5oY3JjKSB7XG4gICAgICBpZiAocy5wZW5kaW5nICsgMiA+IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAgICAgfVxuICAgICAgaWYgKHMucGVuZGluZyArIDIgPD0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgIHB1dF9ieXRlKHMsIHN0cm0uYWRsZXIgJiAweGZmKTtcbiAgICAgICAgcHV0X2J5dGUocywgKHN0cm0uYWRsZXIgPj4gOCkgJiAweGZmKTtcbiAgICAgICAgc3RybS5hZGxlciA9IDA7IC8vY3JjMzIoMEwsIFpfTlVMTCwgMCk7XG4gICAgICAgIHMuc3RhdHVzID0gQlVTWV9TVEFURTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBzLnN0YXR1cyA9IEJVU1lfU1RBVEU7XG4gICAgfVxuICB9XG4vLyNlbmRpZlxuXG4gIC8qIEZsdXNoIGFzIG11Y2ggcGVuZGluZyBvdXRwdXQgYXMgcG9zc2libGUgKi9cbiAgaWYgKHMucGVuZGluZyAhPT0gMCkge1xuICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAvKiBTaW5jZSBhdmFpbF9vdXQgaXMgMCwgZGVmbGF0ZSB3aWxsIGJlIGNhbGxlZCBhZ2FpbiB3aXRoXG4gICAgICAgKiBtb3JlIG91dHB1dCBzcGFjZSwgYnV0IHBvc3NpYmx5IHdpdGggYm90aCBwZW5kaW5nIGFuZFxuICAgICAgICogYXZhaWxfaW4gZXF1YWwgdG8gemVyby4gVGhlcmUgd29uJ3QgYmUgYW55dGhpbmcgdG8gZG8sXG4gICAgICAgKiBidXQgdGhpcyBpcyBub3QgYW4gZXJyb3Igc2l0dWF0aW9uIHNvIG1ha2Ugc3VyZSB3ZVxuICAgICAgICogcmV0dXJuIE9LIGluc3RlYWQgb2YgQlVGX0VSUk9SIGF0IG5leHQgY2FsbCBvZiBkZWZsYXRlOlxuICAgICAgICovXG4gICAgICBzLmxhc3RfZmx1c2ggPSAtMTtcbiAgICAgIHJldHVybiBaX09LO1xuICAgIH1cblxuICAgIC8qIE1ha2Ugc3VyZSB0aGVyZSBpcyBzb21ldGhpbmcgdG8gZG8gYW5kIGF2b2lkIGR1cGxpY2F0ZSBjb25zZWN1dGl2ZVxuICAgICAqIGZsdXNoZXMuIEZvciByZXBlYXRlZCBhbmQgdXNlbGVzcyBjYWxscyB3aXRoIFpfRklOSVNILCB3ZSBrZWVwXG4gICAgICogcmV0dXJuaW5nIFpfU1RSRUFNX0VORCBpbnN0ZWFkIG9mIFpfQlVGX0VSUk9SLlxuICAgICAqL1xuICB9IGVsc2UgaWYgKHN0cm0uYXZhaWxfaW4gPT09IDAgJiYgcmFuayhmbHVzaCkgPD0gcmFuayhvbGRfZmx1c2gpICYmXG4gICAgZmx1c2ggIT09IFpfRklOSVNIKSB7XG4gICAgcmV0dXJuIGVycihzdHJtLCBaX0JVRl9FUlJPUik7XG4gIH1cblxuICAvKiBVc2VyIG11c3Qgbm90IHByb3ZpZGUgbW9yZSBpbnB1dCBhZnRlciB0aGUgZmlyc3QgRklOSVNIOiAqL1xuICBpZiAocy5zdGF0dXMgPT09IEZJTklTSF9TVEFURSAmJiBzdHJtLmF2YWlsX2luICE9PSAwKSB7XG4gICAgcmV0dXJuIGVycihzdHJtLCBaX0JVRl9FUlJPUik7XG4gIH1cblxuICAvKiBTdGFydCBhIG5ldyBibG9jayBvciBjb250aW51ZSB0aGUgY3VycmVudCBvbmUuXG4gICAqL1xuICBpZiAoc3RybS5hdmFpbF9pbiAhPT0gMCB8fCBzLmxvb2thaGVhZCAhPT0gMCB8fFxuICAgIChmbHVzaCAhPT0gWl9OT19GTFVTSCAmJiBzLnN0YXR1cyAhPT0gRklOSVNIX1NUQVRFKSkge1xuICAgIHZhciBic3RhdGUgPSAocy5zdHJhdGVneSA9PT0gWl9IVUZGTUFOX09OTFkpID8gZGVmbGF0ZV9odWZmKHMsIGZsdXNoKSA6XG4gICAgICAocy5zdHJhdGVneSA9PT0gWl9STEUgPyBkZWZsYXRlX3JsZShzLCBmbHVzaCkgOlxuICAgICAgICBjb25maWd1cmF0aW9uX3RhYmxlW3MubGV2ZWxdLmZ1bmMocywgZmx1c2gpKTtcblxuICAgIGlmIChic3RhdGUgPT09IEJTX0ZJTklTSF9TVEFSVEVEIHx8IGJzdGF0ZSA9PT0gQlNfRklOSVNIX0RPTkUpIHtcbiAgICAgIHMuc3RhdHVzID0gRklOSVNIX1NUQVRFO1xuICAgIH1cbiAgICBpZiAoYnN0YXRlID09PSBCU19ORUVEX01PUkUgfHwgYnN0YXRlID09PSBCU19GSU5JU0hfU1RBUlRFRCkge1xuICAgICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHMubGFzdF9mbHVzaCA9IC0xO1xuICAgICAgICAvKiBhdm9pZCBCVUZfRVJST1IgbmV4dCBjYWxsLCBzZWUgYWJvdmUgKi9cbiAgICAgIH1cbiAgICAgIHJldHVybiBaX09LO1xuICAgICAgLyogSWYgZmx1c2ggIT0gWl9OT19GTFVTSCAmJiBhdmFpbF9vdXQgPT0gMCwgdGhlIG5leHQgY2FsbFxuICAgICAgICogb2YgZGVmbGF0ZSBzaG91bGQgdXNlIHRoZSBzYW1lIGZsdXNoIHBhcmFtZXRlciB0byBtYWtlIHN1cmVcbiAgICAgICAqIHRoYXQgdGhlIGZsdXNoIGlzIGNvbXBsZXRlLiBTbyB3ZSBkb24ndCBoYXZlIHRvIG91dHB1dCBhblxuICAgICAgICogZW1wdHkgYmxvY2sgaGVyZSwgdGhpcyB3aWxsIGJlIGRvbmUgYXQgbmV4dCBjYWxsLiBUaGlzIGFsc29cbiAgICAgICAqIGVuc3VyZXMgdGhhdCBmb3IgYSB2ZXJ5IHNtYWxsIG91dHB1dCBidWZmZXIsIHdlIGVtaXQgYXQgbW9zdFxuICAgICAgICogb25lIGVtcHR5IGJsb2NrLlxuICAgICAgICovXG4gICAgfVxuICAgIGlmIChic3RhdGUgPT09IEJTX0JMT0NLX0RPTkUpIHtcbiAgICAgIGlmIChmbHVzaCA9PT0gWl9QQVJUSUFMX0ZMVVNIKSB7XG4gICAgICAgIHRyZWVzLl90cl9hbGlnbihzKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGZsdXNoICE9PSBaX0JMT0NLKSB7IC8qIEZVTExfRkxVU0ggb3IgU1lOQ19GTFVTSCAqL1xuXG4gICAgICAgIHRyZWVzLl90cl9zdG9yZWRfYmxvY2socywgMCwgMCwgZmFsc2UpO1xuICAgICAgICAvKiBGb3IgYSBmdWxsIGZsdXNoLCB0aGlzIGVtcHR5IGJsb2NrIHdpbGwgYmUgcmVjb2duaXplZFxuICAgICAgICAgKiBhcyBhIHNwZWNpYWwgbWFya2VyIGJ5IGluZmxhdGVfc3luYygpLlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKGZsdXNoID09PSBaX0ZVTExfRkxVU0gpIHtcbiAgICAgICAgICAvKioqIENMRUFSX0hBU0gocyk7ICoqKi8gICAgICAgICAgICAgLyogZm9yZ2V0IGhpc3RvcnkgKi9cbiAgICAgICAgICB6ZXJvKHMuaGVhZCk7IC8vIEZpbGwgd2l0aCBOSUwgKD0gMCk7XG5cbiAgICAgICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHtcbiAgICAgICAgICAgIHMuc3Ryc3RhcnQgPSAwO1xuICAgICAgICAgICAgcy5ibG9ja19zdGFydCA9IDA7XG4gICAgICAgICAgICBzLmluc2VydCA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAgICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHMubGFzdF9mbHVzaCA9IC0xOyAvKiBhdm9pZCBCVUZfRVJST1IgYXQgbmV4dCBjYWxsLCBzZWUgYWJvdmUgKi9cbiAgICAgICAgcmV0dXJuIFpfT0s7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vQXNzZXJ0KHN0cm0tPmF2YWlsX291dCA+IDAsIFwiYnVnMlwiKTtcbiAgLy9pZiAoc3RybS5hdmFpbF9vdXQgPD0gMCkgeyB0aHJvdyBuZXcgRXJyb3IoXCJidWcyXCIpO31cblxuICBpZiAoZmx1c2ggIT09IFpfRklOSVNIKSB7IHJldHVybiBaX09LOyB9XG4gIGlmIChzLndyYXAgPD0gMCkgeyByZXR1cm4gWl9TVFJFQU1fRU5EOyB9XG5cbiAgLyogV3JpdGUgdGhlIHRyYWlsZXIgKi9cbiAgaWYgKHMud3JhcCA9PT0gMikge1xuICAgIHB1dF9ieXRlKHMsIHN0cm0uYWRsZXIgJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCAoc3RybS5hZGxlciA+PiA4KSAmIDB4ZmYpO1xuICAgIHB1dF9ieXRlKHMsIChzdHJtLmFkbGVyID4+IDE2KSAmIDB4ZmYpO1xuICAgIHB1dF9ieXRlKHMsIChzdHJtLmFkbGVyID4+IDI0KSAmIDB4ZmYpO1xuICAgIHB1dF9ieXRlKHMsIHN0cm0udG90YWxfaW4gJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCAoc3RybS50b3RhbF9pbiA+PiA4KSAmIDB4ZmYpO1xuICAgIHB1dF9ieXRlKHMsIChzdHJtLnRvdGFsX2luID4+IDE2KSAmIDB4ZmYpO1xuICAgIHB1dF9ieXRlKHMsIChzdHJtLnRvdGFsX2luID4+IDI0KSAmIDB4ZmYpO1xuICB9XG4gIGVsc2VcbiAge1xuICAgIHB1dFNob3J0TVNCKHMsIHN0cm0uYWRsZXIgPj4+IDE2KTtcbiAgICBwdXRTaG9ydE1TQihzLCBzdHJtLmFkbGVyICYgMHhmZmZmKTtcbiAgfVxuXG4gIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gIC8qIElmIGF2YWlsX291dCBpcyB6ZXJvLCB0aGUgYXBwbGljYXRpb24gd2lsbCBjYWxsIGRlZmxhdGUgYWdhaW5cbiAgICogdG8gZmx1c2ggdGhlIHJlc3QuXG4gICAqL1xuICBpZiAocy53cmFwID4gMCkgeyBzLndyYXAgPSAtcy53cmFwOyB9XG4gIC8qIHdyaXRlIHRoZSB0cmFpbGVyIG9ubHkgb25jZSEgKi9cbiAgcmV0dXJuIHMucGVuZGluZyAhPT0gMCA/IFpfT0sgOiBaX1NUUkVBTV9FTkQ7XG59XG5cbmZ1bmN0aW9uIGRlZmxhdGVFbmQoc3RybSkge1xuICB2YXIgc3RhdHVzO1xuXG4gIGlmICghc3RybS8qPT0gWl9OVUxMKi8gfHwgIXN0cm0uc3RhdGUvKj09IFpfTlVMTCovKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICB9XG5cbiAgc3RhdHVzID0gc3RybS5zdGF0ZS5zdGF0dXM7XG4gIGlmIChzdGF0dXMgIT09IElOSVRfU1RBVEUgJiZcbiAgICBzdGF0dXMgIT09IEVYVFJBX1NUQVRFICYmXG4gICAgc3RhdHVzICE9PSBOQU1FX1NUQVRFICYmXG4gICAgc3RhdHVzICE9PSBDT01NRU5UX1NUQVRFICYmXG4gICAgc3RhdHVzICE9PSBIQ1JDX1NUQVRFICYmXG4gICAgc3RhdHVzICE9PSBCVVNZX1NUQVRFICYmXG4gICAgc3RhdHVzICE9PSBGSU5JU0hfU1RBVEVcbiAgKSB7XG4gICAgcmV0dXJuIGVycihzdHJtLCBaX1NUUkVBTV9FUlJPUik7XG4gIH1cblxuICBzdHJtLnN0YXRlID0gbnVsbDtcblxuICByZXR1cm4gc3RhdHVzID09PSBCVVNZX1NUQVRFID8gZXJyKHN0cm0sIFpfREFUQV9FUlJPUikgOiBaX09LO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEluaXRpYWxpemVzIHRoZSBjb21wcmVzc2lvbiBkaWN0aW9uYXJ5IGZyb20gdGhlIGdpdmVuIGJ5dGVcbiAqIHNlcXVlbmNlIHdpdGhvdXQgcHJvZHVjaW5nIGFueSBjb21wcmVzc2VkIG91dHB1dC5cbiAqL1xuZnVuY3Rpb24gZGVmbGF0ZVNldERpY3Rpb25hcnkoc3RybSwgZGljdGlvbmFyeSkge1xuICB2YXIgZGljdExlbmd0aCA9IGRpY3Rpb25hcnkubGVuZ3RoO1xuXG4gIHZhciBzO1xuICB2YXIgc3RyLCBuO1xuICB2YXIgd3JhcDtcbiAgdmFyIGF2YWlsO1xuICB2YXIgbmV4dDtcbiAgdmFyIGlucHV0O1xuICB2YXIgdG1wRGljdDtcblxuICBpZiAoIXN0cm0vKj09IFpfTlVMTCovIHx8ICFzdHJtLnN0YXRlLyo9PSBaX05VTEwqLykge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuXG4gIHMgPSBzdHJtLnN0YXRlO1xuICB3cmFwID0gcy53cmFwO1xuXG4gIGlmICh3cmFwID09PSAyIHx8ICh3cmFwID09PSAxICYmIHMuc3RhdHVzICE9PSBJTklUX1NUQVRFKSB8fCBzLmxvb2thaGVhZCkge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuXG4gIC8qIHdoZW4gdXNpbmcgemxpYiB3cmFwcGVycywgY29tcHV0ZSBBZGxlci0zMiBmb3IgcHJvdmlkZWQgZGljdGlvbmFyeSAqL1xuICBpZiAod3JhcCA9PT0gMSkge1xuICAgIC8qIGFkbGVyMzIoc3RybS0+YWRsZXIsIGRpY3Rpb25hcnksIGRpY3RMZW5ndGgpOyAqL1xuICAgIHN0cm0uYWRsZXIgPSBhZGxlcjMyKHN0cm0uYWRsZXIsIGRpY3Rpb25hcnksIGRpY3RMZW5ndGgsIDApO1xuICB9XG5cbiAgcy53cmFwID0gMDsgICAvKiBhdm9pZCBjb21wdXRpbmcgQWRsZXItMzIgaW4gcmVhZF9idWYgKi9cblxuICAvKiBpZiBkaWN0aW9uYXJ5IHdvdWxkIGZpbGwgd2luZG93LCBqdXN0IHJlcGxhY2UgdGhlIGhpc3RvcnkgKi9cbiAgaWYgKGRpY3RMZW5ndGggPj0gcy53X3NpemUpIHtcbiAgICBpZiAod3JhcCA9PT0gMCkgeyAgICAgICAgICAgIC8qIGFscmVhZHkgZW1wdHkgb3RoZXJ3aXNlICovXG4gICAgICAvKioqIENMRUFSX0hBU0gocyk7ICoqKi9cbiAgICAgIHplcm8ocy5oZWFkKTsgLy8gRmlsbCB3aXRoIE5JTCAoPSAwKTtcbiAgICAgIHMuc3Ryc3RhcnQgPSAwO1xuICAgICAgcy5ibG9ja19zdGFydCA9IDA7XG4gICAgICBzLmluc2VydCA9IDA7XG4gICAgfVxuICAgIC8qIHVzZSB0aGUgdGFpbCAqL1xuICAgIC8vIGRpY3Rpb25hcnkgPSBkaWN0aW9uYXJ5LnNsaWNlKGRpY3RMZW5ndGggLSBzLndfc2l6ZSk7XG4gICAgdG1wRGljdCA9IG5ldyB1dGlscy5CdWY4KHMud19zaXplKTtcbiAgICB1dGlscy5hcnJheVNldCh0bXBEaWN0LCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoIC0gcy53X3NpemUsIHMud19zaXplLCAwKTtcbiAgICBkaWN0aW9uYXJ5ID0gdG1wRGljdDtcbiAgICBkaWN0TGVuZ3RoID0gcy53X3NpemU7XG4gIH1cbiAgLyogaW5zZXJ0IGRpY3Rpb25hcnkgaW50byB3aW5kb3cgYW5kIGhhc2ggKi9cbiAgYXZhaWwgPSBzdHJtLmF2YWlsX2luO1xuICBuZXh0ID0gc3RybS5uZXh0X2luO1xuICBpbnB1dCA9IHN0cm0uaW5wdXQ7XG4gIHN0cm0uYXZhaWxfaW4gPSBkaWN0TGVuZ3RoO1xuICBzdHJtLm5leHRfaW4gPSAwO1xuICBzdHJtLmlucHV0ID0gZGljdGlvbmFyeTtcbiAgZmlsbF93aW5kb3cocyk7XG4gIHdoaWxlIChzLmxvb2thaGVhZCA+PSBNSU5fTUFUQ0gpIHtcbiAgICBzdHIgPSBzLnN0cnN0YXJ0O1xuICAgIG4gPSBzLmxvb2thaGVhZCAtIChNSU5fTUFUQ0ggLSAxKTtcbiAgICBkbyB7XG4gICAgICAvKiBVUERBVEVfSEFTSChzLCBzLT5pbnNfaCwgcy0+d2luZG93W3N0ciArIE1JTl9NQVRDSC0xXSk7ICovXG4gICAgICBzLmluc19oID0gKChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCkgXiBzLndpbmRvd1tzdHIgKyBNSU5fTUFUQ0ggLSAxXSkgJiBzLmhhc2hfbWFzaztcblxuICAgICAgcy5wcmV2W3N0ciAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTtcblxuICAgICAgcy5oZWFkW3MuaW5zX2hdID0gc3RyO1xuICAgICAgc3RyKys7XG4gICAgfSB3aGlsZSAoLS1uKTtcbiAgICBzLnN0cnN0YXJ0ID0gc3RyO1xuICAgIHMubG9va2FoZWFkID0gTUlOX01BVENIIC0gMTtcbiAgICBmaWxsX3dpbmRvdyhzKTtcbiAgfVxuICBzLnN0cnN0YXJ0ICs9IHMubG9va2FoZWFkO1xuICBzLmJsb2NrX3N0YXJ0ID0gcy5zdHJzdGFydDtcbiAgcy5pbnNlcnQgPSBzLmxvb2thaGVhZDtcbiAgcy5sb29rYWhlYWQgPSAwO1xuICBzLm1hdGNoX2xlbmd0aCA9IHMucHJldl9sZW5ndGggPSBNSU5fTUFUQ0ggLSAxO1xuICBzLm1hdGNoX2F2YWlsYWJsZSA9IDA7XG4gIHN0cm0ubmV4dF9pbiA9IG5leHQ7XG4gIHN0cm0uaW5wdXQgPSBpbnB1dDtcbiAgc3RybS5hdmFpbF9pbiA9IGF2YWlsO1xuICBzLndyYXAgPSB3cmFwO1xuICByZXR1cm4gWl9PSztcbn1cblxuXG5leHBvcnRzLmRlZmxhdGVJbml0ID0gZGVmbGF0ZUluaXQ7XG5leHBvcnRzLmRlZmxhdGVJbml0MiA9IGRlZmxhdGVJbml0MjtcbmV4cG9ydHMuZGVmbGF0ZVJlc2V0ID0gZGVmbGF0ZVJlc2V0O1xuZXhwb3J0cy5kZWZsYXRlUmVzZXRLZWVwID0gZGVmbGF0ZVJlc2V0S2VlcDtcbmV4cG9ydHMuZGVmbGF0ZVNldEhlYWRlciA9IGRlZmxhdGVTZXRIZWFkZXI7XG5leHBvcnRzLmRlZmxhdGUgPSBkZWZsYXRlO1xuZXhwb3J0cy5kZWZsYXRlRW5kID0gZGVmbGF0ZUVuZDtcbmV4cG9ydHMuZGVmbGF0ZVNldERpY3Rpb25hcnkgPSBkZWZsYXRlU2V0RGljdGlvbmFyeTtcbmV4cG9ydHMuZGVmbGF0ZUluZm8gPSAncGFrbyBkZWZsYXRlIChmcm9tIE5vZGVjYSBwcm9qZWN0KSc7XG5cbi8qIE5vdCBpbXBsZW1lbnRlZFxuZXhwb3J0cy5kZWZsYXRlQm91bmQgPSBkZWZsYXRlQm91bmQ7XG5leHBvcnRzLmRlZmxhdGVDb3B5ID0gZGVmbGF0ZUNvcHk7XG5leHBvcnRzLmRlZmxhdGVQYXJhbXMgPSBkZWZsYXRlUGFyYW1zO1xuZXhwb3J0cy5kZWZsYXRlUGVuZGluZyA9IGRlZmxhdGVQZW5kaW5nO1xuZXhwb3J0cy5kZWZsYXRlUHJpbWUgPSBkZWZsYXRlUHJpbWU7XG5leHBvcnRzLmRlZmxhdGVUdW5lID0gZGVmbGF0ZVR1bmU7XG4qL1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbmZ1bmN0aW9uIEdaaGVhZGVyKCkge1xuICAvKiB0cnVlIGlmIGNvbXByZXNzZWQgZGF0YSBiZWxpZXZlZCB0byBiZSB0ZXh0ICovXG4gIHRoaXMudGV4dCAgICAgICA9IDA7XG4gIC8qIG1vZGlmaWNhdGlvbiB0aW1lICovXG4gIHRoaXMudGltZSAgICAgICA9IDA7XG4gIC8qIGV4dHJhIGZsYWdzIChub3QgdXNlZCB3aGVuIHdyaXRpbmcgYSBnemlwIGZpbGUpICovXG4gIHRoaXMueGZsYWdzICAgICA9IDA7XG4gIC8qIG9wZXJhdGluZyBzeXN0ZW0gKi9cbiAgdGhpcy5vcyAgICAgICAgID0gMDtcbiAgLyogcG9pbnRlciB0byBleHRyYSBmaWVsZCBvciBaX05VTEwgaWYgbm9uZSAqL1xuICB0aGlzLmV4dHJhICAgICAgPSBudWxsO1xuICAvKiBleHRyYSBmaWVsZCBsZW5ndGggKHZhbGlkIGlmIGV4dHJhICE9IFpfTlVMTCkgKi9cbiAgdGhpcy5leHRyYV9sZW4gID0gMDsgLy8gQWN0dWFsbHksIHdlIGRvbid0IG5lZWQgaXQgaW4gSlMsXG4gICAgICAgICAgICAgICAgICAgICAgIC8vIGJ1dCBsZWF2ZSBmb3IgZmV3IGNvZGUgbW9kaWZpY2F0aW9uc1xuXG4gIC8vXG4gIC8vIFNldHVwIGxpbWl0cyBpcyBub3QgbmVjZXNzYXJ5IGJlY2F1c2UgaW4ganMgd2Ugc2hvdWxkIG5vdCBwcmVhbGxvY2F0ZSBtZW1vcnlcbiAgLy8gZm9yIGluZmxhdGUgdXNlIGNvbnN0YW50IGxpbWl0IGluIDY1NTM2IGJ5dGVzXG4gIC8vXG5cbiAgLyogc3BhY2UgYXQgZXh0cmEgKG9ubHkgd2hlbiByZWFkaW5nIGhlYWRlcikgKi9cbiAgLy8gdGhpcy5leHRyYV9tYXggID0gMDtcbiAgLyogcG9pbnRlciB0byB6ZXJvLXRlcm1pbmF0ZWQgZmlsZSBuYW1lIG9yIFpfTlVMTCAqL1xuICB0aGlzLm5hbWUgICAgICAgPSAnJztcbiAgLyogc3BhY2UgYXQgbmFtZSAob25seSB3aGVuIHJlYWRpbmcgaGVhZGVyKSAqL1xuICAvLyB0aGlzLm5hbWVfbWF4ICAgPSAwO1xuICAvKiBwb2ludGVyIHRvIHplcm8tdGVybWluYXRlZCBjb21tZW50IG9yIFpfTlVMTCAqL1xuICB0aGlzLmNvbW1lbnQgICAgPSAnJztcbiAgLyogc3BhY2UgYXQgY29tbWVudCAob25seSB3aGVuIHJlYWRpbmcgaGVhZGVyKSAqL1xuICAvLyB0aGlzLmNvbW1fbWF4ICAgPSAwO1xuICAvKiB0cnVlIGlmIHRoZXJlIHdhcyBvciB3aWxsIGJlIGEgaGVhZGVyIGNyYyAqL1xuICB0aGlzLmhjcmMgICAgICAgPSAwO1xuICAvKiB0cnVlIHdoZW4gZG9uZSByZWFkaW5nIGd6aXAgaGVhZGVyIChub3QgdXNlZCB3aGVuIHdyaXRpbmcgYSBnemlwIGZpbGUpICovXG4gIHRoaXMuZG9uZSAgICAgICA9IGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEdaaGVhZGVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbi8vIFNlZSBzdGF0ZSBkZWZzIGZyb20gaW5mbGF0ZS5qc1xudmFyIEJBRCA9IDMwOyAgICAgICAvKiBnb3QgYSBkYXRhIGVycm9yIC0tIHJlbWFpbiBoZXJlIHVudGlsIHJlc2V0ICovXG52YXIgVFlQRSA9IDEyOyAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIHR5cGUgYml0cywgaW5jbHVkaW5nIGxhc3QtZmxhZyBiaXQgKi9cblxuLypcbiAgIERlY29kZSBsaXRlcmFsLCBsZW5ndGgsIGFuZCBkaXN0YW5jZSBjb2RlcyBhbmQgd3JpdGUgb3V0IHRoZSByZXN1bHRpbmdcbiAgIGxpdGVyYWwgYW5kIG1hdGNoIGJ5dGVzIHVudGlsIGVpdGhlciBub3QgZW5vdWdoIGlucHV0IG9yIG91dHB1dCBpc1xuICAgYXZhaWxhYmxlLCBhbiBlbmQtb2YtYmxvY2sgaXMgZW5jb3VudGVyZWQsIG9yIGEgZGF0YSBlcnJvciBpcyBlbmNvdW50ZXJlZC5cbiAgIFdoZW4gbGFyZ2UgZW5vdWdoIGlucHV0IGFuZCBvdXRwdXQgYnVmZmVycyBhcmUgc3VwcGxpZWQgdG8gaW5mbGF0ZSgpLCBmb3JcbiAgIGV4YW1wbGUsIGEgMTZLIGlucHV0IGJ1ZmZlciBhbmQgYSA2NEsgb3V0cHV0IGJ1ZmZlciwgbW9yZSB0aGFuIDk1JSBvZiB0aGVcbiAgIGluZmxhdGUgZXhlY3V0aW9uIHRpbWUgaXMgc3BlbnQgaW4gdGhpcyByb3V0aW5lLlxuXG4gICBFbnRyeSBhc3N1bXB0aW9uczpcblxuICAgICAgICBzdGF0ZS5tb2RlID09PSBMRU5cbiAgICAgICAgc3RybS5hdmFpbF9pbiA+PSA2XG4gICAgICAgIHN0cm0uYXZhaWxfb3V0ID49IDI1OFxuICAgICAgICBzdGFydCA+PSBzdHJtLmF2YWlsX291dFxuICAgICAgICBzdGF0ZS5iaXRzIDwgOFxuXG4gICBPbiByZXR1cm4sIHN0YXRlLm1vZGUgaXMgb25lIG9mOlxuXG4gICAgICAgIExFTiAtLSByYW4gb3V0IG9mIGVub3VnaCBvdXRwdXQgc3BhY2Ugb3IgZW5vdWdoIGF2YWlsYWJsZSBpbnB1dFxuICAgICAgICBUWVBFIC0tIHJlYWNoZWQgZW5kIG9mIGJsb2NrIGNvZGUsIGluZmxhdGUoKSB0byBpbnRlcnByZXQgbmV4dCBibG9ja1xuICAgICAgICBCQUQgLS0gZXJyb3IgaW4gYmxvY2sgZGF0YVxuXG4gICBOb3RlczpcblxuICAgIC0gVGhlIG1heGltdW0gaW5wdXQgYml0cyB1c2VkIGJ5IGEgbGVuZ3RoL2Rpc3RhbmNlIHBhaXIgaXMgMTUgYml0cyBmb3IgdGhlXG4gICAgICBsZW5ndGggY29kZSwgNSBiaXRzIGZvciB0aGUgbGVuZ3RoIGV4dHJhLCAxNSBiaXRzIGZvciB0aGUgZGlzdGFuY2UgY29kZSxcbiAgICAgIGFuZCAxMyBiaXRzIGZvciB0aGUgZGlzdGFuY2UgZXh0cmEuICBUaGlzIHRvdGFscyA0OCBiaXRzLCBvciBzaXggYnl0ZXMuXG4gICAgICBUaGVyZWZvcmUgaWYgc3RybS5hdmFpbF9pbiA+PSA2LCB0aGVuIHRoZXJlIGlzIGVub3VnaCBpbnB1dCB0byBhdm9pZFxuICAgICAgY2hlY2tpbmcgZm9yIGF2YWlsYWJsZSBpbnB1dCB3aGlsZSBkZWNvZGluZy5cblxuICAgIC0gVGhlIG1heGltdW0gYnl0ZXMgdGhhdCBhIHNpbmdsZSBsZW5ndGgvZGlzdGFuY2UgcGFpciBjYW4gb3V0cHV0IGlzIDI1OFxuICAgICAgYnl0ZXMsIHdoaWNoIGlzIHRoZSBtYXhpbXVtIGxlbmd0aCB0aGF0IGNhbiBiZSBjb2RlZC4gIGluZmxhdGVfZmFzdCgpXG4gICAgICByZXF1aXJlcyBzdHJtLmF2YWlsX291dCA+PSAyNTggZm9yIGVhY2ggbG9vcCB0byBhdm9pZCBjaGVja2luZyBmb3JcbiAgICAgIG91dHB1dCBzcGFjZS5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmZsYXRlX2Zhc3Qoc3RybSwgc3RhcnQpIHtcbiAgdmFyIHN0YXRlO1xuICB2YXIgX2luOyAgICAgICAgICAgICAgICAgICAgLyogbG9jYWwgc3RybS5pbnB1dCAqL1xuICB2YXIgbGFzdDsgICAgICAgICAgICAgICAgICAgLyogaGF2ZSBlbm91Z2ggaW5wdXQgd2hpbGUgaW4gPCBsYXN0ICovXG4gIHZhciBfb3V0OyAgICAgICAgICAgICAgICAgICAvKiBsb2NhbCBzdHJtLm91dHB1dCAqL1xuICB2YXIgYmVnOyAgICAgICAgICAgICAgICAgICAgLyogaW5mbGF0ZSgpJ3MgaW5pdGlhbCBzdHJtLm91dHB1dCAqL1xuICB2YXIgZW5kOyAgICAgICAgICAgICAgICAgICAgLyogd2hpbGUgb3V0IDwgZW5kLCBlbm91Z2ggc3BhY2UgYXZhaWxhYmxlICovXG4vLyNpZmRlZiBJTkZMQVRFX1NUUklDVFxuICB2YXIgZG1heDsgICAgICAgICAgICAgICAgICAgLyogbWF4aW11bSBkaXN0YW5jZSBmcm9tIHpsaWIgaGVhZGVyICovXG4vLyNlbmRpZlxuICB2YXIgd3NpemU7ICAgICAgICAgICAgICAgICAgLyogd2luZG93IHNpemUgb3IgemVybyBpZiBub3QgdXNpbmcgd2luZG93ICovXG4gIHZhciB3aGF2ZTsgICAgICAgICAgICAgICAgICAvKiB2YWxpZCBieXRlcyBpbiB0aGUgd2luZG93ICovXG4gIHZhciB3bmV4dDsgICAgICAgICAgICAgICAgICAvKiB3aW5kb3cgd3JpdGUgaW5kZXggKi9cbiAgLy8gVXNlIGBzX3dpbmRvd2AgaW5zdGVhZCBgd2luZG93YCwgYXZvaWQgY29uZmxpY3Qgd2l0aCBpbnN0cnVtZW50YXRpb24gdG9vbHNcbiAgdmFyIHNfd2luZG93OyAgICAgICAgICAgICAgIC8qIGFsbG9jYXRlZCBzbGlkaW5nIHdpbmRvdywgaWYgd3NpemUgIT0gMCAqL1xuICB2YXIgaG9sZDsgICAgICAgICAgICAgICAgICAgLyogbG9jYWwgc3RybS5ob2xkICovXG4gIHZhciBiaXRzOyAgICAgICAgICAgICAgICAgICAvKiBsb2NhbCBzdHJtLmJpdHMgKi9cbiAgdmFyIGxjb2RlOyAgICAgICAgICAgICAgICAgIC8qIGxvY2FsIHN0cm0ubGVuY29kZSAqL1xuICB2YXIgZGNvZGU7ICAgICAgICAgICAgICAgICAgLyogbG9jYWwgc3RybS5kaXN0Y29kZSAqL1xuICB2YXIgbG1hc2s7ICAgICAgICAgICAgICAgICAgLyogbWFzayBmb3IgZmlyc3QgbGV2ZWwgb2YgbGVuZ3RoIGNvZGVzICovXG4gIHZhciBkbWFzazsgICAgICAgICAgICAgICAgICAvKiBtYXNrIGZvciBmaXJzdCBsZXZlbCBvZiBkaXN0YW5jZSBjb2RlcyAqL1xuICB2YXIgaGVyZTsgICAgICAgICAgICAgICAgICAgLyogcmV0cmlldmVkIHRhYmxlIGVudHJ5ICovXG4gIHZhciBvcDsgICAgICAgICAgICAgICAgICAgICAvKiBjb2RlIGJpdHMsIG9wZXJhdGlvbiwgZXh0cmEgYml0cywgb3IgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qICB3aW5kb3cgcG9zaXRpb24sIHdpbmRvdyBieXRlcyB0byBjb3B5ICovXG4gIHZhciBsZW47ICAgICAgICAgICAgICAgICAgICAvKiBtYXRjaCBsZW5ndGgsIHVudXNlZCBieXRlcyAqL1xuICB2YXIgZGlzdDsgICAgICAgICAgICAgICAgICAgLyogbWF0Y2ggZGlzdGFuY2UgKi9cbiAgdmFyIGZyb207ICAgICAgICAgICAgICAgICAgIC8qIHdoZXJlIHRvIGNvcHkgbWF0Y2ggZnJvbSAqL1xuICB2YXIgZnJvbV9zb3VyY2U7XG5cblxuICB2YXIgaW5wdXQsIG91dHB1dDsgLy8gSlMgc3BlY2lmaWMsIGJlY2F1c2Ugd2UgaGF2ZSBubyBwb2ludGVyc1xuXG4gIC8qIGNvcHkgc3RhdGUgdG8gbG9jYWwgdmFyaWFibGVzICovXG4gIHN0YXRlID0gc3RybS5zdGF0ZTtcbiAgLy9oZXJlID0gc3RhdGUuaGVyZTtcbiAgX2luID0gc3RybS5uZXh0X2luO1xuICBpbnB1dCA9IHN0cm0uaW5wdXQ7XG4gIGxhc3QgPSBfaW4gKyAoc3RybS5hdmFpbF9pbiAtIDUpO1xuICBfb3V0ID0gc3RybS5uZXh0X291dDtcbiAgb3V0cHV0ID0gc3RybS5vdXRwdXQ7XG4gIGJlZyA9IF9vdXQgLSAoc3RhcnQgLSBzdHJtLmF2YWlsX291dCk7XG4gIGVuZCA9IF9vdXQgKyAoc3RybS5hdmFpbF9vdXQgLSAyNTcpO1xuLy8jaWZkZWYgSU5GTEFURV9TVFJJQ1RcbiAgZG1heCA9IHN0YXRlLmRtYXg7XG4vLyNlbmRpZlxuICB3c2l6ZSA9IHN0YXRlLndzaXplO1xuICB3aGF2ZSA9IHN0YXRlLndoYXZlO1xuICB3bmV4dCA9IHN0YXRlLnduZXh0O1xuICBzX3dpbmRvdyA9IHN0YXRlLndpbmRvdztcbiAgaG9sZCA9IHN0YXRlLmhvbGQ7XG4gIGJpdHMgPSBzdGF0ZS5iaXRzO1xuICBsY29kZSA9IHN0YXRlLmxlbmNvZGU7XG4gIGRjb2RlID0gc3RhdGUuZGlzdGNvZGU7XG4gIGxtYXNrID0gKDEgPDwgc3RhdGUubGVuYml0cykgLSAxO1xuICBkbWFzayA9ICgxIDw8IHN0YXRlLmRpc3RiaXRzKSAtIDE7XG5cblxuICAvKiBkZWNvZGUgbGl0ZXJhbHMgYW5kIGxlbmd0aC9kaXN0YW5jZXMgdW50aWwgZW5kLW9mLWJsb2NrIG9yIG5vdCBlbm91Z2hcbiAgICAgaW5wdXQgZGF0YSBvciBvdXRwdXQgc3BhY2UgKi9cblxuICB0b3A6XG4gIGRvIHtcbiAgICBpZiAoYml0cyA8IDE1KSB7XG4gICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgYml0cyArPSA4O1xuICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0cztcbiAgICAgIGJpdHMgKz0gODtcbiAgICB9XG5cbiAgICBoZXJlID0gbGNvZGVbaG9sZCAmIGxtYXNrXTtcblxuICAgIGRvbGVuOlxuICAgIGZvciAoOzspIHsgLy8gR290byBlbXVsYXRpb25cbiAgICAgIG9wID0gaGVyZSA+Pj4gMjQvKmhlcmUuYml0cyovO1xuICAgICAgaG9sZCA+Pj49IG9wO1xuICAgICAgYml0cyAtPSBvcDtcbiAgICAgIG9wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmYvKmhlcmUub3AqLztcbiAgICAgIGlmIChvcCA9PT0gMCkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgLyogbGl0ZXJhbCAqL1xuICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgaGVyZS52YWwgPj0gMHgyMCAmJiBoZXJlLnZhbCA8IDB4N2YgP1xuICAgICAgICAvLyAgICAgICAgXCJpbmZsYXRlOiAgICAgICAgIGxpdGVyYWwgJyVjJ1xcblwiIDpcbiAgICAgICAgLy8gICAgICAgIFwiaW5mbGF0ZTogICAgICAgICBsaXRlcmFsIDB4JTAyeFxcblwiLCBoZXJlLnZhbCkpO1xuICAgICAgICBvdXRwdXRbX291dCsrXSA9IGhlcmUgJiAweGZmZmYvKmhlcmUudmFsKi87XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChvcCAmIDE2KSB7ICAgICAgICAgICAgICAgICAgICAgLyogbGVuZ3RoIGJhc2UgKi9cbiAgICAgICAgbGVuID0gaGVyZSAmIDB4ZmZmZi8qaGVyZS52YWwqLztcbiAgICAgICAgb3AgJj0gMTU7ICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGV4dHJhIGJpdHMgKi9cbiAgICAgICAgaWYgKG9wKSB7XG4gICAgICAgICAgaWYgKGJpdHMgPCBvcCkge1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGVuICs9IGhvbGQgJiAoKDEgPDwgb3ApIC0gMSk7XG4gICAgICAgICAgaG9sZCA+Pj49IG9wO1xuICAgICAgICAgIGJpdHMgLT0gb3A7XG4gICAgICAgIH1cbiAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgICBsZW5ndGggJXVcXG5cIiwgbGVuKSk7XG4gICAgICAgIGlmIChiaXRzIDwgMTUpIHtcbiAgICAgICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICBoZXJlID0gZGNvZGVbaG9sZCAmIGRtYXNrXTtcblxuICAgICAgICBkb2Rpc3Q6XG4gICAgICAgIGZvciAoOzspIHsgLy8gZ290byBlbXVsYXRpb25cbiAgICAgICAgICBvcCA9IGhlcmUgPj4+IDI0LypoZXJlLmJpdHMqLztcbiAgICAgICAgICBob2xkID4+Pj0gb3A7XG4gICAgICAgICAgYml0cyAtPSBvcDtcbiAgICAgICAgICBvcCA9IChoZXJlID4+PiAxNikgJiAweGZmLypoZXJlLm9wKi87XG5cbiAgICAgICAgICBpZiAob3AgJiAxNikgeyAgICAgICAgICAgICAgICAgICAgICAvKiBkaXN0YW5jZSBiYXNlICovXG4gICAgICAgICAgICBkaXN0ID0gaGVyZSAmIDB4ZmZmZi8qaGVyZS52YWwqLztcbiAgICAgICAgICAgIG9wICY9IDE1OyAgICAgICAgICAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGV4dHJhIGJpdHMgKi9cbiAgICAgICAgICAgIGlmIChiaXRzIDwgb3ApIHtcbiAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0cztcbiAgICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgICAgICBpZiAoYml0cyA8IG9wKSB7XG4gICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0cztcbiAgICAgICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRpc3QgKz0gaG9sZCAmICgoMSA8PCBvcCkgLSAxKTtcbi8vI2lmZGVmIElORkxBVEVfU1RSSUNUXG4gICAgICAgICAgICBpZiAoZGlzdCA+IGRtYXgpIHtcbiAgICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyIGJhY2snO1xuICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgICBicmVhayB0b3A7XG4gICAgICAgICAgICB9XG4vLyNlbmRpZlxuICAgICAgICAgICAgaG9sZCA+Pj49IG9wO1xuICAgICAgICAgICAgYml0cyAtPSBvcDtcbiAgICAgICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgICAgZGlzdGFuY2UgJXVcXG5cIiwgZGlzdCkpO1xuICAgICAgICAgICAgb3AgPSBfb3V0IC0gYmVnOyAgICAgICAgICAgICAgICAvKiBtYXggZGlzdGFuY2UgaW4gb3V0cHV0ICovXG4gICAgICAgICAgICBpZiAoZGlzdCA+IG9wKSB7ICAgICAgICAgICAgICAgIC8qIHNlZSBpZiBjb3B5IGZyb20gd2luZG93ICovXG4gICAgICAgICAgICAgIG9wID0gZGlzdCAtIG9wOyAgICAgICAgICAgICAgIC8qIGRpc3RhbmNlIGJhY2sgaW4gd2luZG93ICovXG4gICAgICAgICAgICAgIGlmIChvcCA+IHdoYXZlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlLnNhbmUpIHtcbiAgICAgICAgICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgZGlzdGFuY2UgdG9vIGZhciBiYWNrJztcbiAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICAgICAgICBicmVhayB0b3A7XG4gICAgICAgICAgICAgICAgfVxuXG4vLyAoISkgVGhpcyBibG9jayBpcyBkaXNhYmxlZCBpbiB6bGliIGRlZmF1bHRzLFxuLy8gZG9uJ3QgZW5hYmxlIGl0IGZvciBiaW5hcnkgY29tcGF0aWJpbGl0eVxuLy8jaWZkZWYgSU5GTEFURV9BTExPV19JTlZBTElEX0RJU1RBTkNFX1RPT0ZBUl9BUlJSXG4vLyAgICAgICAgICAgICAgICBpZiAobGVuIDw9IG9wIC0gd2hhdmUpIHtcbi8vICAgICAgICAgICAgICAgICAgZG8ge1xuLy8gICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gMDtcbi8vICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1sZW4pO1xuLy8gICAgICAgICAgICAgICAgICBjb250aW51ZSB0b3A7XG4vLyAgICAgICAgICAgICAgICB9XG4vLyAgICAgICAgICAgICAgICBsZW4gLT0gb3AgLSB3aGF2ZTtcbi8vICAgICAgICAgICAgICAgIGRvIHtcbi8vICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSAwO1xuLy8gICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1vcCA+IHdoYXZlKTtcbi8vICAgICAgICAgICAgICAgIGlmIChvcCA9PT0gMCkge1xuLy8gICAgICAgICAgICAgICAgICBmcm9tID0gX291dCAtIGRpc3Q7XG4vLyAgICAgICAgICAgICAgICAgIGRvIHtcbi8vICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IG91dHB1dFtmcm9tKytdO1xuLy8gICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLWxlbik7XG4vLyAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIHRvcDtcbi8vICAgICAgICAgICAgICAgIH1cbi8vI2VuZGlmXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZnJvbSA9IDA7IC8vIHdpbmRvdyBpbmRleFxuICAgICAgICAgICAgICBmcm9tX3NvdXJjZSA9IHNfd2luZG93O1xuICAgICAgICAgICAgICBpZiAod25leHQgPT09IDApIHsgICAgICAgICAgIC8qIHZlcnkgY29tbW9uIGNhc2UgKi9cbiAgICAgICAgICAgICAgICBmcm9tICs9IHdzaXplIC0gb3A7XG4gICAgICAgICAgICAgICAgaWYgKG9wIDwgbGVuKSB7ICAgICAgICAgLyogc29tZSBmcm9tIHdpbmRvdyAqL1xuICAgICAgICAgICAgICAgICAgbGVuIC09IG9wO1xuICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IHNfd2luZG93W2Zyb20rK107XG4gICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW9wKTtcbiAgICAgICAgICAgICAgICAgIGZyb20gPSBfb3V0IC0gZGlzdDsgIC8qIHJlc3QgZnJvbSBvdXRwdXQgKi9cbiAgICAgICAgICAgICAgICAgIGZyb21fc291cmNlID0gb3V0cHV0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIGlmICh3bmV4dCA8IG9wKSB7ICAgICAgLyogd3JhcCBhcm91bmQgd2luZG93ICovXG4gICAgICAgICAgICAgICAgZnJvbSArPSB3c2l6ZSArIHduZXh0IC0gb3A7XG4gICAgICAgICAgICAgICAgb3AgLT0gd25leHQ7XG4gICAgICAgICAgICAgICAgaWYgKG9wIDwgbGVuKSB7ICAgICAgICAgLyogc29tZSBmcm9tIGVuZCBvZiB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgICAgIGxlbiAtPSBvcDtcbiAgICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBzX3dpbmRvd1tmcm9tKytdO1xuICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1vcCk7XG4gICAgICAgICAgICAgICAgICBmcm9tID0gMDtcbiAgICAgICAgICAgICAgICAgIGlmICh3bmV4dCA8IGxlbikgeyAgLyogc29tZSBmcm9tIHN0YXJ0IG9mIHdpbmRvdyAqL1xuICAgICAgICAgICAgICAgICAgICBvcCA9IHduZXh0O1xuICAgICAgICAgICAgICAgICAgICBsZW4gLT0gb3A7XG4gICAgICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IHNfd2luZG93W2Zyb20rK107XG4gICAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tb3ApO1xuICAgICAgICAgICAgICAgICAgICBmcm9tID0gX291dCAtIGRpc3Q7ICAgICAgLyogcmVzdCBmcm9tIG91dHB1dCAqL1xuICAgICAgICAgICAgICAgICAgICBmcm9tX3NvdXJjZSA9IG91dHB1dDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSB7ICAgICAgICAgICAgICAgICAgICAgIC8qIGNvbnRpZ3VvdXMgaW4gd2luZG93ICovXG4gICAgICAgICAgICAgICAgZnJvbSArPSB3bmV4dCAtIG9wO1xuICAgICAgICAgICAgICAgIGlmIChvcCA8IGxlbikgeyAgICAgICAgIC8qIHNvbWUgZnJvbSB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgICAgIGxlbiAtPSBvcDtcbiAgICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBzX3dpbmRvd1tmcm9tKytdO1xuICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1vcCk7XG4gICAgICAgICAgICAgICAgICBmcm9tID0gX291dCAtIGRpc3Q7ICAvKiByZXN0IGZyb20gb3V0cHV0ICovXG4gICAgICAgICAgICAgICAgICBmcm9tX3NvdXJjZSA9IG91dHB1dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgd2hpbGUgKGxlbiA+IDIpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107XG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBmcm9tX3NvdXJjZVtmcm9tKytdO1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBsZW4gLT0gMztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAobGVuKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBmcm9tX3NvdXJjZVtmcm9tKytdO1xuICAgICAgICAgICAgICAgIGlmIChsZW4gPiAxKSB7XG4gICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgZnJvbSA9IF9vdXQgLSBkaXN0OyAgICAgICAgICAvKiBjb3B5IGRpcmVjdCBmcm9tIG91dHB1dCAqL1xuICAgICAgICAgICAgICBkbyB7ICAgICAgICAgICAgICAgICAgICAgICAgLyogbWluaW11bSBsZW5ndGggaXMgdGhyZWUgKi9cbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IG91dHB1dFtmcm9tKytdO1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107XG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBsZW4gLT0gMztcbiAgICAgICAgICAgICAgfSB3aGlsZSAobGVuID4gMik7XG4gICAgICAgICAgICAgIGlmIChsZW4pIHtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IG91dHB1dFtmcm9tKytdO1xuICAgICAgICAgICAgICAgIGlmIChsZW4gPiAxKSB7XG4gICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IG91dHB1dFtmcm9tKytdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmICgob3AgJiA2NCkgPT09IDApIHsgICAgICAgICAgLyogMm5kIGxldmVsIGRpc3RhbmNlIGNvZGUgKi9cbiAgICAgICAgICAgIGhlcmUgPSBkY29kZVsoaGVyZSAmIDB4ZmZmZikvKmhlcmUudmFsKi8gKyAoaG9sZCAmICgoMSA8PCBvcCkgLSAxKSldO1xuICAgICAgICAgICAgY29udGludWUgZG9kaXN0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgZGlzdGFuY2UgY29kZSc7XG4gICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgYnJlYWsgdG9wO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrOyAvLyBuZWVkIHRvIGVtdWxhdGUgZ290byB2aWEgXCJjb250aW51ZVwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKChvcCAmIDY0KSA9PT0gMCkgeyAgICAgICAgICAgICAgLyogMm5kIGxldmVsIGxlbmd0aCBjb2RlICovXG4gICAgICAgIGhlcmUgPSBsY29kZVsoaGVyZSAmIDB4ZmZmZikvKmhlcmUudmFsKi8gKyAoaG9sZCAmICgoMSA8PCBvcCkgLSAxKSldO1xuICAgICAgICBjb250aW51ZSBkb2xlbjtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG9wICYgMzIpIHsgICAgICAgICAgICAgICAgICAgICAvKiBlbmQtb2YtYmxvY2sgKi9cbiAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgICBlbmQgb2YgYmxvY2tcXG5cIikpO1xuICAgICAgICBzdGF0ZS5tb2RlID0gVFlQRTtcbiAgICAgICAgYnJlYWsgdG9wO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgbGl0ZXJhbC9sZW5ndGggY29kZSc7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgIGJyZWFrIHRvcDtcbiAgICAgIH1cblxuICAgICAgYnJlYWs7IC8vIG5lZWQgdG8gZW11bGF0ZSBnb3RvIHZpYSBcImNvbnRpbnVlXCJcbiAgICB9XG4gIH0gd2hpbGUgKF9pbiA8IGxhc3QgJiYgX291dCA8IGVuZCk7XG5cbiAgLyogcmV0dXJuIHVudXNlZCBieXRlcyAob24gZW50cnksIGJpdHMgPCA4LCBzbyBpbiB3b24ndCBnbyB0b28gZmFyIGJhY2spICovXG4gIGxlbiA9IGJpdHMgPj4gMztcbiAgX2luIC09IGxlbjtcbiAgYml0cyAtPSBsZW4gPDwgMztcbiAgaG9sZCAmPSAoMSA8PCBiaXRzKSAtIDE7XG5cbiAgLyogdXBkYXRlIHN0YXRlIGFuZCByZXR1cm4gKi9cbiAgc3RybS5uZXh0X2luID0gX2luO1xuICBzdHJtLm5leHRfb3V0ID0gX291dDtcbiAgc3RybS5hdmFpbF9pbiA9IChfaW4gPCBsYXN0ID8gNSArIChsYXN0IC0gX2luKSA6IDUgLSAoX2luIC0gbGFzdCkpO1xuICBzdHJtLmF2YWlsX291dCA9IChfb3V0IDwgZW5kID8gMjU3ICsgKGVuZCAtIF9vdXQpIDogMjU3IC0gKF9vdXQgLSBlbmQpKTtcbiAgc3RhdGUuaG9sZCA9IGhvbGQ7XG4gIHN0YXRlLmJpdHMgPSBiaXRzO1xuICByZXR1cm47XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbnZhciB1dGlscyAgICAgICAgID0gcmVxdWlyZSgnLi4vdXRpbHMvY29tbW9uJyk7XG52YXIgYWRsZXIzMiAgICAgICA9IHJlcXVpcmUoJy4vYWRsZXIzMicpO1xudmFyIGNyYzMyICAgICAgICAgPSByZXF1aXJlKCcuL2NyYzMyJyk7XG52YXIgaW5mbGF0ZV9mYXN0ICA9IHJlcXVpcmUoJy4vaW5mZmFzdCcpO1xudmFyIGluZmxhdGVfdGFibGUgPSByZXF1aXJlKCcuL2luZnRyZWVzJyk7XG5cbnZhciBDT0RFUyA9IDA7XG52YXIgTEVOUyA9IDE7XG52YXIgRElTVFMgPSAyO1xuXG4vKiBQdWJsaWMgY29uc3RhbnRzID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG4vKiBBbGxvd2VkIGZsdXNoIHZhbHVlczsgc2VlIGRlZmxhdGUoKSBhbmQgaW5mbGF0ZSgpIGJlbG93IGZvciBkZXRhaWxzICovXG4vL3ZhciBaX05PX0ZMVVNIICAgICAgPSAwO1xuLy92YXIgWl9QQVJUSUFMX0ZMVVNIID0gMTtcbi8vdmFyIFpfU1lOQ19GTFVTSCAgICA9IDI7XG4vL3ZhciBaX0ZVTExfRkxVU0ggICAgPSAzO1xudmFyIFpfRklOSVNIICAgICAgICA9IDQ7XG52YXIgWl9CTE9DSyAgICAgICAgID0gNTtcbnZhciBaX1RSRUVTICAgICAgICAgPSA2O1xuXG5cbi8qIFJldHVybiBjb2RlcyBmb3IgdGhlIGNvbXByZXNzaW9uL2RlY29tcHJlc3Npb24gZnVuY3Rpb25zLiBOZWdhdGl2ZSB2YWx1ZXNcbiAqIGFyZSBlcnJvcnMsIHBvc2l0aXZlIHZhbHVlcyBhcmUgdXNlZCBmb3Igc3BlY2lhbCBidXQgbm9ybWFsIGV2ZW50cy5cbiAqL1xudmFyIFpfT0sgICAgICAgICAgICA9IDA7XG52YXIgWl9TVFJFQU1fRU5EICAgID0gMTtcbnZhciBaX05FRURfRElDVCAgICAgPSAyO1xuLy92YXIgWl9FUlJOTyAgICAgICAgID0gLTE7XG52YXIgWl9TVFJFQU1fRVJST1IgID0gLTI7XG52YXIgWl9EQVRBX0VSUk9SICAgID0gLTM7XG52YXIgWl9NRU1fRVJST1IgICAgID0gLTQ7XG52YXIgWl9CVUZfRVJST1IgICAgID0gLTU7XG4vL3ZhciBaX1ZFUlNJT05fRVJST1IgPSAtNjtcblxuLyogVGhlIGRlZmxhdGUgY29tcHJlc3Npb24gbWV0aG9kICovXG52YXIgWl9ERUZMQVRFRCAgPSA4O1xuXG5cbi8qIFNUQVRFUyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cbnZhciAgICBIRUFEID0gMTsgICAgICAgLyogaTogd2FpdGluZyBmb3IgbWFnaWMgaGVhZGVyICovXG52YXIgICAgRkxBR1MgPSAyOyAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIG1ldGhvZCBhbmQgZmxhZ3MgKGd6aXApICovXG52YXIgICAgVElNRSA9IDM7ICAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIG1vZGlmaWNhdGlvbiB0aW1lIChnemlwKSAqL1xudmFyICAgIE9TID0gNDsgICAgICAgICAvKiBpOiB3YWl0aW5nIGZvciBleHRyYSBmbGFncyBhbmQgb3BlcmF0aW5nIHN5c3RlbSAoZ3ppcCkgKi9cbnZhciAgICBFWExFTiA9IDU7ICAgICAgLyogaTogd2FpdGluZyBmb3IgZXh0cmEgbGVuZ3RoIChnemlwKSAqL1xudmFyICAgIEVYVFJBID0gNjsgICAgICAvKiBpOiB3YWl0aW5nIGZvciBleHRyYSBieXRlcyAoZ3ppcCkgKi9cbnZhciAgICBOQU1FID0gNzsgICAgICAgLyogaTogd2FpdGluZyBmb3IgZW5kIG9mIGZpbGUgbmFtZSAoZ3ppcCkgKi9cbnZhciAgICBDT01NRU5UID0gODsgICAgLyogaTogd2FpdGluZyBmb3IgZW5kIG9mIGNvbW1lbnQgKGd6aXApICovXG52YXIgICAgSENSQyA9IDk7ICAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGhlYWRlciBjcmMgKGd6aXApICovXG52YXIgICAgRElDVElEID0gMTA7ICAgIC8qIGk6IHdhaXRpbmcgZm9yIGRpY3Rpb25hcnkgY2hlY2sgdmFsdWUgKi9cbnZhciAgICBESUNUID0gMTE7ICAgICAgLyogd2FpdGluZyBmb3IgaW5mbGF0ZVNldERpY3Rpb25hcnkoKSBjYWxsICovXG52YXIgICAgICAgIFRZUEUgPSAxMjsgICAgICAvKiBpOiB3YWl0aW5nIGZvciB0eXBlIGJpdHMsIGluY2x1ZGluZyBsYXN0LWZsYWcgYml0ICovXG52YXIgICAgICAgIFRZUEVETyA9IDEzOyAgICAvKiBpOiBzYW1lLCBidXQgc2tpcCBjaGVjayB0byBleGl0IGluZmxhdGUgb24gbmV3IGJsb2NrICovXG52YXIgICAgICAgIFNUT1JFRCA9IDE0OyAgICAvKiBpOiB3YWl0aW5nIGZvciBzdG9yZWQgc2l6ZSAobGVuZ3RoIGFuZCBjb21wbGVtZW50KSAqL1xudmFyICAgICAgICBDT1BZXyA9IDE1OyAgICAgLyogaS9vOiBzYW1lIGFzIENPUFkgYmVsb3csIGJ1dCBvbmx5IGZpcnN0IHRpbWUgaW4gKi9cbnZhciAgICAgICAgQ09QWSA9IDE2OyAgICAgIC8qIGkvbzogd2FpdGluZyBmb3IgaW5wdXQgb3Igb3V0cHV0IHRvIGNvcHkgc3RvcmVkIGJsb2NrICovXG52YXIgICAgICAgIFRBQkxFID0gMTc7ICAgICAvKiBpOiB3YWl0aW5nIGZvciBkeW5hbWljIGJsb2NrIHRhYmxlIGxlbmd0aHMgKi9cbnZhciAgICAgICAgTEVOTEVOUyA9IDE4OyAgIC8qIGk6IHdhaXRpbmcgZm9yIGNvZGUgbGVuZ3RoIGNvZGUgbGVuZ3RocyAqL1xudmFyICAgICAgICBDT0RFTEVOUyA9IDE5OyAgLyogaTogd2FpdGluZyBmb3IgbGVuZ3RoL2xpdCBhbmQgZGlzdGFuY2UgY29kZSBsZW5ndGhzICovXG52YXIgICAgICAgICAgICBMRU5fID0gMjA7ICAgICAgLyogaTogc2FtZSBhcyBMRU4gYmVsb3csIGJ1dCBvbmx5IGZpcnN0IHRpbWUgaW4gKi9cbnZhciAgICAgICAgICAgIExFTiA9IDIxOyAgICAgICAvKiBpOiB3YWl0aW5nIGZvciBsZW5ndGgvbGl0L2VvYiBjb2RlICovXG52YXIgICAgICAgICAgICBMRU5FWFQgPSAyMjsgICAgLyogaTogd2FpdGluZyBmb3IgbGVuZ3RoIGV4dHJhIGJpdHMgKi9cbnZhciAgICAgICAgICAgIERJU1QgPSAyMzsgICAgICAvKiBpOiB3YWl0aW5nIGZvciBkaXN0YW5jZSBjb2RlICovXG52YXIgICAgICAgICAgICBESVNURVhUID0gMjQ7ICAgLyogaTogd2FpdGluZyBmb3IgZGlzdGFuY2UgZXh0cmEgYml0cyAqL1xudmFyICAgICAgICAgICAgTUFUQ0ggPSAyNTsgICAgIC8qIG86IHdhaXRpbmcgZm9yIG91dHB1dCBzcGFjZSB0byBjb3B5IHN0cmluZyAqL1xudmFyICAgICAgICAgICAgTElUID0gMjY7ICAgICAgIC8qIG86IHdhaXRpbmcgZm9yIG91dHB1dCBzcGFjZSB0byB3cml0ZSBsaXRlcmFsICovXG52YXIgICAgQ0hFQ0sgPSAyNzsgICAgIC8qIGk6IHdhaXRpbmcgZm9yIDMyLWJpdCBjaGVjayB2YWx1ZSAqL1xudmFyICAgIExFTkdUSCA9IDI4OyAgICAvKiBpOiB3YWl0aW5nIGZvciAzMi1iaXQgbGVuZ3RoIChnemlwKSAqL1xudmFyICAgIERPTkUgPSAyOTsgICAgICAvKiBmaW5pc2hlZCBjaGVjaywgZG9uZSAtLSByZW1haW4gaGVyZSB1bnRpbCByZXNldCAqL1xudmFyICAgIEJBRCA9IDMwOyAgICAgICAvKiBnb3QgYSBkYXRhIGVycm9yIC0tIHJlbWFpbiBoZXJlIHVudGlsIHJlc2V0ICovXG52YXIgICAgTUVNID0gMzE7ICAgICAgIC8qIGdvdCBhbiBpbmZsYXRlKCkgbWVtb3J5IGVycm9yIC0tIHJlbWFpbiBoZXJlIHVudGlsIHJlc2V0ICovXG52YXIgICAgU1lOQyA9IDMyOyAgICAgIC8qIGxvb2tpbmcgZm9yIHN5bmNocm9uaXphdGlvbiBieXRlcyB0byByZXN0YXJ0IGluZmxhdGUoKSAqL1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cblxudmFyIEVOT1VHSF9MRU5TID0gODUyO1xudmFyIEVOT1VHSF9ESVNUUyA9IDU5Mjtcbi8vdmFyIEVOT1VHSCA9ICAoRU5PVUdIX0xFTlMrRU5PVUdIX0RJU1RTKTtcblxudmFyIE1BWF9XQklUUyA9IDE1O1xuLyogMzJLIExaNzcgd2luZG93ICovXG52YXIgREVGX1dCSVRTID0gTUFYX1dCSVRTO1xuXG5cbmZ1bmN0aW9uIHpzd2FwMzIocSkge1xuICByZXR1cm4gICgoKHEgPj4+IDI0KSAmIDB4ZmYpICtcbiAgICAgICAgICAoKHEgPj4+IDgpICYgMHhmZjAwKSArXG4gICAgICAgICAgKChxICYgMHhmZjAwKSA8PCA4KSArXG4gICAgICAgICAgKChxICYgMHhmZikgPDwgMjQpKTtcbn1cblxuXG5mdW5jdGlvbiBJbmZsYXRlU3RhdGUoKSB7XG4gIHRoaXMubW9kZSA9IDA7ICAgICAgICAgICAgIC8qIGN1cnJlbnQgaW5mbGF0ZSBtb2RlICovXG4gIHRoaXMubGFzdCA9IGZhbHNlOyAgICAgICAgICAvKiB0cnVlIGlmIHByb2Nlc3NpbmcgbGFzdCBibG9jayAqL1xuICB0aGlzLndyYXAgPSAwOyAgICAgICAgICAgICAgLyogYml0IDAgdHJ1ZSBmb3IgemxpYiwgYml0IDEgdHJ1ZSBmb3IgZ3ppcCAqL1xuICB0aGlzLmhhdmVkaWN0ID0gZmFsc2U7ICAgICAgLyogdHJ1ZSBpZiBkaWN0aW9uYXJ5IHByb3ZpZGVkICovXG4gIHRoaXMuZmxhZ3MgPSAwOyAgICAgICAgICAgICAvKiBnemlwIGhlYWRlciBtZXRob2QgYW5kIGZsYWdzICgwIGlmIHpsaWIpICovXG4gIHRoaXMuZG1heCA9IDA7ICAgICAgICAgICAgICAvKiB6bGliIGhlYWRlciBtYXggZGlzdGFuY2UgKElORkxBVEVfU1RSSUNUKSAqL1xuICB0aGlzLmNoZWNrID0gMDsgICAgICAgICAgICAgLyogcHJvdGVjdGVkIGNvcHkgb2YgY2hlY2sgdmFsdWUgKi9cbiAgdGhpcy50b3RhbCA9IDA7ICAgICAgICAgICAgIC8qIHByb3RlY3RlZCBjb3B5IG9mIG91dHB1dCBjb3VudCAqL1xuICAvLyBUT0RPOiBtYXkgYmUge31cbiAgdGhpcy5oZWFkID0gbnVsbDsgICAgICAgICAgIC8qIHdoZXJlIHRvIHNhdmUgZ3ppcCBoZWFkZXIgaW5mb3JtYXRpb24gKi9cblxuICAvKiBzbGlkaW5nIHdpbmRvdyAqL1xuICB0aGlzLndiaXRzID0gMDsgICAgICAgICAgICAgLyogbG9nIGJhc2UgMiBvZiByZXF1ZXN0ZWQgd2luZG93IHNpemUgKi9cbiAgdGhpcy53c2l6ZSA9IDA7ICAgICAgICAgICAgIC8qIHdpbmRvdyBzaXplIG9yIHplcm8gaWYgbm90IHVzaW5nIHdpbmRvdyAqL1xuICB0aGlzLndoYXZlID0gMDsgICAgICAgICAgICAgLyogdmFsaWQgYnl0ZXMgaW4gdGhlIHdpbmRvdyAqL1xuICB0aGlzLnduZXh0ID0gMDsgICAgICAgICAgICAgLyogd2luZG93IHdyaXRlIGluZGV4ICovXG4gIHRoaXMud2luZG93ID0gbnVsbDsgICAgICAgICAvKiBhbGxvY2F0ZWQgc2xpZGluZyB3aW5kb3csIGlmIG5lZWRlZCAqL1xuXG4gIC8qIGJpdCBhY2N1bXVsYXRvciAqL1xuICB0aGlzLmhvbGQgPSAwOyAgICAgICAgICAgICAgLyogaW5wdXQgYml0IGFjY3VtdWxhdG9yICovXG4gIHRoaXMuYml0cyA9IDA7ICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgYml0cyBpbiBcImluXCIgKi9cblxuICAvKiBmb3Igc3RyaW5nIGFuZCBzdG9yZWQgYmxvY2sgY29weWluZyAqL1xuICB0aGlzLmxlbmd0aCA9IDA7ICAgICAgICAgICAgLyogbGl0ZXJhbCBvciBsZW5ndGggb2YgZGF0YSB0byBjb3B5ICovXG4gIHRoaXMub2Zmc2V0ID0gMDsgICAgICAgICAgICAvKiBkaXN0YW5jZSBiYWNrIHRvIGNvcHkgc3RyaW5nIGZyb20gKi9cblxuICAvKiBmb3IgdGFibGUgYW5kIGNvZGUgZGVjb2RpbmcgKi9cbiAgdGhpcy5leHRyYSA9IDA7ICAgICAgICAgICAgIC8qIGV4dHJhIGJpdHMgbmVlZGVkICovXG5cbiAgLyogZml4ZWQgYW5kIGR5bmFtaWMgY29kZSB0YWJsZXMgKi9cbiAgdGhpcy5sZW5jb2RlID0gbnVsbDsgICAgICAgICAgLyogc3RhcnRpbmcgdGFibGUgZm9yIGxlbmd0aC9saXRlcmFsIGNvZGVzICovXG4gIHRoaXMuZGlzdGNvZGUgPSBudWxsOyAgICAgICAgIC8qIHN0YXJ0aW5nIHRhYmxlIGZvciBkaXN0YW5jZSBjb2RlcyAqL1xuICB0aGlzLmxlbmJpdHMgPSAwOyAgICAgICAgICAgLyogaW5kZXggYml0cyBmb3IgbGVuY29kZSAqL1xuICB0aGlzLmRpc3RiaXRzID0gMDsgICAgICAgICAgLyogaW5kZXggYml0cyBmb3IgZGlzdGNvZGUgKi9cblxuICAvKiBkeW5hbWljIHRhYmxlIGJ1aWxkaW5nICovXG4gIHRoaXMubmNvZGUgPSAwOyAgICAgICAgICAgICAvKiBudW1iZXIgb2YgY29kZSBsZW5ndGggY29kZSBsZW5ndGhzICovXG4gIHRoaXMubmxlbiA9IDA7ICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgbGVuZ3RoIGNvZGUgbGVuZ3RocyAqL1xuICB0aGlzLm5kaXN0ID0gMDsgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGRpc3RhbmNlIGNvZGUgbGVuZ3RocyAqL1xuICB0aGlzLmhhdmUgPSAwOyAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGNvZGUgbGVuZ3RocyBpbiBsZW5zW10gKi9cbiAgdGhpcy5uZXh0ID0gbnVsbDsgICAgICAgICAgICAgIC8qIG5leHQgYXZhaWxhYmxlIHNwYWNlIGluIGNvZGVzW10gKi9cblxuICB0aGlzLmxlbnMgPSBuZXcgdXRpbHMuQnVmMTYoMzIwKTsgLyogdGVtcG9yYXJ5IHN0b3JhZ2UgZm9yIGNvZGUgbGVuZ3RocyAqL1xuICB0aGlzLndvcmsgPSBuZXcgdXRpbHMuQnVmMTYoMjg4KTsgLyogd29yayBhcmVhIGZvciBjb2RlIHRhYmxlIGJ1aWxkaW5nICovXG5cbiAgLypcbiAgIGJlY2F1c2Ugd2UgZG9uJ3QgaGF2ZSBwb2ludGVycyBpbiBqcywgd2UgdXNlIGxlbmNvZGUgYW5kIGRpc3Rjb2RlIGRpcmVjdGx5XG4gICBhcyBidWZmZXJzIHNvIHdlIGRvbid0IG5lZWQgY29kZXNcbiAgKi9cbiAgLy90aGlzLmNvZGVzID0gbmV3IHV0aWxzLkJ1ZjMyKEVOT1VHSCk7ICAgICAgIC8qIHNwYWNlIGZvciBjb2RlIHRhYmxlcyAqL1xuICB0aGlzLmxlbmR5biA9IG51bGw7ICAgICAgICAgICAgICAvKiBkeW5hbWljIHRhYmxlIGZvciBsZW5ndGgvbGl0ZXJhbCBjb2RlcyAoSlMgc3BlY2lmaWMpICovXG4gIHRoaXMuZGlzdGR5biA9IG51bGw7ICAgICAgICAgICAgIC8qIGR5bmFtaWMgdGFibGUgZm9yIGRpc3RhbmNlIGNvZGVzIChKUyBzcGVjaWZpYykgKi9cbiAgdGhpcy5zYW5lID0gMDsgICAgICAgICAgICAgICAgICAgLyogaWYgZmFsc2UsIGFsbG93IGludmFsaWQgZGlzdGFuY2UgdG9vIGZhciAqL1xuICB0aGlzLmJhY2sgPSAwOyAgICAgICAgICAgICAgICAgICAvKiBiaXRzIGJhY2sgb2YgbGFzdCB1bnByb2Nlc3NlZCBsZW5ndGgvbGl0ICovXG4gIHRoaXMud2FzID0gMDsgICAgICAgICAgICAgICAgICAgIC8qIGluaXRpYWwgbGVuZ3RoIG9mIG1hdGNoICovXG59XG5cbmZ1bmN0aW9uIGluZmxhdGVSZXNldEtlZXAoc3RybSkge1xuICB2YXIgc3RhdGU7XG5cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuICBzdGF0ZSA9IHN0cm0uc3RhdGU7XG4gIHN0cm0udG90YWxfaW4gPSBzdHJtLnRvdGFsX291dCA9IHN0YXRlLnRvdGFsID0gMDtcbiAgc3RybS5tc2cgPSAnJzsgLypaX05VTEwqL1xuICBpZiAoc3RhdGUud3JhcCkgeyAgICAgICAvKiB0byBzdXBwb3J0IGlsbC1jb25jZWl2ZWQgSmF2YSB0ZXN0IHN1aXRlICovXG4gICAgc3RybS5hZGxlciA9IHN0YXRlLndyYXAgJiAxO1xuICB9XG4gIHN0YXRlLm1vZGUgPSBIRUFEO1xuICBzdGF0ZS5sYXN0ID0gMDtcbiAgc3RhdGUuaGF2ZWRpY3QgPSAwO1xuICBzdGF0ZS5kbWF4ID0gMzI3Njg7XG4gIHN0YXRlLmhlYWQgPSBudWxsLypaX05VTEwqLztcbiAgc3RhdGUuaG9sZCA9IDA7XG4gIHN0YXRlLmJpdHMgPSAwO1xuICAvL3N0YXRlLmxlbmNvZGUgPSBzdGF0ZS5kaXN0Y29kZSA9IHN0YXRlLm5leHQgPSBzdGF0ZS5jb2RlcztcbiAgc3RhdGUubGVuY29kZSA9IHN0YXRlLmxlbmR5biA9IG5ldyB1dGlscy5CdWYzMihFTk9VR0hfTEVOUyk7XG4gIHN0YXRlLmRpc3Rjb2RlID0gc3RhdGUuZGlzdGR5biA9IG5ldyB1dGlscy5CdWYzMihFTk9VR0hfRElTVFMpO1xuXG4gIHN0YXRlLnNhbmUgPSAxO1xuICBzdGF0ZS5iYWNrID0gLTE7XG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogcmVzZXRcXG5cIikpO1xuICByZXR1cm4gWl9PSztcbn1cblxuZnVuY3Rpb24gaW5mbGF0ZVJlc2V0KHN0cm0pIHtcbiAgdmFyIHN0YXRlO1xuXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkgeyByZXR1cm4gWl9TVFJFQU1fRVJST1I7IH1cbiAgc3RhdGUgPSBzdHJtLnN0YXRlO1xuICBzdGF0ZS53c2l6ZSA9IDA7XG4gIHN0YXRlLndoYXZlID0gMDtcbiAgc3RhdGUud25leHQgPSAwO1xuICByZXR1cm4gaW5mbGF0ZVJlc2V0S2VlcChzdHJtKTtcblxufVxuXG5mdW5jdGlvbiBpbmZsYXRlUmVzZXQyKHN0cm0sIHdpbmRvd0JpdHMpIHtcbiAgdmFyIHdyYXA7XG4gIHZhciBzdGF0ZTtcblxuICAvKiBnZXQgdGhlIHN0YXRlICovXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkgeyByZXR1cm4gWl9TVFJFQU1fRVJST1I7IH1cbiAgc3RhdGUgPSBzdHJtLnN0YXRlO1xuXG4gIC8qIGV4dHJhY3Qgd3JhcCByZXF1ZXN0IGZyb20gd2luZG93Qml0cyBwYXJhbWV0ZXIgKi9cbiAgaWYgKHdpbmRvd0JpdHMgPCAwKSB7XG4gICAgd3JhcCA9IDA7XG4gICAgd2luZG93Qml0cyA9IC13aW5kb3dCaXRzO1xuICB9XG4gIGVsc2Uge1xuICAgIHdyYXAgPSAod2luZG93Qml0cyA+PiA0KSArIDE7XG4gICAgaWYgKHdpbmRvd0JpdHMgPCA0OCkge1xuICAgICAgd2luZG93Qml0cyAmPSAxNTtcbiAgICB9XG4gIH1cblxuICAvKiBzZXQgbnVtYmVyIG9mIHdpbmRvdyBiaXRzLCBmcmVlIHdpbmRvdyBpZiBkaWZmZXJlbnQgKi9cbiAgaWYgKHdpbmRvd0JpdHMgJiYgKHdpbmRvd0JpdHMgPCA4IHx8IHdpbmRvd0JpdHMgPiAxNSkpIHtcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gIH1cbiAgaWYgKHN0YXRlLndpbmRvdyAhPT0gbnVsbCAmJiBzdGF0ZS53Yml0cyAhPT0gd2luZG93Qml0cykge1xuICAgIHN0YXRlLndpbmRvdyA9IG51bGw7XG4gIH1cblxuICAvKiB1cGRhdGUgc3RhdGUgYW5kIHJlc2V0IHRoZSByZXN0IG9mIGl0ICovXG4gIHN0YXRlLndyYXAgPSB3cmFwO1xuICBzdGF0ZS53Yml0cyA9IHdpbmRvd0JpdHM7XG4gIHJldHVybiBpbmZsYXRlUmVzZXQoc3RybSk7XG59XG5cbmZ1bmN0aW9uIGluZmxhdGVJbml0MihzdHJtLCB3aW5kb3dCaXRzKSB7XG4gIHZhciByZXQ7XG4gIHZhciBzdGF0ZTtcblxuICBpZiAoIXN0cm0pIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG4gIC8vc3RybS5tc2cgPSBaX05VTEw7ICAgICAgICAgICAgICAgICAvKiBpbiBjYXNlIHdlIHJldHVybiBhbiBlcnJvciAqL1xuXG4gIHN0YXRlID0gbmV3IEluZmxhdGVTdGF0ZSgpO1xuXG4gIC8vaWYgKHN0YXRlID09PSBaX05VTEwpIHJldHVybiBaX01FTV9FUlJPUjtcbiAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiBhbGxvY2F0ZWRcXG5cIikpO1xuICBzdHJtLnN0YXRlID0gc3RhdGU7XG4gIHN0YXRlLndpbmRvdyA9IG51bGwvKlpfTlVMTCovO1xuICByZXQgPSBpbmZsYXRlUmVzZXQyKHN0cm0sIHdpbmRvd0JpdHMpO1xuICBpZiAocmV0ICE9PSBaX09LKSB7XG4gICAgc3RybS5zdGF0ZSA9IG51bGwvKlpfTlVMTCovO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGluZmxhdGVJbml0KHN0cm0pIHtcbiAgcmV0dXJuIGluZmxhdGVJbml0MihzdHJtLCBERUZfV0JJVFMpO1xufVxuXG5cbi8qXG4gUmV0dXJuIHN0YXRlIHdpdGggbGVuZ3RoIGFuZCBkaXN0YW5jZSBkZWNvZGluZyB0YWJsZXMgYW5kIGluZGV4IHNpemVzIHNldCB0b1xuIGZpeGVkIGNvZGUgZGVjb2RpbmcuICBOb3JtYWxseSB0aGlzIHJldHVybnMgZml4ZWQgdGFibGVzIGZyb20gaW5mZml4ZWQuaC5cbiBJZiBCVUlMREZJWEVEIGlzIGRlZmluZWQsIHRoZW4gaW5zdGVhZCB0aGlzIHJvdXRpbmUgYnVpbGRzIHRoZSB0YWJsZXMgdGhlXG4gZmlyc3QgdGltZSBpdCdzIGNhbGxlZCwgYW5kIHJldHVybnMgdGhvc2UgdGFibGVzIHRoZSBmaXJzdCB0aW1lIGFuZFxuIHRoZXJlYWZ0ZXIuICBUaGlzIHJlZHVjZXMgdGhlIHNpemUgb2YgdGhlIGNvZGUgYnkgYWJvdXQgMksgYnl0ZXMsIGluXG4gZXhjaGFuZ2UgZm9yIGEgbGl0dGxlIGV4ZWN1dGlvbiB0aW1lLiAgSG93ZXZlciwgQlVJTERGSVhFRCBzaG91bGQgbm90IGJlXG4gdXNlZCBmb3IgdGhyZWFkZWQgYXBwbGljYXRpb25zLCBzaW5jZSB0aGUgcmV3cml0aW5nIG9mIHRoZSB0YWJsZXMgYW5kIHZpcmdpblxuIG1heSBub3QgYmUgdGhyZWFkLXNhZmUuXG4gKi9cbnZhciB2aXJnaW4gPSB0cnVlO1xuXG52YXIgbGVuZml4LCBkaXN0Zml4OyAvLyBXZSBoYXZlIG5vIHBvaW50ZXJzIGluIEpTLCBzbyBrZWVwIHRhYmxlcyBzZXBhcmF0ZVxuXG5mdW5jdGlvbiBmaXhlZHRhYmxlcyhzdGF0ZSkge1xuICAvKiBidWlsZCBmaXhlZCBodWZmbWFuIHRhYmxlcyBpZiBmaXJzdCBjYWxsIChtYXkgbm90IGJlIHRocmVhZCBzYWZlKSAqL1xuICBpZiAodmlyZ2luKSB7XG4gICAgdmFyIHN5bTtcblxuICAgIGxlbmZpeCA9IG5ldyB1dGlscy5CdWYzMig1MTIpO1xuICAgIGRpc3RmaXggPSBuZXcgdXRpbHMuQnVmMzIoMzIpO1xuXG4gICAgLyogbGl0ZXJhbC9sZW5ndGggdGFibGUgKi9cbiAgICBzeW0gPSAwO1xuICAgIHdoaWxlIChzeW0gPCAxNDQpIHsgc3RhdGUubGVuc1tzeW0rK10gPSA4OyB9XG4gICAgd2hpbGUgKHN5bSA8IDI1NikgeyBzdGF0ZS5sZW5zW3N5bSsrXSA9IDk7IH1cbiAgICB3aGlsZSAoc3ltIDwgMjgwKSB7IHN0YXRlLmxlbnNbc3ltKytdID0gNzsgfVxuICAgIHdoaWxlIChzeW0gPCAyODgpIHsgc3RhdGUubGVuc1tzeW0rK10gPSA4OyB9XG5cbiAgICBpbmZsYXRlX3RhYmxlKExFTlMsICBzdGF0ZS5sZW5zLCAwLCAyODgsIGxlbmZpeCwgICAwLCBzdGF0ZS53b3JrLCB7IGJpdHM6IDkgfSk7XG5cbiAgICAvKiBkaXN0YW5jZSB0YWJsZSAqL1xuICAgIHN5bSA9IDA7XG4gICAgd2hpbGUgKHN5bSA8IDMyKSB7IHN0YXRlLmxlbnNbc3ltKytdID0gNTsgfVxuXG4gICAgaW5mbGF0ZV90YWJsZShESVNUUywgc3RhdGUubGVucywgMCwgMzIsICAgZGlzdGZpeCwgMCwgc3RhdGUud29yaywgeyBiaXRzOiA1IH0pO1xuXG4gICAgLyogZG8gdGhpcyBqdXN0IG9uY2UgKi9cbiAgICB2aXJnaW4gPSBmYWxzZTtcbiAgfVxuXG4gIHN0YXRlLmxlbmNvZGUgPSBsZW5maXg7XG4gIHN0YXRlLmxlbmJpdHMgPSA5O1xuICBzdGF0ZS5kaXN0Y29kZSA9IGRpc3RmaXg7XG4gIHN0YXRlLmRpc3RiaXRzID0gNTtcbn1cblxuXG4vKlxuIFVwZGF0ZSB0aGUgd2luZG93IHdpdGggdGhlIGxhc3Qgd3NpemUgKG5vcm1hbGx5IDMySykgYnl0ZXMgd3JpdHRlbiBiZWZvcmVcbiByZXR1cm5pbmcuICBJZiB3aW5kb3cgZG9lcyBub3QgZXhpc3QgeWV0LCBjcmVhdGUgaXQuICBUaGlzIGlzIG9ubHkgY2FsbGVkXG4gd2hlbiBhIHdpbmRvdyBpcyBhbHJlYWR5IGluIHVzZSwgb3Igd2hlbiBvdXRwdXQgaGFzIGJlZW4gd3JpdHRlbiBkdXJpbmcgdGhpc1xuIGluZmxhdGUgY2FsbCwgYnV0IHRoZSBlbmQgb2YgdGhlIGRlZmxhdGUgc3RyZWFtIGhhcyBub3QgYmVlbiByZWFjaGVkIHlldC5cbiBJdCBpcyBhbHNvIGNhbGxlZCB0byBjcmVhdGUgYSB3aW5kb3cgZm9yIGRpY3Rpb25hcnkgZGF0YSB3aGVuIGEgZGljdGlvbmFyeVxuIGlzIGxvYWRlZC5cblxuIFByb3ZpZGluZyBvdXRwdXQgYnVmZmVycyBsYXJnZXIgdGhhbiAzMksgdG8gaW5mbGF0ZSgpIHNob3VsZCBwcm92aWRlIGEgc3BlZWRcbiBhZHZhbnRhZ2UsIHNpbmNlIG9ubHkgdGhlIGxhc3QgMzJLIG9mIG91dHB1dCBpcyBjb3BpZWQgdG8gdGhlIHNsaWRpbmcgd2luZG93XG4gdXBvbiByZXR1cm4gZnJvbSBpbmZsYXRlKCksIGFuZCBzaW5jZSBhbGwgZGlzdGFuY2VzIGFmdGVyIHRoZSBmaXJzdCAzMksgb2ZcbiBvdXRwdXQgd2lsbCBmYWxsIGluIHRoZSBvdXRwdXQgZGF0YSwgbWFraW5nIG1hdGNoIGNvcGllcyBzaW1wbGVyIGFuZCBmYXN0ZXIuXG4gVGhlIGFkdmFudGFnZSBtYXkgYmUgZGVwZW5kZW50IG9uIHRoZSBzaXplIG9mIHRoZSBwcm9jZXNzb3IncyBkYXRhIGNhY2hlcy5cbiAqL1xuZnVuY3Rpb24gdXBkYXRld2luZG93KHN0cm0sIHNyYywgZW5kLCBjb3B5KSB7XG4gIHZhciBkaXN0O1xuICB2YXIgc3RhdGUgPSBzdHJtLnN0YXRlO1xuXG4gIC8qIGlmIGl0IGhhc24ndCBiZWVuIGRvbmUgYWxyZWFkeSwgYWxsb2NhdGUgc3BhY2UgZm9yIHRoZSB3aW5kb3cgKi9cbiAgaWYgKHN0YXRlLndpbmRvdyA9PT0gbnVsbCkge1xuICAgIHN0YXRlLndzaXplID0gMSA8PCBzdGF0ZS53Yml0cztcbiAgICBzdGF0ZS53bmV4dCA9IDA7XG4gICAgc3RhdGUud2hhdmUgPSAwO1xuXG4gICAgc3RhdGUud2luZG93ID0gbmV3IHV0aWxzLkJ1Zjgoc3RhdGUud3NpemUpO1xuICB9XG5cbiAgLyogY29weSBzdGF0ZS0+d3NpemUgb3IgbGVzcyBvdXRwdXQgYnl0ZXMgaW50byB0aGUgY2lyY3VsYXIgd2luZG93ICovXG4gIGlmIChjb3B5ID49IHN0YXRlLndzaXplKSB7XG4gICAgdXRpbHMuYXJyYXlTZXQoc3RhdGUud2luZG93LCBzcmMsIGVuZCAtIHN0YXRlLndzaXplLCBzdGF0ZS53c2l6ZSwgMCk7XG4gICAgc3RhdGUud25leHQgPSAwO1xuICAgIHN0YXRlLndoYXZlID0gc3RhdGUud3NpemU7XG4gIH1cbiAgZWxzZSB7XG4gICAgZGlzdCA9IHN0YXRlLndzaXplIC0gc3RhdGUud25leHQ7XG4gICAgaWYgKGRpc3QgPiBjb3B5KSB7XG4gICAgICBkaXN0ID0gY29weTtcbiAgICB9XG4gICAgLy96bWVtY3B5KHN0YXRlLT53aW5kb3cgKyBzdGF0ZS0+d25leHQsIGVuZCAtIGNvcHksIGRpc3QpO1xuICAgIHV0aWxzLmFycmF5U2V0KHN0YXRlLndpbmRvdywgc3JjLCBlbmQgLSBjb3B5LCBkaXN0LCBzdGF0ZS53bmV4dCk7XG4gICAgY29weSAtPSBkaXN0O1xuICAgIGlmIChjb3B5KSB7XG4gICAgICAvL3ptZW1jcHkoc3RhdGUtPndpbmRvdywgZW5kIC0gY29weSwgY29weSk7XG4gICAgICB1dGlscy5hcnJheVNldChzdGF0ZS53aW5kb3csIHNyYywgZW5kIC0gY29weSwgY29weSwgMCk7XG4gICAgICBzdGF0ZS53bmV4dCA9IGNvcHk7XG4gICAgICBzdGF0ZS53aGF2ZSA9IHN0YXRlLndzaXplO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHN0YXRlLnduZXh0ICs9IGRpc3Q7XG4gICAgICBpZiAoc3RhdGUud25leHQgPT09IHN0YXRlLndzaXplKSB7IHN0YXRlLnduZXh0ID0gMDsgfVxuICAgICAgaWYgKHN0YXRlLndoYXZlIDwgc3RhdGUud3NpemUpIHsgc3RhdGUud2hhdmUgKz0gZGlzdDsgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gMDtcbn1cblxuZnVuY3Rpb24gaW5mbGF0ZShzdHJtLCBmbHVzaCkge1xuICB2YXIgc3RhdGU7XG4gIHZhciBpbnB1dCwgb3V0cHV0OyAgICAgICAgICAvLyBpbnB1dC9vdXRwdXQgYnVmZmVyc1xuICB2YXIgbmV4dDsgICAgICAgICAgICAgICAgICAgLyogbmV4dCBpbnB1dCBJTkRFWCAqL1xuICB2YXIgcHV0OyAgICAgICAgICAgICAgICAgICAgLyogbmV4dCBvdXRwdXQgSU5ERVggKi9cbiAgdmFyIGhhdmUsIGxlZnQ7ICAgICAgICAgICAgIC8qIGF2YWlsYWJsZSBpbnB1dCBhbmQgb3V0cHV0ICovXG4gIHZhciBob2xkOyAgICAgICAgICAgICAgICAgICAvKiBiaXQgYnVmZmVyICovXG4gIHZhciBiaXRzOyAgICAgICAgICAgICAgICAgICAvKiBiaXRzIGluIGJpdCBidWZmZXIgKi9cbiAgdmFyIF9pbiwgX291dDsgICAgICAgICAgICAgIC8qIHNhdmUgc3RhcnRpbmcgYXZhaWxhYmxlIGlucHV0IGFuZCBvdXRwdXQgKi9cbiAgdmFyIGNvcHk7ICAgICAgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBzdG9yZWQgb3IgbWF0Y2ggYnl0ZXMgdG8gY29weSAqL1xuICB2YXIgZnJvbTsgICAgICAgICAgICAgICAgICAgLyogd2hlcmUgdG8gY29weSBtYXRjaCBieXRlcyBmcm9tICovXG4gIHZhciBmcm9tX3NvdXJjZTtcbiAgdmFyIGhlcmUgPSAwOyAgICAgICAgICAgICAgIC8qIGN1cnJlbnQgZGVjb2RpbmcgdGFibGUgZW50cnkgKi9cbiAgdmFyIGhlcmVfYml0cywgaGVyZV9vcCwgaGVyZV92YWw7IC8vIHBha2VkIFwiaGVyZVwiIGRlbm9ybWFsaXplZCAoSlMgc3BlY2lmaWMpXG4gIC8vdmFyIGxhc3Q7ICAgICAgICAgICAgICAgICAgIC8qIHBhcmVudCB0YWJsZSBlbnRyeSAqL1xuICB2YXIgbGFzdF9iaXRzLCBsYXN0X29wLCBsYXN0X3ZhbDsgLy8gcGFrZWQgXCJsYXN0XCIgZGVub3JtYWxpemVkIChKUyBzcGVjaWZpYylcbiAgdmFyIGxlbjsgICAgICAgICAgICAgICAgICAgIC8qIGxlbmd0aCB0byBjb3B5IGZvciByZXBlYXRzLCBiaXRzIHRvIGRyb3AgKi9cbiAgdmFyIHJldDsgICAgICAgICAgICAgICAgICAgIC8qIHJldHVybiBjb2RlICovXG4gIHZhciBoYnVmID0gbmV3IHV0aWxzLkJ1ZjgoNCk7ICAgIC8qIGJ1ZmZlciBmb3IgZ3ppcCBoZWFkZXIgY3JjIGNhbGN1bGF0aW9uICovXG4gIHZhciBvcHRzO1xuXG4gIHZhciBuOyAvLyB0ZW1wb3JhcnkgdmFyIGZvciBORUVEX0JJVFNcblxuICB2YXIgb3JkZXIgPSAvKiBwZXJtdXRhdGlvbiBvZiBjb2RlIGxlbmd0aHMgKi9cbiAgICBbIDE2LCAxNywgMTgsIDAsIDgsIDcsIDksIDYsIDEwLCA1LCAxMSwgNCwgMTIsIDMsIDEzLCAyLCAxNCwgMSwgMTUgXTtcblxuXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSB8fCAhc3RybS5vdXRwdXQgfHxcbiAgICAgICghc3RybS5pbnB1dCAmJiBzdHJtLmF2YWlsX2luICE9PSAwKSkge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuXG4gIHN0YXRlID0gc3RybS5zdGF0ZTtcbiAgaWYgKHN0YXRlLm1vZGUgPT09IFRZUEUpIHsgc3RhdGUubW9kZSA9IFRZUEVETzsgfSAgICAvKiBza2lwIGNoZWNrICovXG5cblxuICAvLy0tLSBMT0FEKCkgLS0tXG4gIHB1dCA9IHN0cm0ubmV4dF9vdXQ7XG4gIG91dHB1dCA9IHN0cm0ub3V0cHV0O1xuICBsZWZ0ID0gc3RybS5hdmFpbF9vdXQ7XG4gIG5leHQgPSBzdHJtLm5leHRfaW47XG4gIGlucHV0ID0gc3RybS5pbnB1dDtcbiAgaGF2ZSA9IHN0cm0uYXZhaWxfaW47XG4gIGhvbGQgPSBzdGF0ZS5ob2xkO1xuICBiaXRzID0gc3RhdGUuYml0cztcbiAgLy8tLS1cblxuICBfaW4gPSBoYXZlO1xuICBfb3V0ID0gbGVmdDtcbiAgcmV0ID0gWl9PSztcblxuICBpbmZfbGVhdmU6IC8vIGdvdG8gZW11bGF0aW9uXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKHN0YXRlLm1vZGUpIHtcbiAgICAgIGNhc2UgSEVBRDpcbiAgICAgICAgaWYgKHN0YXRlLndyYXAgPT09IDApIHtcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gVFlQRURPO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vPT09IE5FRURCSVRTKDE2KTtcbiAgICAgICAgd2hpbGUgKGJpdHMgPCAxNikge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBpZiAoKHN0YXRlLndyYXAgJiAyKSAmJiBob2xkID09PSAweDhiMWYpIHsgIC8qIGd6aXAgaGVhZGVyICovXG4gICAgICAgICAgc3RhdGUuY2hlY2sgPSAwLypjcmMzMigwTCwgWl9OVUxMLCAwKSovO1xuICAgICAgICAgIC8vPT09IENSQzIoc3RhdGUuY2hlY2ssIGhvbGQpO1xuICAgICAgICAgIGhidWZbMF0gPSBob2xkICYgMHhmZjtcbiAgICAgICAgICBoYnVmWzFdID0gKGhvbGQgPj4+IDgpICYgMHhmZjtcbiAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBoYnVmLCAyLCAwKTtcbiAgICAgICAgICAvLz09PS8vXG5cbiAgICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICAgIGhvbGQgPSAwO1xuICAgICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICBzdGF0ZS5tb2RlID0gRkxBR1M7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUuZmxhZ3MgPSAwOyAgICAgICAgICAgLyogZXhwZWN0IHpsaWIgaGVhZGVyICovXG4gICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgc3RhdGUuaGVhZC5kb25lID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoc3RhdGUud3JhcCAmIDEpIHx8ICAgLyogY2hlY2sgaWYgemxpYiBoZWFkZXIgYWxsb3dlZCAqL1xuICAgICAgICAgICgoKGhvbGQgJiAweGZmKS8qQklUUyg4KSovIDw8IDgpICsgKGhvbGQgPj4gOCkpICUgMzEpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbmNvcnJlY3QgaGVhZGVyIGNoZWNrJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoaG9sZCAmIDB4MGYpLypCSVRTKDQpKi8gIT09IFpfREVGTEFURUQpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICd1bmtub3duIGNvbXByZXNzaW9uIG1ldGhvZCc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvLy0tLSBEUk9QQklUUyg0KSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gNDtcbiAgICAgICAgYml0cyAtPSA0O1xuICAgICAgICAvLy0tLS8vXG4gICAgICAgIGxlbiA9IChob2xkICYgMHgwZikvKkJJVFMoNCkqLyArIDg7XG4gICAgICAgIGlmIChzdGF0ZS53Yml0cyA9PT0gMCkge1xuICAgICAgICAgIHN0YXRlLndiaXRzID0gbGVuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxlbiA+IHN0YXRlLndiaXRzKSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCB3aW5kb3cgc2l6ZSc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5kbWF4ID0gMSA8PCBsZW47XG4gICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICB6bGliIGhlYWRlciBva1xcblwiKSk7XG4gICAgICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9IDEvKmFkbGVyMzIoMEwsIFpfTlVMTCwgMCkqLztcbiAgICAgICAgc3RhdGUubW9kZSA9IGhvbGQgJiAweDIwMCA/IERJQ1RJRCA6IFRZUEU7XG4gICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgIGhvbGQgPSAwO1xuICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgLy89PT0vL1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRkxBR1M6XG4gICAgICAgIC8vPT09IE5FRURCSVRTKDE2KTsgKi9cbiAgICAgICAgd2hpbGUgKGJpdHMgPCAxNikge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5mbGFncyA9IGhvbGQ7XG4gICAgICAgIGlmICgoc3RhdGUuZmxhZ3MgJiAweGZmKSAhPT0gWl9ERUZMQVRFRCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ3Vua25vd24gY29tcHJlc3Npb24gbWV0aG9kJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4ZTAwMCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ3Vua25vd24gaGVhZGVyIGZsYWdzIHNldCc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgIHN0YXRlLmhlYWQudGV4dCA9ICgoaG9sZCA+PiA4KSAmIDEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAgIC8vPT09IENSQzIoc3RhdGUuY2hlY2ssIGhvbGQpO1xuICAgICAgICAgIGhidWZbMF0gPSBob2xkICYgMHhmZjtcbiAgICAgICAgICBoYnVmWzFdID0gKGhvbGQgPj4+IDgpICYgMHhmZjtcbiAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBoYnVmLCAyLCAwKTtcbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgIH1cbiAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLm1vZGUgPSBUSU1FO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIFRJTUU6XG4gICAgICAgIC8vPT09IE5FRURCSVRTKDMyKTsgKi9cbiAgICAgICAgd2hpbGUgKGJpdHMgPCAzMikge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgIHN0YXRlLmhlYWQudGltZSA9IGhvbGQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgICAgLy89PT0gQ1JDNChzdGF0ZS5jaGVjaywgaG9sZClcbiAgICAgICAgICBoYnVmWzBdID0gaG9sZCAmIDB4ZmY7XG4gICAgICAgICAgaGJ1ZlsxXSA9IChob2xkID4+PiA4KSAmIDB4ZmY7XG4gICAgICAgICAgaGJ1ZlsyXSA9IChob2xkID4+PiAxNikgJiAweGZmO1xuICAgICAgICAgIGhidWZbM10gPSAoaG9sZCA+Pj4gMjQpICYgMHhmZjtcbiAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBoYnVmLCA0LCAwKTtcbiAgICAgICAgICAvLz09PVxuICAgICAgICB9XG4gICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgIGhvbGQgPSAwO1xuICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5tb2RlID0gT1M7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgT1M6XG4gICAgICAgIC8vPT09IE5FRURCSVRTKDE2KTsgKi9cbiAgICAgICAgd2hpbGUgKGJpdHMgPCAxNikge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgIHN0YXRlLmhlYWQueGZsYWdzID0gKGhvbGQgJiAweGZmKTtcbiAgICAgICAgICBzdGF0ZS5oZWFkLm9zID0gKGhvbGQgPj4gOCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgICAgLy89PT0gQ1JDMihzdGF0ZS5jaGVjaywgaG9sZCk7XG4gICAgICAgICAgaGJ1ZlswXSA9IGhvbGQgJiAweGZmO1xuICAgICAgICAgIGhidWZbMV0gPSAoaG9sZCA+Pj4gOCkgJiAweGZmO1xuICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGhidWYsIDIsIDApO1xuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgfVxuICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICBob2xkID0gMDtcbiAgICAgICAgYml0cyA9IDA7XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUubW9kZSA9IEVYTEVOO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIEVYTEVOOlxuICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDA0MDApIHtcbiAgICAgICAgICAvLz09PSBORUVEQklUUygxNik7ICovXG4gICAgICAgICAgd2hpbGUgKGJpdHMgPCAxNikge1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIHN0YXRlLmxlbmd0aCA9IGhvbGQ7XG4gICAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICAgIHN0YXRlLmhlYWQuZXh0cmFfbGVuID0gaG9sZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgICAgICAvLz09PSBDUkMyKHN0YXRlLmNoZWNrLCBob2xkKTtcbiAgICAgICAgICAgIGhidWZbMF0gPSBob2xkICYgMHhmZjtcbiAgICAgICAgICAgIGhidWZbMV0gPSAoaG9sZCA+Pj4gOCkgJiAweGZmO1xuICAgICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaGJ1ZiwgMiwgMCk7XG4gICAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgICAgYml0cyA9IDA7XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICBzdGF0ZS5oZWFkLmV4dHJhID0gbnVsbC8qWl9OVUxMKi87XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUubW9kZSA9IEVYVFJBO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIEVYVFJBOlxuICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDA0MDApIHtcbiAgICAgICAgICBjb3B5ID0gc3RhdGUubGVuZ3RoO1xuICAgICAgICAgIGlmIChjb3B5ID4gaGF2ZSkgeyBjb3B5ID0gaGF2ZTsgfVxuICAgICAgICAgIGlmIChjb3B5KSB7XG4gICAgICAgICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgICAgICBsZW4gPSBzdGF0ZS5oZWFkLmV4dHJhX2xlbiAtIHN0YXRlLmxlbmd0aDtcbiAgICAgICAgICAgICAgaWYgKCFzdGF0ZS5oZWFkLmV4dHJhKSB7XG4gICAgICAgICAgICAgICAgLy8gVXNlIHVudHlwZWQgYXJyYXkgZm9yIG1vcmUgY29udmVuaWVudCBwcm9jZXNzaW5nIGxhdGVyXG4gICAgICAgICAgICAgICAgc3RhdGUuaGVhZC5leHRyYSA9IG5ldyBBcnJheShzdGF0ZS5oZWFkLmV4dHJhX2xlbik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdXRpbHMuYXJyYXlTZXQoXG4gICAgICAgICAgICAgICAgc3RhdGUuaGVhZC5leHRyYSxcbiAgICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgICBuZXh0LFxuICAgICAgICAgICAgICAgIC8vIGV4dHJhIGZpZWxkIGlzIGxpbWl0ZWQgdG8gNjU1MzYgYnl0ZXNcbiAgICAgICAgICAgICAgICAvLyAtIG5vIG5lZWQgZm9yIGFkZGl0aW9uYWwgc2l6ZSBjaGVja1xuICAgICAgICAgICAgICAgIGNvcHksXG4gICAgICAgICAgICAgICAgLypsZW4gKyBjb3B5ID4gc3RhdGUuaGVhZC5leHRyYV9tYXggLSBsZW4gPyBzdGF0ZS5oZWFkLmV4dHJhX21heCA6IGNvcHksKi9cbiAgICAgICAgICAgICAgICBsZW5cbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgLy96bWVtY3B5KHN0YXRlLmhlYWQuZXh0cmEgKyBsZW4sIG5leHQsXG4gICAgICAgICAgICAgIC8vICAgICAgICBsZW4gKyBjb3B5ID4gc3RhdGUuaGVhZC5leHRyYV9tYXggP1xuICAgICAgICAgICAgICAvLyAgICAgICAgc3RhdGUuaGVhZC5leHRyYV9tYXggLSBsZW4gOiBjb3B5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBpbnB1dCwgY29weSwgbmV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBoYXZlIC09IGNvcHk7XG4gICAgICAgICAgICBuZXh0ICs9IGNvcHk7XG4gICAgICAgICAgICBzdGF0ZS5sZW5ndGggLT0gY29weTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHN0YXRlLmxlbmd0aCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5sZW5ndGggPSAwO1xuICAgICAgICBzdGF0ZS5tb2RlID0gTkFNRTtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBOQU1FOlxuICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDA4MDApIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBjb3B5ID0gMDtcbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAvLyBUT0RPOiAyIG9yIDEgYnl0ZXM/XG4gICAgICAgICAgICBsZW4gPSBpbnB1dFtuZXh0ICsgY29weSsrXTtcbiAgICAgICAgICAgIC8qIHVzZSBjb25zdGFudCBsaW1pdCBiZWNhdXNlIGluIGpzIHdlIHNob3VsZCBub3QgcHJlYWxsb2NhdGUgbWVtb3J5ICovXG4gICAgICAgICAgICBpZiAoc3RhdGUuaGVhZCAmJiBsZW4gJiZcbiAgICAgICAgICAgICAgICAoc3RhdGUubGVuZ3RoIDwgNjU1MzYgLypzdGF0ZS5oZWFkLm5hbWVfbWF4Ki8pKSB7XG4gICAgICAgICAgICAgIHN0YXRlLmhlYWQubmFtZSArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGxlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSB3aGlsZSAobGVuICYmIGNvcHkgPCBoYXZlKTtcblxuICAgICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaW5wdXQsIGNvcHksIG5leHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBoYXZlIC09IGNvcHk7XG4gICAgICAgICAgbmV4dCArPSBjb3B5O1xuICAgICAgICAgIGlmIChsZW4pIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgIHN0YXRlLmhlYWQubmFtZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUubGVuZ3RoID0gMDtcbiAgICAgICAgc3RhdGUubW9kZSA9IENPTU1FTlQ7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgQ09NTUVOVDpcbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgxMDAwKSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgY29weSA9IDA7XG4gICAgICAgICAgZG8ge1xuICAgICAgICAgICAgbGVuID0gaW5wdXRbbmV4dCArIGNvcHkrK107XG4gICAgICAgICAgICAvKiB1c2UgY29uc3RhbnQgbGltaXQgYmVjYXVzZSBpbiBqcyB3ZSBzaG91bGQgbm90IHByZWFsbG9jYXRlIG1lbW9yeSAqL1xuICAgICAgICAgICAgaWYgKHN0YXRlLmhlYWQgJiYgbGVuICYmXG4gICAgICAgICAgICAgICAgKHN0YXRlLmxlbmd0aCA8IDY1NTM2IC8qc3RhdGUuaGVhZC5jb21tX21heCovKSkge1xuICAgICAgICAgICAgICBzdGF0ZS5oZWFkLmNvbW1lbnQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShsZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gd2hpbGUgKGxlbiAmJiBjb3B5IDwgaGF2ZSk7XG4gICAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBpbnB1dCwgY29weSwgbmV4dCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGhhdmUgLT0gY29weTtcbiAgICAgICAgICBuZXh0ICs9IGNvcHk7XG4gICAgICAgICAgaWYgKGxlbikgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgc3RhdGUuaGVhZC5jb21tZW50ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5tb2RlID0gSENSQztcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBIQ1JDOlxuICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgICAvLz09PSBORUVEQklUUygxNik7ICovXG4gICAgICAgICAgd2hpbGUgKGJpdHMgPCAxNikge1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIGlmIChob2xkICE9PSAoc3RhdGUuY2hlY2sgJiAweGZmZmYpKSB7XG4gICAgICAgICAgICBzdHJtLm1zZyA9ICdoZWFkZXIgY3JjIG1pc21hdGNoJztcbiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgICBob2xkID0gMDtcbiAgICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICBzdGF0ZS5oZWFkLmhjcmMgPSAoKHN0YXRlLmZsYWdzID4+IDkpICYgMSk7XG4gICAgICAgICAgc3RhdGUuaGVhZC5kb25lID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBzdHJtLmFkbGVyID0gc3RhdGUuY2hlY2sgPSAwO1xuICAgICAgICBzdGF0ZS5tb2RlID0gVFlQRTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERJQ1RJRDpcbiAgICAgICAgLy89PT0gTkVFREJJVFMoMzIpOyAqL1xuICAgICAgICB3aGlsZSAoYml0cyA8IDMyKSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9IHpzd2FwMzIoaG9sZCk7XG4gICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgIGhvbGQgPSAwO1xuICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5tb2RlID0gRElDVDtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBESUNUOlxuICAgICAgICBpZiAoc3RhdGUuaGF2ZWRpY3QgPT09IDApIHtcbiAgICAgICAgICAvLy0tLSBSRVNUT1JFKCkgLS0tXG4gICAgICAgICAgc3RybS5uZXh0X291dCA9IHB1dDtcbiAgICAgICAgICBzdHJtLmF2YWlsX291dCA9IGxlZnQ7XG4gICAgICAgICAgc3RybS5uZXh0X2luID0gbmV4dDtcbiAgICAgICAgICBzdHJtLmF2YWlsX2luID0gaGF2ZTtcbiAgICAgICAgICBzdGF0ZS5ob2xkID0gaG9sZDtcbiAgICAgICAgICBzdGF0ZS5iaXRzID0gYml0cztcbiAgICAgICAgICAvLy0tLVxuICAgICAgICAgIHJldHVybiBaX05FRURfRElDVDtcbiAgICAgICAgfVxuICAgICAgICBzdHJtLmFkbGVyID0gc3RhdGUuY2hlY2sgPSAxLyphZGxlcjMyKDBMLCBaX05VTEwsIDApKi87XG4gICAgICAgIHN0YXRlLm1vZGUgPSBUWVBFO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIFRZUEU6XG4gICAgICAgIGlmIChmbHVzaCA9PT0gWl9CTE9DSyB8fCBmbHVzaCA9PT0gWl9UUkVFUykgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBUWVBFRE86XG4gICAgICAgIGlmIChzdGF0ZS5sYXN0KSB7XG4gICAgICAgICAgLy8tLS0gQllURUJJVFMoKSAtLS0vL1xuICAgICAgICAgIGhvbGQgPj4+PSBiaXRzICYgNztcbiAgICAgICAgICBiaXRzIC09IGJpdHMgJiA3O1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQ0hFQ0s7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0gTkVFREJJVFMoMyk7ICovXG4gICAgICAgIHdoaWxlIChiaXRzIDwgMykge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5sYXN0ID0gKGhvbGQgJiAweDAxKS8qQklUUygxKSovO1xuICAgICAgICAvLy0tLSBEUk9QQklUUygxKSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gMTtcbiAgICAgICAgYml0cyAtPSAxO1xuICAgICAgICAvLy0tLS8vXG5cbiAgICAgICAgc3dpdGNoICgoaG9sZCAmIDB4MDMpLypCSVRTKDIpKi8pIHtcbiAgICAgICAgICBjYXNlIDA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBzdG9yZWQgYmxvY2sgKi9cbiAgICAgICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgIHN0b3JlZCBibG9jayVzXFxuXCIsXG4gICAgICAgICAgICAvLyAgICAgICAgc3RhdGUubGFzdCA/IFwiIChsYXN0KVwiIDogXCJcIikpO1xuICAgICAgICAgICAgc3RhdGUubW9kZSA9IFNUT1JFRDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTogICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGZpeGVkIGJsb2NrICovXG4gICAgICAgICAgICBmaXhlZHRhYmxlcyhzdGF0ZSk7XG4gICAgICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgICBmaXhlZCBjb2RlcyBibG9jayVzXFxuXCIsXG4gICAgICAgICAgICAvLyAgICAgICAgc3RhdGUubGFzdCA/IFwiIChsYXN0KVwiIDogXCJcIikpO1xuICAgICAgICAgICAgc3RhdGUubW9kZSA9IExFTl87ICAgICAgICAgICAgIC8qIGRlY29kZSBjb2RlcyAqL1xuICAgICAgICAgICAgaWYgKGZsdXNoID09PSBaX1RSRUVTKSB7XG4gICAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKDIpIC0tLS8vXG4gICAgICAgICAgICAgIGhvbGQgPj4+PSAyO1xuICAgICAgICAgICAgICBiaXRzIC09IDI7XG4gICAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAyOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogZHluYW1pYyBibG9jayAqL1xuICAgICAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgZHluYW1pYyBjb2RlcyBibG9jayVzXFxuXCIsXG4gICAgICAgICAgICAvLyAgICAgICAgc3RhdGUubGFzdCA/IFwiIChsYXN0KVwiIDogXCJcIikpO1xuICAgICAgICAgICAgc3RhdGUubW9kZSA9IFRBQkxFO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBibG9jayB0eXBlJztcbiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8tLS0gRFJPUEJJVFMoMikgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IDI7XG4gICAgICAgIGJpdHMgLT0gMjtcbiAgICAgICAgLy8tLS0vL1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU1RPUkVEOlxuICAgICAgICAvLy0tLSBCWVRFQklUUygpIC0tLS8vIC8qIGdvIHRvIGJ5dGUgYm91bmRhcnkgKi9cbiAgICAgICAgaG9sZCA+Pj49IGJpdHMgJiA3O1xuICAgICAgICBiaXRzIC09IGJpdHMgJiA3O1xuICAgICAgICAvLy0tLS8vXG4gICAgICAgIC8vPT09IE5FRURCSVRTKDMyKTsgKi9cbiAgICAgICAgd2hpbGUgKGJpdHMgPCAzMikge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBpZiAoKGhvbGQgJiAweGZmZmYpICE9PSAoKGhvbGQgPj4+IDE2KSBeIDB4ZmZmZikpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIHN0b3JlZCBibG9jayBsZW5ndGhzJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmxlbmd0aCA9IGhvbGQgJiAweGZmZmY7XG4gICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgc3RvcmVkIGxlbmd0aCAldVxcblwiLFxuICAgICAgICAvLyAgICAgICAgc3RhdGUubGVuZ3RoKSk7XG4gICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgIGhvbGQgPSAwO1xuICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5tb2RlID0gQ09QWV87XG4gICAgICAgIGlmIChmbHVzaCA9PT0gWl9UUkVFUykgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBDT1BZXzpcbiAgICAgICAgc3RhdGUubW9kZSA9IENPUFk7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgQ09QWTpcbiAgICAgICAgY29weSA9IHN0YXRlLmxlbmd0aDtcbiAgICAgICAgaWYgKGNvcHkpIHtcbiAgICAgICAgICBpZiAoY29weSA+IGhhdmUpIHsgY29weSA9IGhhdmU7IH1cbiAgICAgICAgICBpZiAoY29weSA+IGxlZnQpIHsgY29weSA9IGxlZnQ7IH1cbiAgICAgICAgICBpZiAoY29weSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAvLy0tLSB6bWVtY3B5KHB1dCwgbmV4dCwgY29weSk7IC0tLVxuICAgICAgICAgIHV0aWxzLmFycmF5U2V0KG91dHB1dCwgaW5wdXQsIG5leHQsIGNvcHksIHB1dCk7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIGhhdmUgLT0gY29weTtcbiAgICAgICAgICBuZXh0ICs9IGNvcHk7XG4gICAgICAgICAgbGVmdCAtPSBjb3B5O1xuICAgICAgICAgIHB1dCArPSBjb3B5O1xuICAgICAgICAgIHN0YXRlLmxlbmd0aCAtPSBjb3B5O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgc3RvcmVkIGVuZFxcblwiKSk7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBUWVBFO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVEFCTEU6XG4gICAgICAgIC8vPT09IE5FRURCSVRTKDE0KTsgKi9cbiAgICAgICAgd2hpbGUgKGJpdHMgPCAxNCkge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5ubGVuID0gKGhvbGQgJiAweDFmKS8qQklUUyg1KSovICsgMjU3O1xuICAgICAgICAvLy0tLSBEUk9QQklUUyg1KSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gNTtcbiAgICAgICAgYml0cyAtPSA1O1xuICAgICAgICAvLy0tLS8vXG4gICAgICAgIHN0YXRlLm5kaXN0ID0gKGhvbGQgJiAweDFmKS8qQklUUyg1KSovICsgMTtcbiAgICAgICAgLy8tLS0gRFJPUEJJVFMoNSkgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IDU7XG4gICAgICAgIGJpdHMgLT0gNTtcbiAgICAgICAgLy8tLS0vL1xuICAgICAgICBzdGF0ZS5uY29kZSA9IChob2xkICYgMHgwZikvKkJJVFMoNCkqLyArIDQ7XG4gICAgICAgIC8vLS0tIERST1BCSVRTKDQpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSA0O1xuICAgICAgICBiaXRzIC09IDQ7XG4gICAgICAgIC8vLS0tLy9cbi8vI2lmbmRlZiBQS1pJUF9CVUdfV09SS0FST1VORFxuICAgICAgICBpZiAoc3RhdGUubmxlbiA+IDI4NiB8fCBzdGF0ZS5uZGlzdCA+IDMwKSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAndG9vIG1hbnkgbGVuZ3RoIG9yIGRpc3RhbmNlIHN5bWJvbHMnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbi8vI2VuZGlmXG4gICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgdGFibGUgc2l6ZXMgb2tcXG5cIikpO1xuICAgICAgICBzdGF0ZS5oYXZlID0gMDtcbiAgICAgICAgc3RhdGUubW9kZSA9IExFTkxFTlM7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgTEVOTEVOUzpcbiAgICAgICAgd2hpbGUgKHN0YXRlLmhhdmUgPCBzdGF0ZS5uY29kZSkge1xuICAgICAgICAgIC8vPT09IE5FRURCSVRTKDMpO1xuICAgICAgICAgIHdoaWxlIChiaXRzIDwgMykge1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIHN0YXRlLmxlbnNbb3JkZXJbc3RhdGUuaGF2ZSsrXV0gPSAoaG9sZCAmIDB4MDcpOy8vQklUUygzKTtcbiAgICAgICAgICAvLy0tLSBEUk9QQklUUygzKSAtLS0vL1xuICAgICAgICAgIGhvbGQgPj4+PSAzO1xuICAgICAgICAgIGJpdHMgLT0gMztcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHN0YXRlLmhhdmUgPCAxOSkge1xuICAgICAgICAgIHN0YXRlLmxlbnNbb3JkZXJbc3RhdGUuaGF2ZSsrXV0gPSAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdlIGhhdmUgc2VwYXJhdGUgdGFibGVzICYgbm8gcG9pbnRlcnMuIDIgY29tbWVudGVkIGxpbmVzIGJlbG93IG5vdCBuZWVkZWQuXG4gICAgICAgIC8vc3RhdGUubmV4dCA9IHN0YXRlLmNvZGVzO1xuICAgICAgICAvL3N0YXRlLmxlbmNvZGUgPSBzdGF0ZS5uZXh0O1xuICAgICAgICAvLyBTd2l0Y2ggdG8gdXNlIGR5bmFtaWMgdGFibGVcbiAgICAgICAgc3RhdGUubGVuY29kZSA9IHN0YXRlLmxlbmR5bjtcbiAgICAgICAgc3RhdGUubGVuYml0cyA9IDc7XG5cbiAgICAgICAgb3B0cyA9IHsgYml0czogc3RhdGUubGVuYml0cyB9O1xuICAgICAgICByZXQgPSBpbmZsYXRlX3RhYmxlKENPREVTLCBzdGF0ZS5sZW5zLCAwLCAxOSwgc3RhdGUubGVuY29kZSwgMCwgc3RhdGUud29yaywgb3B0cyk7XG4gICAgICAgIHN0YXRlLmxlbmJpdHMgPSBvcHRzLmJpdHM7XG5cbiAgICAgICAgaWYgKHJldCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgY29kZSBsZW5ndGhzIHNldCc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgIGNvZGUgbGVuZ3RocyBva1xcblwiKSk7XG4gICAgICAgIHN0YXRlLmhhdmUgPSAwO1xuICAgICAgICBzdGF0ZS5tb2RlID0gQ09ERUxFTlM7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgQ09ERUxFTlM6XG4gICAgICAgIHdoaWxlIChzdGF0ZS5oYXZlIDwgc3RhdGUubmxlbiArIHN0YXRlLm5kaXN0KSB7XG4gICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgaGVyZSA9IHN0YXRlLmxlbmNvZGVbaG9sZCAmICgoMSA8PCBzdGF0ZS5sZW5iaXRzKSAtIDEpXTsvKkJJVFMoc3RhdGUubGVuYml0cykqL1xuICAgICAgICAgICAgaGVyZV9iaXRzID0gaGVyZSA+Pj4gMjQ7XG4gICAgICAgICAgICBoZXJlX29wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmY7XG4gICAgICAgICAgICBoZXJlX3ZhbCA9IGhlcmUgJiAweGZmZmY7XG5cbiAgICAgICAgICAgIGlmICgoaGVyZV9iaXRzKSA8PSBiaXRzKSB7IGJyZWFrOyB9XG4gICAgICAgICAgICAvLy0tLSBQVUxMQllURSgpIC0tLS8vXG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaGVyZV92YWwgPCAxNikge1xuICAgICAgICAgICAgLy8tLS0gRFJPUEJJVFMoaGVyZS5iaXRzKSAtLS0vL1xuICAgICAgICAgICAgaG9sZCA+Pj49IGhlcmVfYml0cztcbiAgICAgICAgICAgIGJpdHMgLT0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgICAgc3RhdGUubGVuc1tzdGF0ZS5oYXZlKytdID0gaGVyZV92YWw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGhlcmVfdmFsID09PSAxNikge1xuICAgICAgICAgICAgICAvLz09PSBORUVEQklUUyhoZXJlLmJpdHMgKyAyKTtcbiAgICAgICAgICAgICAgbiA9IGhlcmVfYml0cyArIDI7XG4gICAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgbikge1xuICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy89PT0vL1xuICAgICAgICAgICAgICAvLy0tLSBEUk9QQklUUyhoZXJlLmJpdHMpIC0tLS8vXG4gICAgICAgICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7XG4gICAgICAgICAgICAgIGJpdHMgLT0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICAgIGlmIChzdGF0ZS5oYXZlID09PSAwKSB7XG4gICAgICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBiaXQgbGVuZ3RoIHJlcGVhdCc7XG4gICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBsZW4gPSBzdGF0ZS5sZW5zW3N0YXRlLmhhdmUgLSAxXTtcbiAgICAgICAgICAgICAgY29weSA9IDMgKyAoaG9sZCAmIDB4MDMpOy8vQklUUygyKTtcbiAgICAgICAgICAgICAgLy8tLS0gRFJPUEJJVFMoMikgLS0tLy9cbiAgICAgICAgICAgICAgaG9sZCA+Pj49IDI7XG4gICAgICAgICAgICAgIGJpdHMgLT0gMjtcbiAgICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaGVyZV92YWwgPT09IDE3KSB7XG4gICAgICAgICAgICAgIC8vPT09IE5FRURCSVRTKGhlcmUuYml0cyArIDMpO1xuICAgICAgICAgICAgICBuID0gaGVyZV9iaXRzICsgMztcbiAgICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCBuKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKGhlcmUuYml0cykgLS0tLy9cbiAgICAgICAgICAgICAgaG9sZCA+Pj49IGhlcmVfYml0cztcbiAgICAgICAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7XG4gICAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICAgICAgbGVuID0gMDtcbiAgICAgICAgICAgICAgY29weSA9IDMgKyAoaG9sZCAmIDB4MDcpOy8vQklUUygzKTtcbiAgICAgICAgICAgICAgLy8tLS0gRFJPUEJJVFMoMykgLS0tLy9cbiAgICAgICAgICAgICAgaG9sZCA+Pj49IDM7XG4gICAgICAgICAgICAgIGJpdHMgLT0gMztcbiAgICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIC8vPT09IE5FRURCSVRTKGhlcmUuYml0cyArIDcpO1xuICAgICAgICAgICAgICBuID0gaGVyZV9iaXRzICsgNztcbiAgICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCBuKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKGhlcmUuYml0cykgLS0tLy9cbiAgICAgICAgICAgICAgaG9sZCA+Pj49IGhlcmVfYml0cztcbiAgICAgICAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7XG4gICAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICAgICAgbGVuID0gMDtcbiAgICAgICAgICAgICAgY29weSA9IDExICsgKGhvbGQgJiAweDdmKTsvL0JJVFMoNyk7XG4gICAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKDcpIC0tLS8vXG4gICAgICAgICAgICAgIGhvbGQgPj4+PSA3O1xuICAgICAgICAgICAgICBiaXRzIC09IDc7XG4gICAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdGF0ZS5oYXZlICsgY29weSA+IHN0YXRlLm5sZW4gKyBzdGF0ZS5uZGlzdCkge1xuICAgICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGJpdCBsZW5ndGggcmVwZWF0JztcbiAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoY29weS0tKSB7XG4gICAgICAgICAgICAgIHN0YXRlLmxlbnNbc3RhdGUuaGF2ZSsrXSA9IGxlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKiBoYW5kbGUgZXJyb3IgYnJlYWtzIGluIHdoaWxlICovXG4gICAgICAgIGlmIChzdGF0ZS5tb2RlID09PSBCQUQpIHsgYnJlYWs7IH1cblxuICAgICAgICAvKiBjaGVjayBmb3IgZW5kLW9mLWJsb2NrIGNvZGUgKGJldHRlciBoYXZlIG9uZSkgKi9cbiAgICAgICAgaWYgKHN0YXRlLmxlbnNbMjU2XSA9PT0gMCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgY29kZSAtLSBtaXNzaW5nIGVuZC1vZi1ibG9jayc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIC8qIGJ1aWxkIGNvZGUgdGFibGVzIC0tIG5vdGU6IGRvIG5vdCBjaGFuZ2UgdGhlIGxlbmJpdHMgb3IgZGlzdGJpdHNcbiAgICAgICAgICAgdmFsdWVzIGhlcmUgKDkgYW5kIDYpIHdpdGhvdXQgcmVhZGluZyB0aGUgY29tbWVudHMgaW4gaW5mdHJlZXMuaFxuICAgICAgICAgICBjb25jZXJuaW5nIHRoZSBFTk9VR0ggY29uc3RhbnRzLCB3aGljaCBkZXBlbmQgb24gdGhvc2UgdmFsdWVzICovXG4gICAgICAgIHN0YXRlLmxlbmJpdHMgPSA5O1xuXG4gICAgICAgIG9wdHMgPSB7IGJpdHM6IHN0YXRlLmxlbmJpdHMgfTtcbiAgICAgICAgcmV0ID0gaW5mbGF0ZV90YWJsZShMRU5TLCBzdGF0ZS5sZW5zLCAwLCBzdGF0ZS5ubGVuLCBzdGF0ZS5sZW5jb2RlLCAwLCBzdGF0ZS53b3JrLCBvcHRzKTtcbiAgICAgICAgLy8gV2UgaGF2ZSBzZXBhcmF0ZSB0YWJsZXMgJiBubyBwb2ludGVycy4gMiBjb21tZW50ZWQgbGluZXMgYmVsb3cgbm90IG5lZWRlZC5cbiAgICAgICAgLy8gc3RhdGUubmV4dF9pbmRleCA9IG9wdHMudGFibGVfaW5kZXg7XG4gICAgICAgIHN0YXRlLmxlbmJpdHMgPSBvcHRzLmJpdHM7XG4gICAgICAgIC8vIHN0YXRlLmxlbmNvZGUgPSBzdGF0ZS5uZXh0O1xuXG4gICAgICAgIGlmIChyZXQpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGxpdGVyYWwvbGVuZ3RocyBzZXQnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZS5kaXN0Yml0cyA9IDY7XG4gICAgICAgIC8vc3RhdGUuZGlzdGNvZGUuY29weShzdGF0ZS5jb2Rlcyk7XG4gICAgICAgIC8vIFN3aXRjaCB0byB1c2UgZHluYW1pYyB0YWJsZVxuICAgICAgICBzdGF0ZS5kaXN0Y29kZSA9IHN0YXRlLmRpc3RkeW47XG4gICAgICAgIG9wdHMgPSB7IGJpdHM6IHN0YXRlLmRpc3RiaXRzIH07XG4gICAgICAgIHJldCA9IGluZmxhdGVfdGFibGUoRElTVFMsIHN0YXRlLmxlbnMsIHN0YXRlLm5sZW4sIHN0YXRlLm5kaXN0LCBzdGF0ZS5kaXN0Y29kZSwgMCwgc3RhdGUud29yaywgb3B0cyk7XG4gICAgICAgIC8vIFdlIGhhdmUgc2VwYXJhdGUgdGFibGVzICYgbm8gcG9pbnRlcnMuIDIgY29tbWVudGVkIGxpbmVzIGJlbG93IG5vdCBuZWVkZWQuXG4gICAgICAgIC8vIHN0YXRlLm5leHRfaW5kZXggPSBvcHRzLnRhYmxlX2luZGV4O1xuICAgICAgICBzdGF0ZS5kaXN0Yml0cyA9IG9wdHMuYml0cztcbiAgICAgICAgLy8gc3RhdGUuZGlzdGNvZGUgPSBzdGF0ZS5uZXh0O1xuXG4gICAgICAgIGlmIChyZXQpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGRpc3RhbmNlcyBzZXQnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgJ2luZmxhdGU6ICAgICAgIGNvZGVzIG9rXFxuJykpO1xuICAgICAgICBzdGF0ZS5tb2RlID0gTEVOXztcbiAgICAgICAgaWYgKGZsdXNoID09PSBaX1RSRUVTKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIExFTl86XG4gICAgICAgIHN0YXRlLm1vZGUgPSBMRU47XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgTEVOOlxuICAgICAgICBpZiAoaGF2ZSA+PSA2ICYmIGxlZnQgPj0gMjU4KSB7XG4gICAgICAgICAgLy8tLS0gUkVTVE9SRSgpIC0tLVxuICAgICAgICAgIHN0cm0ubmV4dF9vdXQgPSBwdXQ7XG4gICAgICAgICAgc3RybS5hdmFpbF9vdXQgPSBsZWZ0O1xuICAgICAgICAgIHN0cm0ubmV4dF9pbiA9IG5leHQ7XG4gICAgICAgICAgc3RybS5hdmFpbF9pbiA9IGhhdmU7XG4gICAgICAgICAgc3RhdGUuaG9sZCA9IGhvbGQ7XG4gICAgICAgICAgc3RhdGUuYml0cyA9IGJpdHM7XG4gICAgICAgICAgLy8tLS1cbiAgICAgICAgICBpbmZsYXRlX2Zhc3Qoc3RybSwgX291dCk7XG4gICAgICAgICAgLy8tLS0gTE9BRCgpIC0tLVxuICAgICAgICAgIHB1dCA9IHN0cm0ubmV4dF9vdXQ7XG4gICAgICAgICAgb3V0cHV0ID0gc3RybS5vdXRwdXQ7XG4gICAgICAgICAgbGVmdCA9IHN0cm0uYXZhaWxfb3V0O1xuICAgICAgICAgIG5leHQgPSBzdHJtLm5leHRfaW47XG4gICAgICAgICAgaW5wdXQgPSBzdHJtLmlucHV0O1xuICAgICAgICAgIGhhdmUgPSBzdHJtLmF2YWlsX2luO1xuICAgICAgICAgIGhvbGQgPSBzdGF0ZS5ob2xkO1xuICAgICAgICAgIGJpdHMgPSBzdGF0ZS5iaXRzO1xuICAgICAgICAgIC8vLS0tXG5cbiAgICAgICAgICBpZiAoc3RhdGUubW9kZSA9PT0gVFlQRSkge1xuICAgICAgICAgICAgc3RhdGUuYmFjayA9IC0xO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5iYWNrID0gMDtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgIGhlcmUgPSBzdGF0ZS5sZW5jb2RlW2hvbGQgJiAoKDEgPDwgc3RhdGUubGVuYml0cykgLSAxKV07ICAvKkJJVFMoc3RhdGUubGVuYml0cykqL1xuICAgICAgICAgIGhlcmVfYml0cyA9IGhlcmUgPj4+IDI0O1xuICAgICAgICAgIGhlcmVfb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZjtcbiAgICAgICAgICBoZXJlX3ZhbCA9IGhlcmUgJiAweGZmZmY7XG5cbiAgICAgICAgICBpZiAoaGVyZV9iaXRzIDw9IGJpdHMpIHsgYnJlYWs7IH1cbiAgICAgICAgICAvLy0tLSBQVUxMQllURSgpIC0tLS8vXG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhlcmVfb3AgJiYgKGhlcmVfb3AgJiAweGYwKSA9PT0gMCkge1xuICAgICAgICAgIGxhc3RfYml0cyA9IGhlcmVfYml0cztcbiAgICAgICAgICBsYXN0X29wID0gaGVyZV9vcDtcbiAgICAgICAgICBsYXN0X3ZhbCA9IGhlcmVfdmFsO1xuICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGhlcmUgPSBzdGF0ZS5sZW5jb2RlW2xhc3RfdmFsICtcbiAgICAgICAgICAgICAgICAgICAgKChob2xkICYgKCgxIDw8IChsYXN0X2JpdHMgKyBsYXN0X29wKSkgLSAxKSkvKkJJVFMobGFzdC5iaXRzICsgbGFzdC5vcCkqLyA+PiBsYXN0X2JpdHMpXTtcbiAgICAgICAgICAgIGhlcmVfYml0cyA9IGhlcmUgPj4+IDI0O1xuICAgICAgICAgICAgaGVyZV9vcCA9IChoZXJlID4+PiAxNikgJiAweGZmO1xuICAgICAgICAgICAgaGVyZV92YWwgPSBoZXJlICYgMHhmZmZmO1xuXG4gICAgICAgICAgICBpZiAoKGxhc3RfYml0cyArIGhlcmVfYml0cykgPD0gYml0cykgeyBicmVhazsgfVxuICAgICAgICAgICAgLy8tLS0gUFVMTEJZVEUoKSAtLS0vL1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8tLS0gRFJPUEJJVFMobGFzdC5iaXRzKSAtLS0vL1xuICAgICAgICAgIGhvbGQgPj4+PSBsYXN0X2JpdHM7XG4gICAgICAgICAgYml0cyAtPSBsYXN0X2JpdHM7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIHN0YXRlLmJhY2sgKz0gbGFzdF9iaXRzO1xuICAgICAgICB9XG4gICAgICAgIC8vLS0tIERST1BCSVRTKGhlcmUuYml0cykgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IGhlcmVfYml0cztcbiAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgICAgc3RhdGUuYmFjayArPSBoZXJlX2JpdHM7XG4gICAgICAgIHN0YXRlLmxlbmd0aCA9IGhlcmVfdmFsO1xuICAgICAgICBpZiAoaGVyZV9vcCA9PT0gMCkge1xuICAgICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBoZXJlLnZhbCA+PSAweDIwICYmIGhlcmUudmFsIDwgMHg3ZiA/XG4gICAgICAgICAgLy8gICAgICAgIFwiaW5mbGF0ZTogICAgICAgICBsaXRlcmFsICclYydcXG5cIiA6XG4gICAgICAgICAgLy8gICAgICAgIFwiaW5mbGF0ZTogICAgICAgICBsaXRlcmFsIDB4JTAyeFxcblwiLCBoZXJlLnZhbCkpO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBMSVQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhlcmVfb3AgJiAzMikge1xuICAgICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgICAgZW5kIG9mIGJsb2NrXFxuXCIpKTtcbiAgICAgICAgICBzdGF0ZS5iYWNrID0gLTE7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IFRZUEU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhlcmVfb3AgJiA2NCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgbGl0ZXJhbC9sZW5ndGggY29kZSc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5leHRyYSA9IGhlcmVfb3AgJiAxNTtcbiAgICAgICAgc3RhdGUubW9kZSA9IExFTkVYVDtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBMRU5FWFQ6XG4gICAgICAgIGlmIChzdGF0ZS5leHRyYSkge1xuICAgICAgICAgIC8vPT09IE5FRURCSVRTKHN0YXRlLmV4dHJhKTtcbiAgICAgICAgICBuID0gc3RhdGUuZXh0cmE7XG4gICAgICAgICAgd2hpbGUgKGJpdHMgPCBuKSB7XG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgc3RhdGUubGVuZ3RoICs9IGhvbGQgJiAoKDEgPDwgc3RhdGUuZXh0cmEpIC0gMSkvKkJJVFMoc3RhdGUuZXh0cmEpKi87XG4gICAgICAgICAgLy8tLS0gRFJPUEJJVFMoc3RhdGUuZXh0cmEpIC0tLS8vXG4gICAgICAgICAgaG9sZCA+Pj49IHN0YXRlLmV4dHJhO1xuICAgICAgICAgIGJpdHMgLT0gc3RhdGUuZXh0cmE7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIHN0YXRlLmJhY2sgKz0gc3RhdGUuZXh0cmE7XG4gICAgICAgIH1cbiAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgICBsZW5ndGggJXVcXG5cIiwgc3RhdGUubGVuZ3RoKSk7XG4gICAgICAgIHN0YXRlLndhcyA9IHN0YXRlLmxlbmd0aDtcbiAgICAgICAgc3RhdGUubW9kZSA9IERJU1Q7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgRElTVDpcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgIGhlcmUgPSBzdGF0ZS5kaXN0Y29kZVtob2xkICYgKCgxIDw8IHN0YXRlLmRpc3RiaXRzKSAtIDEpXTsvKkJJVFMoc3RhdGUuZGlzdGJpdHMpKi9cbiAgICAgICAgICBoZXJlX2JpdHMgPSBoZXJlID4+PiAyNDtcbiAgICAgICAgICBoZXJlX29wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmY7XG4gICAgICAgICAgaGVyZV92YWwgPSBoZXJlICYgMHhmZmZmO1xuXG4gICAgICAgICAgaWYgKChoZXJlX2JpdHMpIDw9IGJpdHMpIHsgYnJlYWs7IH1cbiAgICAgICAgICAvLy0tLSBQVUxMQllURSgpIC0tLS8vXG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgIH1cbiAgICAgICAgaWYgKChoZXJlX29wICYgMHhmMCkgPT09IDApIHtcbiAgICAgICAgICBsYXN0X2JpdHMgPSBoZXJlX2JpdHM7XG4gICAgICAgICAgbGFzdF9vcCA9IGhlcmVfb3A7XG4gICAgICAgICAgbGFzdF92YWwgPSBoZXJlX3ZhbDtcbiAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBoZXJlID0gc3RhdGUuZGlzdGNvZGVbbGFzdF92YWwgK1xuICAgICAgICAgICAgICAgICAgICAoKGhvbGQgJiAoKDEgPDwgKGxhc3RfYml0cyArIGxhc3Rfb3ApKSAtIDEpKS8qQklUUyhsYXN0LmJpdHMgKyBsYXN0Lm9wKSovID4+IGxhc3RfYml0cyldO1xuICAgICAgICAgICAgaGVyZV9iaXRzID0gaGVyZSA+Pj4gMjQ7XG4gICAgICAgICAgICBoZXJlX29wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmY7XG4gICAgICAgICAgICBoZXJlX3ZhbCA9IGhlcmUgJiAweGZmZmY7XG5cbiAgICAgICAgICAgIGlmICgobGFzdF9iaXRzICsgaGVyZV9iaXRzKSA8PSBiaXRzKSB7IGJyZWFrOyB9XG4gICAgICAgICAgICAvLy0tLSBQVUxMQllURSgpIC0tLS8vXG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLy0tLSBEUk9QQklUUyhsYXN0LmJpdHMpIC0tLS8vXG4gICAgICAgICAgaG9sZCA+Pj49IGxhc3RfYml0cztcbiAgICAgICAgICBiaXRzIC09IGxhc3RfYml0cztcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgc3RhdGUuYmFjayArPSBsYXN0X2JpdHM7XG4gICAgICAgIH1cbiAgICAgICAgLy8tLS0gRFJPUEJJVFMoaGVyZS5iaXRzKSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gaGVyZV9iaXRzO1xuICAgICAgICBiaXRzIC09IGhlcmVfYml0cztcbiAgICAgICAgLy8tLS0vL1xuICAgICAgICBzdGF0ZS5iYWNrICs9IGhlcmVfYml0cztcbiAgICAgICAgaWYgKGhlcmVfb3AgJiA2NCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgZGlzdGFuY2UgY29kZSc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5vZmZzZXQgPSBoZXJlX3ZhbDtcbiAgICAgICAgc3RhdGUuZXh0cmEgPSAoaGVyZV9vcCkgJiAxNTtcbiAgICAgICAgc3RhdGUubW9kZSA9IERJU1RFWFQ7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgRElTVEVYVDpcbiAgICAgICAgaWYgKHN0YXRlLmV4dHJhKSB7XG4gICAgICAgICAgLy89PT0gTkVFREJJVFMoc3RhdGUuZXh0cmEpO1xuICAgICAgICAgIG4gPSBzdGF0ZS5leHRyYTtcbiAgICAgICAgICB3aGlsZSAoYml0cyA8IG4pIHtcbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICBzdGF0ZS5vZmZzZXQgKz0gaG9sZCAmICgoMSA8PCBzdGF0ZS5leHRyYSkgLSAxKS8qQklUUyhzdGF0ZS5leHRyYSkqLztcbiAgICAgICAgICAvLy0tLSBEUk9QQklUUyhzdGF0ZS5leHRyYSkgLS0tLy9cbiAgICAgICAgICBob2xkID4+Pj0gc3RhdGUuZXh0cmE7XG4gICAgICAgICAgYml0cyAtPSBzdGF0ZS5leHRyYTtcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgc3RhdGUuYmFjayArPSBzdGF0ZS5leHRyYTtcbiAgICAgICAgfVxuLy8jaWZkZWYgSU5GTEFURV9TVFJJQ1RcbiAgICAgICAgaWYgKHN0YXRlLm9mZnNldCA+IHN0YXRlLmRtYXgpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgYmFjayc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuLy8jZW5kaWZcbiAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgICBkaXN0YW5jZSAldVxcblwiLCBzdGF0ZS5vZmZzZXQpKTtcbiAgICAgICAgc3RhdGUubW9kZSA9IE1BVENIO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIE1BVENIOlxuICAgICAgICBpZiAobGVmdCA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgY29weSA9IF9vdXQgLSBsZWZ0O1xuICAgICAgICBpZiAoc3RhdGUub2Zmc2V0ID4gY29weSkgeyAgICAgICAgIC8qIGNvcHkgZnJvbSB3aW5kb3cgKi9cbiAgICAgICAgICBjb3B5ID0gc3RhdGUub2Zmc2V0IC0gY29weTtcbiAgICAgICAgICBpZiAoY29weSA+IHN0YXRlLndoYXZlKSB7XG4gICAgICAgICAgICBpZiAoc3RhdGUuc2FuZSkge1xuICAgICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgYmFjayc7XG4gICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuLy8gKCEpIFRoaXMgYmxvY2sgaXMgZGlzYWJsZWQgaW4gemxpYiBkZWZhdWx0cyxcbi8vIGRvbid0IGVuYWJsZSBpdCBmb3IgYmluYXJ5IGNvbXBhdGliaWxpdHlcbi8vI2lmZGVmIElORkxBVEVfQUxMT1dfSU5WQUxJRF9ESVNUQU5DRV9UT09GQVJfQVJSUlxuLy8gICAgICAgICAgVHJhY2UoKHN0ZGVyciwgXCJpbmZsYXRlLmMgdG9vIGZhclxcblwiKSk7XG4vLyAgICAgICAgICBjb3B5IC09IHN0YXRlLndoYXZlO1xuLy8gICAgICAgICAgaWYgKGNvcHkgPiBzdGF0ZS5sZW5ndGgpIHsgY29weSA9IHN0YXRlLmxlbmd0aDsgfVxuLy8gICAgICAgICAgaWYgKGNvcHkgPiBsZWZ0KSB7IGNvcHkgPSBsZWZ0OyB9XG4vLyAgICAgICAgICBsZWZ0IC09IGNvcHk7XG4vLyAgICAgICAgICBzdGF0ZS5sZW5ndGggLT0gY29weTtcbi8vICAgICAgICAgIGRvIHtcbi8vICAgICAgICAgICAgb3V0cHV0W3B1dCsrXSA9IDA7XG4vLyAgICAgICAgICB9IHdoaWxlICgtLWNvcHkpO1xuLy8gICAgICAgICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgeyBzdGF0ZS5tb2RlID0gTEVOOyB9XG4vLyAgICAgICAgICBicmVhaztcbi8vI2VuZGlmXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjb3B5ID4gc3RhdGUud25leHQpIHtcbiAgICAgICAgICAgIGNvcHkgLT0gc3RhdGUud25leHQ7XG4gICAgICAgICAgICBmcm9tID0gc3RhdGUud3NpemUgLSBjb3B5O1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZyb20gPSBzdGF0ZS53bmV4dCAtIGNvcHk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjb3B5ID4gc3RhdGUubGVuZ3RoKSB7IGNvcHkgPSBzdGF0ZS5sZW5ndGg7IH1cbiAgICAgICAgICBmcm9tX3NvdXJjZSA9IHN0YXRlLndpbmRvdztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBjb3B5IGZyb20gb3V0cHV0ICovXG4gICAgICAgICAgZnJvbV9zb3VyY2UgPSBvdXRwdXQ7XG4gICAgICAgICAgZnJvbSA9IHB1dCAtIHN0YXRlLm9mZnNldDtcbiAgICAgICAgICBjb3B5ID0gc3RhdGUubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb3B5ID4gbGVmdCkgeyBjb3B5ID0gbGVmdDsgfVxuICAgICAgICBsZWZ0IC09IGNvcHk7XG4gICAgICAgIHN0YXRlLmxlbmd0aCAtPSBjb3B5O1xuICAgICAgICBkbyB7XG4gICAgICAgICAgb3V0cHV0W3B1dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107XG4gICAgICAgIH0gd2hpbGUgKC0tY29weSk7XG4gICAgICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHsgc3RhdGUubW9kZSA9IExFTjsgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgTElUOlxuICAgICAgICBpZiAobGVmdCA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgb3V0cHV0W3B1dCsrXSA9IHN0YXRlLmxlbmd0aDtcbiAgICAgICAgbGVmdC0tO1xuICAgICAgICBzdGF0ZS5tb2RlID0gTEVOO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQ0hFQ0s6XG4gICAgICAgIGlmIChzdGF0ZS53cmFwKSB7XG4gICAgICAgICAgLy89PT0gTkVFREJJVFMoMzIpO1xuICAgICAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHtcbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgLy8gVXNlICd8JyBpbnN0ZWFkIG9mICcrJyB0byBtYWtlIHN1cmUgdGhhdCByZXN1bHQgaXMgc2lnbmVkXG4gICAgICAgICAgICBob2xkIHw9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIF9vdXQgLT0gbGVmdDtcbiAgICAgICAgICBzdHJtLnRvdGFsX291dCArPSBfb3V0O1xuICAgICAgICAgIHN0YXRlLnRvdGFsICs9IF9vdXQ7XG4gICAgICAgICAgaWYgKF9vdXQpIHtcbiAgICAgICAgICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9XG4gICAgICAgICAgICAgICAgLypVUERBVEUoc3RhdGUuY2hlY2ssIHB1dCAtIF9vdXQsIF9vdXQpOyovXG4gICAgICAgICAgICAgICAgKHN0YXRlLmZsYWdzID8gY3JjMzIoc3RhdGUuY2hlY2ssIG91dHB1dCwgX291dCwgcHV0IC0gX291dCkgOiBhZGxlcjMyKHN0YXRlLmNoZWNrLCBvdXRwdXQsIF9vdXQsIHB1dCAtIF9vdXQpKTtcblxuICAgICAgICAgIH1cbiAgICAgICAgICBfb3V0ID0gbGVmdDtcbiAgICAgICAgICAvLyBOQjogY3JjMzIgc3RvcmVkIGFzIHNpZ25lZCAzMi1iaXQgaW50LCB6c3dhcDMyIHJldHVybnMgc2lnbmVkIHRvb1xuICAgICAgICAgIGlmICgoc3RhdGUuZmxhZ3MgPyBob2xkIDogenN3YXAzMihob2xkKSkgIT09IHN0YXRlLmNoZWNrKSB7XG4gICAgICAgICAgICBzdHJtLm1zZyA9ICdpbmNvcnJlY3QgZGF0YSBjaGVjayc7XG4gICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgICAgYml0cyA9IDA7XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICBjaGVjayBtYXRjaGVzIHRyYWlsZXJcXG5cIikpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLm1vZGUgPSBMRU5HVEg7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgTEVOR1RIOlxuICAgICAgICBpZiAoc3RhdGUud3JhcCAmJiBzdGF0ZS5mbGFncykge1xuICAgICAgICAgIC8vPT09IE5FRURCSVRTKDMyKTtcbiAgICAgICAgICB3aGlsZSAoYml0cyA8IDMyKSB7XG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgaWYgKGhvbGQgIT09IChzdGF0ZS50b3RhbCAmIDB4ZmZmZmZmZmYpKSB7XG4gICAgICAgICAgICBzdHJtLm1zZyA9ICdpbmNvcnJlY3QgbGVuZ3RoIGNoZWNrJztcbiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgICBob2xkID0gMDtcbiAgICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgIGxlbmd0aCBtYXRjaGVzIHRyYWlsZXJcXG5cIikpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLm1vZGUgPSBET05FO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIERPTkU6XG4gICAgICAgIHJldCA9IFpfU1RSRUFNX0VORDtcbiAgICAgICAgYnJlYWsgaW5mX2xlYXZlO1xuICAgICAgY2FzZSBCQUQ6XG4gICAgICAgIHJldCA9IFpfREFUQV9FUlJPUjtcbiAgICAgICAgYnJlYWsgaW5mX2xlYXZlO1xuICAgICAgY2FzZSBNRU06XG4gICAgICAgIHJldHVybiBaX01FTV9FUlJPUjtcbiAgICAgIGNhc2UgU1lOQzpcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICAgIH1cbiAgfVxuXG4gIC8vIGluZl9sZWF2ZSA8LSBoZXJlIGlzIHJlYWwgcGxhY2UgZm9yIFwiZ290byBpbmZfbGVhdmVcIiwgZW11bGF0ZWQgdmlhIFwiYnJlYWsgaW5mX2xlYXZlXCJcblxuICAvKlxuICAgICBSZXR1cm4gZnJvbSBpbmZsYXRlKCksIHVwZGF0aW5nIHRoZSB0b3RhbCBjb3VudHMgYW5kIHRoZSBjaGVjayB2YWx1ZS5cbiAgICAgSWYgdGhlcmUgd2FzIG5vIHByb2dyZXNzIGR1cmluZyB0aGUgaW5mbGF0ZSgpIGNhbGwsIHJldHVybiBhIGJ1ZmZlclxuICAgICBlcnJvci4gIENhbGwgdXBkYXRld2luZG93KCkgdG8gY3JlYXRlIGFuZC9vciB1cGRhdGUgdGhlIHdpbmRvdyBzdGF0ZS5cbiAgICAgTm90ZTogYSBtZW1vcnkgZXJyb3IgZnJvbSBpbmZsYXRlKCkgaXMgbm9uLXJlY292ZXJhYmxlLlxuICAgKi9cblxuICAvLy0tLSBSRVNUT1JFKCkgLS0tXG4gIHN0cm0ubmV4dF9vdXQgPSBwdXQ7XG4gIHN0cm0uYXZhaWxfb3V0ID0gbGVmdDtcbiAgc3RybS5uZXh0X2luID0gbmV4dDtcbiAgc3RybS5hdmFpbF9pbiA9IGhhdmU7XG4gIHN0YXRlLmhvbGQgPSBob2xkO1xuICBzdGF0ZS5iaXRzID0gYml0cztcbiAgLy8tLS1cblxuICBpZiAoc3RhdGUud3NpemUgfHwgKF9vdXQgIT09IHN0cm0uYXZhaWxfb3V0ICYmIHN0YXRlLm1vZGUgPCBCQUQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAoc3RhdGUubW9kZSA8IENIRUNLIHx8IGZsdXNoICE9PSBaX0ZJTklTSCkpKSB7XG4gICAgaWYgKHVwZGF0ZXdpbmRvdyhzdHJtLCBzdHJtLm91dHB1dCwgc3RybS5uZXh0X291dCwgX291dCAtIHN0cm0uYXZhaWxfb3V0KSkge1xuICAgICAgc3RhdGUubW9kZSA9IE1FTTtcbiAgICAgIHJldHVybiBaX01FTV9FUlJPUjtcbiAgICB9XG4gIH1cbiAgX2luIC09IHN0cm0uYXZhaWxfaW47XG4gIF9vdXQgLT0gc3RybS5hdmFpbF9vdXQ7XG4gIHN0cm0udG90YWxfaW4gKz0gX2luO1xuICBzdHJtLnRvdGFsX291dCArPSBfb3V0O1xuICBzdGF0ZS50b3RhbCArPSBfb3V0O1xuICBpZiAoc3RhdGUud3JhcCAmJiBfb3V0KSB7XG4gICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0gLypVUERBVEUoc3RhdGUuY2hlY2ssIHN0cm0ubmV4dF9vdXQgLSBfb3V0LCBfb3V0KTsqL1xuICAgICAgKHN0YXRlLmZsYWdzID8gY3JjMzIoc3RhdGUuY2hlY2ssIG91dHB1dCwgX291dCwgc3RybS5uZXh0X291dCAtIF9vdXQpIDogYWRsZXIzMihzdGF0ZS5jaGVjaywgb3V0cHV0LCBfb3V0LCBzdHJtLm5leHRfb3V0IC0gX291dCkpO1xuICB9XG4gIHN0cm0uZGF0YV90eXBlID0gc3RhdGUuYml0cyArIChzdGF0ZS5sYXN0ID8gNjQgOiAwKSArXG4gICAgICAgICAgICAgICAgICAgIChzdGF0ZS5tb2RlID09PSBUWVBFID8gMTI4IDogMCkgK1xuICAgICAgICAgICAgICAgICAgICAoc3RhdGUubW9kZSA9PT0gTEVOXyB8fCBzdGF0ZS5tb2RlID09PSBDT1BZXyA/IDI1NiA6IDApO1xuICBpZiAoKChfaW4gPT09IDAgJiYgX291dCA9PT0gMCkgfHwgZmx1c2ggPT09IFpfRklOSVNIKSAmJiByZXQgPT09IFpfT0spIHtcbiAgICByZXQgPSBaX0JVRl9FUlJPUjtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBpbmZsYXRlRW5kKHN0cm0pIHtcblxuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUgLyp8fCBzdHJtLT56ZnJlZSA9PSAoZnJlZV9mdW5jKTAqLykge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuXG4gIHZhciBzdGF0ZSA9IHN0cm0uc3RhdGU7XG4gIGlmIChzdGF0ZS53aW5kb3cpIHtcbiAgICBzdGF0ZS53aW5kb3cgPSBudWxsO1xuICB9XG4gIHN0cm0uc3RhdGUgPSBudWxsO1xuICByZXR1cm4gWl9PSztcbn1cblxuZnVuY3Rpb24gaW5mbGF0ZUdldEhlYWRlcihzdHJtLCBoZWFkKSB7XG4gIHZhciBzdGF0ZTtcblxuICAvKiBjaGVjayBzdGF0ZSAqL1xuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG4gIHN0YXRlID0gc3RybS5zdGF0ZTtcbiAgaWYgKChzdGF0ZS53cmFwICYgMikgPT09IDApIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG5cbiAgLyogc2F2ZSBoZWFkZXIgc3RydWN0dXJlICovXG4gIHN0YXRlLmhlYWQgPSBoZWFkO1xuICBoZWFkLmRvbmUgPSBmYWxzZTtcbiAgcmV0dXJuIFpfT0s7XG59XG5cbmZ1bmN0aW9uIGluZmxhdGVTZXREaWN0aW9uYXJ5KHN0cm0sIGRpY3Rpb25hcnkpIHtcbiAgdmFyIGRpY3RMZW5ndGggPSBkaWN0aW9uYXJ5Lmxlbmd0aDtcblxuICB2YXIgc3RhdGU7XG4gIHZhciBkaWN0aWQ7XG4gIHZhciByZXQ7XG5cbiAgLyogY2hlY2sgc3RhdGUgKi9cbiAgaWYgKCFzdHJtIC8qID09IFpfTlVMTCAqLyB8fCAhc3RybS5zdGF0ZSAvKiA9PSBaX05VTEwgKi8pIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG4gIHN0YXRlID0gc3RybS5zdGF0ZTtcblxuICBpZiAoc3RhdGUud3JhcCAhPT0gMCAmJiBzdGF0ZS5tb2RlICE9PSBESUNUKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICB9XG5cbiAgLyogY2hlY2sgZm9yIGNvcnJlY3QgZGljdGlvbmFyeSBpZGVudGlmaWVyICovXG4gIGlmIChzdGF0ZS5tb2RlID09PSBESUNUKSB7XG4gICAgZGljdGlkID0gMTsgLyogYWRsZXIzMigwLCBudWxsLCAwKSovXG4gICAgLyogZGljdGlkID0gYWRsZXIzMihkaWN0aWQsIGRpY3Rpb25hcnksIGRpY3RMZW5ndGgpOyAqL1xuICAgIGRpY3RpZCA9IGFkbGVyMzIoZGljdGlkLCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoLCAwKTtcbiAgICBpZiAoZGljdGlkICE9PSBzdGF0ZS5jaGVjaykge1xuICAgICAgcmV0dXJuIFpfREFUQV9FUlJPUjtcbiAgICB9XG4gIH1cbiAgLyogY29weSBkaWN0aW9uYXJ5IHRvIHdpbmRvdyB1c2luZyB1cGRhdGV3aW5kb3coKSwgd2hpY2ggd2lsbCBhbWVuZCB0aGVcbiAgIGV4aXN0aW5nIGRpY3Rpb25hcnkgaWYgYXBwcm9wcmlhdGUgKi9cbiAgcmV0ID0gdXBkYXRld2luZG93KHN0cm0sIGRpY3Rpb25hcnksIGRpY3RMZW5ndGgsIGRpY3RMZW5ndGgpO1xuICBpZiAocmV0KSB7XG4gICAgc3RhdGUubW9kZSA9IE1FTTtcbiAgICByZXR1cm4gWl9NRU1fRVJST1I7XG4gIH1cbiAgc3RhdGUuaGF2ZWRpY3QgPSAxO1xuICAvLyBUcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgIGRpY3Rpb25hcnkgc2V0XFxuXCIpKTtcbiAgcmV0dXJuIFpfT0s7XG59XG5cbmV4cG9ydHMuaW5mbGF0ZVJlc2V0ID0gaW5mbGF0ZVJlc2V0O1xuZXhwb3J0cy5pbmZsYXRlUmVzZXQyID0gaW5mbGF0ZVJlc2V0MjtcbmV4cG9ydHMuaW5mbGF0ZVJlc2V0S2VlcCA9IGluZmxhdGVSZXNldEtlZXA7XG5leHBvcnRzLmluZmxhdGVJbml0ID0gaW5mbGF0ZUluaXQ7XG5leHBvcnRzLmluZmxhdGVJbml0MiA9IGluZmxhdGVJbml0MjtcbmV4cG9ydHMuaW5mbGF0ZSA9IGluZmxhdGU7XG5leHBvcnRzLmluZmxhdGVFbmQgPSBpbmZsYXRlRW5kO1xuZXhwb3J0cy5pbmZsYXRlR2V0SGVhZGVyID0gaW5mbGF0ZUdldEhlYWRlcjtcbmV4cG9ydHMuaW5mbGF0ZVNldERpY3Rpb25hcnkgPSBpbmZsYXRlU2V0RGljdGlvbmFyeTtcbmV4cG9ydHMuaW5mbGF0ZUluZm8gPSAncGFrbyBpbmZsYXRlIChmcm9tIE5vZGVjYSBwcm9qZWN0KSc7XG5cbi8qIE5vdCBpbXBsZW1lbnRlZFxuZXhwb3J0cy5pbmZsYXRlQ29weSA9IGluZmxhdGVDb3B5O1xuZXhwb3J0cy5pbmZsYXRlR2V0RGljdGlvbmFyeSA9IGluZmxhdGVHZXREaWN0aW9uYXJ5O1xuZXhwb3J0cy5pbmZsYXRlTWFyayA9IGluZmxhdGVNYXJrO1xuZXhwb3J0cy5pbmZsYXRlUHJpbWUgPSBpbmZsYXRlUHJpbWU7XG5leHBvcnRzLmluZmxhdGVTeW5jID0gaW5mbGF0ZVN5bmM7XG5leHBvcnRzLmluZmxhdGVTeW5jUG9pbnQgPSBpbmZsYXRlU3luY1BvaW50O1xuZXhwb3J0cy5pbmZsYXRlVW5kZXJtaW5lID0gaW5mbGF0ZVVuZGVybWluZTtcbiovXG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvY29tbW9uJyk7XG5cbnZhciBNQVhCSVRTID0gMTU7XG52YXIgRU5PVUdIX0xFTlMgPSA4NTI7XG52YXIgRU5PVUdIX0RJU1RTID0gNTkyO1xuLy92YXIgRU5PVUdIID0gKEVOT1VHSF9MRU5TK0VOT1VHSF9ESVNUUyk7XG5cbnZhciBDT0RFUyA9IDA7XG52YXIgTEVOUyA9IDE7XG52YXIgRElTVFMgPSAyO1xuXG52YXIgbGJhc2UgPSBbIC8qIExlbmd0aCBjb2RlcyAyNTcuLjI4NSBiYXNlICovXG4gIDMsIDQsIDUsIDYsIDcsIDgsIDksIDEwLCAxMSwgMTMsIDE1LCAxNywgMTksIDIzLCAyNywgMzEsXG4gIDM1LCA0MywgNTEsIDU5LCA2NywgODMsIDk5LCAxMTUsIDEzMSwgMTYzLCAxOTUsIDIyNywgMjU4LCAwLCAwXG5dO1xuXG52YXIgbGV4dCA9IFsgLyogTGVuZ3RoIGNvZGVzIDI1Ny4uMjg1IGV4dHJhICovXG4gIDE2LCAxNiwgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNiwgMTcsIDE3LCAxNywgMTcsIDE4LCAxOCwgMTgsIDE4LFxuICAxOSwgMTksIDE5LCAxOSwgMjAsIDIwLCAyMCwgMjAsIDIxLCAyMSwgMjEsIDIxLCAxNiwgNzIsIDc4XG5dO1xuXG52YXIgZGJhc2UgPSBbIC8qIERpc3RhbmNlIGNvZGVzIDAuLjI5IGJhc2UgKi9cbiAgMSwgMiwgMywgNCwgNSwgNywgOSwgMTMsIDE3LCAyNSwgMzMsIDQ5LCA2NSwgOTcsIDEyOSwgMTkzLFxuICAyNTcsIDM4NSwgNTEzLCA3NjksIDEwMjUsIDE1MzcsIDIwNDksIDMwNzMsIDQwOTcsIDYxNDUsXG4gIDgxOTMsIDEyMjg5LCAxNjM4NSwgMjQ1NzcsIDAsIDBcbl07XG5cbnZhciBkZXh0ID0gWyAvKiBEaXN0YW5jZSBjb2RlcyAwLi4yOSBleHRyYSAqL1xuICAxNiwgMTYsIDE2LCAxNiwgMTcsIDE3LCAxOCwgMTgsIDE5LCAxOSwgMjAsIDIwLCAyMSwgMjEsIDIyLCAyMixcbiAgMjMsIDIzLCAyNCwgMjQsIDI1LCAyNSwgMjYsIDI2LCAyNywgMjcsXG4gIDI4LCAyOCwgMjksIDI5LCA2NCwgNjRcbl07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5mbGF0ZV90YWJsZSh0eXBlLCBsZW5zLCBsZW5zX2luZGV4LCBjb2RlcywgdGFibGUsIHRhYmxlX2luZGV4LCB3b3JrLCBvcHRzKVxue1xuICB2YXIgYml0cyA9IG9wdHMuYml0cztcbiAgICAgIC8vaGVyZSA9IG9wdHMuaGVyZTsgLyogdGFibGUgZW50cnkgZm9yIGR1cGxpY2F0aW9uICovXG5cbiAgdmFyIGxlbiA9IDA7ICAgICAgICAgICAgICAgLyogYSBjb2RlJ3MgbGVuZ3RoIGluIGJpdHMgKi9cbiAgdmFyIHN5bSA9IDA7ICAgICAgICAgICAgICAgLyogaW5kZXggb2YgY29kZSBzeW1ib2xzICovXG4gIHZhciBtaW4gPSAwLCBtYXggPSAwOyAgICAgICAgICAvKiBtaW5pbXVtIGFuZCBtYXhpbXVtIGNvZGUgbGVuZ3RocyAqL1xuICB2YXIgcm9vdCA9IDA7ICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgaW5kZXggYml0cyBmb3Igcm9vdCB0YWJsZSAqL1xuICB2YXIgY3VyciA9IDA7ICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgaW5kZXggYml0cyBmb3IgY3VycmVudCB0YWJsZSAqL1xuICB2YXIgZHJvcCA9IDA7ICAgICAgICAgICAgICAvKiBjb2RlIGJpdHMgdG8gZHJvcCBmb3Igc3ViLXRhYmxlICovXG4gIHZhciBsZWZ0ID0gMDsgICAgICAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIHByZWZpeCBjb2RlcyBhdmFpbGFibGUgKi9cbiAgdmFyIHVzZWQgPSAwOyAgICAgICAgICAgICAgLyogY29kZSBlbnRyaWVzIGluIHRhYmxlIHVzZWQgKi9cbiAgdmFyIGh1ZmYgPSAwOyAgICAgICAgICAgICAgLyogSHVmZm1hbiBjb2RlICovXG4gIHZhciBpbmNyOyAgICAgICAgICAgICAgLyogZm9yIGluY3JlbWVudGluZyBjb2RlLCBpbmRleCAqL1xuICB2YXIgZmlsbDsgICAgICAgICAgICAgIC8qIGluZGV4IGZvciByZXBsaWNhdGluZyBlbnRyaWVzICovXG4gIHZhciBsb3c7ICAgICAgICAgICAgICAgLyogbG93IGJpdHMgZm9yIGN1cnJlbnQgcm9vdCBlbnRyeSAqL1xuICB2YXIgbWFzazsgICAgICAgICAgICAgIC8qIG1hc2sgZm9yIGxvdyByb290IGJpdHMgKi9cbiAgdmFyIG5leHQ7ICAgICAgICAgICAgIC8qIG5leHQgYXZhaWxhYmxlIHNwYWNlIGluIHRhYmxlICovXG4gIHZhciBiYXNlID0gbnVsbDsgICAgIC8qIGJhc2UgdmFsdWUgdGFibGUgdG8gdXNlICovXG4gIHZhciBiYXNlX2luZGV4ID0gMDtcbi8vICB2YXIgc2hvZXh0cmE7ICAgIC8qIGV4dHJhIGJpdHMgdGFibGUgdG8gdXNlICovXG4gIHZhciBlbmQ7ICAgICAgICAgICAgICAgICAgICAvKiB1c2UgYmFzZSBhbmQgZXh0cmEgZm9yIHN5bWJvbCA+IGVuZCAqL1xuICB2YXIgY291bnQgPSBuZXcgdXRpbHMuQnVmMTYoTUFYQklUUyArIDEpOyAvL1tNQVhCSVRTKzFdOyAgICAvKiBudW1iZXIgb2YgY29kZXMgb2YgZWFjaCBsZW5ndGggKi9cbiAgdmFyIG9mZnMgPSBuZXcgdXRpbHMuQnVmMTYoTUFYQklUUyArIDEpOyAvL1tNQVhCSVRTKzFdOyAgICAgLyogb2Zmc2V0cyBpbiB0YWJsZSBmb3IgZWFjaCBsZW5ndGggKi9cbiAgdmFyIGV4dHJhID0gbnVsbDtcbiAgdmFyIGV4dHJhX2luZGV4ID0gMDtcblxuICB2YXIgaGVyZV9iaXRzLCBoZXJlX29wLCBoZXJlX3ZhbDtcblxuICAvKlxuICAgUHJvY2VzcyBhIHNldCBvZiBjb2RlIGxlbmd0aHMgdG8gY3JlYXRlIGEgY2Fub25pY2FsIEh1ZmZtYW4gY29kZS4gIFRoZVxuICAgY29kZSBsZW5ndGhzIGFyZSBsZW5zWzAuLmNvZGVzLTFdLiAgRWFjaCBsZW5ndGggY29ycmVzcG9uZHMgdG8gdGhlXG4gICBzeW1ib2xzIDAuLmNvZGVzLTEuICBUaGUgSHVmZm1hbiBjb2RlIGlzIGdlbmVyYXRlZCBieSBmaXJzdCBzb3J0aW5nIHRoZVxuICAgc3ltYm9scyBieSBsZW5ndGggZnJvbSBzaG9ydCB0byBsb25nLCBhbmQgcmV0YWluaW5nIHRoZSBzeW1ib2wgb3JkZXJcbiAgIGZvciBjb2RlcyB3aXRoIGVxdWFsIGxlbmd0aHMuICBUaGVuIHRoZSBjb2RlIHN0YXJ0cyB3aXRoIGFsbCB6ZXJvIGJpdHNcbiAgIGZvciB0aGUgZmlyc3QgY29kZSBvZiB0aGUgc2hvcnRlc3QgbGVuZ3RoLCBhbmQgdGhlIGNvZGVzIGFyZSBpbnRlZ2VyXG4gICBpbmNyZW1lbnRzIGZvciB0aGUgc2FtZSBsZW5ndGgsIGFuZCB6ZXJvcyBhcmUgYXBwZW5kZWQgYXMgdGhlIGxlbmd0aFxuICAgaW5jcmVhc2VzLiAgRm9yIHRoZSBkZWZsYXRlIGZvcm1hdCwgdGhlc2UgYml0cyBhcmUgc3RvcmVkIGJhY2t3YXJkc1xuICAgZnJvbSB0aGVpciBtb3JlIG5hdHVyYWwgaW50ZWdlciBpbmNyZW1lbnQgb3JkZXJpbmcsIGFuZCBzbyB3aGVuIHRoZVxuICAgZGVjb2RpbmcgdGFibGVzIGFyZSBidWlsdCBpbiB0aGUgbGFyZ2UgbG9vcCBiZWxvdywgdGhlIGludGVnZXIgY29kZXNcbiAgIGFyZSBpbmNyZW1lbnRlZCBiYWNrd2FyZHMuXG5cbiAgIFRoaXMgcm91dGluZSBhc3N1bWVzLCBidXQgZG9lcyBub3QgY2hlY2ssIHRoYXQgYWxsIG9mIHRoZSBlbnRyaWVzIGluXG4gICBsZW5zW10gYXJlIGluIHRoZSByYW5nZSAwLi5NQVhCSVRTLiAgVGhlIGNhbGxlciBtdXN0IGFzc3VyZSB0aGlzLlxuICAgMS4uTUFYQklUUyBpcyBpbnRlcnByZXRlZCBhcyB0aGF0IGNvZGUgbGVuZ3RoLiAgemVybyBtZWFucyB0aGF0IHRoYXRcbiAgIHN5bWJvbCBkb2VzIG5vdCBvY2N1ciBpbiB0aGlzIGNvZGUuXG5cbiAgIFRoZSBjb2RlcyBhcmUgc29ydGVkIGJ5IGNvbXB1dGluZyBhIGNvdW50IG9mIGNvZGVzIGZvciBlYWNoIGxlbmd0aCxcbiAgIGNyZWF0aW5nIGZyb20gdGhhdCBhIHRhYmxlIG9mIHN0YXJ0aW5nIGluZGljZXMgZm9yIGVhY2ggbGVuZ3RoIGluIHRoZVxuICAgc29ydGVkIHRhYmxlLCBhbmQgdGhlbiBlbnRlcmluZyB0aGUgc3ltYm9scyBpbiBvcmRlciBpbiB0aGUgc29ydGVkXG4gICB0YWJsZS4gIFRoZSBzb3J0ZWQgdGFibGUgaXMgd29ya1tdLCB3aXRoIHRoYXQgc3BhY2UgYmVpbmcgcHJvdmlkZWQgYnlcbiAgIHRoZSBjYWxsZXIuXG5cbiAgIFRoZSBsZW5ndGggY291bnRzIGFyZSB1c2VkIGZvciBvdGhlciBwdXJwb3NlcyBhcyB3ZWxsLCBpLmUuIGZpbmRpbmdcbiAgIHRoZSBtaW5pbXVtIGFuZCBtYXhpbXVtIGxlbmd0aCBjb2RlcywgZGV0ZXJtaW5pbmcgaWYgdGhlcmUgYXJlIGFueVxuICAgY29kZXMgYXQgYWxsLCBjaGVja2luZyBmb3IgYSB2YWxpZCBzZXQgb2YgbGVuZ3RocywgYW5kIGxvb2tpbmcgYWhlYWRcbiAgIGF0IGxlbmd0aCBjb3VudHMgdG8gZGV0ZXJtaW5lIHN1Yi10YWJsZSBzaXplcyB3aGVuIGJ1aWxkaW5nIHRoZVxuICAgZGVjb2RpbmcgdGFibGVzLlxuICAgKi9cblxuICAvKiBhY2N1bXVsYXRlIGxlbmd0aHMgZm9yIGNvZGVzIChhc3N1bWVzIGxlbnNbXSBhbGwgaW4gMC4uTUFYQklUUykgKi9cbiAgZm9yIChsZW4gPSAwOyBsZW4gPD0gTUFYQklUUzsgbGVuKyspIHtcbiAgICBjb3VudFtsZW5dID0gMDtcbiAgfVxuICBmb3IgKHN5bSA9IDA7IHN5bSA8IGNvZGVzOyBzeW0rKykge1xuICAgIGNvdW50W2xlbnNbbGVuc19pbmRleCArIHN5bV1dKys7XG4gIH1cblxuICAvKiBib3VuZCBjb2RlIGxlbmd0aHMsIGZvcmNlIHJvb3QgdG8gYmUgd2l0aGluIGNvZGUgbGVuZ3RocyAqL1xuICByb290ID0gYml0cztcbiAgZm9yIChtYXggPSBNQVhCSVRTOyBtYXggPj0gMTsgbWF4LS0pIHtcbiAgICBpZiAoY291bnRbbWF4XSAhPT0gMCkgeyBicmVhazsgfVxuICB9XG4gIGlmIChyb290ID4gbWF4KSB7XG4gICAgcm9vdCA9IG1heDtcbiAgfVxuICBpZiAobWF4ID09PSAwKSB7ICAgICAgICAgICAgICAgICAgICAgLyogbm8gc3ltYm9scyB0byBjb2RlIGF0IGFsbCAqL1xuICAgIC8vdGFibGUub3Bbb3B0cy50YWJsZV9pbmRleF0gPSA2NDsgIC8vaGVyZS5vcCA9ICh2YXIgY2hhcik2NDsgICAgLyogaW52YWxpZCBjb2RlIG1hcmtlciAqL1xuICAgIC8vdGFibGUuYml0c1tvcHRzLnRhYmxlX2luZGV4XSA9IDE7ICAgLy9oZXJlLmJpdHMgPSAodmFyIGNoYXIpMTtcbiAgICAvL3RhYmxlLnZhbFtvcHRzLnRhYmxlX2luZGV4KytdID0gMDsgICAvL2hlcmUudmFsID0gKHZhciBzaG9ydCkwO1xuICAgIHRhYmxlW3RhYmxlX2luZGV4KytdID0gKDEgPDwgMjQpIHwgKDY0IDw8IDE2KSB8IDA7XG5cblxuICAgIC8vdGFibGUub3Bbb3B0cy50YWJsZV9pbmRleF0gPSA2NDtcbiAgICAvL3RhYmxlLmJpdHNbb3B0cy50YWJsZV9pbmRleF0gPSAxO1xuICAgIC8vdGFibGUudmFsW29wdHMudGFibGVfaW5kZXgrK10gPSAwO1xuICAgIHRhYmxlW3RhYmxlX2luZGV4KytdID0gKDEgPDwgMjQpIHwgKDY0IDw8IDE2KSB8IDA7XG5cbiAgICBvcHRzLmJpdHMgPSAxO1xuICAgIHJldHVybiAwOyAgICAgLyogbm8gc3ltYm9scywgYnV0IHdhaXQgZm9yIGRlY29kaW5nIHRvIHJlcG9ydCBlcnJvciAqL1xuICB9XG4gIGZvciAobWluID0gMTsgbWluIDwgbWF4OyBtaW4rKykge1xuICAgIGlmIChjb3VudFttaW5dICE9PSAwKSB7IGJyZWFrOyB9XG4gIH1cbiAgaWYgKHJvb3QgPCBtaW4pIHtcbiAgICByb290ID0gbWluO1xuICB9XG5cbiAgLyogY2hlY2sgZm9yIGFuIG92ZXItc3Vic2NyaWJlZCBvciBpbmNvbXBsZXRlIHNldCBvZiBsZW5ndGhzICovXG4gIGxlZnQgPSAxO1xuICBmb3IgKGxlbiA9IDE7IGxlbiA8PSBNQVhCSVRTOyBsZW4rKykge1xuICAgIGxlZnQgPDw9IDE7XG4gICAgbGVmdCAtPSBjb3VudFtsZW5dO1xuICAgIGlmIChsZWZ0IDwgMCkge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH0gICAgICAgIC8qIG92ZXItc3Vic2NyaWJlZCAqL1xuICB9XG4gIGlmIChsZWZ0ID4gMCAmJiAodHlwZSA9PT0gQ09ERVMgfHwgbWF4ICE9PSAxKSkge1xuICAgIHJldHVybiAtMTsgICAgICAgICAgICAgICAgICAgICAgLyogaW5jb21wbGV0ZSBzZXQgKi9cbiAgfVxuXG4gIC8qIGdlbmVyYXRlIG9mZnNldHMgaW50byBzeW1ib2wgdGFibGUgZm9yIGVhY2ggbGVuZ3RoIGZvciBzb3J0aW5nICovXG4gIG9mZnNbMV0gPSAwO1xuICBmb3IgKGxlbiA9IDE7IGxlbiA8IE1BWEJJVFM7IGxlbisrKSB7XG4gICAgb2Zmc1tsZW4gKyAxXSA9IG9mZnNbbGVuXSArIGNvdW50W2xlbl07XG4gIH1cblxuICAvKiBzb3J0IHN5bWJvbHMgYnkgbGVuZ3RoLCBieSBzeW1ib2wgb3JkZXIgd2l0aGluIGVhY2ggbGVuZ3RoICovXG4gIGZvciAoc3ltID0gMDsgc3ltIDwgY29kZXM7IHN5bSsrKSB7XG4gICAgaWYgKGxlbnNbbGVuc19pbmRleCArIHN5bV0gIT09IDApIHtcbiAgICAgIHdvcmtbb2Zmc1tsZW5zW2xlbnNfaW5kZXggKyBzeW1dXSsrXSA9IHN5bTtcbiAgICB9XG4gIH1cblxuICAvKlxuICAgQ3JlYXRlIGFuZCBmaWxsIGluIGRlY29kaW5nIHRhYmxlcy4gIEluIHRoaXMgbG9vcCwgdGhlIHRhYmxlIGJlaW5nXG4gICBmaWxsZWQgaXMgYXQgbmV4dCBhbmQgaGFzIGN1cnIgaW5kZXggYml0cy4gIFRoZSBjb2RlIGJlaW5nIHVzZWQgaXMgaHVmZlxuICAgd2l0aCBsZW5ndGggbGVuLiAgVGhhdCBjb2RlIGlzIGNvbnZlcnRlZCB0byBhbiBpbmRleCBieSBkcm9wcGluZyBkcm9wXG4gICBiaXRzIG9mZiBvZiB0aGUgYm90dG9tLiAgRm9yIGNvZGVzIHdoZXJlIGxlbiBpcyBsZXNzIHRoYW4gZHJvcCArIGN1cnIsXG4gICB0aG9zZSB0b3AgZHJvcCArIGN1cnIgLSBsZW4gYml0cyBhcmUgaW5jcmVtZW50ZWQgdGhyb3VnaCBhbGwgdmFsdWVzIHRvXG4gICBmaWxsIHRoZSB0YWJsZSB3aXRoIHJlcGxpY2F0ZWQgZW50cmllcy5cblxuICAgcm9vdCBpcyB0aGUgbnVtYmVyIG9mIGluZGV4IGJpdHMgZm9yIHRoZSByb290IHRhYmxlLiAgV2hlbiBsZW4gZXhjZWVkc1xuICAgcm9vdCwgc3ViLXRhYmxlcyBhcmUgY3JlYXRlZCBwb2ludGVkIHRvIGJ5IHRoZSByb290IGVudHJ5IHdpdGggYW4gaW5kZXhcbiAgIG9mIHRoZSBsb3cgcm9vdCBiaXRzIG9mIGh1ZmYuICBUaGlzIGlzIHNhdmVkIGluIGxvdyB0byBjaGVjayBmb3Igd2hlbiBhXG4gICBuZXcgc3ViLXRhYmxlIHNob3VsZCBiZSBzdGFydGVkLiAgZHJvcCBpcyB6ZXJvIHdoZW4gdGhlIHJvb3QgdGFibGUgaXNcbiAgIGJlaW5nIGZpbGxlZCwgYW5kIGRyb3AgaXMgcm9vdCB3aGVuIHN1Yi10YWJsZXMgYXJlIGJlaW5nIGZpbGxlZC5cblxuICAgV2hlbiBhIG5ldyBzdWItdGFibGUgaXMgbmVlZGVkLCBpdCBpcyBuZWNlc3NhcnkgdG8gbG9vayBhaGVhZCBpbiB0aGVcbiAgIGNvZGUgbGVuZ3RocyB0byBkZXRlcm1pbmUgd2hhdCBzaXplIHN1Yi10YWJsZSBpcyBuZWVkZWQuICBUaGUgbGVuZ3RoXG4gICBjb3VudHMgYXJlIHVzZWQgZm9yIHRoaXMsIGFuZCBzbyBjb3VudFtdIGlzIGRlY3JlbWVudGVkIGFzIGNvZGVzIGFyZVxuICAgZW50ZXJlZCBpbiB0aGUgdGFibGVzLlxuXG4gICB1c2VkIGtlZXBzIHRyYWNrIG9mIGhvdyBtYW55IHRhYmxlIGVudHJpZXMgaGF2ZSBiZWVuIGFsbG9jYXRlZCBmcm9tIHRoZVxuICAgcHJvdmlkZWQgKnRhYmxlIHNwYWNlLiAgSXQgaXMgY2hlY2tlZCBmb3IgTEVOUyBhbmQgRElTVCB0YWJsZXMgYWdhaW5zdFxuICAgdGhlIGNvbnN0YW50cyBFTk9VR0hfTEVOUyBhbmQgRU5PVUdIX0RJU1RTIHRvIGd1YXJkIGFnYWluc3QgY2hhbmdlcyBpblxuICAgdGhlIGluaXRpYWwgcm9vdCB0YWJsZSBzaXplIGNvbnN0YW50cy4gIFNlZSB0aGUgY29tbWVudHMgaW4gaW5mdHJlZXMuaFxuICAgZm9yIG1vcmUgaW5mb3JtYXRpb24uXG5cbiAgIHN5bSBpbmNyZW1lbnRzIHRocm91Z2ggYWxsIHN5bWJvbHMsIGFuZCB0aGUgbG9vcCB0ZXJtaW5hdGVzIHdoZW5cbiAgIGFsbCBjb2RlcyBvZiBsZW5ndGggbWF4LCBpLmUuIGFsbCBjb2RlcywgaGF2ZSBiZWVuIHByb2Nlc3NlZC4gIFRoaXNcbiAgIHJvdXRpbmUgcGVybWl0cyBpbmNvbXBsZXRlIGNvZGVzLCBzbyBhbm90aGVyIGxvb3AgYWZ0ZXIgdGhpcyBvbmUgZmlsbHNcbiAgIGluIHRoZSByZXN0IG9mIHRoZSBkZWNvZGluZyB0YWJsZXMgd2l0aCBpbnZhbGlkIGNvZGUgbWFya2Vycy5cbiAgICovXG5cbiAgLyogc2V0IHVwIGZvciBjb2RlIHR5cGUgKi9cbiAgLy8gcG9vciBtYW4gb3B0aW1pemF0aW9uIC0gdXNlIGlmLWVsc2UgaW5zdGVhZCBvZiBzd2l0Y2gsXG4gIC8vIHRvIGF2b2lkIGRlb3B0cyBpbiBvbGQgdjhcbiAgaWYgKHR5cGUgPT09IENPREVTKSB7XG4gICAgYmFzZSA9IGV4dHJhID0gd29yazsgICAgLyogZHVtbXkgdmFsdWUtLW5vdCB1c2VkICovXG4gICAgZW5kID0gMTk7XG5cbiAgfSBlbHNlIGlmICh0eXBlID09PSBMRU5TKSB7XG4gICAgYmFzZSA9IGxiYXNlO1xuICAgIGJhc2VfaW5kZXggLT0gMjU3O1xuICAgIGV4dHJhID0gbGV4dDtcbiAgICBleHRyYV9pbmRleCAtPSAyNTc7XG4gICAgZW5kID0gMjU2O1xuXG4gIH0gZWxzZSB7ICAgICAgICAgICAgICAgICAgICAvKiBESVNUUyAqL1xuICAgIGJhc2UgPSBkYmFzZTtcbiAgICBleHRyYSA9IGRleHQ7XG4gICAgZW5kID0gLTE7XG4gIH1cblxuICAvKiBpbml0aWFsaXplIG9wdHMgZm9yIGxvb3AgKi9cbiAgaHVmZiA9IDA7ICAgICAgICAgICAgICAgICAgIC8qIHN0YXJ0aW5nIGNvZGUgKi9cbiAgc3ltID0gMDsgICAgICAgICAgICAgICAgICAgIC8qIHN0YXJ0aW5nIGNvZGUgc3ltYm9sICovXG4gIGxlbiA9IG1pbjsgICAgICAgICAgICAgICAgICAvKiBzdGFydGluZyBjb2RlIGxlbmd0aCAqL1xuICBuZXh0ID0gdGFibGVfaW5kZXg7ICAgICAgICAgICAgICAvKiBjdXJyZW50IHRhYmxlIHRvIGZpbGwgaW4gKi9cbiAgY3VyciA9IHJvb3Q7ICAgICAgICAgICAgICAgIC8qIGN1cnJlbnQgdGFibGUgaW5kZXggYml0cyAqL1xuICBkcm9wID0gMDsgICAgICAgICAgICAgICAgICAgLyogY3VycmVudCBiaXRzIHRvIGRyb3AgZnJvbSBjb2RlIGZvciBpbmRleCAqL1xuICBsb3cgPSAtMTsgICAgICAgICAgICAgICAgICAgLyogdHJpZ2dlciBuZXcgc3ViLXRhYmxlIHdoZW4gbGVuID4gcm9vdCAqL1xuICB1c2VkID0gMSA8PCByb290OyAgICAgICAgICAvKiB1c2Ugcm9vdCB0YWJsZSBlbnRyaWVzICovXG4gIG1hc2sgPSB1c2VkIC0gMTsgICAgICAgICAgICAvKiBtYXNrIGZvciBjb21wYXJpbmcgbG93ICovXG5cbiAgLyogY2hlY2sgYXZhaWxhYmxlIHRhYmxlIHNwYWNlICovXG4gIGlmICgodHlwZSA9PT0gTEVOUyAmJiB1c2VkID4gRU5PVUdIX0xFTlMpIHx8XG4gICAgKHR5cGUgPT09IERJU1RTICYmIHVzZWQgPiBFTk9VR0hfRElTVFMpKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICAvKiBwcm9jZXNzIGFsbCBjb2RlcyBhbmQgbWFrZSB0YWJsZSBlbnRyaWVzICovXG4gIGZvciAoOzspIHtcbiAgICAvKiBjcmVhdGUgdGFibGUgZW50cnkgKi9cbiAgICBoZXJlX2JpdHMgPSBsZW4gLSBkcm9wO1xuICAgIGlmICh3b3JrW3N5bV0gPCBlbmQpIHtcbiAgICAgIGhlcmVfb3AgPSAwO1xuICAgICAgaGVyZV92YWwgPSB3b3JrW3N5bV07XG4gICAgfVxuICAgIGVsc2UgaWYgKHdvcmtbc3ltXSA+IGVuZCkge1xuICAgICAgaGVyZV9vcCA9IGV4dHJhW2V4dHJhX2luZGV4ICsgd29ya1tzeW1dXTtcbiAgICAgIGhlcmVfdmFsID0gYmFzZVtiYXNlX2luZGV4ICsgd29ya1tzeW1dXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBoZXJlX29wID0gMzIgKyA2NDsgICAgICAgICAvKiBlbmQgb2YgYmxvY2sgKi9cbiAgICAgIGhlcmVfdmFsID0gMDtcbiAgICB9XG5cbiAgICAvKiByZXBsaWNhdGUgZm9yIHRob3NlIGluZGljZXMgd2l0aCBsb3cgbGVuIGJpdHMgZXF1YWwgdG8gaHVmZiAqL1xuICAgIGluY3IgPSAxIDw8IChsZW4gLSBkcm9wKTtcbiAgICBmaWxsID0gMSA8PCBjdXJyO1xuICAgIG1pbiA9IGZpbGw7ICAgICAgICAgICAgICAgICAvKiBzYXZlIG9mZnNldCB0byBuZXh0IHRhYmxlICovXG4gICAgZG8ge1xuICAgICAgZmlsbCAtPSBpbmNyO1xuICAgICAgdGFibGVbbmV4dCArIChodWZmID4+IGRyb3ApICsgZmlsbF0gPSAoaGVyZV9iaXRzIDw8IDI0KSB8IChoZXJlX29wIDw8IDE2KSB8IGhlcmVfdmFsIHwwO1xuICAgIH0gd2hpbGUgKGZpbGwgIT09IDApO1xuXG4gICAgLyogYmFja3dhcmRzIGluY3JlbWVudCB0aGUgbGVuLWJpdCBjb2RlIGh1ZmYgKi9cbiAgICBpbmNyID0gMSA8PCAobGVuIC0gMSk7XG4gICAgd2hpbGUgKGh1ZmYgJiBpbmNyKSB7XG4gICAgICBpbmNyID4+PSAxO1xuICAgIH1cbiAgICBpZiAoaW5jciAhPT0gMCkge1xuICAgICAgaHVmZiAmPSBpbmNyIC0gMTtcbiAgICAgIGh1ZmYgKz0gaW5jcjtcbiAgICB9IGVsc2Uge1xuICAgICAgaHVmZiA9IDA7XG4gICAgfVxuXG4gICAgLyogZ28gdG8gbmV4dCBzeW1ib2wsIHVwZGF0ZSBjb3VudCwgbGVuICovXG4gICAgc3ltKys7XG4gICAgaWYgKC0tY291bnRbbGVuXSA9PT0gMCkge1xuICAgICAgaWYgKGxlbiA9PT0gbWF4KSB7IGJyZWFrOyB9XG4gICAgICBsZW4gPSBsZW5zW2xlbnNfaW5kZXggKyB3b3JrW3N5bV1dO1xuICAgIH1cblxuICAgIC8qIGNyZWF0ZSBuZXcgc3ViLXRhYmxlIGlmIG5lZWRlZCAqL1xuICAgIGlmIChsZW4gPiByb290ICYmIChodWZmICYgbWFzaykgIT09IGxvdykge1xuICAgICAgLyogaWYgZmlyc3QgdGltZSwgdHJhbnNpdGlvbiB0byBzdWItdGFibGVzICovXG4gICAgICBpZiAoZHJvcCA9PT0gMCkge1xuICAgICAgICBkcm9wID0gcm9vdDtcbiAgICAgIH1cblxuICAgICAgLyogaW5jcmVtZW50IHBhc3QgbGFzdCB0YWJsZSAqL1xuICAgICAgbmV4dCArPSBtaW47ICAgICAgICAgICAgLyogaGVyZSBtaW4gaXMgMSA8PCBjdXJyICovXG5cbiAgICAgIC8qIGRldGVybWluZSBsZW5ndGggb2YgbmV4dCB0YWJsZSAqL1xuICAgICAgY3VyciA9IGxlbiAtIGRyb3A7XG4gICAgICBsZWZ0ID0gMSA8PCBjdXJyO1xuICAgICAgd2hpbGUgKGN1cnIgKyBkcm9wIDwgbWF4KSB7XG4gICAgICAgIGxlZnQgLT0gY291bnRbY3VyciArIGRyb3BdO1xuICAgICAgICBpZiAobGVmdCA8PSAwKSB7IGJyZWFrOyB9XG4gICAgICAgIGN1cnIrKztcbiAgICAgICAgbGVmdCA8PD0gMTtcbiAgICAgIH1cblxuICAgICAgLyogY2hlY2sgZm9yIGVub3VnaCBzcGFjZSAqL1xuICAgICAgdXNlZCArPSAxIDw8IGN1cnI7XG4gICAgICBpZiAoKHR5cGUgPT09IExFTlMgJiYgdXNlZCA+IEVOT1VHSF9MRU5TKSB8fFxuICAgICAgICAodHlwZSA9PT0gRElTVFMgJiYgdXNlZCA+IEVOT1VHSF9ESVNUUykpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG5cbiAgICAgIC8qIHBvaW50IGVudHJ5IGluIHJvb3QgdGFibGUgdG8gc3ViLXRhYmxlICovXG4gICAgICBsb3cgPSBodWZmICYgbWFzaztcbiAgICAgIC8qdGFibGUub3BbbG93XSA9IGN1cnI7XG4gICAgICB0YWJsZS5iaXRzW2xvd10gPSByb290O1xuICAgICAgdGFibGUudmFsW2xvd10gPSBuZXh0IC0gb3B0cy50YWJsZV9pbmRleDsqL1xuICAgICAgdGFibGVbbG93XSA9IChyb290IDw8IDI0KSB8IChjdXJyIDw8IDE2KSB8IChuZXh0IC0gdGFibGVfaW5kZXgpIHwwO1xuICAgIH1cbiAgfVxuXG4gIC8qIGZpbGwgaW4gcmVtYWluaW5nIHRhYmxlIGVudHJ5IGlmIGNvZGUgaXMgaW5jb21wbGV0ZSAoZ3VhcmFudGVlZCB0byBoYXZlXG4gICBhdCBtb3N0IG9uZSByZW1haW5pbmcgZW50cnksIHNpbmNlIGlmIHRoZSBjb2RlIGlzIGluY29tcGxldGUsIHRoZVxuICAgbWF4aW11bSBjb2RlIGxlbmd0aCB0aGF0IHdhcyBhbGxvd2VkIHRvIGdldCB0aGlzIGZhciBpcyBvbmUgYml0KSAqL1xuICBpZiAoaHVmZiAhPT0gMCkge1xuICAgIC8vdGFibGUub3BbbmV4dCArIGh1ZmZdID0gNjQ7ICAgICAgICAgICAgLyogaW52YWxpZCBjb2RlIG1hcmtlciAqL1xuICAgIC8vdGFibGUuYml0c1tuZXh0ICsgaHVmZl0gPSBsZW4gLSBkcm9wO1xuICAgIC8vdGFibGUudmFsW25leHQgKyBodWZmXSA9IDA7XG4gICAgdGFibGVbbmV4dCArIGh1ZmZdID0gKChsZW4gLSBkcm9wKSA8PCAyNCkgfCAoNjQgPDwgMTYpIHwwO1xuICB9XG5cbiAgLyogc2V0IHJldHVybiBwYXJhbWV0ZXJzICovXG4gIC8vb3B0cy50YWJsZV9pbmRleCArPSB1c2VkO1xuICBvcHRzLmJpdHMgPSByb290O1xuICByZXR1cm4gMDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIDI6ICAgICAgJ25lZWQgZGljdGlvbmFyeScsICAgICAvKiBaX05FRURfRElDVCAgICAgICAyICAqL1xuICAxOiAgICAgICdzdHJlYW0gZW5kJywgICAgICAgICAgLyogWl9TVFJFQU1fRU5EICAgICAgMSAgKi9cbiAgMDogICAgICAnJywgICAgICAgICAgICAgICAgICAgIC8qIFpfT0sgICAgICAgICAgICAgIDAgICovXG4gICctMSc6ICAgJ2ZpbGUgZXJyb3InLCAgICAgICAgICAvKiBaX0VSUk5PICAgICAgICAgKC0xKSAqL1xuICAnLTInOiAgICdzdHJlYW0gZXJyb3InLCAgICAgICAgLyogWl9TVFJFQU1fRVJST1IgICgtMikgKi9cbiAgJy0zJzogICAnZGF0YSBlcnJvcicsICAgICAgICAgIC8qIFpfREFUQV9FUlJPUiAgICAoLTMpICovXG4gICctNCc6ICAgJ2luc3VmZmljaWVudCBtZW1vcnknLCAvKiBaX01FTV9FUlJPUiAgICAgKC00KSAqL1xuICAnLTUnOiAgICdidWZmZXIgZXJyb3InLCAgICAgICAgLyogWl9CVUZfRVJST1IgICAgICgtNSkgKi9cbiAgJy02JzogICAnaW5jb21wYXRpYmxlIHZlcnNpb24nIC8qIFpfVkVSU0lPTl9FUlJPUiAoLTYpICovXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL2NvbW1vbicpO1xuXG4vKiBQdWJsaWMgY29uc3RhbnRzID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG4vL3ZhciBaX0ZJTFRFUkVEICAgICAgICAgID0gMTtcbi8vdmFyIFpfSFVGRk1BTl9PTkxZICAgICAgPSAyO1xuLy92YXIgWl9STEUgICAgICAgICAgICAgICA9IDM7XG52YXIgWl9GSVhFRCAgICAgICAgICAgICAgID0gNDtcbi8vdmFyIFpfREVGQVVMVF9TVFJBVEVHWSAgPSAwO1xuXG4vKiBQb3NzaWJsZSB2YWx1ZXMgb2YgdGhlIGRhdGFfdHlwZSBmaWVsZCAodGhvdWdoIHNlZSBpbmZsYXRlKCkpICovXG52YXIgWl9CSU5BUlkgICAgICAgICAgICAgID0gMDtcbnZhciBaX1RFWFQgICAgICAgICAgICAgICAgPSAxO1xuLy92YXIgWl9BU0NJSSAgICAgICAgICAgICA9IDE7IC8vID0gWl9URVhUXG52YXIgWl9VTktOT1dOICAgICAgICAgICAgID0gMjtcblxuLyo9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG5mdW5jdGlvbiB6ZXJvKGJ1ZikgeyB2YXIgbGVuID0gYnVmLmxlbmd0aDsgd2hpbGUgKC0tbGVuID49IDApIHsgYnVmW2xlbl0gPSAwOyB9IH1cblxuLy8gRnJvbSB6dXRpbC5oXG5cbnZhciBTVE9SRURfQkxPQ0sgPSAwO1xudmFyIFNUQVRJQ19UUkVFUyA9IDE7XG52YXIgRFlOX1RSRUVTICAgID0gMjtcbi8qIFRoZSB0aHJlZSBraW5kcyBvZiBibG9jayB0eXBlICovXG5cbnZhciBNSU5fTUFUQ0ggICAgPSAzO1xudmFyIE1BWF9NQVRDSCAgICA9IDI1ODtcbi8qIFRoZSBtaW5pbXVtIGFuZCBtYXhpbXVtIG1hdGNoIGxlbmd0aHMgKi9cblxuLy8gRnJvbSBkZWZsYXRlLmhcbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogSW50ZXJuYWwgY29tcHJlc3Npb24gc3RhdGUuXG4gKi9cblxudmFyIExFTkdUSF9DT0RFUyAgPSAyOTtcbi8qIG51bWJlciBvZiBsZW5ndGggY29kZXMsIG5vdCBjb3VudGluZyB0aGUgc3BlY2lhbCBFTkRfQkxPQ0sgY29kZSAqL1xuXG52YXIgTElURVJBTFMgICAgICA9IDI1Njtcbi8qIG51bWJlciBvZiBsaXRlcmFsIGJ5dGVzIDAuLjI1NSAqL1xuXG52YXIgTF9DT0RFUyAgICAgICA9IExJVEVSQUxTICsgMSArIExFTkdUSF9DT0RFUztcbi8qIG51bWJlciBvZiBMaXRlcmFsIG9yIExlbmd0aCBjb2RlcywgaW5jbHVkaW5nIHRoZSBFTkRfQkxPQ0sgY29kZSAqL1xuXG52YXIgRF9DT0RFUyAgICAgICA9IDMwO1xuLyogbnVtYmVyIG9mIGRpc3RhbmNlIGNvZGVzICovXG5cbnZhciBCTF9DT0RFUyAgICAgID0gMTk7XG4vKiBudW1iZXIgb2YgY29kZXMgdXNlZCB0byB0cmFuc2ZlciB0aGUgYml0IGxlbmd0aHMgKi9cblxudmFyIEhFQVBfU0laRSAgICAgPSAyICogTF9DT0RFUyArIDE7XG4vKiBtYXhpbXVtIGhlYXAgc2l6ZSAqL1xuXG52YXIgTUFYX0JJVFMgICAgICA9IDE1O1xuLyogQWxsIGNvZGVzIG11c3Qgbm90IGV4Y2VlZCBNQVhfQklUUyBiaXRzICovXG5cbnZhciBCdWZfc2l6ZSAgICAgID0gMTY7XG4vKiBzaXplIG9mIGJpdCBidWZmZXIgaW4gYmlfYnVmICovXG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb25zdGFudHNcbiAqL1xuXG52YXIgTUFYX0JMX0JJVFMgPSA3O1xuLyogQml0IGxlbmd0aCBjb2RlcyBtdXN0IG5vdCBleGNlZWQgTUFYX0JMX0JJVFMgYml0cyAqL1xuXG52YXIgRU5EX0JMT0NLICAgPSAyNTY7XG4vKiBlbmQgb2YgYmxvY2sgbGl0ZXJhbCBjb2RlICovXG5cbnZhciBSRVBfM182ICAgICA9IDE2O1xuLyogcmVwZWF0IHByZXZpb3VzIGJpdCBsZW5ndGggMy02IHRpbWVzICgyIGJpdHMgb2YgcmVwZWF0IGNvdW50KSAqL1xuXG52YXIgUkVQWl8zXzEwICAgPSAxNztcbi8qIHJlcGVhdCBhIHplcm8gbGVuZ3RoIDMtMTAgdGltZXMgICgzIGJpdHMgb2YgcmVwZWF0IGNvdW50KSAqL1xuXG52YXIgUkVQWl8xMV8xMzggPSAxODtcbi8qIHJlcGVhdCBhIHplcm8gbGVuZ3RoIDExLTEzOCB0aW1lcyAgKDcgYml0cyBvZiByZXBlYXQgY291bnQpICovXG5cbi8qIGVzbGludC1kaXNhYmxlIGNvbW1hLXNwYWNpbmcsYXJyYXktYnJhY2tldC1zcGFjaW5nICovXG52YXIgZXh0cmFfbGJpdHMgPSAgIC8qIGV4dHJhIGJpdHMgZm9yIGVhY2ggbGVuZ3RoIGNvZGUgKi9cbiAgWzAsMCwwLDAsMCwwLDAsMCwxLDEsMSwxLDIsMiwyLDIsMywzLDMsMyw0LDQsNCw0LDUsNSw1LDUsMF07XG5cbnZhciBleHRyYV9kYml0cyA9ICAgLyogZXh0cmEgYml0cyBmb3IgZWFjaCBkaXN0YW5jZSBjb2RlICovXG4gIFswLDAsMCwwLDEsMSwyLDIsMywzLDQsNCw1LDUsNiw2LDcsNyw4LDgsOSw5LDEwLDEwLDExLDExLDEyLDEyLDEzLDEzXTtcblxudmFyIGV4dHJhX2JsYml0cyA9ICAvKiBleHRyYSBiaXRzIGZvciBlYWNoIGJpdCBsZW5ndGggY29kZSAqL1xuICBbMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwyLDMsN107XG5cbnZhciBibF9vcmRlciA9XG4gIFsxNiwxNywxOCwwLDgsNyw5LDYsMTAsNSwxMSw0LDEyLDMsMTMsMiwxNCwxLDE1XTtcbi8qIGVzbGludC1lbmFibGUgY29tbWEtc3BhY2luZyxhcnJheS1icmFja2V0LXNwYWNpbmcgKi9cblxuLyogVGhlIGxlbmd0aHMgb2YgdGhlIGJpdCBsZW5ndGggY29kZXMgYXJlIHNlbnQgaW4gb3JkZXIgb2YgZGVjcmVhc2luZ1xuICogcHJvYmFiaWxpdHksIHRvIGF2b2lkIHRyYW5zbWl0dGluZyB0aGUgbGVuZ3RocyBmb3IgdW51c2VkIGJpdCBsZW5ndGggY29kZXMuXG4gKi9cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBMb2NhbCBkYXRhLiBUaGVzZSBhcmUgaW5pdGlhbGl6ZWQgb25seSBvbmNlLlxuICovXG5cbi8vIFdlIHByZS1maWxsIGFycmF5cyB3aXRoIDAgdG8gYXZvaWQgdW5pbml0aWFsaXplZCBnYXBzXG5cbnZhciBESVNUX0NPREVfTEVOID0gNTEyOyAvKiBzZWUgZGVmaW5pdGlvbiBvZiBhcnJheSBkaXN0X2NvZGUgYmVsb3cgKi9cblxuLy8gISEhISBVc2UgZmxhdCBhcnJheSBpbnN0ZWFkIG9mIHN0cnVjdHVyZSwgRnJlcSA9IGkqMiwgTGVuID0gaSoyKzFcbnZhciBzdGF0aWNfbHRyZWUgID0gbmV3IEFycmF5KChMX0NPREVTICsgMikgKiAyKTtcbnplcm8oc3RhdGljX2x0cmVlKTtcbi8qIFRoZSBzdGF0aWMgbGl0ZXJhbCB0cmVlLiBTaW5jZSB0aGUgYml0IGxlbmd0aHMgYXJlIGltcG9zZWQsIHRoZXJlIGlzIG5vXG4gKiBuZWVkIGZvciB0aGUgTF9DT0RFUyBleHRyYSBjb2RlcyB1c2VkIGR1cmluZyBoZWFwIGNvbnN0cnVjdGlvbi4gSG93ZXZlclxuICogVGhlIGNvZGVzIDI4NiBhbmQgMjg3IGFyZSBuZWVkZWQgdG8gYnVpbGQgYSBjYW5vbmljYWwgdHJlZSAoc2VlIF90cl9pbml0XG4gKiBiZWxvdykuXG4gKi9cblxudmFyIHN0YXRpY19kdHJlZSAgPSBuZXcgQXJyYXkoRF9DT0RFUyAqIDIpO1xuemVybyhzdGF0aWNfZHRyZWUpO1xuLyogVGhlIHN0YXRpYyBkaXN0YW5jZSB0cmVlLiAoQWN0dWFsbHkgYSB0cml2aWFsIHRyZWUgc2luY2UgYWxsIGNvZGVzIHVzZVxuICogNSBiaXRzLilcbiAqL1xuXG52YXIgX2Rpc3RfY29kZSAgICA9IG5ldyBBcnJheShESVNUX0NPREVfTEVOKTtcbnplcm8oX2Rpc3RfY29kZSk7XG4vKiBEaXN0YW5jZSBjb2Rlcy4gVGhlIGZpcnN0IDI1NiB2YWx1ZXMgY29ycmVzcG9uZCB0byB0aGUgZGlzdGFuY2VzXG4gKiAzIC4uIDI1OCwgdGhlIGxhc3QgMjU2IHZhbHVlcyBjb3JyZXNwb25kIHRvIHRoZSB0b3AgOCBiaXRzIG9mXG4gKiB0aGUgMTUgYml0IGRpc3RhbmNlcy5cbiAqL1xuXG52YXIgX2xlbmd0aF9jb2RlICA9IG5ldyBBcnJheShNQVhfTUFUQ0ggLSBNSU5fTUFUQ0ggKyAxKTtcbnplcm8oX2xlbmd0aF9jb2RlKTtcbi8qIGxlbmd0aCBjb2RlIGZvciBlYWNoIG5vcm1hbGl6ZWQgbWF0Y2ggbGVuZ3RoICgwID09IE1JTl9NQVRDSCkgKi9cblxudmFyIGJhc2VfbGVuZ3RoICAgPSBuZXcgQXJyYXkoTEVOR1RIX0NPREVTKTtcbnplcm8oYmFzZV9sZW5ndGgpO1xuLyogRmlyc3Qgbm9ybWFsaXplZCBsZW5ndGggZm9yIGVhY2ggY29kZSAoMCA9IE1JTl9NQVRDSCkgKi9cblxudmFyIGJhc2VfZGlzdCAgICAgPSBuZXcgQXJyYXkoRF9DT0RFUyk7XG56ZXJvKGJhc2VfZGlzdCk7XG4vKiBGaXJzdCBub3JtYWxpemVkIGRpc3RhbmNlIGZvciBlYWNoIGNvZGUgKDAgPSBkaXN0YW5jZSBvZiAxKSAqL1xuXG5cbmZ1bmN0aW9uIFN0YXRpY1RyZWVEZXNjKHN0YXRpY190cmVlLCBleHRyYV9iaXRzLCBleHRyYV9iYXNlLCBlbGVtcywgbWF4X2xlbmd0aCkge1xuXG4gIHRoaXMuc3RhdGljX3RyZWUgID0gc3RhdGljX3RyZWU7ICAvKiBzdGF0aWMgdHJlZSBvciBOVUxMICovXG4gIHRoaXMuZXh0cmFfYml0cyAgID0gZXh0cmFfYml0czsgICAvKiBleHRyYSBiaXRzIGZvciBlYWNoIGNvZGUgb3IgTlVMTCAqL1xuICB0aGlzLmV4dHJhX2Jhc2UgICA9IGV4dHJhX2Jhc2U7ICAgLyogYmFzZSBpbmRleCBmb3IgZXh0cmFfYml0cyAqL1xuICB0aGlzLmVsZW1zICAgICAgICA9IGVsZW1zOyAgICAgICAgLyogbWF4IG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgdHJlZSAqL1xuICB0aGlzLm1heF9sZW5ndGggICA9IG1heF9sZW5ndGg7ICAgLyogbWF4IGJpdCBsZW5ndGggZm9yIHRoZSBjb2RlcyAqL1xuXG4gIC8vIHNob3cgaWYgYHN0YXRpY190cmVlYCBoYXMgZGF0YSBvciBkdW1teSAtIG5lZWRlZCBmb3IgbW9ub21vcnBoaWMgb2JqZWN0c1xuICB0aGlzLmhhc19zdHJlZSAgICA9IHN0YXRpY190cmVlICYmIHN0YXRpY190cmVlLmxlbmd0aDtcbn1cblxuXG52YXIgc3RhdGljX2xfZGVzYztcbnZhciBzdGF0aWNfZF9kZXNjO1xudmFyIHN0YXRpY19ibF9kZXNjO1xuXG5cbmZ1bmN0aW9uIFRyZWVEZXNjKGR5bl90cmVlLCBzdGF0X2Rlc2MpIHtcbiAgdGhpcy5keW5fdHJlZSA9IGR5bl90cmVlOyAgICAgLyogdGhlIGR5bmFtaWMgdHJlZSAqL1xuICB0aGlzLm1heF9jb2RlID0gMDsgICAgICAgICAgICAvKiBsYXJnZXN0IGNvZGUgd2l0aCBub24gemVybyBmcmVxdWVuY3kgKi9cbiAgdGhpcy5zdGF0X2Rlc2MgPSBzdGF0X2Rlc2M7ICAgLyogdGhlIGNvcnJlc3BvbmRpbmcgc3RhdGljIHRyZWUgKi9cbn1cblxuXG5cbmZ1bmN0aW9uIGRfY29kZShkaXN0KSB7XG4gIHJldHVybiBkaXN0IDwgMjU2ID8gX2Rpc3RfY29kZVtkaXN0XSA6IF9kaXN0X2NvZGVbMjU2ICsgKGRpc3QgPj4+IDcpXTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIE91dHB1dCBhIHNob3J0IExTQiBmaXJzdCBvbiB0aGUgc3RyZWFtLlxuICogSU4gYXNzZXJ0aW9uOiB0aGVyZSBpcyBlbm91Z2ggcm9vbSBpbiBwZW5kaW5nQnVmLlxuICovXG5mdW5jdGlvbiBwdXRfc2hvcnQocywgdykge1xuLy8gICAgcHV0X2J5dGUocywgKHVjaCkoKHcpICYgMHhmZikpO1xuLy8gICAgcHV0X2J5dGUocywgKHVjaCkoKHVzaCkodykgPj4gOCkpO1xuICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9ICh3KSAmIDB4ZmY7XG4gIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gKHcgPj4+IDgpICYgMHhmZjtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNlbmQgYSB2YWx1ZSBvbiBhIGdpdmVuIG51bWJlciBvZiBiaXRzLlxuICogSU4gYXNzZXJ0aW9uOiBsZW5ndGggPD0gMTYgYW5kIHZhbHVlIGZpdHMgaW4gbGVuZ3RoIGJpdHMuXG4gKi9cbmZ1bmN0aW9uIHNlbmRfYml0cyhzLCB2YWx1ZSwgbGVuZ3RoKSB7XG4gIGlmIChzLmJpX3ZhbGlkID4gKEJ1Zl9zaXplIC0gbGVuZ3RoKSkge1xuICAgIHMuYmlfYnVmIHw9ICh2YWx1ZSA8PCBzLmJpX3ZhbGlkKSAmIDB4ZmZmZjtcbiAgICBwdXRfc2hvcnQocywgcy5iaV9idWYpO1xuICAgIHMuYmlfYnVmID0gdmFsdWUgPj4gKEJ1Zl9zaXplIC0gcy5iaV92YWxpZCk7XG4gICAgcy5iaV92YWxpZCArPSBsZW5ndGggLSBCdWZfc2l6ZTtcbiAgfSBlbHNlIHtcbiAgICBzLmJpX2J1ZiB8PSAodmFsdWUgPDwgcy5iaV92YWxpZCkgJiAweGZmZmY7XG4gICAgcy5iaV92YWxpZCArPSBsZW5ndGg7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBzZW5kX2NvZGUocywgYywgdHJlZSkge1xuICBzZW5kX2JpdHMocywgdHJlZVtjICogMl0vKi5Db2RlKi8sIHRyZWVbYyAqIDIgKyAxXS8qLkxlbiovKTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFJldmVyc2UgdGhlIGZpcnN0IGxlbiBiaXRzIG9mIGEgY29kZSwgdXNpbmcgc3RyYWlnaHRmb3J3YXJkIGNvZGUgKGEgZmFzdGVyXG4gKiBtZXRob2Qgd291bGQgdXNlIGEgdGFibGUpXG4gKiBJTiBhc3NlcnRpb246IDEgPD0gbGVuIDw9IDE1XG4gKi9cbmZ1bmN0aW9uIGJpX3JldmVyc2UoY29kZSwgbGVuKSB7XG4gIHZhciByZXMgPSAwO1xuICBkbyB7XG4gICAgcmVzIHw9IGNvZGUgJiAxO1xuICAgIGNvZGUgPj4+PSAxO1xuICAgIHJlcyA8PD0gMTtcbiAgfSB3aGlsZSAoLS1sZW4gPiAwKTtcbiAgcmV0dXJuIHJlcyA+Pj4gMTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEZsdXNoIHRoZSBiaXQgYnVmZmVyLCBrZWVwaW5nIGF0IG1vc3QgNyBiaXRzIGluIGl0LlxuICovXG5mdW5jdGlvbiBiaV9mbHVzaChzKSB7XG4gIGlmIChzLmJpX3ZhbGlkID09PSAxNikge1xuICAgIHB1dF9zaG9ydChzLCBzLmJpX2J1Zik7XG4gICAgcy5iaV9idWYgPSAwO1xuICAgIHMuYmlfdmFsaWQgPSAwO1xuXG4gIH0gZWxzZSBpZiAocy5iaV92YWxpZCA+PSA4KSB7XG4gICAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSBzLmJpX2J1ZiAmIDB4ZmY7XG4gICAgcy5iaV9idWYgPj49IDg7XG4gICAgcy5iaV92YWxpZCAtPSA4O1xuICB9XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb21wdXRlIHRoZSBvcHRpbWFsIGJpdCBsZW5ndGhzIGZvciBhIHRyZWUgYW5kIHVwZGF0ZSB0aGUgdG90YWwgYml0IGxlbmd0aFxuICogZm9yIHRoZSBjdXJyZW50IGJsb2NrLlxuICogSU4gYXNzZXJ0aW9uOiB0aGUgZmllbGRzIGZyZXEgYW5kIGRhZCBhcmUgc2V0LCBoZWFwW2hlYXBfbWF4XSBhbmRcbiAqICAgIGFib3ZlIGFyZSB0aGUgdHJlZSBub2RlcyBzb3J0ZWQgYnkgaW5jcmVhc2luZyBmcmVxdWVuY3kuXG4gKiBPVVQgYXNzZXJ0aW9uczogdGhlIGZpZWxkIGxlbiBpcyBzZXQgdG8gdGhlIG9wdGltYWwgYml0IGxlbmd0aCwgdGhlXG4gKiAgICAgYXJyYXkgYmxfY291bnQgY29udGFpbnMgdGhlIGZyZXF1ZW5jaWVzIGZvciBlYWNoIGJpdCBsZW5ndGguXG4gKiAgICAgVGhlIGxlbmd0aCBvcHRfbGVuIGlzIHVwZGF0ZWQ7IHN0YXRpY19sZW4gaXMgYWxzbyB1cGRhdGVkIGlmIHN0cmVlIGlzXG4gKiAgICAgbm90IG51bGwuXG4gKi9cbmZ1bmN0aW9uIGdlbl9iaXRsZW4ocywgZGVzYylcbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICB0cmVlX2Rlc2MgKmRlc2M7ICAgIC8qIHRoZSB0cmVlIGRlc2NyaXB0b3IgKi9cbntcbiAgdmFyIHRyZWUgICAgICAgICAgICA9IGRlc2MuZHluX3RyZWU7XG4gIHZhciBtYXhfY29kZSAgICAgICAgPSBkZXNjLm1heF9jb2RlO1xuICB2YXIgc3RyZWUgICAgICAgICAgID0gZGVzYy5zdGF0X2Rlc2Muc3RhdGljX3RyZWU7XG4gIHZhciBoYXNfc3RyZWUgICAgICAgPSBkZXNjLnN0YXRfZGVzYy5oYXNfc3RyZWU7XG4gIHZhciBleHRyYSAgICAgICAgICAgPSBkZXNjLnN0YXRfZGVzYy5leHRyYV9iaXRzO1xuICB2YXIgYmFzZSAgICAgICAgICAgID0gZGVzYy5zdGF0X2Rlc2MuZXh0cmFfYmFzZTtcbiAgdmFyIG1heF9sZW5ndGggICAgICA9IGRlc2Muc3RhdF9kZXNjLm1heF9sZW5ndGg7XG4gIHZhciBoOyAgICAgICAgICAgICAgLyogaGVhcCBpbmRleCAqL1xuICB2YXIgbiwgbTsgICAgICAgICAgIC8qIGl0ZXJhdGUgb3ZlciB0aGUgdHJlZSBlbGVtZW50cyAqL1xuICB2YXIgYml0czsgICAgICAgICAgIC8qIGJpdCBsZW5ndGggKi9cbiAgdmFyIHhiaXRzOyAgICAgICAgICAvKiBleHRyYSBiaXRzICovXG4gIHZhciBmOyAgICAgICAgICAgICAgLyogZnJlcXVlbmN5ICovXG4gIHZhciBvdmVyZmxvdyA9IDA7ICAgLyogbnVtYmVyIG9mIGVsZW1lbnRzIHdpdGggYml0IGxlbmd0aCB0b28gbGFyZ2UgKi9cblxuICBmb3IgKGJpdHMgPSAwOyBiaXRzIDw9IE1BWF9CSVRTOyBiaXRzKyspIHtcbiAgICBzLmJsX2NvdW50W2JpdHNdID0gMDtcbiAgfVxuXG4gIC8qIEluIGEgZmlyc3QgcGFzcywgY29tcHV0ZSB0aGUgb3B0aW1hbCBiaXQgbGVuZ3RocyAod2hpY2ggbWF5XG4gICAqIG92ZXJmbG93IGluIHRoZSBjYXNlIG9mIHRoZSBiaXQgbGVuZ3RoIHRyZWUpLlxuICAgKi9cbiAgdHJlZVtzLmhlYXBbcy5oZWFwX21heF0gKiAyICsgMV0vKi5MZW4qLyA9IDA7IC8qIHJvb3Qgb2YgdGhlIGhlYXAgKi9cblxuICBmb3IgKGggPSBzLmhlYXBfbWF4ICsgMTsgaCA8IEhFQVBfU0laRTsgaCsrKSB7XG4gICAgbiA9IHMuaGVhcFtoXTtcbiAgICBiaXRzID0gdHJlZVt0cmVlW24gKiAyICsgMV0vKi5EYWQqLyAqIDIgKyAxXS8qLkxlbiovICsgMTtcbiAgICBpZiAoYml0cyA+IG1heF9sZW5ndGgpIHtcbiAgICAgIGJpdHMgPSBtYXhfbGVuZ3RoO1xuICAgICAgb3ZlcmZsb3crKztcbiAgICB9XG4gICAgdHJlZVtuICogMiArIDFdLyouTGVuKi8gPSBiaXRzO1xuICAgIC8qIFdlIG92ZXJ3cml0ZSB0cmVlW25dLkRhZCB3aGljaCBpcyBubyBsb25nZXIgbmVlZGVkICovXG5cbiAgICBpZiAobiA+IG1heF9jb2RlKSB7IGNvbnRpbnVlOyB9IC8qIG5vdCBhIGxlYWYgbm9kZSAqL1xuXG4gICAgcy5ibF9jb3VudFtiaXRzXSsrO1xuICAgIHhiaXRzID0gMDtcbiAgICBpZiAobiA+PSBiYXNlKSB7XG4gICAgICB4Yml0cyA9IGV4dHJhW24gLSBiYXNlXTtcbiAgICB9XG4gICAgZiA9IHRyZWVbbiAqIDJdLyouRnJlcSovO1xuICAgIHMub3B0X2xlbiArPSBmICogKGJpdHMgKyB4Yml0cyk7XG4gICAgaWYgKGhhc19zdHJlZSkge1xuICAgICAgcy5zdGF0aWNfbGVuICs9IGYgKiAoc3RyZWVbbiAqIDIgKyAxXS8qLkxlbiovICsgeGJpdHMpO1xuICAgIH1cbiAgfVxuICBpZiAob3ZlcmZsb3cgPT09IDApIHsgcmV0dXJuOyB9XG5cbiAgLy8gVHJhY2UoKHN0ZGVycixcIlxcbmJpdCBsZW5ndGggb3ZlcmZsb3dcXG5cIikpO1xuICAvKiBUaGlzIGhhcHBlbnMgZm9yIGV4YW1wbGUgb24gb2JqMiBhbmQgcGljIG9mIHRoZSBDYWxnYXJ5IGNvcnB1cyAqL1xuXG4gIC8qIEZpbmQgdGhlIGZpcnN0IGJpdCBsZW5ndGggd2hpY2ggY291bGQgaW5jcmVhc2U6ICovXG4gIGRvIHtcbiAgICBiaXRzID0gbWF4X2xlbmd0aCAtIDE7XG4gICAgd2hpbGUgKHMuYmxfY291bnRbYml0c10gPT09IDApIHsgYml0cy0tOyB9XG4gICAgcy5ibF9jb3VudFtiaXRzXS0tOyAgICAgIC8qIG1vdmUgb25lIGxlYWYgZG93biB0aGUgdHJlZSAqL1xuICAgIHMuYmxfY291bnRbYml0cyArIDFdICs9IDI7IC8qIG1vdmUgb25lIG92ZXJmbG93IGl0ZW0gYXMgaXRzIGJyb3RoZXIgKi9cbiAgICBzLmJsX2NvdW50W21heF9sZW5ndGhdLS07XG4gICAgLyogVGhlIGJyb3RoZXIgb2YgdGhlIG92ZXJmbG93IGl0ZW0gYWxzbyBtb3ZlcyBvbmUgc3RlcCB1cCxcbiAgICAgKiBidXQgdGhpcyBkb2VzIG5vdCBhZmZlY3QgYmxfY291bnRbbWF4X2xlbmd0aF1cbiAgICAgKi9cbiAgICBvdmVyZmxvdyAtPSAyO1xuICB9IHdoaWxlIChvdmVyZmxvdyA+IDApO1xuXG4gIC8qIE5vdyByZWNvbXB1dGUgYWxsIGJpdCBsZW5ndGhzLCBzY2FubmluZyBpbiBpbmNyZWFzaW5nIGZyZXF1ZW5jeS5cbiAgICogaCBpcyBzdGlsbCBlcXVhbCB0byBIRUFQX1NJWkUuIChJdCBpcyBzaW1wbGVyIHRvIHJlY29uc3RydWN0IGFsbFxuICAgKiBsZW5ndGhzIGluc3RlYWQgb2YgZml4aW5nIG9ubHkgdGhlIHdyb25nIG9uZXMuIFRoaXMgaWRlYSBpcyB0YWtlblxuICAgKiBmcm9tICdhcicgd3JpdHRlbiBieSBIYXJ1aGlrbyBPa3VtdXJhLilcbiAgICovXG4gIGZvciAoYml0cyA9IG1heF9sZW5ndGg7IGJpdHMgIT09IDA7IGJpdHMtLSkge1xuICAgIG4gPSBzLmJsX2NvdW50W2JpdHNdO1xuICAgIHdoaWxlIChuICE9PSAwKSB7XG4gICAgICBtID0gcy5oZWFwWy0taF07XG4gICAgICBpZiAobSA+IG1heF9jb2RlKSB7IGNvbnRpbnVlOyB9XG4gICAgICBpZiAodHJlZVttICogMiArIDFdLyouTGVuKi8gIT09IGJpdHMpIHtcbiAgICAgICAgLy8gVHJhY2UoKHN0ZGVycixcImNvZGUgJWQgYml0cyAlZC0+JWRcXG5cIiwgbSwgdHJlZVttXS5MZW4sIGJpdHMpKTtcbiAgICAgICAgcy5vcHRfbGVuICs9IChiaXRzIC0gdHJlZVttICogMiArIDFdLyouTGVuKi8pICogdHJlZVttICogMl0vKi5GcmVxKi87XG4gICAgICAgIHRyZWVbbSAqIDIgKyAxXS8qLkxlbiovID0gYml0cztcbiAgICAgIH1cbiAgICAgIG4tLTtcbiAgICB9XG4gIH1cbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEdlbmVyYXRlIHRoZSBjb2RlcyBmb3IgYSBnaXZlbiB0cmVlIGFuZCBiaXQgY291bnRzICh3aGljaCBuZWVkIG5vdCBiZVxuICogb3B0aW1hbCkuXG4gKiBJTiBhc3NlcnRpb246IHRoZSBhcnJheSBibF9jb3VudCBjb250YWlucyB0aGUgYml0IGxlbmd0aCBzdGF0aXN0aWNzIGZvclxuICogdGhlIGdpdmVuIHRyZWUgYW5kIHRoZSBmaWVsZCBsZW4gaXMgc2V0IGZvciBhbGwgdHJlZSBlbGVtZW50cy5cbiAqIE9VVCBhc3NlcnRpb246IHRoZSBmaWVsZCBjb2RlIGlzIHNldCBmb3IgYWxsIHRyZWUgZWxlbWVudHMgb2Ygbm9uXG4gKiAgICAgemVybyBjb2RlIGxlbmd0aC5cbiAqL1xuZnVuY3Rpb24gZ2VuX2NvZGVzKHRyZWUsIG1heF9jb2RlLCBibF9jb3VudClcbi8vICAgIGN0X2RhdGEgKnRyZWU7ICAgICAgICAgICAgIC8qIHRoZSB0cmVlIHRvIGRlY29yYXRlICovXG4vLyAgICBpbnQgbWF4X2NvZGU7ICAgICAgICAgICAgICAvKiBsYXJnZXN0IGNvZGUgd2l0aCBub24gemVybyBmcmVxdWVuY3kgKi9cbi8vICAgIHVzaGYgKmJsX2NvdW50OyAgICAgICAgICAgIC8qIG51bWJlciBvZiBjb2RlcyBhdCBlYWNoIGJpdCBsZW5ndGggKi9cbntcbiAgdmFyIG5leHRfY29kZSA9IG5ldyBBcnJheShNQVhfQklUUyArIDEpOyAvKiBuZXh0IGNvZGUgdmFsdWUgZm9yIGVhY2ggYml0IGxlbmd0aCAqL1xuICB2YXIgY29kZSA9IDA7ICAgICAgICAgICAgICAvKiBydW5uaW5nIGNvZGUgdmFsdWUgKi9cbiAgdmFyIGJpdHM7ICAgICAgICAgICAgICAgICAgLyogYml0IGluZGV4ICovXG4gIHZhciBuOyAgICAgICAgICAgICAgICAgICAgIC8qIGNvZGUgaW5kZXggKi9cblxuICAvKiBUaGUgZGlzdHJpYnV0aW9uIGNvdW50cyBhcmUgZmlyc3QgdXNlZCB0byBnZW5lcmF0ZSB0aGUgY29kZSB2YWx1ZXNcbiAgICogd2l0aG91dCBiaXQgcmV2ZXJzYWwuXG4gICAqL1xuICBmb3IgKGJpdHMgPSAxOyBiaXRzIDw9IE1BWF9CSVRTOyBiaXRzKyspIHtcbiAgICBuZXh0X2NvZGVbYml0c10gPSBjb2RlID0gKGNvZGUgKyBibF9jb3VudFtiaXRzIC0gMV0pIDw8IDE7XG4gIH1cbiAgLyogQ2hlY2sgdGhhdCB0aGUgYml0IGNvdW50cyBpbiBibF9jb3VudCBhcmUgY29uc2lzdGVudC4gVGhlIGxhc3QgY29kZVxuICAgKiBtdXN0IGJlIGFsbCBvbmVzLlxuICAgKi9cbiAgLy9Bc3NlcnQgKGNvZGUgKyBibF9jb3VudFtNQVhfQklUU10tMSA9PSAoMTw8TUFYX0JJVFMpLTEsXG4gIC8vICAgICAgICBcImluY29uc2lzdGVudCBiaXQgY291bnRzXCIpO1xuICAvL1RyYWNldigoc3RkZXJyLFwiXFxuZ2VuX2NvZGVzOiBtYXhfY29kZSAlZCBcIiwgbWF4X2NvZGUpKTtcblxuICBmb3IgKG4gPSAwOyAgbiA8PSBtYXhfY29kZTsgbisrKSB7XG4gICAgdmFyIGxlbiA9IHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovO1xuICAgIGlmIChsZW4gPT09IDApIHsgY29udGludWU7IH1cbiAgICAvKiBOb3cgcmV2ZXJzZSB0aGUgYml0cyAqL1xuICAgIHRyZWVbbiAqIDJdLyouQ29kZSovID0gYmlfcmV2ZXJzZShuZXh0X2NvZGVbbGVuXSsrLCBsZW4pO1xuXG4gICAgLy9UcmFjZWN2KHRyZWUgIT0gc3RhdGljX2x0cmVlLCAoc3RkZXJyLFwiXFxubiAlM2QgJWMgbCAlMmQgYyAlNHggKCV4KSBcIixcbiAgICAvLyAgICAgbiwgKGlzZ3JhcGgobikgPyBuIDogJyAnKSwgbGVuLCB0cmVlW25dLkNvZGUsIG5leHRfY29kZVtsZW5dLTEpKTtcbiAgfVxufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogSW5pdGlhbGl6ZSB0aGUgdmFyaW91cyAnY29uc3RhbnQnIHRhYmxlcy5cbiAqL1xuZnVuY3Rpb24gdHJfc3RhdGljX2luaXQoKSB7XG4gIHZhciBuOyAgICAgICAgLyogaXRlcmF0ZXMgb3ZlciB0cmVlIGVsZW1lbnRzICovXG4gIHZhciBiaXRzOyAgICAgLyogYml0IGNvdW50ZXIgKi9cbiAgdmFyIGxlbmd0aDsgICAvKiBsZW5ndGggdmFsdWUgKi9cbiAgdmFyIGNvZGU7ICAgICAvKiBjb2RlIHZhbHVlICovXG4gIHZhciBkaXN0OyAgICAgLyogZGlzdGFuY2UgaW5kZXggKi9cbiAgdmFyIGJsX2NvdW50ID0gbmV3IEFycmF5KE1BWF9CSVRTICsgMSk7XG4gIC8qIG51bWJlciBvZiBjb2RlcyBhdCBlYWNoIGJpdCBsZW5ndGggZm9yIGFuIG9wdGltYWwgdHJlZSAqL1xuXG4gIC8vIGRvIGNoZWNrIGluIF90cl9pbml0KClcbiAgLy9pZiAoc3RhdGljX2luaXRfZG9uZSkgcmV0dXJuO1xuXG4gIC8qIEZvciBzb21lIGVtYmVkZGVkIHRhcmdldHMsIGdsb2JhbCB2YXJpYWJsZXMgYXJlIG5vdCBpbml0aWFsaXplZDogKi9cbi8qI2lmZGVmIE5PX0lOSVRfR0xPQkFMX1BPSU5URVJTXG4gIHN0YXRpY19sX2Rlc2Muc3RhdGljX3RyZWUgPSBzdGF0aWNfbHRyZWU7XG4gIHN0YXRpY19sX2Rlc2MuZXh0cmFfYml0cyA9IGV4dHJhX2xiaXRzO1xuICBzdGF0aWNfZF9kZXNjLnN0YXRpY190cmVlID0gc3RhdGljX2R0cmVlO1xuICBzdGF0aWNfZF9kZXNjLmV4dHJhX2JpdHMgPSBleHRyYV9kYml0cztcbiAgc3RhdGljX2JsX2Rlc2MuZXh0cmFfYml0cyA9IGV4dHJhX2JsYml0cztcbiNlbmRpZiovXG5cbiAgLyogSW5pdGlhbGl6ZSB0aGUgbWFwcGluZyBsZW5ndGggKDAuLjI1NSkgLT4gbGVuZ3RoIGNvZGUgKDAuLjI4KSAqL1xuICBsZW5ndGggPSAwO1xuICBmb3IgKGNvZGUgPSAwOyBjb2RlIDwgTEVOR1RIX0NPREVTIC0gMTsgY29kZSsrKSB7XG4gICAgYmFzZV9sZW5ndGhbY29kZV0gPSBsZW5ndGg7XG4gICAgZm9yIChuID0gMDsgbiA8ICgxIDw8IGV4dHJhX2xiaXRzW2NvZGVdKTsgbisrKSB7XG4gICAgICBfbGVuZ3RoX2NvZGVbbGVuZ3RoKytdID0gY29kZTtcbiAgICB9XG4gIH1cbiAgLy9Bc3NlcnQgKGxlbmd0aCA9PSAyNTYsIFwidHJfc3RhdGljX2luaXQ6IGxlbmd0aCAhPSAyNTZcIik7XG4gIC8qIE5vdGUgdGhhdCB0aGUgbGVuZ3RoIDI1NSAobWF0Y2ggbGVuZ3RoIDI1OCkgY2FuIGJlIHJlcHJlc2VudGVkXG4gICAqIGluIHR3byBkaWZmZXJlbnQgd2F5czogY29kZSAyODQgKyA1IGJpdHMgb3IgY29kZSAyODUsIHNvIHdlXG4gICAqIG92ZXJ3cml0ZSBsZW5ndGhfY29kZVsyNTVdIHRvIHVzZSB0aGUgYmVzdCBlbmNvZGluZzpcbiAgICovXG4gIF9sZW5ndGhfY29kZVtsZW5ndGggLSAxXSA9IGNvZGU7XG5cbiAgLyogSW5pdGlhbGl6ZSB0aGUgbWFwcGluZyBkaXN0ICgwLi4zMkspIC0+IGRpc3QgY29kZSAoMC4uMjkpICovXG4gIGRpc3QgPSAwO1xuICBmb3IgKGNvZGUgPSAwOyBjb2RlIDwgMTY7IGNvZGUrKykge1xuICAgIGJhc2VfZGlzdFtjb2RlXSA9IGRpc3Q7XG4gICAgZm9yIChuID0gMDsgbiA8ICgxIDw8IGV4dHJhX2RiaXRzW2NvZGVdKTsgbisrKSB7XG4gICAgICBfZGlzdF9jb2RlW2Rpc3QrK10gPSBjb2RlO1xuICAgIH1cbiAgfVxuICAvL0Fzc2VydCAoZGlzdCA9PSAyNTYsIFwidHJfc3RhdGljX2luaXQ6IGRpc3QgIT0gMjU2XCIpO1xuICBkaXN0ID4+PSA3OyAvKiBmcm9tIG5vdyBvbiwgYWxsIGRpc3RhbmNlcyBhcmUgZGl2aWRlZCBieSAxMjggKi9cbiAgZm9yICg7IGNvZGUgPCBEX0NPREVTOyBjb2RlKyspIHtcbiAgICBiYXNlX2Rpc3RbY29kZV0gPSBkaXN0IDw8IDc7XG4gICAgZm9yIChuID0gMDsgbiA8ICgxIDw8IChleHRyYV9kYml0c1tjb2RlXSAtIDcpKTsgbisrKSB7XG4gICAgICBfZGlzdF9jb2RlWzI1NiArIGRpc3QrK10gPSBjb2RlO1xuICAgIH1cbiAgfVxuICAvL0Fzc2VydCAoZGlzdCA9PSAyNTYsIFwidHJfc3RhdGljX2luaXQ6IDI1NitkaXN0ICE9IDUxMlwiKTtcblxuICAvKiBDb25zdHJ1Y3QgdGhlIGNvZGVzIG9mIHRoZSBzdGF0aWMgbGl0ZXJhbCB0cmVlICovXG4gIGZvciAoYml0cyA9IDA7IGJpdHMgPD0gTUFYX0JJVFM7IGJpdHMrKykge1xuICAgIGJsX2NvdW50W2JpdHNdID0gMDtcbiAgfVxuXG4gIG4gPSAwO1xuICB3aGlsZSAobiA8PSAxNDMpIHtcbiAgICBzdGF0aWNfbHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovID0gODtcbiAgICBuKys7XG4gICAgYmxfY291bnRbOF0rKztcbiAgfVxuICB3aGlsZSAobiA8PSAyNTUpIHtcbiAgICBzdGF0aWNfbHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovID0gOTtcbiAgICBuKys7XG4gICAgYmxfY291bnRbOV0rKztcbiAgfVxuICB3aGlsZSAobiA8PSAyNzkpIHtcbiAgICBzdGF0aWNfbHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovID0gNztcbiAgICBuKys7XG4gICAgYmxfY291bnRbN10rKztcbiAgfVxuICB3aGlsZSAobiA8PSAyODcpIHtcbiAgICBzdGF0aWNfbHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovID0gODtcbiAgICBuKys7XG4gICAgYmxfY291bnRbOF0rKztcbiAgfVxuICAvKiBDb2RlcyAyODYgYW5kIDI4NyBkbyBub3QgZXhpc3QsIGJ1dCB3ZSBtdXN0IGluY2x1ZGUgdGhlbSBpbiB0aGVcbiAgICogdHJlZSBjb25zdHJ1Y3Rpb24gdG8gZ2V0IGEgY2Fub25pY2FsIEh1ZmZtYW4gdHJlZSAobG9uZ2VzdCBjb2RlXG4gICAqIGFsbCBvbmVzKVxuICAgKi9cbiAgZ2VuX2NvZGVzKHN0YXRpY19sdHJlZSwgTF9DT0RFUyArIDEsIGJsX2NvdW50KTtcblxuICAvKiBUaGUgc3RhdGljIGRpc3RhbmNlIHRyZWUgaXMgdHJpdmlhbDogKi9cbiAgZm9yIChuID0gMDsgbiA8IERfQ09ERVM7IG4rKykge1xuICAgIHN0YXRpY19kdHJlZVtuICogMiArIDFdLyouTGVuKi8gPSA1O1xuICAgIHN0YXRpY19kdHJlZVtuICogMl0vKi5Db2RlKi8gPSBiaV9yZXZlcnNlKG4sIDUpO1xuICB9XG5cbiAgLy8gTm93IGRhdGEgcmVhZHkgYW5kIHdlIGNhbiBpbml0IHN0YXRpYyB0cmVlc1xuICBzdGF0aWNfbF9kZXNjID0gbmV3IFN0YXRpY1RyZWVEZXNjKHN0YXRpY19sdHJlZSwgZXh0cmFfbGJpdHMsIExJVEVSQUxTICsgMSwgTF9DT0RFUywgTUFYX0JJVFMpO1xuICBzdGF0aWNfZF9kZXNjID0gbmV3IFN0YXRpY1RyZWVEZXNjKHN0YXRpY19kdHJlZSwgZXh0cmFfZGJpdHMsIDAsICAgICAgICAgIERfQ09ERVMsIE1BWF9CSVRTKTtcbiAgc3RhdGljX2JsX2Rlc2MgPSBuZXcgU3RhdGljVHJlZURlc2MobmV3IEFycmF5KDApLCBleHRyYV9ibGJpdHMsIDAsICAgICAgICAgQkxfQ09ERVMsIE1BWF9CTF9CSVRTKTtcblxuICAvL3N0YXRpY19pbml0X2RvbmUgPSB0cnVlO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogSW5pdGlhbGl6ZSBhIG5ldyBibG9jay5cbiAqL1xuZnVuY3Rpb24gaW5pdF9ibG9jayhzKSB7XG4gIHZhciBuOyAvKiBpdGVyYXRlcyBvdmVyIHRyZWUgZWxlbWVudHMgKi9cblxuICAvKiBJbml0aWFsaXplIHRoZSB0cmVlcy4gKi9cbiAgZm9yIChuID0gMDsgbiA8IExfQ09ERVM7ICBuKyspIHsgcy5keW5fbHRyZWVbbiAqIDJdLyouRnJlcSovID0gMDsgfVxuICBmb3IgKG4gPSAwOyBuIDwgRF9DT0RFUzsgIG4rKykgeyBzLmR5bl9kdHJlZVtuICogMl0vKi5GcmVxKi8gPSAwOyB9XG4gIGZvciAobiA9IDA7IG4gPCBCTF9DT0RFUzsgbisrKSB7IHMuYmxfdHJlZVtuICogMl0vKi5GcmVxKi8gPSAwOyB9XG5cbiAgcy5keW5fbHRyZWVbRU5EX0JMT0NLICogMl0vKi5GcmVxKi8gPSAxO1xuICBzLm9wdF9sZW4gPSBzLnN0YXRpY19sZW4gPSAwO1xuICBzLmxhc3RfbGl0ID0gcy5tYXRjaGVzID0gMDtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEZsdXNoIHRoZSBiaXQgYnVmZmVyIGFuZCBhbGlnbiB0aGUgb3V0cHV0IG9uIGEgYnl0ZSBib3VuZGFyeVxuICovXG5mdW5jdGlvbiBiaV93aW5kdXAocylcbntcbiAgaWYgKHMuYmlfdmFsaWQgPiA4KSB7XG4gICAgcHV0X3Nob3J0KHMsIHMuYmlfYnVmKTtcbiAgfSBlbHNlIGlmIChzLmJpX3ZhbGlkID4gMCkge1xuICAgIC8vcHV0X2J5dGUocywgKEJ5dGUpcy0+YmlfYnVmKTtcbiAgICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9IHMuYmlfYnVmO1xuICB9XG4gIHMuYmlfYnVmID0gMDtcbiAgcy5iaV92YWxpZCA9IDA7XG59XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29weSBhIHN0b3JlZCBibG9jaywgc3RvcmluZyBmaXJzdCB0aGUgbGVuZ3RoIGFuZCBpdHNcbiAqIG9uZSdzIGNvbXBsZW1lbnQgaWYgcmVxdWVzdGVkLlxuICovXG5mdW5jdGlvbiBjb3B5X2Jsb2NrKHMsIGJ1ZiwgbGVuLCBoZWFkZXIpXG4vL0RlZmxhdGVTdGF0ZSAqcztcbi8vY2hhcmYgICAgKmJ1ZjsgICAgLyogdGhlIGlucHV0IGRhdGEgKi9cbi8vdW5zaWduZWQgbGVuOyAgICAgLyogaXRzIGxlbmd0aCAqL1xuLy9pbnQgICAgICBoZWFkZXI7ICAvKiB0cnVlIGlmIGJsb2NrIGhlYWRlciBtdXN0IGJlIHdyaXR0ZW4gKi9cbntcbiAgYmlfd2luZHVwKHMpOyAgICAgICAgLyogYWxpZ24gb24gYnl0ZSBib3VuZGFyeSAqL1xuXG4gIGlmIChoZWFkZXIpIHtcbiAgICBwdXRfc2hvcnQocywgbGVuKTtcbiAgICBwdXRfc2hvcnQocywgfmxlbik7XG4gIH1cbi8vICB3aGlsZSAobGVuLS0pIHtcbi8vICAgIHB1dF9ieXRlKHMsICpidWYrKyk7XG4vLyAgfVxuICB1dGlscy5hcnJheVNldChzLnBlbmRpbmdfYnVmLCBzLndpbmRvdywgYnVmLCBsZW4sIHMucGVuZGluZyk7XG4gIHMucGVuZGluZyArPSBsZW47XG59XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29tcGFyZXMgdG8gc3VidHJlZXMsIHVzaW5nIHRoZSB0cmVlIGRlcHRoIGFzIHRpZSBicmVha2VyIHdoZW5cbiAqIHRoZSBzdWJ0cmVlcyBoYXZlIGVxdWFsIGZyZXF1ZW5jeS4gVGhpcyBtaW5pbWl6ZXMgdGhlIHdvcnN0IGNhc2UgbGVuZ3RoLlxuICovXG5mdW5jdGlvbiBzbWFsbGVyKHRyZWUsIG4sIG0sIGRlcHRoKSB7XG4gIHZhciBfbjIgPSBuICogMjtcbiAgdmFyIF9tMiA9IG0gKiAyO1xuICByZXR1cm4gKHRyZWVbX24yXS8qLkZyZXEqLyA8IHRyZWVbX20yXS8qLkZyZXEqLyB8fFxuICAgICAgICAgKHRyZWVbX24yXS8qLkZyZXEqLyA9PT0gdHJlZVtfbTJdLyouRnJlcSovICYmIGRlcHRoW25dIDw9IGRlcHRoW21dKSk7XG59XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogUmVzdG9yZSB0aGUgaGVhcCBwcm9wZXJ0eSBieSBtb3ZpbmcgZG93biB0aGUgdHJlZSBzdGFydGluZyBhdCBub2RlIGssXG4gKiBleGNoYW5naW5nIGEgbm9kZSB3aXRoIHRoZSBzbWFsbGVzdCBvZiBpdHMgdHdvIHNvbnMgaWYgbmVjZXNzYXJ5LCBzdG9wcGluZ1xuICogd2hlbiB0aGUgaGVhcCBwcm9wZXJ0eSBpcyByZS1lc3RhYmxpc2hlZCAoZWFjaCBmYXRoZXIgc21hbGxlciB0aGFuIGl0c1xuICogdHdvIHNvbnMpLlxuICovXG5mdW5jdGlvbiBwcWRvd25oZWFwKHMsIHRyZWUsIGspXG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgY3RfZGF0YSAqdHJlZTsgIC8qIHRoZSB0cmVlIHRvIHJlc3RvcmUgKi9cbi8vICAgIGludCBrOyAgICAgICAgICAgICAgIC8qIG5vZGUgdG8gbW92ZSBkb3duICovXG57XG4gIHZhciB2ID0gcy5oZWFwW2tdO1xuICB2YXIgaiA9IGsgPDwgMTsgIC8qIGxlZnQgc29uIG9mIGsgKi9cbiAgd2hpbGUgKGogPD0gcy5oZWFwX2xlbikge1xuICAgIC8qIFNldCBqIHRvIHRoZSBzbWFsbGVzdCBvZiB0aGUgdHdvIHNvbnM6ICovXG4gICAgaWYgKGogPCBzLmhlYXBfbGVuICYmXG4gICAgICBzbWFsbGVyKHRyZWUsIHMuaGVhcFtqICsgMV0sIHMuaGVhcFtqXSwgcy5kZXB0aCkpIHtcbiAgICAgIGorKztcbiAgICB9XG4gICAgLyogRXhpdCBpZiB2IGlzIHNtYWxsZXIgdGhhbiBib3RoIHNvbnMgKi9cbiAgICBpZiAoc21hbGxlcih0cmVlLCB2LCBzLmhlYXBbal0sIHMuZGVwdGgpKSB7IGJyZWFrOyB9XG5cbiAgICAvKiBFeGNoYW5nZSB2IHdpdGggdGhlIHNtYWxsZXN0IHNvbiAqL1xuICAgIHMuaGVhcFtrXSA9IHMuaGVhcFtqXTtcbiAgICBrID0gajtcblxuICAgIC8qIEFuZCBjb250aW51ZSBkb3duIHRoZSB0cmVlLCBzZXR0aW5nIGogdG8gdGhlIGxlZnQgc29uIG9mIGsgKi9cbiAgICBqIDw8PSAxO1xuICB9XG4gIHMuaGVhcFtrXSA9IHY7XG59XG5cblxuLy8gaW5saW5lZCBtYW51YWxseVxuLy8gdmFyIFNNQUxMRVNUID0gMTtcblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTZW5kIHRoZSBibG9jayBkYXRhIGNvbXByZXNzZWQgdXNpbmcgdGhlIGdpdmVuIEh1ZmZtYW4gdHJlZXNcbiAqL1xuZnVuY3Rpb24gY29tcHJlc3NfYmxvY2socywgbHRyZWUsIGR0cmVlKVxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIGNvbnN0IGN0X2RhdGEgKmx0cmVlOyAvKiBsaXRlcmFsIHRyZWUgKi9cbi8vICAgIGNvbnN0IGN0X2RhdGEgKmR0cmVlOyAvKiBkaXN0YW5jZSB0cmVlICovXG57XG4gIHZhciBkaXN0OyAgICAgICAgICAgLyogZGlzdGFuY2Ugb2YgbWF0Y2hlZCBzdHJpbmcgKi9cbiAgdmFyIGxjOyAgICAgICAgICAgICAvKiBtYXRjaCBsZW5ndGggb3IgdW5tYXRjaGVkIGNoYXIgKGlmIGRpc3QgPT0gMCkgKi9cbiAgdmFyIGx4ID0gMDsgICAgICAgICAvKiBydW5uaW5nIGluZGV4IGluIGxfYnVmICovXG4gIHZhciBjb2RlOyAgICAgICAgICAgLyogdGhlIGNvZGUgdG8gc2VuZCAqL1xuICB2YXIgZXh0cmE7ICAgICAgICAgIC8qIG51bWJlciBvZiBleHRyYSBiaXRzIHRvIHNlbmQgKi9cblxuICBpZiAocy5sYXN0X2xpdCAhPT0gMCkge1xuICAgIGRvIHtcbiAgICAgIGRpc3QgPSAocy5wZW5kaW5nX2J1ZltzLmRfYnVmICsgbHggKiAyXSA8PCA4KSB8IChzLnBlbmRpbmdfYnVmW3MuZF9idWYgKyBseCAqIDIgKyAxXSk7XG4gICAgICBsYyA9IHMucGVuZGluZ19idWZbcy5sX2J1ZiArIGx4XTtcbiAgICAgIGx4Kys7XG5cbiAgICAgIGlmIChkaXN0ID09PSAwKSB7XG4gICAgICAgIHNlbmRfY29kZShzLCBsYywgbHRyZWUpOyAvKiBzZW5kIGEgbGl0ZXJhbCBieXRlICovXG4gICAgICAgIC8vVHJhY2Vjdihpc2dyYXBoKGxjKSwgKHN0ZGVycixcIiAnJWMnIFwiLCBsYykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLyogSGVyZSwgbGMgaXMgdGhlIG1hdGNoIGxlbmd0aCAtIE1JTl9NQVRDSCAqL1xuICAgICAgICBjb2RlID0gX2xlbmd0aF9jb2RlW2xjXTtcbiAgICAgICAgc2VuZF9jb2RlKHMsIGNvZGUgKyBMSVRFUkFMUyArIDEsIGx0cmVlKTsgLyogc2VuZCB0aGUgbGVuZ3RoIGNvZGUgKi9cbiAgICAgICAgZXh0cmEgPSBleHRyYV9sYml0c1tjb2RlXTtcbiAgICAgICAgaWYgKGV4dHJhICE9PSAwKSB7XG4gICAgICAgICAgbGMgLT0gYmFzZV9sZW5ndGhbY29kZV07XG4gICAgICAgICAgc2VuZF9iaXRzKHMsIGxjLCBleHRyYSk7ICAgICAgIC8qIHNlbmQgdGhlIGV4dHJhIGxlbmd0aCBiaXRzICovXG4gICAgICAgIH1cbiAgICAgICAgZGlzdC0tOyAvKiBkaXN0IGlzIG5vdyB0aGUgbWF0Y2ggZGlzdGFuY2UgLSAxICovXG4gICAgICAgIGNvZGUgPSBkX2NvZGUoZGlzdCk7XG4gICAgICAgIC8vQXNzZXJ0IChjb2RlIDwgRF9DT0RFUywgXCJiYWQgZF9jb2RlXCIpO1xuXG4gICAgICAgIHNlbmRfY29kZShzLCBjb2RlLCBkdHJlZSk7ICAgICAgIC8qIHNlbmQgdGhlIGRpc3RhbmNlIGNvZGUgKi9cbiAgICAgICAgZXh0cmEgPSBleHRyYV9kYml0c1tjb2RlXTtcbiAgICAgICAgaWYgKGV4dHJhICE9PSAwKSB7XG4gICAgICAgICAgZGlzdCAtPSBiYXNlX2Rpc3RbY29kZV07XG4gICAgICAgICAgc2VuZF9iaXRzKHMsIGRpc3QsIGV4dHJhKTsgICAvKiBzZW5kIHRoZSBleHRyYSBkaXN0YW5jZSBiaXRzICovXG4gICAgICAgIH1cbiAgICAgIH0gLyogbGl0ZXJhbCBvciBtYXRjaCBwYWlyID8gKi9cblxuICAgICAgLyogQ2hlY2sgdGhhdCB0aGUgb3ZlcmxheSBiZXR3ZWVuIHBlbmRpbmdfYnVmIGFuZCBkX2J1ZitsX2J1ZiBpcyBvazogKi9cbiAgICAgIC8vQXNzZXJ0KCh1SW50KShzLT5wZW5kaW5nKSA8IHMtPmxpdF9idWZzaXplICsgMipseCxcbiAgICAgIC8vICAgICAgIFwicGVuZGluZ0J1ZiBvdmVyZmxvd1wiKTtcblxuICAgIH0gd2hpbGUgKGx4IDwgcy5sYXN0X2xpdCk7XG4gIH1cblxuICBzZW5kX2NvZGUocywgRU5EX0JMT0NLLCBsdHJlZSk7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb25zdHJ1Y3Qgb25lIEh1ZmZtYW4gdHJlZSBhbmQgYXNzaWducyB0aGUgY29kZSBiaXQgc3RyaW5ncyBhbmQgbGVuZ3Rocy5cbiAqIFVwZGF0ZSB0aGUgdG90YWwgYml0IGxlbmd0aCBmb3IgdGhlIGN1cnJlbnQgYmxvY2suXG4gKiBJTiBhc3NlcnRpb246IHRoZSBmaWVsZCBmcmVxIGlzIHNldCBmb3IgYWxsIHRyZWUgZWxlbWVudHMuXG4gKiBPVVQgYXNzZXJ0aW9uczogdGhlIGZpZWxkcyBsZW4gYW5kIGNvZGUgYXJlIHNldCB0byB0aGUgb3B0aW1hbCBiaXQgbGVuZ3RoXG4gKiAgICAgYW5kIGNvcnJlc3BvbmRpbmcgY29kZS4gVGhlIGxlbmd0aCBvcHRfbGVuIGlzIHVwZGF0ZWQ7IHN0YXRpY19sZW4gaXNcbiAqICAgICBhbHNvIHVwZGF0ZWQgaWYgc3RyZWUgaXMgbm90IG51bGwuIFRoZSBmaWVsZCBtYXhfY29kZSBpcyBzZXQuXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkX3RyZWUocywgZGVzYylcbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICB0cmVlX2Rlc2MgKmRlc2M7IC8qIHRoZSB0cmVlIGRlc2NyaXB0b3IgKi9cbntcbiAgdmFyIHRyZWUgICAgID0gZGVzYy5keW5fdHJlZTtcbiAgdmFyIHN0cmVlICAgID0gZGVzYy5zdGF0X2Rlc2Muc3RhdGljX3RyZWU7XG4gIHZhciBoYXNfc3RyZWUgPSBkZXNjLnN0YXRfZGVzYy5oYXNfc3RyZWU7XG4gIHZhciBlbGVtcyAgICA9IGRlc2Muc3RhdF9kZXNjLmVsZW1zO1xuICB2YXIgbiwgbTsgICAgICAgICAgLyogaXRlcmF0ZSBvdmVyIGhlYXAgZWxlbWVudHMgKi9cbiAgdmFyIG1heF9jb2RlID0gLTE7IC8qIGxhcmdlc3QgY29kZSB3aXRoIG5vbiB6ZXJvIGZyZXF1ZW5jeSAqL1xuICB2YXIgbm9kZTsgICAgICAgICAgLyogbmV3IG5vZGUgYmVpbmcgY3JlYXRlZCAqL1xuXG4gIC8qIENvbnN0cnVjdCB0aGUgaW5pdGlhbCBoZWFwLCB3aXRoIGxlYXN0IGZyZXF1ZW50IGVsZW1lbnQgaW5cbiAgICogaGVhcFtTTUFMTEVTVF0uIFRoZSBzb25zIG9mIGhlYXBbbl0gYXJlIGhlYXBbMipuXSBhbmQgaGVhcFsyKm4rMV0uXG4gICAqIGhlYXBbMF0gaXMgbm90IHVzZWQuXG4gICAqL1xuICBzLmhlYXBfbGVuID0gMDtcbiAgcy5oZWFwX21heCA9IEhFQVBfU0laRTtcblxuICBmb3IgKG4gPSAwOyBuIDwgZWxlbXM7IG4rKykge1xuICAgIGlmICh0cmVlW24gKiAyXS8qLkZyZXEqLyAhPT0gMCkge1xuICAgICAgcy5oZWFwWysrcy5oZWFwX2xlbl0gPSBtYXhfY29kZSA9IG47XG4gICAgICBzLmRlcHRoW25dID0gMDtcblxuICAgIH0gZWxzZSB7XG4gICAgICB0cmVlW24gKiAyICsgMV0vKi5MZW4qLyA9IDA7XG4gICAgfVxuICB9XG5cbiAgLyogVGhlIHBremlwIGZvcm1hdCByZXF1aXJlcyB0aGF0IGF0IGxlYXN0IG9uZSBkaXN0YW5jZSBjb2RlIGV4aXN0cyxcbiAgICogYW5kIHRoYXQgYXQgbGVhc3Qgb25lIGJpdCBzaG91bGQgYmUgc2VudCBldmVuIGlmIHRoZXJlIGlzIG9ubHkgb25lXG4gICAqIHBvc3NpYmxlIGNvZGUuIFNvIHRvIGF2b2lkIHNwZWNpYWwgY2hlY2tzIGxhdGVyIG9uIHdlIGZvcmNlIGF0IGxlYXN0XG4gICAqIHR3byBjb2RlcyBvZiBub24gemVybyBmcmVxdWVuY3kuXG4gICAqL1xuICB3aGlsZSAocy5oZWFwX2xlbiA8IDIpIHtcbiAgICBub2RlID0gcy5oZWFwWysrcy5oZWFwX2xlbl0gPSAobWF4X2NvZGUgPCAyID8gKyttYXhfY29kZSA6IDApO1xuICAgIHRyZWVbbm9kZSAqIDJdLyouRnJlcSovID0gMTtcbiAgICBzLmRlcHRoW25vZGVdID0gMDtcbiAgICBzLm9wdF9sZW4tLTtcblxuICAgIGlmIChoYXNfc3RyZWUpIHtcbiAgICAgIHMuc3RhdGljX2xlbiAtPSBzdHJlZVtub2RlICogMiArIDFdLyouTGVuKi87XG4gICAgfVxuICAgIC8qIG5vZGUgaXMgMCBvciAxIHNvIGl0IGRvZXMgbm90IGhhdmUgZXh0cmEgYml0cyAqL1xuICB9XG4gIGRlc2MubWF4X2NvZGUgPSBtYXhfY29kZTtcblxuICAvKiBUaGUgZWxlbWVudHMgaGVhcFtoZWFwX2xlbi8yKzEgLi4gaGVhcF9sZW5dIGFyZSBsZWF2ZXMgb2YgdGhlIHRyZWUsXG4gICAqIGVzdGFibGlzaCBzdWItaGVhcHMgb2YgaW5jcmVhc2luZyBsZW5ndGhzOlxuICAgKi9cbiAgZm9yIChuID0gKHMuaGVhcF9sZW4gPj4gMS8qaW50IC8yKi8pOyBuID49IDE7IG4tLSkgeyBwcWRvd25oZWFwKHMsIHRyZWUsIG4pOyB9XG5cbiAgLyogQ29uc3RydWN0IHRoZSBIdWZmbWFuIHRyZWUgYnkgcmVwZWF0ZWRseSBjb21iaW5pbmcgdGhlIGxlYXN0IHR3b1xuICAgKiBmcmVxdWVudCBub2Rlcy5cbiAgICovXG4gIG5vZGUgPSBlbGVtczsgICAgICAgICAgICAgIC8qIG5leHQgaW50ZXJuYWwgbm9kZSBvZiB0aGUgdHJlZSAqL1xuICBkbyB7XG4gICAgLy9wcXJlbW92ZShzLCB0cmVlLCBuKTsgIC8qIG4gPSBub2RlIG9mIGxlYXN0IGZyZXF1ZW5jeSAqL1xuICAgIC8qKiogcHFyZW1vdmUgKioqL1xuICAgIG4gPSBzLmhlYXBbMS8qU01BTExFU1QqL107XG4gICAgcy5oZWFwWzEvKlNNQUxMRVNUKi9dID0gcy5oZWFwW3MuaGVhcF9sZW4tLV07XG4gICAgcHFkb3duaGVhcChzLCB0cmVlLCAxLypTTUFMTEVTVCovKTtcbiAgICAvKioqL1xuXG4gICAgbSA9IHMuaGVhcFsxLypTTUFMTEVTVCovXTsgLyogbSA9IG5vZGUgb2YgbmV4dCBsZWFzdCBmcmVxdWVuY3kgKi9cblxuICAgIHMuaGVhcFstLXMuaGVhcF9tYXhdID0gbjsgLyoga2VlcCB0aGUgbm9kZXMgc29ydGVkIGJ5IGZyZXF1ZW5jeSAqL1xuICAgIHMuaGVhcFstLXMuaGVhcF9tYXhdID0gbTtcblxuICAgIC8qIENyZWF0ZSBhIG5ldyBub2RlIGZhdGhlciBvZiBuIGFuZCBtICovXG4gICAgdHJlZVtub2RlICogMl0vKi5GcmVxKi8gPSB0cmVlW24gKiAyXS8qLkZyZXEqLyArIHRyZWVbbSAqIDJdLyouRnJlcSovO1xuICAgIHMuZGVwdGhbbm9kZV0gPSAocy5kZXB0aFtuXSA+PSBzLmRlcHRoW21dID8gcy5kZXB0aFtuXSA6IHMuZGVwdGhbbV0pICsgMTtcbiAgICB0cmVlW24gKiAyICsgMV0vKi5EYWQqLyA9IHRyZWVbbSAqIDIgKyAxXS8qLkRhZCovID0gbm9kZTtcblxuICAgIC8qIGFuZCBpbnNlcnQgdGhlIG5ldyBub2RlIGluIHRoZSBoZWFwICovXG4gICAgcy5oZWFwWzEvKlNNQUxMRVNUKi9dID0gbm9kZSsrO1xuICAgIHBxZG93bmhlYXAocywgdHJlZSwgMS8qU01BTExFU1QqLyk7XG5cbiAgfSB3aGlsZSAocy5oZWFwX2xlbiA+PSAyKTtcblxuICBzLmhlYXBbLS1zLmhlYXBfbWF4XSA9IHMuaGVhcFsxLypTTUFMTEVTVCovXTtcblxuICAvKiBBdCB0aGlzIHBvaW50LCB0aGUgZmllbGRzIGZyZXEgYW5kIGRhZCBhcmUgc2V0LiBXZSBjYW4gbm93XG4gICAqIGdlbmVyYXRlIHRoZSBiaXQgbGVuZ3Rocy5cbiAgICovXG4gIGdlbl9iaXRsZW4ocywgZGVzYyk7XG5cbiAgLyogVGhlIGZpZWxkIGxlbiBpcyBub3cgc2V0LCB3ZSBjYW4gZ2VuZXJhdGUgdGhlIGJpdCBjb2RlcyAqL1xuICBnZW5fY29kZXModHJlZSwgbWF4X2NvZGUsIHMuYmxfY291bnQpO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2NhbiBhIGxpdGVyYWwgb3IgZGlzdGFuY2UgdHJlZSB0byBkZXRlcm1pbmUgdGhlIGZyZXF1ZW5jaWVzIG9mIHRoZSBjb2Rlc1xuICogaW4gdGhlIGJpdCBsZW5ndGggdHJlZS5cbiAqL1xuZnVuY3Rpb24gc2Nhbl90cmVlKHMsIHRyZWUsIG1heF9jb2RlKVxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIGN0X2RhdGEgKnRyZWU7ICAgLyogdGhlIHRyZWUgdG8gYmUgc2Nhbm5lZCAqL1xuLy8gICAgaW50IG1heF9jb2RlOyAgICAvKiBhbmQgaXRzIGxhcmdlc3QgY29kZSBvZiBub24gemVybyBmcmVxdWVuY3kgKi9cbntcbiAgdmFyIG47ICAgICAgICAgICAgICAgICAgICAgLyogaXRlcmF0ZXMgb3ZlciBhbGwgdHJlZSBlbGVtZW50cyAqL1xuICB2YXIgcHJldmxlbiA9IC0xOyAgICAgICAgICAvKiBsYXN0IGVtaXR0ZWQgbGVuZ3RoICovXG4gIHZhciBjdXJsZW47ICAgICAgICAgICAgICAgIC8qIGxlbmd0aCBvZiBjdXJyZW50IGNvZGUgKi9cblxuICB2YXIgbmV4dGxlbiA9IHRyZWVbMCAqIDIgKyAxXS8qLkxlbiovOyAvKiBsZW5ndGggb2YgbmV4dCBjb2RlICovXG5cbiAgdmFyIGNvdW50ID0gMDsgICAgICAgICAgICAgLyogcmVwZWF0IGNvdW50IG9mIHRoZSBjdXJyZW50IGNvZGUgKi9cbiAgdmFyIG1heF9jb3VudCA9IDc7ICAgICAgICAgLyogbWF4IHJlcGVhdCBjb3VudCAqL1xuICB2YXIgbWluX2NvdW50ID0gNDsgICAgICAgICAvKiBtaW4gcmVwZWF0IGNvdW50ICovXG5cbiAgaWYgKG5leHRsZW4gPT09IDApIHtcbiAgICBtYXhfY291bnQgPSAxMzg7XG4gICAgbWluX2NvdW50ID0gMztcbiAgfVxuICB0cmVlWyhtYXhfY29kZSArIDEpICogMiArIDFdLyouTGVuKi8gPSAweGZmZmY7IC8qIGd1YXJkICovXG5cbiAgZm9yIChuID0gMDsgbiA8PSBtYXhfY29kZTsgbisrKSB7XG4gICAgY3VybGVuID0gbmV4dGxlbjtcbiAgICBuZXh0bGVuID0gdHJlZVsobiArIDEpICogMiArIDFdLyouTGVuKi87XG5cbiAgICBpZiAoKytjb3VudCA8IG1heF9jb3VudCAmJiBjdXJsZW4gPT09IG5leHRsZW4pIHtcbiAgICAgIGNvbnRpbnVlO1xuXG4gICAgfSBlbHNlIGlmIChjb3VudCA8IG1pbl9jb3VudCkge1xuICAgICAgcy5ibF90cmVlW2N1cmxlbiAqIDJdLyouRnJlcSovICs9IGNvdW50O1xuXG4gICAgfSBlbHNlIGlmIChjdXJsZW4gIT09IDApIHtcblxuICAgICAgaWYgKGN1cmxlbiAhPT0gcHJldmxlbikgeyBzLmJsX3RyZWVbY3VybGVuICogMl0vKi5GcmVxKi8rKzsgfVxuICAgICAgcy5ibF90cmVlW1JFUF8zXzYgKiAyXS8qLkZyZXEqLysrO1xuXG4gICAgfSBlbHNlIGlmIChjb3VudCA8PSAxMCkge1xuICAgICAgcy5ibF90cmVlW1JFUFpfM18xMCAqIDJdLyouRnJlcSovKys7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgcy5ibF90cmVlW1JFUFpfMTFfMTM4ICogMl0vKi5GcmVxKi8rKztcbiAgICB9XG5cbiAgICBjb3VudCA9IDA7XG4gICAgcHJldmxlbiA9IGN1cmxlbjtcblxuICAgIGlmIChuZXh0bGVuID09PSAwKSB7XG4gICAgICBtYXhfY291bnQgPSAxMzg7XG4gICAgICBtaW5fY291bnQgPSAzO1xuXG4gICAgfSBlbHNlIGlmIChjdXJsZW4gPT09IG5leHRsZW4pIHtcbiAgICAgIG1heF9jb3VudCA9IDY7XG4gICAgICBtaW5fY291bnQgPSAzO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIG1heF9jb3VudCA9IDc7XG4gICAgICBtaW5fY291bnQgPSA0O1xuICAgIH1cbiAgfVxufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2VuZCBhIGxpdGVyYWwgb3IgZGlzdGFuY2UgdHJlZSBpbiBjb21wcmVzc2VkIGZvcm0sIHVzaW5nIHRoZSBjb2RlcyBpblxuICogYmxfdHJlZS5cbiAqL1xuZnVuY3Rpb24gc2VuZF90cmVlKHMsIHRyZWUsIG1heF9jb2RlKVxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIGN0X2RhdGEgKnRyZWU7IC8qIHRoZSB0cmVlIHRvIGJlIHNjYW5uZWQgKi9cbi8vICAgIGludCBtYXhfY29kZTsgICAgICAgLyogYW5kIGl0cyBsYXJnZXN0IGNvZGUgb2Ygbm9uIHplcm8gZnJlcXVlbmN5ICovXG57XG4gIHZhciBuOyAgICAgICAgICAgICAgICAgICAgIC8qIGl0ZXJhdGVzIG92ZXIgYWxsIHRyZWUgZWxlbWVudHMgKi9cbiAgdmFyIHByZXZsZW4gPSAtMTsgICAgICAgICAgLyogbGFzdCBlbWl0dGVkIGxlbmd0aCAqL1xuICB2YXIgY3VybGVuOyAgICAgICAgICAgICAgICAvKiBsZW5ndGggb2YgY3VycmVudCBjb2RlICovXG5cbiAgdmFyIG5leHRsZW4gPSB0cmVlWzAgKiAyICsgMV0vKi5MZW4qLzsgLyogbGVuZ3RoIG9mIG5leHQgY29kZSAqL1xuXG4gIHZhciBjb3VudCA9IDA7ICAgICAgICAgICAgIC8qIHJlcGVhdCBjb3VudCBvZiB0aGUgY3VycmVudCBjb2RlICovXG4gIHZhciBtYXhfY291bnQgPSA3OyAgICAgICAgIC8qIG1heCByZXBlYXQgY291bnQgKi9cbiAgdmFyIG1pbl9jb3VudCA9IDQ7ICAgICAgICAgLyogbWluIHJlcGVhdCBjb3VudCAqL1xuXG4gIC8qIHRyZWVbbWF4X2NvZGUrMV0uTGVuID0gLTE7ICovICAvKiBndWFyZCBhbHJlYWR5IHNldCAqL1xuICBpZiAobmV4dGxlbiA9PT0gMCkge1xuICAgIG1heF9jb3VudCA9IDEzODtcbiAgICBtaW5fY291bnQgPSAzO1xuICB9XG5cbiAgZm9yIChuID0gMDsgbiA8PSBtYXhfY29kZTsgbisrKSB7XG4gICAgY3VybGVuID0gbmV4dGxlbjtcbiAgICBuZXh0bGVuID0gdHJlZVsobiArIDEpICogMiArIDFdLyouTGVuKi87XG5cbiAgICBpZiAoKytjb3VudCA8IG1heF9jb3VudCAmJiBjdXJsZW4gPT09IG5leHRsZW4pIHtcbiAgICAgIGNvbnRpbnVlO1xuXG4gICAgfSBlbHNlIGlmIChjb3VudCA8IG1pbl9jb3VudCkge1xuICAgICAgZG8geyBzZW5kX2NvZGUocywgY3VybGVuLCBzLmJsX3RyZWUpOyB9IHdoaWxlICgtLWNvdW50ICE9PSAwKTtcblxuICAgIH0gZWxzZSBpZiAoY3VybGVuICE9PSAwKSB7XG4gICAgICBpZiAoY3VybGVuICE9PSBwcmV2bGVuKSB7XG4gICAgICAgIHNlbmRfY29kZShzLCBjdXJsZW4sIHMuYmxfdHJlZSk7XG4gICAgICAgIGNvdW50LS07XG4gICAgICB9XG4gICAgICAvL0Fzc2VydChjb3VudCA+PSAzICYmIGNvdW50IDw9IDYsIFwiIDNfNj9cIik7XG4gICAgICBzZW5kX2NvZGUocywgUkVQXzNfNiwgcy5ibF90cmVlKTtcbiAgICAgIHNlbmRfYml0cyhzLCBjb3VudCAtIDMsIDIpO1xuXG4gICAgfSBlbHNlIGlmIChjb3VudCA8PSAxMCkge1xuICAgICAgc2VuZF9jb2RlKHMsIFJFUFpfM18xMCwgcy5ibF90cmVlKTtcbiAgICAgIHNlbmRfYml0cyhzLCBjb3VudCAtIDMsIDMpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbmRfY29kZShzLCBSRVBaXzExXzEzOCwgcy5ibF90cmVlKTtcbiAgICAgIHNlbmRfYml0cyhzLCBjb3VudCAtIDExLCA3KTtcbiAgICB9XG5cbiAgICBjb3VudCA9IDA7XG4gICAgcHJldmxlbiA9IGN1cmxlbjtcbiAgICBpZiAobmV4dGxlbiA9PT0gMCkge1xuICAgICAgbWF4X2NvdW50ID0gMTM4O1xuICAgICAgbWluX2NvdW50ID0gMztcblxuICAgIH0gZWxzZSBpZiAoY3VybGVuID09PSBuZXh0bGVuKSB7XG4gICAgICBtYXhfY291bnQgPSA2O1xuICAgICAgbWluX2NvdW50ID0gMztcblxuICAgIH0gZWxzZSB7XG4gICAgICBtYXhfY291bnQgPSA3O1xuICAgICAgbWluX2NvdW50ID0gNDtcbiAgICB9XG4gIH1cbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvbnN0cnVjdCB0aGUgSHVmZm1hbiB0cmVlIGZvciB0aGUgYml0IGxlbmd0aHMgYW5kIHJldHVybiB0aGUgaW5kZXggaW5cbiAqIGJsX29yZGVyIG9mIHRoZSBsYXN0IGJpdCBsZW5ndGggY29kZSB0byBzZW5kLlxuICovXG5mdW5jdGlvbiBidWlsZF9ibF90cmVlKHMpIHtcbiAgdmFyIG1heF9ibGluZGV4OyAgLyogaW5kZXggb2YgbGFzdCBiaXQgbGVuZ3RoIGNvZGUgb2Ygbm9uIHplcm8gZnJlcSAqL1xuXG4gIC8qIERldGVybWluZSB0aGUgYml0IGxlbmd0aCBmcmVxdWVuY2llcyBmb3IgbGl0ZXJhbCBhbmQgZGlzdGFuY2UgdHJlZXMgKi9cbiAgc2Nhbl90cmVlKHMsIHMuZHluX2x0cmVlLCBzLmxfZGVzYy5tYXhfY29kZSk7XG4gIHNjYW5fdHJlZShzLCBzLmR5bl9kdHJlZSwgcy5kX2Rlc2MubWF4X2NvZGUpO1xuXG4gIC8qIEJ1aWxkIHRoZSBiaXQgbGVuZ3RoIHRyZWU6ICovXG4gIGJ1aWxkX3RyZWUocywgcy5ibF9kZXNjKTtcbiAgLyogb3B0X2xlbiBub3cgaW5jbHVkZXMgdGhlIGxlbmd0aCBvZiB0aGUgdHJlZSByZXByZXNlbnRhdGlvbnMsIGV4Y2VwdFxuICAgKiB0aGUgbGVuZ3RocyBvZiB0aGUgYml0IGxlbmd0aHMgY29kZXMgYW5kIHRoZSA1KzUrNCBiaXRzIGZvciB0aGUgY291bnRzLlxuICAgKi9cblxuICAvKiBEZXRlcm1pbmUgdGhlIG51bWJlciBvZiBiaXQgbGVuZ3RoIGNvZGVzIHRvIHNlbmQuIFRoZSBwa3ppcCBmb3JtYXRcbiAgICogcmVxdWlyZXMgdGhhdCBhdCBsZWFzdCA0IGJpdCBsZW5ndGggY29kZXMgYmUgc2VudC4gKGFwcG5vdGUudHh0IHNheXNcbiAgICogMyBidXQgdGhlIGFjdHVhbCB2YWx1ZSB1c2VkIGlzIDQuKVxuICAgKi9cbiAgZm9yIChtYXhfYmxpbmRleCA9IEJMX0NPREVTIC0gMTsgbWF4X2JsaW5kZXggPj0gMzsgbWF4X2JsaW5kZXgtLSkge1xuICAgIGlmIChzLmJsX3RyZWVbYmxfb3JkZXJbbWF4X2JsaW5kZXhdICogMiArIDFdLyouTGVuKi8gIT09IDApIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICAvKiBVcGRhdGUgb3B0X2xlbiB0byBpbmNsdWRlIHRoZSBiaXQgbGVuZ3RoIHRyZWUgYW5kIGNvdW50cyAqL1xuICBzLm9wdF9sZW4gKz0gMyAqIChtYXhfYmxpbmRleCArIDEpICsgNSArIDUgKyA0O1xuICAvL1RyYWNldigoc3RkZXJyLCBcIlxcbmR5biB0cmVlczogZHluICVsZCwgc3RhdCAlbGRcIixcbiAgLy8gICAgICAgIHMtPm9wdF9sZW4sIHMtPnN0YXRpY19sZW4pKTtcblxuICByZXR1cm4gbWF4X2JsaW5kZXg7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTZW5kIHRoZSBoZWFkZXIgZm9yIGEgYmxvY2sgdXNpbmcgZHluYW1pYyBIdWZmbWFuIHRyZWVzOiB0aGUgY291bnRzLCB0aGVcbiAqIGxlbmd0aHMgb2YgdGhlIGJpdCBsZW5ndGggY29kZXMsIHRoZSBsaXRlcmFsIHRyZWUgYW5kIHRoZSBkaXN0YW5jZSB0cmVlLlxuICogSU4gYXNzZXJ0aW9uOiBsY29kZXMgPj0gMjU3LCBkY29kZXMgPj0gMSwgYmxjb2RlcyA+PSA0LlxuICovXG5mdW5jdGlvbiBzZW5kX2FsbF90cmVlcyhzLCBsY29kZXMsIGRjb2RlcywgYmxjb2Rlcylcbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICBpbnQgbGNvZGVzLCBkY29kZXMsIGJsY29kZXM7IC8qIG51bWJlciBvZiBjb2RlcyBmb3IgZWFjaCB0cmVlICovXG57XG4gIHZhciByYW5rOyAgICAgICAgICAgICAgICAgICAgLyogaW5kZXggaW4gYmxfb3JkZXIgKi9cblxuICAvL0Fzc2VydCAobGNvZGVzID49IDI1NyAmJiBkY29kZXMgPj0gMSAmJiBibGNvZGVzID49IDQsIFwibm90IGVub3VnaCBjb2Rlc1wiKTtcbiAgLy9Bc3NlcnQgKGxjb2RlcyA8PSBMX0NPREVTICYmIGRjb2RlcyA8PSBEX0NPREVTICYmIGJsY29kZXMgPD0gQkxfQ09ERVMsXG4gIC8vICAgICAgICBcInRvbyBtYW55IGNvZGVzXCIpO1xuICAvL1RyYWNldigoc3RkZXJyLCBcIlxcbmJsIGNvdW50czogXCIpKTtcbiAgc2VuZF9iaXRzKHMsIGxjb2RlcyAtIDI1NywgNSk7IC8qIG5vdCArMjU1IGFzIHN0YXRlZCBpbiBhcHBub3RlLnR4dCAqL1xuICBzZW5kX2JpdHMocywgZGNvZGVzIC0gMSwgICA1KTtcbiAgc2VuZF9iaXRzKHMsIGJsY29kZXMgLSA0LCAgNCk7IC8qIG5vdCAtMyBhcyBzdGF0ZWQgaW4gYXBwbm90ZS50eHQgKi9cbiAgZm9yIChyYW5rID0gMDsgcmFuayA8IGJsY29kZXM7IHJhbmsrKykge1xuICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiXFxuYmwgY29kZSAlMmQgXCIsIGJsX29yZGVyW3JhbmtdKSk7XG4gICAgc2VuZF9iaXRzKHMsIHMuYmxfdHJlZVtibF9vcmRlcltyYW5rXSAqIDIgKyAxXS8qLkxlbiovLCAzKTtcbiAgfVxuICAvL1RyYWNldigoc3RkZXJyLCBcIlxcbmJsIHRyZWU6IHNlbnQgJWxkXCIsIHMtPmJpdHNfc2VudCkpO1xuXG4gIHNlbmRfdHJlZShzLCBzLmR5bl9sdHJlZSwgbGNvZGVzIC0gMSk7IC8qIGxpdGVyYWwgdHJlZSAqL1xuICAvL1RyYWNldigoc3RkZXJyLCBcIlxcbmxpdCB0cmVlOiBzZW50ICVsZFwiLCBzLT5iaXRzX3NlbnQpKTtcblxuICBzZW5kX3RyZWUocywgcy5keW5fZHRyZWUsIGRjb2RlcyAtIDEpOyAvKiBkaXN0YW5jZSB0cmVlICovXG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiXFxuZGlzdCB0cmVlOiBzZW50ICVsZFwiLCBzLT5iaXRzX3NlbnQpKTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENoZWNrIGlmIHRoZSBkYXRhIHR5cGUgaXMgVEVYVCBvciBCSU5BUlksIHVzaW5nIHRoZSBmb2xsb3dpbmcgYWxnb3JpdGhtOlxuICogLSBURVhUIGlmIHRoZSB0d28gY29uZGl0aW9ucyBiZWxvdyBhcmUgc2F0aXNmaWVkOlxuICogICAgYSkgVGhlcmUgYXJlIG5vIG5vbi1wb3J0YWJsZSBjb250cm9sIGNoYXJhY3RlcnMgYmVsb25naW5nIHRvIHRoZVxuICogICAgICAgXCJibGFjayBsaXN0XCIgKDAuLjYsIDE0Li4yNSwgMjguLjMxKS5cbiAqICAgIGIpIFRoZXJlIGlzIGF0IGxlYXN0IG9uZSBwcmludGFibGUgY2hhcmFjdGVyIGJlbG9uZ2luZyB0byB0aGVcbiAqICAgICAgIFwid2hpdGUgbGlzdFwiICg5IHtUQUJ9LCAxMCB7TEZ9LCAxMyB7Q1J9LCAzMi4uMjU1KS5cbiAqIC0gQklOQVJZIG90aGVyd2lzZS5cbiAqIC0gVGhlIGZvbGxvd2luZyBwYXJ0aWFsbHktcG9ydGFibGUgY29udHJvbCBjaGFyYWN0ZXJzIGZvcm0gYVxuICogICBcImdyYXkgbGlzdFwiIHRoYXQgaXMgaWdub3JlZCBpbiB0aGlzIGRldGVjdGlvbiBhbGdvcml0aG06XG4gKiAgICg3IHtCRUx9LCA4IHtCU30sIDExIHtWVH0sIDEyIHtGRn0sIDI2IHtTVUJ9LCAyNyB7RVNDfSkuXG4gKiBJTiBhc3NlcnRpb246IHRoZSBmaWVsZHMgRnJlcSBvZiBkeW5fbHRyZWUgYXJlIHNldC5cbiAqL1xuZnVuY3Rpb24gZGV0ZWN0X2RhdGFfdHlwZShzKSB7XG4gIC8qIGJsYWNrX21hc2sgaXMgdGhlIGJpdCBtYXNrIG9mIGJsYWNrLWxpc3RlZCBieXRlc1xuICAgKiBzZXQgYml0cyAwLi42LCAxNC4uMjUsIGFuZCAyOC4uMzFcbiAgICogMHhmM2ZmYzA3ZiA9IGJpbmFyeSAxMTExMDAxMTExMTExMTExMTEwMDAwMDAwMTExMTExMVxuICAgKi9cbiAgdmFyIGJsYWNrX21hc2sgPSAweGYzZmZjMDdmO1xuICB2YXIgbjtcblxuICAvKiBDaGVjayBmb3Igbm9uLXRleHR1YWwgKFwiYmxhY2stbGlzdGVkXCIpIGJ5dGVzLiAqL1xuICBmb3IgKG4gPSAwOyBuIDw9IDMxOyBuKyssIGJsYWNrX21hc2sgPj4+PSAxKSB7XG4gICAgaWYgKChibGFja19tYXNrICYgMSkgJiYgKHMuZHluX2x0cmVlW24gKiAyXS8qLkZyZXEqLyAhPT0gMCkpIHtcbiAgICAgIHJldHVybiBaX0JJTkFSWTtcbiAgICB9XG4gIH1cblxuICAvKiBDaGVjayBmb3IgdGV4dHVhbCAoXCJ3aGl0ZS1saXN0ZWRcIikgYnl0ZXMuICovXG4gIGlmIChzLmR5bl9sdHJlZVs5ICogMl0vKi5GcmVxKi8gIT09IDAgfHwgcy5keW5fbHRyZWVbMTAgKiAyXS8qLkZyZXEqLyAhPT0gMCB8fFxuICAgICAgcy5keW5fbHRyZWVbMTMgKiAyXS8qLkZyZXEqLyAhPT0gMCkge1xuICAgIHJldHVybiBaX1RFWFQ7XG4gIH1cbiAgZm9yIChuID0gMzI7IG4gPCBMSVRFUkFMUzsgbisrKSB7XG4gICAgaWYgKHMuZHluX2x0cmVlW24gKiAyXS8qLkZyZXEqLyAhPT0gMCkge1xuICAgICAgcmV0dXJuIFpfVEVYVDtcbiAgICB9XG4gIH1cblxuICAvKiBUaGVyZSBhcmUgbm8gXCJibGFjay1saXN0ZWRcIiBvciBcIndoaXRlLWxpc3RlZFwiIGJ5dGVzOlxuICAgKiB0aGlzIHN0cmVhbSBlaXRoZXIgaXMgZW1wdHkgb3IgaGFzIHRvbGVyYXRlZCAoXCJncmF5LWxpc3RlZFwiKSBieXRlcyBvbmx5LlxuICAgKi9cbiAgcmV0dXJuIFpfQklOQVJZO1xufVxuXG5cbnZhciBzdGF0aWNfaW5pdF9kb25lID0gZmFsc2U7XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogSW5pdGlhbGl6ZSB0aGUgdHJlZSBkYXRhIHN0cnVjdHVyZXMgZm9yIGEgbmV3IHpsaWIgc3RyZWFtLlxuICovXG5mdW5jdGlvbiBfdHJfaW5pdChzKVxue1xuXG4gIGlmICghc3RhdGljX2luaXRfZG9uZSkge1xuICAgIHRyX3N0YXRpY19pbml0KCk7XG4gICAgc3RhdGljX2luaXRfZG9uZSA9IHRydWU7XG4gIH1cblxuICBzLmxfZGVzYyAgPSBuZXcgVHJlZURlc2Mocy5keW5fbHRyZWUsIHN0YXRpY19sX2Rlc2MpO1xuICBzLmRfZGVzYyAgPSBuZXcgVHJlZURlc2Mocy5keW5fZHRyZWUsIHN0YXRpY19kX2Rlc2MpO1xuICBzLmJsX2Rlc2MgPSBuZXcgVHJlZURlc2Mocy5ibF90cmVlLCBzdGF0aWNfYmxfZGVzYyk7XG5cbiAgcy5iaV9idWYgPSAwO1xuICBzLmJpX3ZhbGlkID0gMDtcblxuICAvKiBJbml0aWFsaXplIHRoZSBmaXJzdCBibG9jayBvZiB0aGUgZmlyc3QgZmlsZTogKi9cbiAgaW5pdF9ibG9jayhzKTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNlbmQgYSBzdG9yZWQgYmxvY2tcbiAqL1xuZnVuY3Rpb24gX3RyX3N0b3JlZF9ibG9jayhzLCBidWYsIHN0b3JlZF9sZW4sIGxhc3QpXG4vL0RlZmxhdGVTdGF0ZSAqcztcbi8vY2hhcmYgKmJ1ZjsgICAgICAgLyogaW5wdXQgYmxvY2sgKi9cbi8vdWxnIHN0b3JlZF9sZW47ICAgLyogbGVuZ3RoIG9mIGlucHV0IGJsb2NrICovXG4vL2ludCBsYXN0OyAgICAgICAgIC8qIG9uZSBpZiB0aGlzIGlzIHRoZSBsYXN0IGJsb2NrIGZvciBhIGZpbGUgKi9cbntcbiAgc2VuZF9iaXRzKHMsIChTVE9SRURfQkxPQ0sgPDwgMSkgKyAobGFzdCA/IDEgOiAwKSwgMyk7ICAgIC8qIHNlbmQgYmxvY2sgdHlwZSAqL1xuICBjb3B5X2Jsb2NrKHMsIGJ1Ziwgc3RvcmVkX2xlbiwgdHJ1ZSk7IC8qIHdpdGggaGVhZGVyICovXG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTZW5kIG9uZSBlbXB0eSBzdGF0aWMgYmxvY2sgdG8gZ2l2ZSBlbm91Z2ggbG9va2FoZWFkIGZvciBpbmZsYXRlLlxuICogVGhpcyB0YWtlcyAxMCBiaXRzLCBvZiB3aGljaCA3IG1heSByZW1haW4gaW4gdGhlIGJpdCBidWZmZXIuXG4gKi9cbmZ1bmN0aW9uIF90cl9hbGlnbihzKSB7XG4gIHNlbmRfYml0cyhzLCBTVEFUSUNfVFJFRVMgPDwgMSwgMyk7XG4gIHNlbmRfY29kZShzLCBFTkRfQkxPQ0ssIHN0YXRpY19sdHJlZSk7XG4gIGJpX2ZsdXNoKHMpO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRGV0ZXJtaW5lIHRoZSBiZXN0IGVuY29kaW5nIGZvciB0aGUgY3VycmVudCBibG9jazogZHluYW1pYyB0cmVlcywgc3RhdGljXG4gKiB0cmVlcyBvciBzdG9yZSwgYW5kIG91dHB1dCB0aGUgZW5jb2RlZCBibG9jayB0byB0aGUgemlwIGZpbGUuXG4gKi9cbmZ1bmN0aW9uIF90cl9mbHVzaF9ibG9jayhzLCBidWYsIHN0b3JlZF9sZW4sIGxhc3QpXG4vL0RlZmxhdGVTdGF0ZSAqcztcbi8vY2hhcmYgKmJ1ZjsgICAgICAgLyogaW5wdXQgYmxvY2ssIG9yIE5VTEwgaWYgdG9vIG9sZCAqL1xuLy91bGcgc3RvcmVkX2xlbjsgICAvKiBsZW5ndGggb2YgaW5wdXQgYmxvY2sgKi9cbi8vaW50IGxhc3Q7ICAgICAgICAgLyogb25lIGlmIHRoaXMgaXMgdGhlIGxhc3QgYmxvY2sgZm9yIGEgZmlsZSAqL1xue1xuICB2YXIgb3B0X2xlbmIsIHN0YXRpY19sZW5iOyAgLyogb3B0X2xlbiBhbmQgc3RhdGljX2xlbiBpbiBieXRlcyAqL1xuICB2YXIgbWF4X2JsaW5kZXggPSAwOyAgICAgICAgLyogaW5kZXggb2YgbGFzdCBiaXQgbGVuZ3RoIGNvZGUgb2Ygbm9uIHplcm8gZnJlcSAqL1xuXG4gIC8qIEJ1aWxkIHRoZSBIdWZmbWFuIHRyZWVzIHVubGVzcyBhIHN0b3JlZCBibG9jayBpcyBmb3JjZWQgKi9cbiAgaWYgKHMubGV2ZWwgPiAwKSB7XG5cbiAgICAvKiBDaGVjayBpZiB0aGUgZmlsZSBpcyBiaW5hcnkgb3IgdGV4dCAqL1xuICAgIGlmIChzLnN0cm0uZGF0YV90eXBlID09PSBaX1VOS05PV04pIHtcbiAgICAgIHMuc3RybS5kYXRhX3R5cGUgPSBkZXRlY3RfZGF0YV90eXBlKHMpO1xuICAgIH1cblxuICAgIC8qIENvbnN0cnVjdCB0aGUgbGl0ZXJhbCBhbmQgZGlzdGFuY2UgdHJlZXMgKi9cbiAgICBidWlsZF90cmVlKHMsIHMubF9kZXNjKTtcbiAgICAvLyBUcmFjZXYoKHN0ZGVyciwgXCJcXG5saXQgZGF0YTogZHluICVsZCwgc3RhdCAlbGRcIiwgcy0+b3B0X2xlbixcbiAgICAvLyAgICAgICAgcy0+c3RhdGljX2xlbikpO1xuXG4gICAgYnVpbGRfdHJlZShzLCBzLmRfZGVzYyk7XG4gICAgLy8gVHJhY2V2KChzdGRlcnIsIFwiXFxuZGlzdCBkYXRhOiBkeW4gJWxkLCBzdGF0ICVsZFwiLCBzLT5vcHRfbGVuLFxuICAgIC8vICAgICAgICBzLT5zdGF0aWNfbGVuKSk7XG4gICAgLyogQXQgdGhpcyBwb2ludCwgb3B0X2xlbiBhbmQgc3RhdGljX2xlbiBhcmUgdGhlIHRvdGFsIGJpdCBsZW5ndGhzIG9mXG4gICAgICogdGhlIGNvbXByZXNzZWQgYmxvY2sgZGF0YSwgZXhjbHVkaW5nIHRoZSB0cmVlIHJlcHJlc2VudGF0aW9ucy5cbiAgICAgKi9cblxuICAgIC8qIEJ1aWxkIHRoZSBiaXQgbGVuZ3RoIHRyZWUgZm9yIHRoZSBhYm92ZSB0d28gdHJlZXMsIGFuZCBnZXQgdGhlIGluZGV4XG4gICAgICogaW4gYmxfb3JkZXIgb2YgdGhlIGxhc3QgYml0IGxlbmd0aCBjb2RlIHRvIHNlbmQuXG4gICAgICovXG4gICAgbWF4X2JsaW5kZXggPSBidWlsZF9ibF90cmVlKHMpO1xuXG4gICAgLyogRGV0ZXJtaW5lIHRoZSBiZXN0IGVuY29kaW5nLiBDb21wdXRlIHRoZSBibG9jayBsZW5ndGhzIGluIGJ5dGVzLiAqL1xuICAgIG9wdF9sZW5iID0gKHMub3B0X2xlbiArIDMgKyA3KSA+Pj4gMztcbiAgICBzdGF0aWNfbGVuYiA9IChzLnN0YXRpY19sZW4gKyAzICsgNykgPj4+IDM7XG5cbiAgICAvLyBUcmFjZXYoKHN0ZGVyciwgXCJcXG5vcHQgJWx1KCVsdSkgc3RhdCAlbHUoJWx1KSBzdG9yZWQgJWx1IGxpdCAldSBcIixcbiAgICAvLyAgICAgICAgb3B0X2xlbmIsIHMtPm9wdF9sZW4sIHN0YXRpY19sZW5iLCBzLT5zdGF0aWNfbGVuLCBzdG9yZWRfbGVuLFxuICAgIC8vICAgICAgICBzLT5sYXN0X2xpdCkpO1xuXG4gICAgaWYgKHN0YXRpY19sZW5iIDw9IG9wdF9sZW5iKSB7IG9wdF9sZW5iID0gc3RhdGljX2xlbmI7IH1cblxuICB9IGVsc2Uge1xuICAgIC8vIEFzc2VydChidWYgIT0gKGNoYXIqKTAsIFwibG9zdCBidWZcIik7XG4gICAgb3B0X2xlbmIgPSBzdGF0aWNfbGVuYiA9IHN0b3JlZF9sZW4gKyA1OyAvKiBmb3JjZSBhIHN0b3JlZCBibG9jayAqL1xuICB9XG5cbiAgaWYgKChzdG9yZWRfbGVuICsgNCA8PSBvcHRfbGVuYikgJiYgKGJ1ZiAhPT0gLTEpKSB7XG4gICAgLyogNDogdHdvIHdvcmRzIGZvciB0aGUgbGVuZ3RocyAqL1xuXG4gICAgLyogVGhlIHRlc3QgYnVmICE9IE5VTEwgaXMgb25seSBuZWNlc3NhcnkgaWYgTElUX0JVRlNJWkUgPiBXU0laRS5cbiAgICAgKiBPdGhlcndpc2Ugd2UgY2FuJ3QgaGF2ZSBwcm9jZXNzZWQgbW9yZSB0aGFuIFdTSVpFIGlucHV0IGJ5dGVzIHNpbmNlXG4gICAgICogdGhlIGxhc3QgYmxvY2sgZmx1c2gsIGJlY2F1c2UgY29tcHJlc3Npb24gd291bGQgaGF2ZSBiZWVuXG4gICAgICogc3VjY2Vzc2Z1bC4gSWYgTElUX0JVRlNJWkUgPD0gV1NJWkUsIGl0IGlzIG5ldmVyIHRvbyBsYXRlIHRvXG4gICAgICogdHJhbnNmb3JtIGEgYmxvY2sgaW50byBhIHN0b3JlZCBibG9jay5cbiAgICAgKi9cbiAgICBfdHJfc3RvcmVkX2Jsb2NrKHMsIGJ1Ziwgc3RvcmVkX2xlbiwgbGFzdCk7XG5cbiAgfSBlbHNlIGlmIChzLnN0cmF0ZWd5ID09PSBaX0ZJWEVEIHx8IHN0YXRpY19sZW5iID09PSBvcHRfbGVuYikge1xuXG4gICAgc2VuZF9iaXRzKHMsIChTVEFUSUNfVFJFRVMgPDwgMSkgKyAobGFzdCA/IDEgOiAwKSwgMyk7XG4gICAgY29tcHJlc3NfYmxvY2socywgc3RhdGljX2x0cmVlLCBzdGF0aWNfZHRyZWUpO1xuXG4gIH0gZWxzZSB7XG4gICAgc2VuZF9iaXRzKHMsIChEWU5fVFJFRVMgPDwgMSkgKyAobGFzdCA/IDEgOiAwKSwgMyk7XG4gICAgc2VuZF9hbGxfdHJlZXMocywgcy5sX2Rlc2MubWF4X2NvZGUgKyAxLCBzLmRfZGVzYy5tYXhfY29kZSArIDEsIG1heF9ibGluZGV4ICsgMSk7XG4gICAgY29tcHJlc3NfYmxvY2socywgcy5keW5fbHRyZWUsIHMuZHluX2R0cmVlKTtcbiAgfVxuICAvLyBBc3NlcnQgKHMtPmNvbXByZXNzZWRfbGVuID09IHMtPmJpdHNfc2VudCwgXCJiYWQgY29tcHJlc3NlZCBzaXplXCIpO1xuICAvKiBUaGUgYWJvdmUgY2hlY2sgaXMgbWFkZSBtb2QgMl4zMiwgZm9yIGZpbGVzIGxhcmdlciB0aGFuIDUxMiBNQlxuICAgKiBhbmQgdUxvbmcgaW1wbGVtZW50ZWQgb24gMzIgYml0cy5cbiAgICovXG4gIGluaXRfYmxvY2socyk7XG5cbiAgaWYgKGxhc3QpIHtcbiAgICBiaV93aW5kdXAocyk7XG4gIH1cbiAgLy8gVHJhY2V2KChzdGRlcnIsXCJcXG5jb21wcmxlbiAlbHUoJWx1KSBcIiwgcy0+Y29tcHJlc3NlZF9sZW4+PjMsXG4gIC8vICAgICAgIHMtPmNvbXByZXNzZWRfbGVuLTcqbGFzdCkpO1xufVxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNhdmUgdGhlIG1hdGNoIGluZm8gYW5kIHRhbGx5IHRoZSBmcmVxdWVuY3kgY291bnRzLiBSZXR1cm4gdHJ1ZSBpZlxuICogdGhlIGN1cnJlbnQgYmxvY2sgbXVzdCBiZSBmbHVzaGVkLlxuICovXG5mdW5jdGlvbiBfdHJfdGFsbHkocywgZGlzdCwgbGMpXG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgdW5zaWduZWQgZGlzdDsgIC8qIGRpc3RhbmNlIG9mIG1hdGNoZWQgc3RyaW5nICovXG4vLyAgICB1bnNpZ25lZCBsYzsgICAgLyogbWF0Y2ggbGVuZ3RoLU1JTl9NQVRDSCBvciB1bm1hdGNoZWQgY2hhciAoaWYgZGlzdD09MCkgKi9cbntcbiAgLy92YXIgb3V0X2xlbmd0aCwgaW5fbGVuZ3RoLCBkY29kZTtcblxuICBzLnBlbmRpbmdfYnVmW3MuZF9idWYgKyBzLmxhc3RfbGl0ICogMl0gICAgID0gKGRpc3QgPj4+IDgpICYgMHhmZjtcbiAgcy5wZW5kaW5nX2J1ZltzLmRfYnVmICsgcy5sYXN0X2xpdCAqIDIgKyAxXSA9IGRpc3QgJiAweGZmO1xuXG4gIHMucGVuZGluZ19idWZbcy5sX2J1ZiArIHMubGFzdF9saXRdID0gbGMgJiAweGZmO1xuICBzLmxhc3RfbGl0Kys7XG5cbiAgaWYgKGRpc3QgPT09IDApIHtcbiAgICAvKiBsYyBpcyB0aGUgdW5tYXRjaGVkIGNoYXIgKi9cbiAgICBzLmR5bl9sdHJlZVtsYyAqIDJdLyouRnJlcSovKys7XG4gIH0gZWxzZSB7XG4gICAgcy5tYXRjaGVzKys7XG4gICAgLyogSGVyZSwgbGMgaXMgdGhlIG1hdGNoIGxlbmd0aCAtIE1JTl9NQVRDSCAqL1xuICAgIGRpc3QtLTsgICAgICAgICAgICAgLyogZGlzdCA9IG1hdGNoIGRpc3RhbmNlIC0gMSAqL1xuICAgIC8vQXNzZXJ0KCh1c2gpZGlzdCA8ICh1c2gpTUFYX0RJU1QocykgJiZcbiAgICAvLyAgICAgICAodXNoKWxjIDw9ICh1c2gpKE1BWF9NQVRDSC1NSU5fTUFUQ0gpICYmXG4gICAgLy8gICAgICAgKHVzaClkX2NvZGUoZGlzdCkgPCAodXNoKURfQ09ERVMsICBcIl90cl90YWxseTogYmFkIG1hdGNoXCIpO1xuXG4gICAgcy5keW5fbHRyZWVbKF9sZW5ndGhfY29kZVtsY10gKyBMSVRFUkFMUyArIDEpICogMl0vKi5GcmVxKi8rKztcbiAgICBzLmR5bl9kdHJlZVtkX2NvZGUoZGlzdCkgKiAyXS8qLkZyZXEqLysrO1xuICB9XG5cbi8vICghKSBUaGlzIGJsb2NrIGlzIGRpc2FibGVkIGluIHpsaWIgZGVmYXVsdHMsXG4vLyBkb24ndCBlbmFibGUgaXQgZm9yIGJpbmFyeSBjb21wYXRpYmlsaXR5XG5cbi8vI2lmZGVmIFRSVU5DQVRFX0JMT0NLXG4vLyAgLyogVHJ5IHRvIGd1ZXNzIGlmIGl0IGlzIHByb2ZpdGFibGUgdG8gc3RvcCB0aGUgY3VycmVudCBibG9jayBoZXJlICovXG4vLyAgaWYgKChzLmxhc3RfbGl0ICYgMHgxZmZmKSA9PT0gMCAmJiBzLmxldmVsID4gMikge1xuLy8gICAgLyogQ29tcHV0ZSBhbiB1cHBlciBib3VuZCBmb3IgdGhlIGNvbXByZXNzZWQgbGVuZ3RoICovXG4vLyAgICBvdXRfbGVuZ3RoID0gcy5sYXN0X2xpdCo4O1xuLy8gICAgaW5fbGVuZ3RoID0gcy5zdHJzdGFydCAtIHMuYmxvY2tfc3RhcnQ7XG4vL1xuLy8gICAgZm9yIChkY29kZSA9IDA7IGRjb2RlIDwgRF9DT0RFUzsgZGNvZGUrKykge1xuLy8gICAgICBvdXRfbGVuZ3RoICs9IHMuZHluX2R0cmVlW2Rjb2RlKjJdLyouRnJlcSovICogKDUgKyBleHRyYV9kYml0c1tkY29kZV0pO1xuLy8gICAgfVxuLy8gICAgb3V0X2xlbmd0aCA+Pj49IDM7XG4vLyAgICAvL1RyYWNldigoc3RkZXJyLFwiXFxubGFzdF9saXQgJXUsIGluICVsZCwgb3V0IH4lbGQoJWxkJSUpIFwiLFxuLy8gICAgLy8gICAgICAgcy0+bGFzdF9saXQsIGluX2xlbmd0aCwgb3V0X2xlbmd0aCxcbi8vICAgIC8vICAgICAgIDEwMEwgLSBvdXRfbGVuZ3RoKjEwMEwvaW5fbGVuZ3RoKSk7XG4vLyAgICBpZiAocy5tYXRjaGVzIDwgKHMubGFzdF9saXQ+PjEpLyppbnQgLzIqLyAmJiBvdXRfbGVuZ3RoIDwgKGluX2xlbmd0aD4+MSkvKmludCAvMiovKSB7XG4vLyAgICAgIHJldHVybiB0cnVlO1xuLy8gICAgfVxuLy8gIH1cbi8vI2VuZGlmXG5cbiAgcmV0dXJuIChzLmxhc3RfbGl0ID09PSBzLmxpdF9idWZzaXplIC0gMSk7XG4gIC8qIFdlIGF2b2lkIGVxdWFsaXR5IHdpdGggbGl0X2J1ZnNpemUgYmVjYXVzZSBvZiB3cmFwYXJvdW5kIGF0IDY0S1xuICAgKiBvbiAxNiBiaXQgbWFjaGluZXMgYW5kIGJlY2F1c2Ugc3RvcmVkIGJsb2NrcyBhcmUgcmVzdHJpY3RlZCB0b1xuICAgKiA2NEstMSBieXRlcy5cbiAgICovXG59XG5cbmV4cG9ydHMuX3RyX2luaXQgID0gX3RyX2luaXQ7XG5leHBvcnRzLl90cl9zdG9yZWRfYmxvY2sgPSBfdHJfc3RvcmVkX2Jsb2NrO1xuZXhwb3J0cy5fdHJfZmx1c2hfYmxvY2sgID0gX3RyX2ZsdXNoX2Jsb2NrO1xuZXhwb3J0cy5fdHJfdGFsbHkgPSBfdHJfdGFsbHk7XG5leHBvcnRzLl90cl9hbGlnbiA9IF90cl9hbGlnbjtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG5mdW5jdGlvbiBaU3RyZWFtKCkge1xuICAvKiBuZXh0IGlucHV0IGJ5dGUgKi9cbiAgdGhpcy5pbnB1dCA9IG51bGw7IC8vIEpTIHNwZWNpZmljLCBiZWNhdXNlIHdlIGhhdmUgbm8gcG9pbnRlcnNcbiAgdGhpcy5uZXh0X2luID0gMDtcbiAgLyogbnVtYmVyIG9mIGJ5dGVzIGF2YWlsYWJsZSBhdCBpbnB1dCAqL1xuICB0aGlzLmF2YWlsX2luID0gMDtcbiAgLyogdG90YWwgbnVtYmVyIG9mIGlucHV0IGJ5dGVzIHJlYWQgc28gZmFyICovXG4gIHRoaXMudG90YWxfaW4gPSAwO1xuICAvKiBuZXh0IG91dHB1dCBieXRlIHNob3VsZCBiZSBwdXQgdGhlcmUgKi9cbiAgdGhpcy5vdXRwdXQgPSBudWxsOyAvLyBKUyBzcGVjaWZpYywgYmVjYXVzZSB3ZSBoYXZlIG5vIHBvaW50ZXJzXG4gIHRoaXMubmV4dF9vdXQgPSAwO1xuICAvKiByZW1haW5pbmcgZnJlZSBzcGFjZSBhdCBvdXRwdXQgKi9cbiAgdGhpcy5hdmFpbF9vdXQgPSAwO1xuICAvKiB0b3RhbCBudW1iZXIgb2YgYnl0ZXMgb3V0cHV0IHNvIGZhciAqL1xuICB0aGlzLnRvdGFsX291dCA9IDA7XG4gIC8qIGxhc3QgZXJyb3IgbWVzc2FnZSwgTlVMTCBpZiBubyBlcnJvciAqL1xuICB0aGlzLm1zZyA9ICcnLypaX05VTEwqLztcbiAgLyogbm90IHZpc2libGUgYnkgYXBwbGljYXRpb25zICovXG4gIHRoaXMuc3RhdGUgPSBudWxsO1xuICAvKiBiZXN0IGd1ZXNzIGFib3V0IHRoZSBkYXRhIHR5cGU6IGJpbmFyeSBvciB0ZXh0ICovXG4gIHRoaXMuZGF0YV90eXBlID0gMi8qWl9VTktOT1dOKi87XG4gIC8qIGFkbGVyMzIgdmFsdWUgb2YgdGhlIHVuY29tcHJlc3NlZCBkYXRhICovXG4gIHRoaXMuYWRsZXIgPSAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFpTdHJlYW07XG4iLCIndXNlIHN0cmljdCc7XG5cbmlmICghcHJvY2Vzcy52ZXJzaW9uIHx8XG4gICAgcHJvY2Vzcy52ZXJzaW9uLmluZGV4T2YoJ3YwLicpID09PSAwIHx8XG4gICAgcHJvY2Vzcy52ZXJzaW9uLmluZGV4T2YoJ3YxLicpID09PSAwICYmIHByb2Nlc3MudmVyc2lvbi5pbmRleE9mKCd2MS44LicpICE9PSAwKSB7XG4gIG1vZHVsZS5leHBvcnRzID0geyBuZXh0VGljazogbmV4dFRpY2sgfTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcHJvY2Vzc1xufVxuXG5mdW5jdGlvbiBuZXh0VGljayhmbiwgYXJnMSwgYXJnMiwgYXJnMykge1xuICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJjYWxsYmFja1wiIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICB9XG4gIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICB2YXIgYXJncywgaTtcbiAgc3dpdGNoIChsZW4pIHtcbiAgY2FzZSAwOlxuICBjYXNlIDE6XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZm4pO1xuICBjYXNlIDI6XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrT25lKCkge1xuICAgICAgZm4uY2FsbChudWxsLCBhcmcxKTtcbiAgICB9KTtcbiAgY2FzZSAzOlxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGlja1R3bygpIHtcbiAgICAgIGZuLmNhbGwobnVsbCwgYXJnMSwgYXJnMik7XG4gICAgfSk7XG4gIGNhc2UgNDpcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2tUaHJlZSgpIHtcbiAgICAgIGZuLmNhbGwobnVsbCwgYXJnMSwgYXJnMiwgYXJnMyk7XG4gICAgfSk7XG4gIGRlZmF1bHQ6XG4gICAgYXJncyA9IG5ldyBBcnJheShsZW4gLSAxKTtcbiAgICBpID0gMDtcbiAgICB3aGlsZSAoaSA8IGFyZ3MubGVuZ3RoKSB7XG4gICAgICBhcmdzW2krK10gPSBhcmd1bWVudHNbaV07XG4gICAgfVxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGljaygpIHtcbiAgICAgIGZuLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIH0pO1xuICB9XG59XG5cbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fZHVwbGV4LmpzJyk7XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gYSBkdXBsZXggc3RyZWFtIGlzIGp1c3QgYSBzdHJlYW0gdGhhdCBpcyBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZS5cbi8vIFNpbmNlIEpTIGRvZXNuJ3QgaGF2ZSBtdWx0aXBsZSBwcm90b3R5cGFsIGluaGVyaXRhbmNlLCB0aGlzIGNsYXNzXG4vLyBwcm90b3R5cGFsbHkgaW5oZXJpdHMgZnJvbSBSZWFkYWJsZSwgYW5kIHRoZW4gcGFyYXNpdGljYWxseSBmcm9tXG4vLyBXcml0YWJsZS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgcG5hID0gcmVxdWlyZSgncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciBrZXlzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBrZXlzLnB1c2goa2V5KTtcbiAgfXJldHVybiBrZXlzO1xufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5tb2R1bGUuZXhwb3J0cyA9IER1cGxleDtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgUmVhZGFibGUgPSByZXF1aXJlKCcuL19zdHJlYW1fcmVhZGFibGUnKTtcbnZhciBXcml0YWJsZSA9IHJlcXVpcmUoJy4vX3N0cmVhbV93cml0YWJsZScpO1xuXG51dGlsLmluaGVyaXRzKER1cGxleCwgUmVhZGFibGUpO1xuXG57XG4gIC8vIGF2b2lkIHNjb3BlIGNyZWVwLCB0aGUga2V5cyBhcnJheSBjYW4gdGhlbiBiZSBjb2xsZWN0ZWRcbiAgdmFyIGtleXMgPSBvYmplY3RLZXlzKFdyaXRhYmxlLnByb3RvdHlwZSk7XG4gIGZvciAodmFyIHYgPSAwOyB2IDwga2V5cy5sZW5ndGg7IHYrKykge1xuICAgIHZhciBtZXRob2QgPSBrZXlzW3ZdO1xuICAgIGlmICghRHVwbGV4LnByb3RvdHlwZVttZXRob2RdKSBEdXBsZXgucHJvdG90eXBlW21ldGhvZF0gPSBXcml0YWJsZS5wcm90b3R5cGVbbWV0aG9kXTtcbiAgfVxufVxuXG5mdW5jdGlvbiBEdXBsZXgob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRHVwbGV4KSkgcmV0dXJuIG5ldyBEdXBsZXgob3B0aW9ucyk7XG5cbiAgUmVhZGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgV3JpdGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnJlYWRhYmxlID09PSBmYWxzZSkgdGhpcy5yZWFkYWJsZSA9IGZhbHNlO1xuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMud3JpdGFibGUgPT09IGZhbHNlKSB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG5cbiAgdGhpcy5hbGxvd0hhbGZPcGVuID0gdHJ1ZTtcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5hbGxvd0hhbGZPcGVuID09PSBmYWxzZSkgdGhpcy5hbGxvd0hhbGZPcGVuID0gZmFsc2U7XG5cbiAgdGhpcy5vbmNlKCdlbmQnLCBvbmVuZCk7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShEdXBsZXgucHJvdG90eXBlLCAnd3JpdGFibGVIaWdoV2F0ZXJNYXJrJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICB9XG59KTtcblxuLy8gdGhlIG5vLWhhbGYtb3BlbiBlbmZvcmNlclxuZnVuY3Rpb24gb25lbmQoKSB7XG4gIC8vIGlmIHdlIGFsbG93IGhhbGYtb3BlbiBzdGF0ZSwgb3IgaWYgdGhlIHdyaXRhYmxlIHNpZGUgZW5kZWQsXG4gIC8vIHRoZW4gd2UncmUgb2suXG4gIGlmICh0aGlzLmFsbG93SGFsZk9wZW4gfHwgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRlZCkgcmV0dXJuO1xuXG4gIC8vIG5vIG1vcmUgZGF0YSBjYW4gYmUgd3JpdHRlbi5cbiAgLy8gQnV0IGFsbG93IG1vcmUgd3JpdGVzIHRvIGhhcHBlbiBpbiB0aGlzIHRpY2suXG4gIHBuYS5uZXh0VGljayhvbkVuZE5ULCB0aGlzKTtcbn1cblxuZnVuY3Rpb24gb25FbmROVChzZWxmKSB7XG4gIHNlbGYuZW5kKCk7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShEdXBsZXgucHJvdG90eXBlLCAnZGVzdHJveWVkJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkIHx8IHRoaXMuX3dyaXRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgJiYgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgLy8gd2UgaWdub3JlIHRoZSB2YWx1ZSBpZiB0aGUgc3RyZWFtXG4gICAgLy8gaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkIHlldFxuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlID09PSB1bmRlZmluZWQgfHwgdGhpcy5fd3JpdGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdGhlIHVzZXIgaXMgZXhwbGljaXRseVxuICAgIC8vIG1hbmFnaW5nIGRlc3Ryb3llZFxuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgfVxufSk7XG5cbkR1cGxleC5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICB0aGlzLnB1c2gobnVsbCk7XG4gIHRoaXMuZW5kKCk7XG5cbiAgcG5hLm5leHRUaWNrKGNiLCBlcnIpO1xufTsiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gYSBwYXNzdGhyb3VnaCBzdHJlYW0uXG4vLyBiYXNpY2FsbHkganVzdCB0aGUgbW9zdCBtaW5pbWFsIHNvcnQgb2YgVHJhbnNmb3JtIHN0cmVhbS5cbi8vIEV2ZXJ5IHdyaXR0ZW4gY2h1bmsgZ2V0cyBvdXRwdXQgYXMtaXMuXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBQYXNzVGhyb3VnaDtcblxudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vX3N0cmVhbV90cmFuc2Zvcm0nKTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG51dGlsLmluaGVyaXRzKFBhc3NUaHJvdWdoLCBUcmFuc2Zvcm0pO1xuXG5mdW5jdGlvbiBQYXNzVGhyb3VnaChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBQYXNzVGhyb3VnaCkpIHJldHVybiBuZXcgUGFzc1Rocm91Z2gob3B0aW9ucyk7XG5cbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgb3B0aW9ucyk7XG59XG5cblBhc3NUaHJvdWdoLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobnVsbCwgY2h1bmspO1xufTsiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgcG5hID0gcmVxdWlyZSgncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWRhYmxlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5Jyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBEdXBsZXg7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuUmVhZGFibGUuUmVhZGFibGVTdGF0ZSA9IFJlYWRhYmxlU3RhdGU7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgRUUgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG5cbnZhciBFRWxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbiAoZW1pdHRlciwgdHlwZSkge1xuICByZXR1cm4gZW1pdHRlci5saXN0ZW5lcnModHlwZSkubGVuZ3RoO1xufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIFN0cmVhbSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9zdHJlYW0nKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXI7XG52YXIgT3VyVWludDhBcnJheSA9IGdsb2JhbC5VaW50OEFycmF5IHx8IGZ1bmN0aW9uICgpIHt9O1xuZnVuY3Rpb24gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuaykge1xuICByZXR1cm4gQnVmZmVyLmZyb20oY2h1bmspO1xufVxuZnVuY3Rpb24gX2lzVWludDhBcnJheShvYmopIHtcbiAgcmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcihvYmopIHx8IG9iaiBpbnN0YW5jZW9mIE91clVpbnQ4QXJyYXk7XG59XG5cbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgZGVidWdVdGlsID0gcmVxdWlyZSgndXRpbCcpO1xudmFyIGRlYnVnID0gdm9pZCAwO1xuaWYgKGRlYnVnVXRpbCAmJiBkZWJ1Z1V0aWwuZGVidWdsb2cpIHtcbiAgZGVidWcgPSBkZWJ1Z1V0aWwuZGVidWdsb2coJ3N0cmVhbScpO1xufSBlbHNlIHtcbiAgZGVidWcgPSBmdW5jdGlvbiAoKSB7fTtcbn1cbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgQnVmZmVyTGlzdCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9CdWZmZXJMaXN0Jyk7XG52YXIgZGVzdHJveUltcGwgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveScpO1xudmFyIFN0cmluZ0RlY29kZXI7XG5cbnV0aWwuaW5oZXJpdHMoUmVhZGFibGUsIFN0cmVhbSk7XG5cbnZhciBrUHJveHlFdmVudHMgPSBbJ2Vycm9yJywgJ2Nsb3NlJywgJ2Rlc3Ryb3knLCAncGF1c2UnLCAncmVzdW1lJ107XG5cbmZ1bmN0aW9uIHByZXBlbmRMaXN0ZW5lcihlbWl0dGVyLCBldmVudCwgZm4pIHtcbiAgLy8gU2FkbHkgdGhpcyBpcyBub3QgY2FjaGVhYmxlIGFzIHNvbWUgbGlicmFyaWVzIGJ1bmRsZSB0aGVpciBvd25cbiAgLy8gZXZlbnQgZW1pdHRlciBpbXBsZW1lbnRhdGlvbiB3aXRoIHRoZW0uXG4gIGlmICh0eXBlb2YgZW1pdHRlci5wcmVwZW5kTGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHJldHVybiBlbWl0dGVyLnByZXBlbmRMaXN0ZW5lcihldmVudCwgZm4pO1xuXG4gIC8vIFRoaXMgaXMgYSBoYWNrIHRvIG1ha2Ugc3VyZSB0aGF0IG91ciBlcnJvciBoYW5kbGVyIGlzIGF0dGFjaGVkIGJlZm9yZSBhbnlcbiAgLy8gdXNlcmxhbmQgb25lcy4gIE5FVkVSIERPIFRISVMuIFRoaXMgaXMgaGVyZSBvbmx5IGJlY2F1c2UgdGhpcyBjb2RlIG5lZWRzXG4gIC8vIHRvIGNvbnRpbnVlIHRvIHdvcmsgd2l0aCBvbGRlciB2ZXJzaW9ucyBvZiBOb2RlLmpzIHRoYXQgZG8gbm90IGluY2x1ZGVcbiAgLy8gdGhlIHByZXBlbmRMaXN0ZW5lcigpIG1ldGhvZC4gVGhlIGdvYWwgaXMgdG8gZXZlbnR1YWxseSByZW1vdmUgdGhpcyBoYWNrLlxuICBpZiAoIWVtaXR0ZXIuX2V2ZW50cyB8fCAhZW1pdHRlci5fZXZlbnRzW2V2ZW50XSkgZW1pdHRlci5vbihldmVudCwgZm4pO2Vsc2UgaWYgKGlzQXJyYXkoZW1pdHRlci5fZXZlbnRzW2V2ZW50XSkpIGVtaXR0ZXIuX2V2ZW50c1tldmVudF0udW5zaGlmdChmbik7ZWxzZSBlbWl0dGVyLl9ldmVudHNbZXZlbnRdID0gW2ZuLCBlbWl0dGVyLl9ldmVudHNbZXZlbnRdXTtcbn1cblxuZnVuY3Rpb24gUmVhZGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0pIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvLyBEdXBsZXggc3RyZWFtcyBhcmUgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUsIGJ1dCBzaGFyZVxuICAvLyB0aGUgc2FtZSBvcHRpb25zIG9iamVjdC5cbiAgLy8gSG93ZXZlciwgc29tZSBjYXNlcyByZXF1aXJlIHNldHRpbmcgb3B0aW9ucyB0byBkaWZmZXJlbnRcbiAgLy8gdmFsdWVzIGZvciB0aGUgcmVhZGFibGUgYW5kIHRoZSB3cml0YWJsZSBzaWRlcyBvZiB0aGUgZHVwbGV4IHN0cmVhbS5cbiAgLy8gVGhlc2Ugb3B0aW9ucyBjYW4gYmUgcHJvdmlkZWQgc2VwYXJhdGVseSBhcyByZWFkYWJsZVhYWCBhbmQgd3JpdGFibGVYWFguXG4gIHZhciBpc0R1cGxleCA9IHN0cmVhbSBpbnN0YW5jZW9mIER1cGxleDtcblxuICAvLyBvYmplY3Qgc3RyZWFtIGZsYWcuIFVzZWQgdG8gbWFrZSByZWFkKG4pIGlnbm9yZSBuIGFuZCB0b1xuICAvLyBtYWtlIGFsbCB0aGUgYnVmZmVyIG1lcmdpbmcgYW5kIGxlbmd0aCBjaGVja3MgZ28gYXdheVxuICB0aGlzLm9iamVjdE1vZGUgPSAhIW9wdGlvbnMub2JqZWN0TW9kZTtcblxuICBpZiAoaXNEdXBsZXgpIHRoaXMub2JqZWN0TW9kZSA9IHRoaXMub2JqZWN0TW9kZSB8fCAhIW9wdGlvbnMucmVhZGFibGVPYmplY3RNb2RlO1xuXG4gIC8vIHRoZSBwb2ludCBhdCB3aGljaCBpdCBzdG9wcyBjYWxsaW5nIF9yZWFkKCkgdG8gZmlsbCB0aGUgYnVmZmVyXG4gIC8vIE5vdGU6IDAgaXMgYSB2YWxpZCB2YWx1ZSwgbWVhbnMgXCJkb24ndCBjYWxsIF9yZWFkIHByZWVtcHRpdmVseSBldmVyXCJcbiAgdmFyIGh3bSA9IG9wdGlvbnMuaGlnaFdhdGVyTWFyaztcbiAgdmFyIHJlYWRhYmxlSHdtID0gb3B0aW9ucy5yZWFkYWJsZUhpZ2hXYXRlck1hcms7XG4gIHZhciBkZWZhdWx0SHdtID0gdGhpcy5vYmplY3RNb2RlID8gMTYgOiAxNiAqIDEwMjQ7XG5cbiAgaWYgKGh3bSB8fCBod20gPT09IDApIHRoaXMuaGlnaFdhdGVyTWFyayA9IGh3bTtlbHNlIGlmIChpc0R1cGxleCAmJiAocmVhZGFibGVId20gfHwgcmVhZGFibGVId20gPT09IDApKSB0aGlzLmhpZ2hXYXRlck1hcmsgPSByZWFkYWJsZUh3bTtlbHNlIHRoaXMuaGlnaFdhdGVyTWFyayA9IGRlZmF1bHRId207XG5cbiAgLy8gY2FzdCB0byBpbnRzLlxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSBNYXRoLmZsb29yKHRoaXMuaGlnaFdhdGVyTWFyayk7XG5cbiAgLy8gQSBsaW5rZWQgbGlzdCBpcyB1c2VkIHRvIHN0b3JlIGRhdGEgY2h1bmtzIGluc3RlYWQgb2YgYW4gYXJyYXkgYmVjYXVzZSB0aGVcbiAgLy8gbGlua2VkIGxpc3QgY2FuIHJlbW92ZSBlbGVtZW50cyBmcm9tIHRoZSBiZWdpbm5pbmcgZmFzdGVyIHRoYW5cbiAgLy8gYXJyYXkuc2hpZnQoKVxuICB0aGlzLmJ1ZmZlciA9IG5ldyBCdWZmZXJMaXN0KCk7XG4gIHRoaXMubGVuZ3RoID0gMDtcbiAgdGhpcy5waXBlcyA9IG51bGw7XG4gIHRoaXMucGlwZXNDb3VudCA9IDA7XG4gIHRoaXMuZmxvd2luZyA9IG51bGw7XG4gIHRoaXMuZW5kZWQgPSBmYWxzZTtcbiAgdGhpcy5lbmRFbWl0dGVkID0gZmFsc2U7XG4gIHRoaXMucmVhZGluZyA9IGZhbHNlO1xuXG4gIC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIGV2ZW50ICdyZWFkYWJsZScvJ2RhdGEnIGlzIGVtaXR0ZWRcbiAgLy8gaW1tZWRpYXRlbHksIG9yIG9uIGEgbGF0ZXIgdGljay4gIFdlIHNldCB0aGlzIHRvIHRydWUgYXQgZmlyc3QsIGJlY2F1c2VcbiAgLy8gYW55IGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsIFwibGF0ZXJcIiBzaG91bGQgZ2VuZXJhbGx5IGFsc29cbiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHJlYWQgY2FsbC5cbiAgdGhpcy5zeW5jID0gdHJ1ZTtcblxuICAvLyB3aGVuZXZlciB3ZSByZXR1cm4gbnVsbCwgdGhlbiB3ZSBzZXQgYSBmbGFnIHRvIHNheVxuICAvLyB0aGF0IHdlJ3JlIGF3YWl0aW5nIGEgJ3JlYWRhYmxlJyBldmVudCBlbWlzc2lvbi5cbiAgdGhpcy5uZWVkUmVhZGFibGUgPSBmYWxzZTtcbiAgdGhpcy5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgdGhpcy5yZWFkYWJsZUxpc3RlbmluZyA9IGZhbHNlO1xuICB0aGlzLnJlc3VtZVNjaGVkdWxlZCA9IGZhbHNlO1xuXG4gIC8vIGhhcyBpdCBiZWVuIGRlc3Ryb3llZFxuICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuXG4gIC8vIENyeXB0byBpcyBraW5kIG9mIG9sZCBhbmQgY3J1c3R5LiAgSGlzdG9yaWNhbGx5LCBpdHMgZGVmYXVsdCBzdHJpbmdcbiAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLlxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guXG4gIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgJ3V0ZjgnO1xuXG4gIC8vIHRoZSBudW1iZXIgb2Ygd3JpdGVycyB0aGF0IGFyZSBhd2FpdGluZyBhIGRyYWluIGV2ZW50IGluIC5waXBlKClzXG4gIHRoaXMuYXdhaXREcmFpbiA9IDA7XG5cbiAgLy8gaWYgdHJ1ZSwgYSBtYXliZVJlYWRNb3JlIGhhcyBiZWVuIHNjaGVkdWxlZFxuICB0aGlzLnJlYWRpbmdNb3JlID0gZmFsc2U7XG5cbiAgdGhpcy5kZWNvZGVyID0gbnVsbDtcbiAgdGhpcy5lbmNvZGluZyA9IG51bGw7XG4gIGlmIChvcHRpb25zLmVuY29kaW5nKSB7XG4gICAgaWYgKCFTdHJpbmdEZWNvZGVyKSBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXIvJykuU3RyaW5nRGVjb2RlcjtcbiAgICB0aGlzLmRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihvcHRpb25zLmVuY29kaW5nKTtcbiAgICB0aGlzLmVuY29kaW5nID0gb3B0aW9ucy5lbmNvZGluZztcbiAgfVxufVxuXG5mdW5jdGlvbiBSZWFkYWJsZShvcHRpb25zKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlYWRhYmxlKSkgcmV0dXJuIG5ldyBSZWFkYWJsZShvcHRpb25zKTtcblxuICB0aGlzLl9yZWFkYWJsZVN0YXRlID0gbmV3IFJlYWRhYmxlU3RhdGUob3B0aW9ucywgdGhpcyk7XG5cbiAgLy8gbGVnYWN5XG4gIHRoaXMucmVhZGFibGUgPSB0cnVlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnJlYWQgPT09ICdmdW5jdGlvbicpIHRoaXMuX3JlYWQgPSBvcHRpb25zLnJlYWQ7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZGVzdHJveSA9IG9wdGlvbnMuZGVzdHJveTtcbiAgfVxuXG4gIFN0cmVhbS5jYWxsKHRoaXMpO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGUucHJvdG90eXBlLCAnZGVzdHJveWVkJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAvLyB3ZSBpZ25vcmUgdGhlIHZhbHVlIGlmIHRoZSBzdHJlYW1cbiAgICAvLyBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0XG4gICAgaWYgKCF0aGlzLl9yZWFkYWJsZVN0YXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdGhlIHVzZXIgaXMgZXhwbGljaXRseVxuICAgIC8vIG1hbmFnaW5nIGRlc3Ryb3llZFxuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XG4gIH1cbn0pO1xuXG5SZWFkYWJsZS5wcm90b3R5cGUuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLmRlc3Ryb3k7XG5SZWFkYWJsZS5wcm90b3R5cGUuX3VuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLnVuZGVzdHJveTtcblJlYWRhYmxlLnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XG4gIHRoaXMucHVzaChudWxsKTtcbiAgY2IoZXJyKTtcbn07XG5cbi8vIE1hbnVhbGx5IHNob3ZlIHNvbWV0aGluZyBpbnRvIHRoZSByZWFkKCkgYnVmZmVyLlxuLy8gVGhpcyByZXR1cm5zIHRydWUgaWYgdGhlIGhpZ2hXYXRlck1hcmsgaGFzIG5vdCBiZWVuIGhpdCB5ZXQsXG4vLyBzaW1pbGFyIHRvIGhvdyBXcml0YWJsZS53cml0ZSgpIHJldHVybnMgdHJ1ZSBpZiB5b3Ugc2hvdWxkXG4vLyB3cml0ZSgpIHNvbWUgbW9yZS5cblJlYWRhYmxlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZykge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgc2tpcENodW5rQ2hlY2s7XG5cbiAgaWYgKCFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5jb2RpbmcgfHwgc3RhdGUuZGVmYXVsdEVuY29kaW5nO1xuICAgICAgaWYgKGVuY29kaW5nICE9PSBzdGF0ZS5lbmNvZGluZykge1xuICAgICAgICBjaHVuayA9IEJ1ZmZlci5mcm9tKGNodW5rLCBlbmNvZGluZyk7XG4gICAgICAgIGVuY29kaW5nID0gJyc7XG4gICAgICB9XG4gICAgICBza2lwQ2h1bmtDaGVjayA9IHRydWU7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHNraXBDaHVua0NoZWNrID0gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsIGNodW5rLCBlbmNvZGluZywgZmFsc2UsIHNraXBDaHVua0NoZWNrKTtcbn07XG5cbi8vIFVuc2hpZnQgc2hvdWxkICphbHdheXMqIGJlIHNvbWV0aGluZyBkaXJlY3RseSBvdXQgb2YgcmVhZCgpXG5SZWFkYWJsZS5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uIChjaHVuaykge1xuICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBjaHVuaywgbnVsbCwgdHJ1ZSwgZmFsc2UpO1xufTtcblxuZnVuY3Rpb24gcmVhZGFibGVBZGRDaHVuayhzdHJlYW0sIGNodW5rLCBlbmNvZGluZywgYWRkVG9Gcm9udCwgc2tpcENodW5rQ2hlY2spIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBpZiAoY2h1bmsgPT09IG51bGwpIHtcbiAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgb25Fb2ZDaHVuayhzdHJlYW0sIHN0YXRlKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZXI7XG4gICAgaWYgKCFza2lwQ2h1bmtDaGVjaykgZXIgPSBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKTtcbiAgICBpZiAoZXIpIHtcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgICB9IGVsc2UgaWYgKHN0YXRlLm9iamVjdE1vZGUgfHwgY2h1bmsgJiYgY2h1bmsubGVuZ3RoID4gMCkge1xuICAgICAgaWYgKHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgIXN0YXRlLm9iamVjdE1vZGUgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKGNodW5rKSAhPT0gQnVmZmVyLnByb3RvdHlwZSkge1xuICAgICAgICBjaHVuayA9IF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspO1xuICAgICAgfVxuXG4gICAgICBpZiAoYWRkVG9Gcm9udCkge1xuICAgICAgICBpZiAoc3RhdGUuZW5kRW1pdHRlZCkgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdzdHJlYW0udW5zaGlmdCgpIGFmdGVyIGVuZCBldmVudCcpKTtlbHNlIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCB0cnVlKTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUuZW5kZWQpIHtcbiAgICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdzdHJlYW0ucHVzaCgpIGFmdGVyIEVPRicpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIWVuY29kaW5nKSB7XG4gICAgICAgICAgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKTtcbiAgICAgICAgICBpZiAoc3RhdGUub2JqZWN0TW9kZSB8fCBjaHVuay5sZW5ndGggIT09IDApIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBmYWxzZSk7ZWxzZSBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFhZGRUb0Zyb250KSB7XG4gICAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5lZWRNb3JlRGF0YShzdGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBhZGRUb0Zyb250KSB7XG4gIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmxlbmd0aCA9PT0gMCAmJiAhc3RhdGUuc3luYykge1xuICAgIHN0cmVhbS5lbWl0KCdkYXRhJywgY2h1bmspO1xuICAgIHN0cmVhbS5yZWFkKDApO1xuICB9IGVsc2Uge1xuICAgIC8vIHVwZGF0ZSB0aGUgYnVmZmVyIGluZm8uXG4gICAgc3RhdGUubGVuZ3RoICs9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICAgIGlmIChhZGRUb0Zyb250KSBzdGF0ZS5idWZmZXIudW5zaGlmdChjaHVuayk7ZWxzZSBzdGF0ZS5idWZmZXIucHVzaChjaHVuayk7XG5cbiAgICBpZiAoc3RhdGUubmVlZFJlYWRhYmxlKSBlbWl0UmVhZGFibGUoc3RyZWFtKTtcbiAgfVxuICBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpO1xufVxuXG5mdW5jdGlvbiBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKSB7XG4gIHZhciBlcjtcbiAgaWYgKCFfaXNVaW50OEFycmF5KGNodW5rKSAmJiB0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmIGNodW5rICE9PSB1bmRlZmluZWQgJiYgIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBlciA9IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbm9uLXN0cmluZy9idWZmZXIgY2h1bmsnKTtcbiAgfVxuICByZXR1cm4gZXI7XG59XG5cbi8vIGlmIGl0J3MgcGFzdCB0aGUgaGlnaCB3YXRlciBtYXJrLCB3ZSBjYW4gcHVzaCBpbiBzb21lIG1vcmUuXG4vLyBBbHNvLCBpZiB3ZSBoYXZlIG5vIGRhdGEgeWV0LCB3ZSBjYW4gc3RhbmQgc29tZVxuLy8gbW9yZSBieXRlcy4gIFRoaXMgaXMgdG8gd29yayBhcm91bmQgY2FzZXMgd2hlcmUgaHdtPTAsXG4vLyBzdWNoIGFzIHRoZSByZXBsLiAgQWxzbywgaWYgdGhlIHB1c2goKSB0cmlnZ2VyZWQgYVxuLy8gcmVhZGFibGUgZXZlbnQsIGFuZCB0aGUgdXNlciBjYWxsZWQgcmVhZChsYXJnZU51bWJlcikgc3VjaCB0aGF0XG4vLyBuZWVkUmVhZGFibGUgd2FzIHNldCwgdGhlbiB3ZSBvdWdodCB0byBwdXNoIG1vcmUsIHNvIHRoYXQgYW5vdGhlclxuLy8gJ3JlYWRhYmxlJyBldmVudCB3aWxsIGJlIHRyaWdnZXJlZC5cbmZ1bmN0aW9uIG5lZWRNb3JlRGF0YShzdGF0ZSkge1xuICByZXR1cm4gIXN0YXRlLmVuZGVkICYmIChzdGF0ZS5uZWVkUmVhZGFibGUgfHwgc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyayB8fCBzdGF0ZS5sZW5ndGggPT09IDApO1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUuaXNQYXVzZWQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgPT09IGZhbHNlO1xufTtcblxuLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG5SZWFkYWJsZS5wcm90b3R5cGUuc2V0RW5jb2RpbmcgPSBmdW5jdGlvbiAoZW5jKSB7XG4gIGlmICghU3RyaW5nRGVjb2RlcikgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyLycpLlN0cmluZ0RlY29kZXI7XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKGVuYyk7XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5jb2RpbmcgPSBlbmM7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gRG9uJ3QgcmFpc2UgdGhlIGh3bSA+IDhNQlxudmFyIE1BWF9IV00gPSAweDgwMDAwMDtcbmZ1bmN0aW9uIGNvbXB1dGVOZXdIaWdoV2F0ZXJNYXJrKG4pIHtcbiAgaWYgKG4gPj0gTUFYX0hXTSkge1xuICAgIG4gPSBNQVhfSFdNO1xuICB9IGVsc2Uge1xuICAgIC8vIEdldCB0aGUgbmV4dCBoaWdoZXN0IHBvd2VyIG9mIDIgdG8gcHJldmVudCBpbmNyZWFzaW5nIGh3bSBleGNlc3NpdmVseSBpblxuICAgIC8vIHRpbnkgYW1vdW50c1xuICAgIG4tLTtcbiAgICBuIHw9IG4gPj4+IDE7XG4gICAgbiB8PSBuID4+PiAyO1xuICAgIG4gfD0gbiA+Pj4gNDtcbiAgICBuIHw9IG4gPj4+IDg7XG4gICAgbiB8PSBuID4+PiAxNjtcbiAgICBuKys7XG4gIH1cbiAgcmV0dXJuIG47XG59XG5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gaG93TXVjaFRvUmVhZChuLCBzdGF0ZSkge1xuICBpZiAobiA8PSAwIHx8IHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkgcmV0dXJuIDA7XG4gIGlmIChzdGF0ZS5vYmplY3RNb2RlKSByZXR1cm4gMTtcbiAgaWYgKG4gIT09IG4pIHtcbiAgICAvLyBPbmx5IGZsb3cgb25lIGJ1ZmZlciBhdCBhIHRpbWVcbiAgICBpZiAoc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5sZW5ndGgpIHJldHVybiBzdGF0ZS5idWZmZXIuaGVhZC5kYXRhLmxlbmd0aDtlbHNlIHJldHVybiBzdGF0ZS5sZW5ndGg7XG4gIH1cbiAgLy8gSWYgd2UncmUgYXNraW5nIGZvciBtb3JlIHRoYW4gdGhlIGN1cnJlbnQgaHdtLCB0aGVuIHJhaXNlIHRoZSBod20uXG4gIGlmIChuID4gc3RhdGUuaGlnaFdhdGVyTWFyaykgc3RhdGUuaGlnaFdhdGVyTWFyayA9IGNvbXB1dGVOZXdIaWdoV2F0ZXJNYXJrKG4pO1xuICBpZiAobiA8PSBzdGF0ZS5sZW5ndGgpIHJldHVybiBuO1xuICAvLyBEb24ndCBoYXZlIGVub3VnaFxuICBpZiAoIXN0YXRlLmVuZGVkKSB7XG4gICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICByZXR1cm4gMDtcbiAgfVxuICByZXR1cm4gc3RhdGUubGVuZ3RoO1xufVxuXG4vLyB5b3UgY2FuIG92ZXJyaWRlIGVpdGhlciB0aGlzIG1ldGhvZCwgb3IgdGhlIGFzeW5jIF9yZWFkKG4pIGJlbG93LlxuUmVhZGFibGUucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbiAobikge1xuICBkZWJ1ZygncmVhZCcsIG4pO1xuICBuID0gcGFyc2VJbnQobiwgMTApO1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgbk9yaWcgPSBuO1xuXG4gIGlmIChuICE9PSAwKSBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcblxuICAvLyBpZiB3ZSdyZSBkb2luZyByZWFkKDApIHRvIHRyaWdnZXIgYSByZWFkYWJsZSBldmVudCwgYnV0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhIGJ1bmNoIG9mIGRhdGEgaW4gdGhlIGJ1ZmZlciwgdGhlbiBqdXN0IHRyaWdnZXJcbiAgLy8gdGhlICdyZWFkYWJsZScgZXZlbnQgYW5kIG1vdmUgb24uXG4gIGlmIChuID09PSAwICYmIHN0YXRlLm5lZWRSZWFkYWJsZSAmJiAoc3RhdGUubGVuZ3RoID49IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHwgc3RhdGUuZW5kZWQpKSB7XG4gICAgZGVidWcoJ3JlYWQ6IGVtaXRSZWFkYWJsZScsIHN0YXRlLmxlbmd0aCwgc3RhdGUuZW5kZWQpO1xuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuZW5kZWQpIGVuZFJlYWRhYmxlKHRoaXMpO2Vsc2UgZW1pdFJlYWRhYmxlKHRoaXMpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgbiA9IGhvd011Y2hUb1JlYWQobiwgc3RhdGUpO1xuXG4gIC8vIGlmIHdlJ3ZlIGVuZGVkLCBhbmQgd2UncmUgbm93IGNsZWFyLCB0aGVuIGZpbmlzaCBpdCB1cC5cbiAgaWYgKG4gPT09IDAgJiYgc3RhdGUuZW5kZWQpIHtcbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSBlbmRSZWFkYWJsZSh0aGlzKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIEFsbCB0aGUgYWN0dWFsIGNodW5rIGdlbmVyYXRpb24gbG9naWMgbmVlZHMgdG8gYmVcbiAgLy8gKmJlbG93KiB0aGUgY2FsbCB0byBfcmVhZC4gIFRoZSByZWFzb24gaXMgdGhhdCBpbiBjZXJ0YWluXG4gIC8vIHN5bnRoZXRpYyBzdHJlYW0gY2FzZXMsIHN1Y2ggYXMgcGFzc3Rocm91Z2ggc3RyZWFtcywgX3JlYWRcbiAgLy8gbWF5IGJlIGEgY29tcGxldGVseSBzeW5jaHJvbm91cyBvcGVyYXRpb24gd2hpY2ggbWF5IGNoYW5nZVxuICAvLyB0aGUgc3RhdGUgb2YgdGhlIHJlYWQgYnVmZmVyLCBwcm92aWRpbmcgZW5vdWdoIGRhdGEgd2hlblxuICAvLyBiZWZvcmUgdGhlcmUgd2FzICpub3QqIGVub3VnaC5cbiAgLy9cbiAgLy8gU28sIHRoZSBzdGVwcyBhcmU6XG4gIC8vIDEuIEZpZ3VyZSBvdXQgd2hhdCB0aGUgc3RhdGUgb2YgdGhpbmdzIHdpbGwgYmUgYWZ0ZXIgd2UgZG9cbiAgLy8gYSByZWFkIGZyb20gdGhlIGJ1ZmZlci5cbiAgLy9cbiAgLy8gMi4gSWYgdGhhdCByZXN1bHRpbmcgc3RhdGUgd2lsbCB0cmlnZ2VyIGEgX3JlYWQsIHRoZW4gY2FsbCBfcmVhZC5cbiAgLy8gTm90ZSB0aGF0IHRoaXMgbWF5IGJlIGFzeW5jaHJvbm91cywgb3Igc3luY2hyb25vdXMuICBZZXMsIGl0IGlzXG4gIC8vIGRlZXBseSB1Z2x5IHRvIHdyaXRlIEFQSXMgdGhpcyB3YXksIGJ1dCB0aGF0IHN0aWxsIGRvZXNuJ3QgbWVhblxuICAvLyB0aGF0IHRoZSBSZWFkYWJsZSBjbGFzcyBzaG91bGQgYmVoYXZlIGltcHJvcGVybHksIGFzIHN0cmVhbXMgYXJlXG4gIC8vIGRlc2lnbmVkIHRvIGJlIHN5bmMvYXN5bmMgYWdub3N0aWMuXG4gIC8vIFRha2Ugbm90ZSBpZiB0aGUgX3JlYWQgY2FsbCBpcyBzeW5jIG9yIGFzeW5jIChpZSwgaWYgdGhlIHJlYWQgY2FsbFxuICAvLyBoYXMgcmV0dXJuZWQgeWV0KSwgc28gdGhhdCB3ZSBrbm93IHdoZXRoZXIgb3Igbm90IGl0J3Mgc2FmZSB0byBlbWl0XG4gIC8vICdyZWFkYWJsZScgZXRjLlxuICAvL1xuICAvLyAzLiBBY3R1YWxseSBwdWxsIHRoZSByZXF1ZXN0ZWQgY2h1bmtzIG91dCBvZiB0aGUgYnVmZmVyIGFuZCByZXR1cm4uXG5cbiAgLy8gaWYgd2UgbmVlZCBhIHJlYWRhYmxlIGV2ZW50LCB0aGVuIHdlIG5lZWQgdG8gZG8gc29tZSByZWFkaW5nLlxuICB2YXIgZG9SZWFkID0gc3RhdGUubmVlZFJlYWRhYmxlO1xuICBkZWJ1ZygnbmVlZCByZWFkYWJsZScsIGRvUmVhZCk7XG5cbiAgLy8gaWYgd2UgY3VycmVudGx5IGhhdmUgbGVzcyB0aGFuIHRoZSBoaWdoV2F0ZXJNYXJrLCB0aGVuIGFsc28gcmVhZCBzb21lXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgfHwgc3RhdGUubGVuZ3RoIC0gbiA8IHN0YXRlLmhpZ2hXYXRlck1hcmspIHtcbiAgICBkb1JlYWQgPSB0cnVlO1xuICAgIGRlYnVnKCdsZW5ndGggbGVzcyB0aGFuIHdhdGVybWFyaycsIGRvUmVhZCk7XG4gIH1cblxuICAvLyBob3dldmVyLCBpZiB3ZSd2ZSBlbmRlZCwgdGhlbiB0aGVyZSdzIG5vIHBvaW50LCBhbmQgaWYgd2UncmUgYWxyZWFkeVxuICAvLyByZWFkaW5nLCB0aGVuIGl0J3MgdW5uZWNlc3NhcnkuXG4gIGlmIChzdGF0ZS5lbmRlZCB8fCBzdGF0ZS5yZWFkaW5nKSB7XG4gICAgZG9SZWFkID0gZmFsc2U7XG4gICAgZGVidWcoJ3JlYWRpbmcgb3IgZW5kZWQnLCBkb1JlYWQpO1xuICB9IGVsc2UgaWYgKGRvUmVhZCkge1xuICAgIGRlYnVnKCdkbyByZWFkJyk7XG4gICAgc3RhdGUucmVhZGluZyA9IHRydWU7XG4gICAgc3RhdGUuc3luYyA9IHRydWU7XG4gICAgLy8gaWYgdGhlIGxlbmd0aCBpcyBjdXJyZW50bHkgemVybywgdGhlbiB3ZSAqbmVlZCogYSByZWFkYWJsZSBldmVudC5cbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIC8vIGNhbGwgaW50ZXJuYWwgcmVhZCBtZXRob2RcbiAgICB0aGlzLl9yZWFkKHN0YXRlLmhpZ2hXYXRlck1hcmspO1xuICAgIHN0YXRlLnN5bmMgPSBmYWxzZTtcbiAgICAvLyBJZiBfcmVhZCBwdXNoZWQgZGF0YSBzeW5jaHJvbm91c2x5LCB0aGVuIGByZWFkaW5nYCB3aWxsIGJlIGZhbHNlLFxuICAgIC8vIGFuZCB3ZSBuZWVkIHRvIHJlLWV2YWx1YXRlIGhvdyBtdWNoIGRhdGEgd2UgY2FuIHJldHVybiB0byB0aGUgdXNlci5cbiAgICBpZiAoIXN0YXRlLnJlYWRpbmcpIG4gPSBob3dNdWNoVG9SZWFkKG5PcmlnLCBzdGF0ZSk7XG4gIH1cblxuICB2YXIgcmV0O1xuICBpZiAobiA+IDApIHJldCA9IGZyb21MaXN0KG4sIHN0YXRlKTtlbHNlIHJldCA9IG51bGw7XG5cbiAgaWYgKHJldCA9PT0gbnVsbCkge1xuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgbiA9IDA7XG4gIH0gZWxzZSB7XG4gICAgc3RhdGUubGVuZ3RoIC09IG47XG4gIH1cblxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSB7XG4gICAgLy8gSWYgd2UgaGF2ZSBub3RoaW5nIGluIHRoZSBidWZmZXIsIHRoZW4gd2Ugd2FudCB0byBrbm93XG4gICAgLy8gYXMgc29vbiBhcyB3ZSAqZG8qIGdldCBzb21ldGhpbmcgaW50byB0aGUgYnVmZmVyLlxuICAgIGlmICghc3RhdGUuZW5kZWQpIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG5cbiAgICAvLyBJZiB3ZSB0cmllZCB0byByZWFkKCkgcGFzdCB0aGUgRU9GLCB0aGVuIGVtaXQgZW5kIG9uIHRoZSBuZXh0IHRpY2suXG4gICAgaWYgKG5PcmlnICE9PSBuICYmIHN0YXRlLmVuZGVkKSBlbmRSZWFkYWJsZSh0aGlzKTtcbiAgfVxuXG4gIGlmIChyZXQgIT09IG51bGwpIHRoaXMuZW1pdCgnZGF0YScsIHJldCk7XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbmZ1bmN0aW9uIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUuZW5kZWQpIHJldHVybjtcbiAgaWYgKHN0YXRlLmRlY29kZXIpIHtcbiAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpO1xuICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpIHtcbiAgICAgIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcbiAgICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICB9XG4gIH1cbiAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuXG4gIC8vIGVtaXQgJ3JlYWRhYmxlJyBub3cgdG8gbWFrZSBzdXJlIGl0IGdldHMgcGlja2VkIHVwLlxuICBlbWl0UmVhZGFibGUoc3RyZWFtKTtcbn1cblxuLy8gRG9uJ3QgZW1pdCByZWFkYWJsZSByaWdodCBhd2F5IGluIHN5bmMgbW9kZSwgYmVjYXVzZSB0aGlzIGNhbiB0cmlnZ2VyXG4vLyBhbm90aGVyIHJlYWQoKSBjYWxsID0+IHN0YWNrIG92ZXJmbG93LiAgVGhpcyB3YXksIGl0IG1pZ2h0IHRyaWdnZXJcbi8vIGEgbmV4dFRpY2sgcmVjdXJzaW9uIHdhcm5pbmcsIGJ1dCB0aGF0J3Mgbm90IHNvIGJhZC5cbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZShzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBzdGF0ZS5uZWVkUmVhZGFibGUgPSBmYWxzZTtcbiAgaWYgKCFzdGF0ZS5lbWl0dGVkUmVhZGFibGUpIHtcbiAgICBkZWJ1ZygnZW1pdFJlYWRhYmxlJywgc3RhdGUuZmxvd2luZyk7XG4gICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICBpZiAoc3RhdGUuc3luYykgcG5hLm5leHRUaWNrKGVtaXRSZWFkYWJsZV8sIHN0cmVhbSk7ZWxzZSBlbWl0UmVhZGFibGVfKHN0cmVhbSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW1pdFJlYWRhYmxlXyhzdHJlYW0pIHtcbiAgZGVidWcoJ2VtaXQgcmVhZGFibGUnKTtcbiAgc3RyZWFtLmVtaXQoJ3JlYWRhYmxlJyk7XG4gIGZsb3coc3RyZWFtKTtcbn1cblxuLy8gYXQgdGhpcyBwb2ludCwgdGhlIHVzZXIgaGFzIHByZXN1bWFibHkgc2VlbiB0aGUgJ3JlYWRhYmxlJyBldmVudCxcbi8vIGFuZCBjYWxsZWQgcmVhZCgpIHRvIGNvbnN1bWUgc29tZSBkYXRhLiAgdGhhdCBtYXkgaGF2ZSB0cmlnZ2VyZWRcbi8vIGluIHR1cm4gYW5vdGhlciBfcmVhZChuKSBjYWxsLCBpbiB3aGljaCBjYXNlIHJlYWRpbmcgPSB0cnVlIGlmXG4vLyBpdCdzIGluIHByb2dyZXNzLlxuLy8gSG93ZXZlciwgaWYgd2UncmUgbm90IGVuZGVkLCBvciByZWFkaW5nLCBhbmQgdGhlIGxlbmd0aCA8IGh3bSxcbi8vIHRoZW4gZ28gYWhlYWQgYW5kIHRyeSB0byByZWFkIHNvbWUgbW9yZSBwcmVlbXB0aXZlbHkuXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZWFkaW5nTW9yZSkge1xuICAgIHN0YXRlLnJlYWRpbmdNb3JlID0gdHJ1ZTtcbiAgICBwbmEubmV4dFRpY2sobWF5YmVSZWFkTW9yZV8sIHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1heWJlUmVhZE1vcmVfKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIGxlbiA9IHN0YXRlLmxlbmd0aDtcbiAgd2hpbGUgKCFzdGF0ZS5yZWFkaW5nICYmICFzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5lbmRlZCAmJiBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgZGVidWcoJ21heWJlUmVhZE1vcmUgcmVhZCAwJyk7XG4gICAgc3RyZWFtLnJlYWQoMCk7XG4gICAgaWYgKGxlbiA9PT0gc3RhdGUubGVuZ3RoKVxuICAgICAgLy8gZGlkbid0IGdldCBhbnkgZGF0YSwgc3RvcCBzcGlubmluZy5cbiAgICAgIGJyZWFrO2Vsc2UgbGVuID0gc3RhdGUubGVuZ3RoO1xuICB9XG4gIHN0YXRlLnJlYWRpbmdNb3JlID0gZmFsc2U7XG59XG5cbi8vIGFic3RyYWN0IG1ldGhvZC4gIHRvIGJlIG92ZXJyaWRkZW4gaW4gc3BlY2lmaWMgaW1wbGVtZW50YXRpb24gY2xhc3Nlcy5cbi8vIGNhbGwgY2IoZXIsIGRhdGEpIHdoZXJlIGRhdGEgaXMgPD0gbiBpbiBsZW5ndGguXG4vLyBmb3IgdmlydHVhbCAobm9uLXN0cmluZywgbm9uLWJ1ZmZlcikgc3RyZWFtcywgXCJsZW5ndGhcIiBpcyBzb21ld2hhdFxuLy8gYXJiaXRyYXJ5LCBhbmQgcGVyaGFwcyBub3QgdmVyeSBtZWFuaW5nZnVsLlxuUmVhZGFibGUucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignX3JlYWQoKSBpcyBub3QgaW1wbGVtZW50ZWQnKSk7XG59O1xuXG5SZWFkYWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uIChkZXN0LCBwaXBlT3B0cykge1xuICB2YXIgc3JjID0gdGhpcztcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcblxuICBzd2l0Y2ggKHN0YXRlLnBpcGVzQ291bnQpIHtcbiAgICBjYXNlIDA6XG4gICAgICBzdGF0ZS5waXBlcyA9IGRlc3Q7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDE6XG4gICAgICBzdGF0ZS5waXBlcyA9IFtzdGF0ZS5waXBlcywgZGVzdF07XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgc3RhdGUucGlwZXMucHVzaChkZXN0KTtcbiAgICAgIGJyZWFrO1xuICB9XG4gIHN0YXRlLnBpcGVzQ291bnQgKz0gMTtcbiAgZGVidWcoJ3BpcGUgY291bnQ9JWQgb3B0cz0laicsIHN0YXRlLnBpcGVzQ291bnQsIHBpcGVPcHRzKTtcblxuICB2YXIgZG9FbmQgPSAoIXBpcGVPcHRzIHx8IHBpcGVPcHRzLmVuZCAhPT0gZmFsc2UpICYmIGRlc3QgIT09IHByb2Nlc3Muc3Rkb3V0ICYmIGRlc3QgIT09IHByb2Nlc3Muc3RkZXJyO1xuXG4gIHZhciBlbmRGbiA9IGRvRW5kID8gb25lbmQgOiB1bnBpcGU7XG4gIGlmIChzdGF0ZS5lbmRFbWl0dGVkKSBwbmEubmV4dFRpY2soZW5kRm4pO2Vsc2Ugc3JjLm9uY2UoJ2VuZCcsIGVuZEZuKTtcblxuICBkZXN0Lm9uKCd1bnBpcGUnLCBvbnVucGlwZSk7XG4gIGZ1bmN0aW9uIG9udW5waXBlKHJlYWRhYmxlLCB1bnBpcGVJbmZvKSB7XG4gICAgZGVidWcoJ29udW5waXBlJyk7XG4gICAgaWYgKHJlYWRhYmxlID09PSBzcmMpIHtcbiAgICAgIGlmICh1bnBpcGVJbmZvICYmIHVucGlwZUluZm8uaGFzVW5waXBlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgdW5waXBlSW5mby5oYXNVbnBpcGVkID0gdHJ1ZTtcbiAgICAgICAgY2xlYW51cCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uZW5kKCkge1xuICAgIGRlYnVnKCdvbmVuZCcpO1xuICAgIGRlc3QuZW5kKCk7XG4gIH1cblxuICAvLyB3aGVuIHRoZSBkZXN0IGRyYWlucywgaXQgcmVkdWNlcyB0aGUgYXdhaXREcmFpbiBjb3VudGVyXG4gIC8vIG9uIHRoZSBzb3VyY2UuICBUaGlzIHdvdWxkIGJlIG1vcmUgZWxlZ2FudCB3aXRoIGEgLm9uY2UoKVxuICAvLyBoYW5kbGVyIGluIGZsb3coKSwgYnV0IGFkZGluZyBhbmQgcmVtb3ZpbmcgcmVwZWF0ZWRseSBpc1xuICAvLyB0b28gc2xvdy5cbiAgdmFyIG9uZHJhaW4gPSBwaXBlT25EcmFpbihzcmMpO1xuICBkZXN0Lm9uKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gIHZhciBjbGVhbmVkVXAgPSBmYWxzZTtcbiAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICBkZWJ1ZygnY2xlYW51cCcpO1xuICAgIC8vIGNsZWFudXAgZXZlbnQgaGFuZGxlcnMgb25jZSB0aGUgcGlwZSBpcyBicm9rZW5cbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIG9uZHJhaW4pO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcigndW5waXBlJywgb251bnBpcGUpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgdW5waXBlKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbmRhdGEpO1xuXG4gICAgY2xlYW5lZFVwID0gdHJ1ZTtcblxuICAgIC8vIGlmIHRoZSByZWFkZXIgaXMgd2FpdGluZyBmb3IgYSBkcmFpbiBldmVudCBmcm9tIHRoaXNcbiAgICAvLyBzcGVjaWZpYyB3cml0ZXIsIHRoZW4gaXQgd291bGQgY2F1c2UgaXQgdG8gbmV2ZXIgc3RhcnRcbiAgICAvLyBmbG93aW5nIGFnYWluLlxuICAgIC8vIFNvLCBpZiB0aGlzIGlzIGF3YWl0aW5nIGEgZHJhaW4sIHRoZW4gd2UganVzdCBjYWxsIGl0IG5vdy5cbiAgICAvLyBJZiB3ZSBkb24ndCBrbm93LCB0aGVuIGFzc3VtZSB0aGF0IHdlIGFyZSB3YWl0aW5nIGZvciBvbmUuXG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4gJiYgKCFkZXN0Ll93cml0YWJsZVN0YXRlIHx8IGRlc3QuX3dyaXRhYmxlU3RhdGUubmVlZERyYWluKSkgb25kcmFpbigpO1xuICB9XG5cbiAgLy8gSWYgdGhlIHVzZXIgcHVzaGVzIG1vcmUgZGF0YSB3aGlsZSB3ZSdyZSB3cml0aW5nIHRvIGRlc3QgdGhlbiB3ZSdsbCBlbmQgdXBcbiAgLy8gaW4gb25kYXRhIGFnYWluLiBIb3dldmVyLCB3ZSBvbmx5IHdhbnQgdG8gaW5jcmVhc2UgYXdhaXREcmFpbiBvbmNlIGJlY2F1c2VcbiAgLy8gZGVzdCB3aWxsIG9ubHkgZW1pdCBvbmUgJ2RyYWluJyBldmVudCBmb3IgdGhlIG11bHRpcGxlIHdyaXRlcy5cbiAgLy8gPT4gSW50cm9kdWNlIGEgZ3VhcmQgb24gaW5jcmVhc2luZyBhd2FpdERyYWluLlxuICB2YXIgaW5jcmVhc2VkQXdhaXREcmFpbiA9IGZhbHNlO1xuICBzcmMub24oJ2RhdGEnLCBvbmRhdGEpO1xuICBmdW5jdGlvbiBvbmRhdGEoY2h1bmspIHtcbiAgICBkZWJ1Zygnb25kYXRhJyk7XG4gICAgaW5jcmVhc2VkQXdhaXREcmFpbiA9IGZhbHNlO1xuICAgIHZhciByZXQgPSBkZXN0LndyaXRlKGNodW5rKTtcbiAgICBpZiAoZmFsc2UgPT09IHJldCAmJiAhaW5jcmVhc2VkQXdhaXREcmFpbikge1xuICAgICAgLy8gSWYgdGhlIHVzZXIgdW5waXBlZCBkdXJpbmcgYGRlc3Qud3JpdGUoKWAsIGl0IGlzIHBvc3NpYmxlXG4gICAgICAvLyB0byBnZXQgc3R1Y2sgaW4gYSBwZXJtYW5lbnRseSBwYXVzZWQgc3RhdGUgaWYgdGhhdCB3cml0ZVxuICAgICAgLy8gYWxzbyByZXR1cm5lZCBmYWxzZS5cbiAgICAgIC8vID0+IENoZWNrIHdoZXRoZXIgYGRlc3RgIGlzIHN0aWxsIGEgcGlwaW5nIGRlc3RpbmF0aW9uLlxuICAgICAgaWYgKChzdGF0ZS5waXBlc0NvdW50ID09PSAxICYmIHN0YXRlLnBpcGVzID09PSBkZXN0IHx8IHN0YXRlLnBpcGVzQ291bnQgPiAxICYmIGluZGV4T2Yoc3RhdGUucGlwZXMsIGRlc3QpICE9PSAtMSkgJiYgIWNsZWFuZWRVcCkge1xuICAgICAgICBkZWJ1ZygnZmFsc2Ugd3JpdGUgcmVzcG9uc2UsIHBhdXNlJywgc3JjLl9yZWFkYWJsZVN0YXRlLmF3YWl0RHJhaW4pO1xuICAgICAgICBzcmMuX3JlYWRhYmxlU3RhdGUuYXdhaXREcmFpbisrO1xuICAgICAgICBpbmNyZWFzZWRBd2FpdERyYWluID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHNyYy5wYXVzZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZSBkZXN0IGhhcyBhbiBlcnJvciwgdGhlbiBzdG9wIHBpcGluZyBpbnRvIGl0LlxuICAvLyBob3dldmVyLCBkb24ndCBzdXBwcmVzcyB0aGUgdGhyb3dpbmcgYmVoYXZpb3IgZm9yIHRoaXMuXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHtcbiAgICBkZWJ1Zygnb25lcnJvcicsIGVyKTtcbiAgICB1bnBpcGUoKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGlmIChFRWxpc3RlbmVyQ291bnQoZGVzdCwgJ2Vycm9yJykgPT09IDApIGRlc3QuZW1pdCgnZXJyb3InLCBlcik7XG4gIH1cblxuICAvLyBNYWtlIHN1cmUgb3VyIGVycm9yIGhhbmRsZXIgaXMgYXR0YWNoZWQgYmVmb3JlIHVzZXJsYW5kIG9uZXMuXG4gIHByZXBlbmRMaXN0ZW5lcihkZXN0LCAnZXJyb3InLCBvbmVycm9yKTtcblxuICAvLyBCb3RoIGNsb3NlIGFuZCBmaW5pc2ggc2hvdWxkIHRyaWdnZXIgdW5waXBlLCBidXQgb25seSBvbmNlLlxuICBmdW5jdGlvbiBvbmNsb3NlKCkge1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICB1bnBpcGUoKTtcbiAgfVxuICBkZXN0Lm9uY2UoJ2Nsb3NlJywgb25jbG9zZSk7XG4gIGZ1bmN0aW9uIG9uZmluaXNoKCkge1xuICAgIGRlYnVnKCdvbmZpbmlzaCcpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgdW5waXBlKCk7XG4gIH1cbiAgZGVzdC5vbmNlKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG5cbiAgZnVuY3Rpb24gdW5waXBlKCkge1xuICAgIGRlYnVnKCd1bnBpcGUnKTtcbiAgICBzcmMudW5waXBlKGRlc3QpO1xuICB9XG5cbiAgLy8gdGVsbCB0aGUgZGVzdCB0aGF0IGl0J3MgYmVpbmcgcGlwZWQgdG9cbiAgZGVzdC5lbWl0KCdwaXBlJywgc3JjKTtcblxuICAvLyBzdGFydCB0aGUgZmxvdyBpZiBpdCBoYXNuJ3QgYmVlbiBzdGFydGVkIGFscmVhZHkuXG4gIGlmICghc3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdwaXBlIHJlc3VtZScpO1xuICAgIHNyYy5yZXN1bWUoKTtcbiAgfVxuXG4gIHJldHVybiBkZXN0O1xufTtcblxuZnVuY3Rpb24gcGlwZU9uRHJhaW4oc3JjKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHN0YXRlID0gc3JjLl9yZWFkYWJsZVN0YXRlO1xuICAgIGRlYnVnKCdwaXBlT25EcmFpbicsIHN0YXRlLmF3YWl0RHJhaW4pO1xuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluKSBzdGF0ZS5hd2FpdERyYWluLS07XG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4gPT09IDAgJiYgRUVsaXN0ZW5lckNvdW50KHNyYywgJ2RhdGEnKSkge1xuICAgICAgc3RhdGUuZmxvd2luZyA9IHRydWU7XG4gICAgICBmbG93KHNyYyk7XG4gICAgfVxuICB9O1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUudW5waXBlID0gZnVuY3Rpb24gKGRlc3QpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHVucGlwZUluZm8gPSB7IGhhc1VucGlwZWQ6IGZhbHNlIH07XG5cbiAgLy8gaWYgd2UncmUgbm90IHBpcGluZyBhbnl3aGVyZSwgdGhlbiBkbyBub3RoaW5nLlxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMCkgcmV0dXJuIHRoaXM7XG5cbiAgLy8ganVzdCBvbmUgZGVzdGluYXRpb24uICBtb3N0IGNvbW1vbiBjYXNlLlxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSkge1xuICAgIC8vIHBhc3NlZCBpbiBvbmUsIGJ1dCBpdCdzIG5vdCB0aGUgcmlnaHQgb25lLlxuICAgIGlmIChkZXN0ICYmIGRlc3QgIT09IHN0YXRlLnBpcGVzKSByZXR1cm4gdGhpcztcblxuICAgIGlmICghZGVzdCkgZGVzdCA9IHN0YXRlLnBpcGVzO1xuXG4gICAgLy8gZ290IGEgbWF0Y2guXG4gICAgc3RhdGUucGlwZXMgPSBudWxsO1xuICAgIHN0YXRlLnBpcGVzQ291bnQgPSAwO1xuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcbiAgICBpZiAoZGVzdCkgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzLCB1bnBpcGVJbmZvKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHNsb3cgY2FzZS4gbXVsdGlwbGUgcGlwZSBkZXN0aW5hdGlvbnMuXG5cbiAgaWYgKCFkZXN0KSB7XG4gICAgLy8gcmVtb3ZlIGFsbC5cbiAgICB2YXIgZGVzdHMgPSBzdGF0ZS5waXBlcztcbiAgICB2YXIgbGVuID0gc3RhdGUucGlwZXNDb3VudDtcbiAgICBzdGF0ZS5waXBlcyA9IG51bGw7XG4gICAgc3RhdGUucGlwZXNDb3VudCA9IDA7XG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgZGVzdHNbaV0uZW1pdCgndW5waXBlJywgdGhpcywgdW5waXBlSW5mbyk7XG4gICAgfXJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gdHJ5IHRvIGZpbmQgdGhlIHJpZ2h0IG9uZS5cbiAgdmFyIGluZGV4ID0gaW5kZXhPZihzdGF0ZS5waXBlcywgZGVzdCk7XG4gIGlmIChpbmRleCA9PT0gLTEpIHJldHVybiB0aGlzO1xuXG4gIHN0YXRlLnBpcGVzLnNwbGljZShpbmRleCwgMSk7XG4gIHN0YXRlLnBpcGVzQ291bnQgLT0gMTtcbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpIHN0YXRlLnBpcGVzID0gc3RhdGUucGlwZXNbMF07XG5cbiAgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzLCB1bnBpcGVJbmZvKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIHNldCB1cCBkYXRhIGV2ZW50cyBpZiB0aGV5IGFyZSBhc2tlZCBmb3Jcbi8vIEVuc3VyZSByZWFkYWJsZSBsaXN0ZW5lcnMgZXZlbnR1YWxseSBnZXQgc29tZXRoaW5nXG5SZWFkYWJsZS5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoZXYsIGZuKSB7XG4gIHZhciByZXMgPSBTdHJlYW0ucHJvdG90eXBlLm9uLmNhbGwodGhpcywgZXYsIGZuKTtcblxuICBpZiAoZXYgPT09ICdkYXRhJykge1xuICAgIC8vIFN0YXJ0IGZsb3dpbmcgb24gbmV4dCB0aWNrIGlmIHN0cmVhbSBpc24ndCBleHBsaWNpdGx5IHBhdXNlZFxuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgIT09IGZhbHNlKSB0aGlzLnJlc3VtZSgpO1xuICB9IGVsc2UgaWYgKGV2ID09PSAncmVhZGFibGUnKSB7XG4gICAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQgJiYgIXN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nKSB7XG4gICAgICBzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZyA9IHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgICAgIGlmICghc3RhdGUucmVhZGluZykge1xuICAgICAgICBwbmEubmV4dFRpY2soblJlYWRpbmdOZXh0VGljaywgdGhpcyk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmxlbmd0aCkge1xuICAgICAgICBlbWl0UmVhZGFibGUodGhpcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlcztcbn07XG5SZWFkYWJsZS5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBSZWFkYWJsZS5wcm90b3R5cGUub247XG5cbmZ1bmN0aW9uIG5SZWFkaW5nTmV4dFRpY2soc2VsZikge1xuICBkZWJ1ZygncmVhZGFibGUgbmV4dHRpY2sgcmVhZCAwJyk7XG4gIHNlbGYucmVhZCgwKTtcbn1cblxuLy8gcGF1c2UoKSBhbmQgcmVzdW1lKCkgYXJlIHJlbW5hbnRzIG9mIHRoZSBsZWdhY3kgcmVhZGFibGUgc3RyZWFtIEFQSVxuLy8gSWYgdGhlIHVzZXIgdXNlcyB0aGVtLCB0aGVuIHN3aXRjaCBpbnRvIG9sZCBtb2RlLlxuUmVhZGFibGUucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgaWYgKCFzdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3Jlc3VtZScpO1xuICAgIHN0YXRlLmZsb3dpbmcgPSB0cnVlO1xuICAgIHJlc3VtZSh0aGlzLCBzdGF0ZSk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiByZXN1bWUoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlc3VtZVNjaGVkdWxlZCkge1xuICAgIHN0YXRlLnJlc3VtZVNjaGVkdWxlZCA9IHRydWU7XG4gICAgcG5hLm5leHRUaWNrKHJlc3VtZV8sIHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc3VtZV8oc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlYWRpbmcpIHtcbiAgICBkZWJ1ZygncmVzdW1lIHJlYWQgMCcpO1xuICAgIHN0cmVhbS5yZWFkKDApO1xuICB9XG5cbiAgc3RhdGUucmVzdW1lU2NoZWR1bGVkID0gZmFsc2U7XG4gIHN0YXRlLmF3YWl0RHJhaW4gPSAwO1xuICBzdHJlYW0uZW1pdCgncmVzdW1lJyk7XG4gIGZsb3coc3RyZWFtKTtcbiAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgIXN0YXRlLnJlYWRpbmcpIHN0cmVhbS5yZWFkKDApO1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAoKSB7XG4gIGRlYnVnKCdjYWxsIHBhdXNlIGZsb3dpbmc9JWonLCB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcpO1xuICBpZiAoZmFsc2UgIT09IHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdwYXVzZScpO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuICAgIHRoaXMuZW1pdCgncGF1c2UnKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIGZsb3coc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgZGVidWcoJ2Zsb3cnLCBzdGF0ZS5mbG93aW5nKTtcbiAgd2hpbGUgKHN0YXRlLmZsb3dpbmcgJiYgc3RyZWFtLnJlYWQoKSAhPT0gbnVsbCkge31cbn1cblxuLy8gd3JhcCBhbiBvbGQtc3R5bGUgc3RyZWFtIGFzIHRoZSBhc3luYyBkYXRhIHNvdXJjZS5cbi8vIFRoaXMgaXMgKm5vdCogcGFydCBvZiB0aGUgcmVhZGFibGUgc3RyZWFtIGludGVyZmFjZS5cbi8vIEl0IGlzIGFuIHVnbHkgdW5mb3J0dW5hdGUgbWVzcyBvZiBoaXN0b3J5LlxuUmVhZGFibGUucHJvdG90eXBlLndyYXAgPSBmdW5jdGlvbiAoc3RyZWFtKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHBhdXNlZCA9IGZhbHNlO1xuXG4gIHN0cmVhbS5vbignZW5kJywgZnVuY3Rpb24gKCkge1xuICAgIGRlYnVnKCd3cmFwcGVkIGVuZCcpO1xuICAgIGlmIChzdGF0ZS5kZWNvZGVyICYmICFzdGF0ZS5lbmRlZCkge1xuICAgICAgdmFyIGNodW5rID0gc3RhdGUuZGVjb2Rlci5lbmQoKTtcbiAgICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpIF90aGlzLnB1c2goY2h1bmspO1xuICAgIH1cblxuICAgIF90aGlzLnB1c2gobnVsbCk7XG4gIH0pO1xuXG4gIHN0cmVhbS5vbignZGF0YScsIGZ1bmN0aW9uIChjaHVuaykge1xuICAgIGRlYnVnKCd3cmFwcGVkIGRhdGEnKTtcbiAgICBpZiAoc3RhdGUuZGVjb2RlcikgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKTtcblxuICAgIC8vIGRvbid0IHNraXAgb3ZlciBmYWxzeSB2YWx1ZXMgaW4gb2JqZWN0TW9kZVxuICAgIGlmIChzdGF0ZS5vYmplY3RNb2RlICYmIChjaHVuayA9PT0gbnVsbCB8fCBjaHVuayA9PT0gdW5kZWZpbmVkKSkgcmV0dXJuO2Vsc2UgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmICghY2h1bmsgfHwgIWNodW5rLmxlbmd0aCkpIHJldHVybjtcblxuICAgIHZhciByZXQgPSBfdGhpcy5wdXNoKGNodW5rKTtcbiAgICBpZiAoIXJldCkge1xuICAgICAgcGF1c2VkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5wYXVzZSgpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gcHJveHkgYWxsIHRoZSBvdGhlciBtZXRob2RzLlxuICAvLyBpbXBvcnRhbnQgd2hlbiB3cmFwcGluZyBmaWx0ZXJzIGFuZCBkdXBsZXhlcy5cbiAgZm9yICh2YXIgaSBpbiBzdHJlYW0pIHtcbiAgICBpZiAodGhpc1tpXSA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBzdHJlYW1baV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXNbaV0gPSBmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHN0cmVhbVttZXRob2RdLmFwcGx5KHN0cmVhbSwgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICAgIH0oaSk7XG4gICAgfVxuICB9XG5cbiAgLy8gcHJveHkgY2VydGFpbiBpbXBvcnRhbnQgZXZlbnRzLlxuICBmb3IgKHZhciBuID0gMDsgbiA8IGtQcm94eUV2ZW50cy5sZW5ndGg7IG4rKykge1xuICAgIHN0cmVhbS5vbihrUHJveHlFdmVudHNbbl0sIHRoaXMuZW1pdC5iaW5kKHRoaXMsIGtQcm94eUV2ZW50c1tuXSkpO1xuICB9XG5cbiAgLy8gd2hlbiB3ZSB0cnkgdG8gY29uc3VtZSBzb21lIG1vcmUgYnl0ZXMsIHNpbXBseSB1bnBhdXNlIHRoZVxuICAvLyB1bmRlcmx5aW5nIHN0cmVhbS5cbiAgdGhpcy5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgX3JlYWQnLCBuKTtcbiAgICBpZiAocGF1c2VkKSB7XG4gICAgICBwYXVzZWQgPSBmYWxzZTtcbiAgICAgIHN0cmVhbS5yZXN1bWUoKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGUucHJvdG90eXBlLCAncmVhZGFibGVIaWdoV2F0ZXJNYXJrJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICB9XG59KTtcblxuLy8gZXhwb3NlZCBmb3IgdGVzdGluZyBwdXJwb3NlcyBvbmx5LlxuUmVhZGFibGUuX2Zyb21MaXN0ID0gZnJvbUxpc3Q7XG5cbi8vIFBsdWNrIG9mZiBuIGJ5dGVzIGZyb20gYW4gYXJyYXkgb2YgYnVmZmVycy5cbi8vIExlbmd0aCBpcyB0aGUgY29tYmluZWQgbGVuZ3RocyBvZiBhbGwgdGhlIGJ1ZmZlcnMgaW4gdGhlIGxpc3QuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGZyb21MaXN0KG4sIHN0YXRlKSB7XG4gIC8vIG5vdGhpbmcgYnVmZmVyZWRcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgcmV0dXJuIG51bGw7XG5cbiAgdmFyIHJldDtcbiAgaWYgKHN0YXRlLm9iamVjdE1vZGUpIHJldCA9IHN0YXRlLmJ1ZmZlci5zaGlmdCgpO2Vsc2UgaWYgKCFuIHx8IG4gPj0gc3RhdGUubGVuZ3RoKSB7XG4gICAgLy8gcmVhZCBpdCBhbGwsIHRydW5jYXRlIHRoZSBsaXN0XG4gICAgaWYgKHN0YXRlLmRlY29kZXIpIHJldCA9IHN0YXRlLmJ1ZmZlci5qb2luKCcnKTtlbHNlIGlmIChzdGF0ZS5idWZmZXIubGVuZ3RoID09PSAxKSByZXQgPSBzdGF0ZS5idWZmZXIuaGVhZC5kYXRhO2Vsc2UgcmV0ID0gc3RhdGUuYnVmZmVyLmNvbmNhdChzdGF0ZS5sZW5ndGgpO1xuICAgIHN0YXRlLmJ1ZmZlci5jbGVhcigpO1xuICB9IGVsc2Uge1xuICAgIC8vIHJlYWQgcGFydCBvZiBsaXN0XG4gICAgcmV0ID0gZnJvbUxpc3RQYXJ0aWFsKG4sIHN0YXRlLmJ1ZmZlciwgc3RhdGUuZGVjb2Rlcik7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG4vLyBFeHRyYWN0cyBvbmx5IGVub3VnaCBidWZmZXJlZCBkYXRhIHRvIHNhdGlzZnkgdGhlIGFtb3VudCByZXF1ZXN0ZWQuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGZyb21MaXN0UGFydGlhbChuLCBsaXN0LCBoYXNTdHJpbmdzKSB7XG4gIHZhciByZXQ7XG4gIGlmIChuIDwgbGlzdC5oZWFkLmRhdGEubGVuZ3RoKSB7XG4gICAgLy8gc2xpY2UgaXMgdGhlIHNhbWUgZm9yIGJ1ZmZlcnMgYW5kIHN0cmluZ3NcbiAgICByZXQgPSBsaXN0LmhlYWQuZGF0YS5zbGljZSgwLCBuKTtcbiAgICBsaXN0LmhlYWQuZGF0YSA9IGxpc3QuaGVhZC5kYXRhLnNsaWNlKG4pO1xuICB9IGVsc2UgaWYgKG4gPT09IGxpc3QuaGVhZC5kYXRhLmxlbmd0aCkge1xuICAgIC8vIGZpcnN0IGNodW5rIGlzIGEgcGVyZmVjdCBtYXRjaFxuICAgIHJldCA9IGxpc3Quc2hpZnQoKTtcbiAgfSBlbHNlIHtcbiAgICAvLyByZXN1bHQgc3BhbnMgbW9yZSB0aGFuIG9uZSBidWZmZXJcbiAgICByZXQgPSBoYXNTdHJpbmdzID8gY29weUZyb21CdWZmZXJTdHJpbmcobiwgbGlzdCkgOiBjb3B5RnJvbUJ1ZmZlcihuLCBsaXN0KTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG4vLyBDb3BpZXMgYSBzcGVjaWZpZWQgYW1vdW50IG9mIGNoYXJhY3RlcnMgZnJvbSB0aGUgbGlzdCBvZiBidWZmZXJlZCBkYXRhXG4vLyBjaHVua3MuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGNvcHlGcm9tQnVmZmVyU3RyaW5nKG4sIGxpc3QpIHtcbiAgdmFyIHAgPSBsaXN0LmhlYWQ7XG4gIHZhciBjID0gMTtcbiAgdmFyIHJldCA9IHAuZGF0YTtcbiAgbiAtPSByZXQubGVuZ3RoO1xuICB3aGlsZSAocCA9IHAubmV4dCkge1xuICAgIHZhciBzdHIgPSBwLmRhdGE7XG4gICAgdmFyIG5iID0gbiA+IHN0ci5sZW5ndGggPyBzdHIubGVuZ3RoIDogbjtcbiAgICBpZiAobmIgPT09IHN0ci5sZW5ndGgpIHJldCArPSBzdHI7ZWxzZSByZXQgKz0gc3RyLnNsaWNlKDAsIG4pO1xuICAgIG4gLT0gbmI7XG4gICAgaWYgKG4gPT09IDApIHtcbiAgICAgIGlmIChuYiA9PT0gc3RyLmxlbmd0aCkge1xuICAgICAgICArK2M7XG4gICAgICAgIGlmIChwLm5leHQpIGxpc3QuaGVhZCA9IHAubmV4dDtlbHNlIGxpc3QuaGVhZCA9IGxpc3QudGFpbCA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaXN0LmhlYWQgPSBwO1xuICAgICAgICBwLmRhdGEgPSBzdHIuc2xpY2UobmIpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgICsrYztcbiAgfVxuICBsaXN0Lmxlbmd0aCAtPSBjO1xuICByZXR1cm4gcmV0O1xufVxuXG4vLyBDb3BpZXMgYSBzcGVjaWZpZWQgYW1vdW50IG9mIGJ5dGVzIGZyb20gdGhlIGxpc3Qgb2YgYnVmZmVyZWQgZGF0YSBjaHVua3MuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGNvcHlGcm9tQnVmZmVyKG4sIGxpc3QpIHtcbiAgdmFyIHJldCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuKTtcbiAgdmFyIHAgPSBsaXN0LmhlYWQ7XG4gIHZhciBjID0gMTtcbiAgcC5kYXRhLmNvcHkocmV0KTtcbiAgbiAtPSBwLmRhdGEubGVuZ3RoO1xuICB3aGlsZSAocCA9IHAubmV4dCkge1xuICAgIHZhciBidWYgPSBwLmRhdGE7XG4gICAgdmFyIG5iID0gbiA+IGJ1Zi5sZW5ndGggPyBidWYubGVuZ3RoIDogbjtcbiAgICBidWYuY29weShyZXQsIHJldC5sZW5ndGggLSBuLCAwLCBuYik7XG4gICAgbiAtPSBuYjtcbiAgICBpZiAobiA9PT0gMCkge1xuICAgICAgaWYgKG5iID09PSBidWYubGVuZ3RoKSB7XG4gICAgICAgICsrYztcbiAgICAgICAgaWYgKHAubmV4dCkgbGlzdC5oZWFkID0gcC5uZXh0O2Vsc2UgbGlzdC5oZWFkID0gbGlzdC50YWlsID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpc3QuaGVhZCA9IHA7XG4gICAgICAgIHAuZGF0YSA9IGJ1Zi5zbGljZShuYik7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgKytjO1xuICB9XG4gIGxpc3QubGVuZ3RoIC09IGM7XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGVuZFJlYWRhYmxlKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG5cbiAgLy8gSWYgd2UgZ2V0IGhlcmUgYmVmb3JlIGNvbnN1bWluZyBhbGwgdGhlIGJ5dGVzLCB0aGVuIHRoYXQgaXMgYVxuICAvLyBidWcgaW4gbm9kZS4gIFNob3VsZCBuZXZlciBoYXBwZW4uXG4gIGlmIChzdGF0ZS5sZW5ndGggPiAwKSB0aHJvdyBuZXcgRXJyb3IoJ1wiZW5kUmVhZGFibGUoKVwiIGNhbGxlZCBvbiBub24tZW1wdHkgc3RyZWFtJyk7XG5cbiAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkKSB7XG4gICAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuICAgIHBuYS5uZXh0VGljayhlbmRSZWFkYWJsZU5ULCBzdGF0ZSwgc3RyZWFtKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbmRSZWFkYWJsZU5UKHN0YXRlLCBzdHJlYW0pIHtcbiAgLy8gQ2hlY2sgdGhhdCB3ZSBkaWRuJ3QgZ2V0IG9uZSBsYXN0IHVuc2hpZnQuXG4gIGlmICghc3RhdGUuZW5kRW1pdHRlZCAmJiBzdGF0ZS5sZW5ndGggPT09IDApIHtcbiAgICBzdGF0ZS5lbmRFbWl0dGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0ucmVhZGFibGUgPSBmYWxzZTtcbiAgICBzdHJlYW0uZW1pdCgnZW5kJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5kZXhPZih4cywgeCkge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmICh4c1tpXSA9PT0geCkgcmV0dXJuIGk7XG4gIH1cbiAgcmV0dXJuIC0xO1xufSIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBhIHRyYW5zZm9ybSBzdHJlYW0gaXMgYSByZWFkYWJsZS93cml0YWJsZSBzdHJlYW0gd2hlcmUgeW91IGRvXG4vLyBzb21ldGhpbmcgd2l0aCB0aGUgZGF0YS4gIFNvbWV0aW1lcyBpdCdzIGNhbGxlZCBhIFwiZmlsdGVyXCIsXG4vLyBidXQgdGhhdCdzIG5vdCBhIGdyZWF0IG5hbWUgZm9yIGl0LCBzaW5jZSB0aGF0IGltcGxpZXMgYSB0aGluZyB3aGVyZVxuLy8gc29tZSBiaXRzIHBhc3MgdGhyb3VnaCwgYW5kIG90aGVycyBhcmUgc2ltcGx5IGlnbm9yZWQuICAoVGhhdCB3b3VsZFxuLy8gYmUgYSB2YWxpZCBleGFtcGxlIG9mIGEgdHJhbnNmb3JtLCBvZiBjb3Vyc2UuKVxuLy9cbi8vIFdoaWxlIHRoZSBvdXRwdXQgaXMgY2F1c2FsbHkgcmVsYXRlZCB0byB0aGUgaW5wdXQsIGl0J3Mgbm90IGFcbi8vIG5lY2Vzc2FyaWx5IHN5bW1ldHJpYyBvciBzeW5jaHJvbm91cyB0cmFuc2Zvcm1hdGlvbi4gIEZvciBleGFtcGxlLFxuLy8gYSB6bGliIHN0cmVhbSBtaWdodCB0YWtlIG11bHRpcGxlIHBsYWluLXRleHQgd3JpdGVzKCksIGFuZCB0aGVuXG4vLyBlbWl0IGEgc2luZ2xlIGNvbXByZXNzZWQgY2h1bmsgc29tZSB0aW1lIGluIHRoZSBmdXR1cmUuXG4vL1xuLy8gSGVyZSdzIGhvdyB0aGlzIHdvcmtzOlxuLy9cbi8vIFRoZSBUcmFuc2Zvcm0gc3RyZWFtIGhhcyBhbGwgdGhlIGFzcGVjdHMgb2YgdGhlIHJlYWRhYmxlIGFuZCB3cml0YWJsZVxuLy8gc3RyZWFtIGNsYXNzZXMuICBXaGVuIHlvdSB3cml0ZShjaHVuayksIHRoYXQgY2FsbHMgX3dyaXRlKGNodW5rLGNiKVxuLy8gaW50ZXJuYWxseSwgYW5kIHJldHVybnMgZmFsc2UgaWYgdGhlcmUncyBhIGxvdCBvZiBwZW5kaW5nIHdyaXRlc1xuLy8gYnVmZmVyZWQgdXAuICBXaGVuIHlvdSBjYWxsIHJlYWQoKSwgdGhhdCBjYWxscyBfcmVhZChuKSB1bnRpbFxuLy8gdGhlcmUncyBlbm91Z2ggcGVuZGluZyByZWFkYWJsZSBkYXRhIGJ1ZmZlcmVkIHVwLlxuLy9cbi8vIEluIGEgdHJhbnNmb3JtIHN0cmVhbSwgdGhlIHdyaXR0ZW4gZGF0YSBpcyBwbGFjZWQgaW4gYSBidWZmZXIuICBXaGVuXG4vLyBfcmVhZChuKSBpcyBjYWxsZWQsIGl0IHRyYW5zZm9ybXMgdGhlIHF1ZXVlZCB1cCBkYXRhLCBjYWxsaW5nIHRoZVxuLy8gYnVmZmVyZWQgX3dyaXRlIGNiJ3MgYXMgaXQgY29uc3VtZXMgY2h1bmtzLiAgSWYgY29uc3VtaW5nIGEgc2luZ2xlXG4vLyB3cml0dGVuIGNodW5rIHdvdWxkIHJlc3VsdCBpbiBtdWx0aXBsZSBvdXRwdXQgY2h1bmtzLCB0aGVuIHRoZSBmaXJzdFxuLy8gb3V0cHV0dGVkIGJpdCBjYWxscyB0aGUgcmVhZGNiLCBhbmQgc3Vic2VxdWVudCBjaHVua3MganVzdCBnbyBpbnRvXG4vLyB0aGUgcmVhZCBidWZmZXIsIGFuZCB3aWxsIGNhdXNlIGl0IHRvIGVtaXQgJ3JlYWRhYmxlJyBpZiBuZWNlc3NhcnkuXG4vL1xuLy8gVGhpcyB3YXksIGJhY2stcHJlc3N1cmUgaXMgYWN0dWFsbHkgZGV0ZXJtaW5lZCBieSB0aGUgcmVhZGluZyBzaWRlLFxuLy8gc2luY2UgX3JlYWQgaGFzIHRvIGJlIGNhbGxlZCB0byBzdGFydCBwcm9jZXNzaW5nIGEgbmV3IGNodW5rLiAgSG93ZXZlcixcbi8vIGEgcGF0aG9sb2dpY2FsIGluZmxhdGUgdHlwZSBvZiB0cmFuc2Zvcm0gY2FuIGNhdXNlIGV4Y2Vzc2l2ZSBidWZmZXJpbmdcbi8vIGhlcmUuICBGb3IgZXhhbXBsZSwgaW1hZ2luZSBhIHN0cmVhbSB3aGVyZSBldmVyeSBieXRlIG9mIGlucHV0IGlzXG4vLyBpbnRlcnByZXRlZCBhcyBhbiBpbnRlZ2VyIGZyb20gMC0yNTUsIGFuZCB0aGVuIHJlc3VsdHMgaW4gdGhhdCBtYW55XG4vLyBieXRlcyBvZiBvdXRwdXQuICBXcml0aW5nIHRoZSA0IGJ5dGVzIHtmZixmZixmZixmZn0gd291bGQgcmVzdWx0IGluXG4vLyAxa2Igb2YgZGF0YSBiZWluZyBvdXRwdXQuICBJbiB0aGlzIGNhc2UsIHlvdSBjb3VsZCB3cml0ZSBhIHZlcnkgc21hbGxcbi8vIGFtb3VudCBvZiBpbnB1dCwgYW5kIGVuZCB1cCB3aXRoIGEgdmVyeSBsYXJnZSBhbW91bnQgb2Ygb3V0cHV0LiAgSW5cbi8vIHN1Y2ggYSBwYXRob2xvZ2ljYWwgaW5mbGF0aW5nIG1lY2hhbmlzbSwgdGhlcmUnZCBiZSBubyB3YXkgdG8gdGVsbFxuLy8gdGhlIHN5c3RlbSB0byBzdG9wIGRvaW5nIHRoZSB0cmFuc2Zvcm0uICBBIHNpbmdsZSA0TUIgd3JpdGUgY291bGRcbi8vIGNhdXNlIHRoZSBzeXN0ZW0gdG8gcnVuIG91dCBvZiBtZW1vcnkuXG4vL1xuLy8gSG93ZXZlciwgZXZlbiBpbiBzdWNoIGEgcGF0aG9sb2dpY2FsIGNhc2UsIG9ubHkgYSBzaW5nbGUgd3JpdHRlbiBjaHVua1xuLy8gd291bGQgYmUgY29uc3VtZWQsIGFuZCB0aGVuIHRoZSByZXN0IHdvdWxkIHdhaXQgKHVuLXRyYW5zZm9ybWVkKSB1bnRpbFxuLy8gdGhlIHJlc3VsdHMgb2YgdGhlIHByZXZpb3VzIHRyYW5zZm9ybWVkIGNodW5rIHdlcmUgY29uc3VtZWQuXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc2Zvcm07XG5cbnZhciBEdXBsZXggPSByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudXRpbC5pbmhlcml0cyhUcmFuc2Zvcm0sIER1cGxleCk7XG5cbmZ1bmN0aW9uIGFmdGVyVHJhbnNmb3JtKGVyLCBkYXRhKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuICB0cy50cmFuc2Zvcm1pbmcgPSBmYWxzZTtcblxuICB2YXIgY2IgPSB0cy53cml0ZWNiO1xuXG4gIGlmICghY2IpIHtcbiAgICByZXR1cm4gdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignd3JpdGUgY2FsbGJhY2sgY2FsbGVkIG11bHRpcGxlIHRpbWVzJykpO1xuICB9XG5cbiAgdHMud3JpdGVjaHVuayA9IG51bGw7XG4gIHRzLndyaXRlY2IgPSBudWxsO1xuXG4gIGlmIChkYXRhICE9IG51bGwpIC8vIHNpbmdsZSBlcXVhbHMgY2hlY2sgZm9yIGJvdGggYG51bGxgIGFuZCBgdW5kZWZpbmVkYFxuICAgIHRoaXMucHVzaChkYXRhKTtcblxuICBjYihlcik7XG5cbiAgdmFyIHJzID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgcnMucmVhZGluZyA9IGZhbHNlO1xuICBpZiAocnMubmVlZFJlYWRhYmxlIHx8IHJzLmxlbmd0aCA8IHJzLmhpZ2hXYXRlck1hcmspIHtcbiAgICB0aGlzLl9yZWFkKHJzLmhpZ2hXYXRlck1hcmspO1xuICB9XG59XG5cbmZ1bmN0aW9uIFRyYW5zZm9ybShvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBUcmFuc2Zvcm0pKSByZXR1cm4gbmV3IFRyYW5zZm9ybShvcHRpb25zKTtcblxuICBEdXBsZXguY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICB0aGlzLl90cmFuc2Zvcm1TdGF0ZSA9IHtcbiAgICBhZnRlclRyYW5zZm9ybTogYWZ0ZXJUcmFuc2Zvcm0uYmluZCh0aGlzKSxcbiAgICBuZWVkVHJhbnNmb3JtOiBmYWxzZSxcbiAgICB0cmFuc2Zvcm1pbmc6IGZhbHNlLFxuICAgIHdyaXRlY2I6IG51bGwsXG4gICAgd3JpdGVjaHVuazogbnVsbCxcbiAgICB3cml0ZWVuY29kaW5nOiBudWxsXG4gIH07XG5cbiAgLy8gc3RhcnQgb3V0IGFza2luZyBmb3IgYSByZWFkYWJsZSBldmVudCBvbmNlIGRhdGEgaXMgdHJhbnNmb3JtZWQuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcblxuICAvLyB3ZSBoYXZlIGltcGxlbWVudGVkIHRoZSBfcmVhZCBtZXRob2QsIGFuZCBkb25lIHRoZSBvdGhlciB0aGluZ3NcbiAgLy8gdGhhdCBSZWFkYWJsZSB3YW50cyBiZWZvcmUgdGhlIGZpcnN0IF9yZWFkIGNhbGwsIHNvIHVuc2V0IHRoZVxuICAvLyBzeW5jIGd1YXJkIGZsYWcuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuc3luYyA9IGZhbHNlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnRyYW5zZm9ybSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fdHJhbnNmb3JtID0gb3B0aW9ucy50cmFuc2Zvcm07XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZmx1c2ggPT09ICdmdW5jdGlvbicpIHRoaXMuX2ZsdXNoID0gb3B0aW9ucy5mbHVzaDtcbiAgfVxuXG4gIC8vIFdoZW4gdGhlIHdyaXRhYmxlIHNpZGUgZmluaXNoZXMsIHRoZW4gZmx1c2ggb3V0IGFueXRoaW5nIHJlbWFpbmluZy5cbiAgdGhpcy5vbigncHJlZmluaXNoJywgcHJlZmluaXNoKTtcbn1cblxuZnVuY3Rpb24gcHJlZmluaXNoKCkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIGlmICh0eXBlb2YgdGhpcy5fZmx1c2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aGlzLl9mbHVzaChmdW5jdGlvbiAoZXIsIGRhdGEpIHtcbiAgICAgIGRvbmUoX3RoaXMsIGVyLCBkYXRhKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBkb25lKHRoaXMsIG51bGwsIG51bGwpO1xuICB9XG59XG5cblRyYW5zZm9ybS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcpIHtcbiAgdGhpcy5fdHJhbnNmb3JtU3RhdGUubmVlZFRyYW5zZm9ybSA9IGZhbHNlO1xuICByZXR1cm4gRHVwbGV4LnByb3RvdHlwZS5wdXNoLmNhbGwodGhpcywgY2h1bmssIGVuY29kaW5nKTtcbn07XG5cbi8vIFRoaXMgaXMgdGhlIHBhcnQgd2hlcmUgeW91IGRvIHN0dWZmIVxuLy8gb3ZlcnJpZGUgdGhpcyBmdW5jdGlvbiBpbiBpbXBsZW1lbnRhdGlvbiBjbGFzc2VzLlxuLy8gJ2NodW5rJyBpcyBhbiBpbnB1dCBjaHVuay5cbi8vXG4vLyBDYWxsIGBwdXNoKG5ld0NodW5rKWAgdG8gcGFzcyBhbG9uZyB0cmFuc2Zvcm1lZCBvdXRwdXRcbi8vIHRvIHRoZSByZWFkYWJsZSBzaWRlLiAgWW91IG1heSBjYWxsICdwdXNoJyB6ZXJvIG9yIG1vcmUgdGltZXMuXG4vL1xuLy8gQ2FsbCBgY2IoZXJyKWAgd2hlbiB5b3UgYXJlIGRvbmUgd2l0aCB0aGlzIGNodW5rLiAgSWYgeW91IHBhc3Ncbi8vIGFuIGVycm9yLCB0aGVuIHRoYXQnbGwgcHV0IHRoZSBodXJ0IG9uIHRoZSB3aG9sZSBvcGVyYXRpb24uICBJZiB5b3Vcbi8vIG5ldmVyIGNhbGwgY2IoKSwgdGhlbiB5b3UnbGwgbmV2ZXIgZ2V0IGFub3RoZXIgY2h1bmsuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB0aHJvdyBuZXcgRXJyb3IoJ190cmFuc2Zvcm0oKSBpcyBub3QgaW1wbGVtZW50ZWQnKTtcbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG4gIHRzLndyaXRlY2IgPSBjYjtcbiAgdHMud3JpdGVjaHVuayA9IGNodW5rO1xuICB0cy53cml0ZWVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIGlmICghdHMudHJhbnNmb3JtaW5nKSB7XG4gICAgdmFyIHJzID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgICBpZiAodHMubmVlZFRyYW5zZm9ybSB8fCBycy5uZWVkUmVhZGFibGUgfHwgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaykgdGhpcy5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTtcbiAgfVxufTtcblxuLy8gRG9lc24ndCBtYXR0ZXIgd2hhdCB0aGUgYXJncyBhcmUgaGVyZS5cbi8vIF90cmFuc2Zvcm0gZG9lcyBhbGwgdGhlIHdvcmsuXG4vLyBUaGF0IHdlIGdvdCBoZXJlIG1lYW5zIHRoYXQgdGhlIHJlYWRhYmxlIHNpZGUgd2FudHMgbW9yZSBkYXRhLlxuVHJhbnNmb3JtLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuXG4gIGlmICh0cy53cml0ZWNodW5rICE9PSBudWxsICYmIHRzLndyaXRlY2IgJiYgIXRzLnRyYW5zZm9ybWluZykge1xuICAgIHRzLnRyYW5zZm9ybWluZyA9IHRydWU7XG4gICAgdGhpcy5fdHJhbnNmb3JtKHRzLndyaXRlY2h1bmssIHRzLndyaXRlZW5jb2RpbmcsIHRzLmFmdGVyVHJhbnNmb3JtKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBtYXJrIHRoYXQgd2UgbmVlZCBhIHRyYW5zZm9ybSwgc28gdGhhdCBhbnkgZGF0YSB0aGF0IGNvbWVzIGluXG4gICAgLy8gd2lsbCBnZXQgcHJvY2Vzc2VkLCBub3cgdGhhdCB3ZSd2ZSBhc2tlZCBmb3IgaXQuXG4gICAgdHMubmVlZFRyYW5zZm9ybSA9IHRydWU7XG4gIH1cbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICB2YXIgX3RoaXMyID0gdGhpcztcblxuICBEdXBsZXgucHJvdG90eXBlLl9kZXN0cm95LmNhbGwodGhpcywgZXJyLCBmdW5jdGlvbiAoZXJyMikge1xuICAgIGNiKGVycjIpO1xuICAgIF90aGlzMi5lbWl0KCdjbG9zZScpO1xuICB9KTtcbn07XG5cbmZ1bmN0aW9uIGRvbmUoc3RyZWFtLCBlciwgZGF0YSkge1xuICBpZiAoZXIpIHJldHVybiBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG5cbiAgaWYgKGRhdGEgIT0gbnVsbCkgLy8gc2luZ2xlIGVxdWFscyBjaGVjayBmb3IgYm90aCBgbnVsbGAgYW5kIGB1bmRlZmluZWRgXG4gICAgc3RyZWFtLnB1c2goZGF0YSk7XG5cbiAgLy8gaWYgdGhlcmUncyBub3RoaW5nIGluIHRoZSB3cml0ZSBidWZmZXIsIHRoZW4gdGhhdCBtZWFuc1xuICAvLyB0aGF0IG5vdGhpbmcgbW9yZSB3aWxsIGV2ZXIgYmUgcHJvdmlkZWRcbiAgaWYgKHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5sZW5ndGgpIHRocm93IG5ldyBFcnJvcignQ2FsbGluZyB0cmFuc2Zvcm0gZG9uZSB3aGVuIHdzLmxlbmd0aCAhPSAwJyk7XG5cbiAgaWYgKHN0cmVhbS5fdHJhbnNmb3JtU3RhdGUudHJhbnNmb3JtaW5nKSB0aHJvdyBuZXcgRXJyb3IoJ0NhbGxpbmcgdHJhbnNmb3JtIGRvbmUgd2hlbiBzdGlsbCB0cmFuc2Zvcm1pbmcnKTtcblxuICByZXR1cm4gc3RyZWFtLnB1c2gobnVsbCk7XG59IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIEEgYml0IHNpbXBsZXIgdGhhbiByZWFkYWJsZSBzdHJlYW1zLlxuLy8gSW1wbGVtZW50IGFuIGFzeW5jIC5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBjYiksIGFuZCBpdCdsbCBoYW5kbGUgYWxsXG4vLyB0aGUgZHJhaW4gZXZlbnQgZW1pc3Npb24gYW5kIGJ1ZmZlcmluZy5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgcG5hID0gcmVxdWlyZSgncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdyaXRhYmxlO1xuXG4vKiA8cmVwbGFjZW1lbnQ+ICovXG5mdW5jdGlvbiBXcml0ZVJlcShjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHRoaXMuY2h1bmsgPSBjaHVuaztcbiAgdGhpcy5lbmNvZGluZyA9IGVuY29kaW5nO1xuICB0aGlzLmNhbGxiYWNrID0gY2I7XG4gIHRoaXMubmV4dCA9IG51bGw7XG59XG5cbi8vIEl0IHNlZW1zIGEgbGlua2VkIGxpc3QgYnV0IGl0IGlzIG5vdFxuLy8gdGhlcmUgd2lsbCBiZSBvbmx5IDIgb2YgdGhlc2UgZm9yIGVhY2ggc3RyZWFtXG5mdW5jdGlvbiBDb3JrZWRSZXF1ZXN0KHN0YXRlKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdGhpcy5uZXh0ID0gbnVsbDtcbiAgdGhpcy5lbnRyeSA9IG51bGw7XG4gIHRoaXMuZmluaXNoID0gZnVuY3Rpb24gKCkge1xuICAgIG9uQ29ya2VkRmluaXNoKF90aGlzLCBzdGF0ZSk7XG4gIH07XG59XG4vKiA8L3JlcGxhY2VtZW50PiAqL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGFzeW5jV3JpdGUgPSAhcHJvY2Vzcy5icm93c2VyICYmIFsndjAuMTAnLCAndjAuOS4nXS5pbmRleE9mKHByb2Nlc3MudmVyc2lvbi5zbGljZSgwLCA1KSkgPiAtMSA/IHNldEltbWVkaWF0ZSA6IHBuYS5uZXh0VGljaztcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIER1cGxleDtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5Xcml0YWJsZS5Xcml0YWJsZVN0YXRlID0gV3JpdGFibGVTdGF0ZTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGludGVybmFsVXRpbCA9IHtcbiAgZGVwcmVjYXRlOiByZXF1aXJlKCd1dGlsLWRlcHJlY2F0ZScpXG59O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgU3RyZWFtID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL3N0cmVhbScpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlcjtcbnZhciBPdXJVaW50OEFycmF5ID0gZ2xvYmFsLlVpbnQ4QXJyYXkgfHwgZnVuY3Rpb24gKCkge307XG5mdW5jdGlvbiBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShjaHVuayk7XG59XG5mdW5jdGlvbiBfaXNVaW50OEFycmF5KG9iaikge1xuICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKG9iaikgfHwgb2JqIGluc3RhbmNlb2YgT3VyVWludDhBcnJheTtcbn1cblxuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBkZXN0cm95SW1wbCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9kZXN0cm95Jyk7XG5cbnV0aWwuaW5oZXJpdHMoV3JpdGFibGUsIFN0cmVhbSk7XG5cbmZ1bmN0aW9uIG5vcCgpIHt9XG5cbmZ1bmN0aW9uIFdyaXRhYmxlU3RhdGUob3B0aW9ucywgc3RyZWFtKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgLy8gRHVwbGV4IHN0cmVhbXMgYXJlIGJvdGggcmVhZGFibGUgYW5kIHdyaXRhYmxlLCBidXQgc2hhcmVcbiAgLy8gdGhlIHNhbWUgb3B0aW9ucyBvYmplY3QuXG4gIC8vIEhvd2V2ZXIsIHNvbWUgY2FzZXMgcmVxdWlyZSBzZXR0aW5nIG9wdGlvbnMgdG8gZGlmZmVyZW50XG4gIC8vIHZhbHVlcyBmb3IgdGhlIHJlYWRhYmxlIGFuZCB0aGUgd3JpdGFibGUgc2lkZXMgb2YgdGhlIGR1cGxleCBzdHJlYW0uXG4gIC8vIFRoZXNlIG9wdGlvbnMgY2FuIGJlIHByb3ZpZGVkIHNlcGFyYXRlbHkgYXMgcmVhZGFibGVYWFggYW5kIHdyaXRhYmxlWFhYLlxuICB2YXIgaXNEdXBsZXggPSBzdHJlYW0gaW5zdGFuY2VvZiBEdXBsZXg7XG5cbiAgLy8gb2JqZWN0IHN0cmVhbSBmbGFnIHRvIGluZGljYXRlIHdoZXRoZXIgb3Igbm90IHRoaXMgc3RyZWFtXG4gIC8vIGNvbnRhaW5zIGJ1ZmZlcnMgb3Igb2JqZWN0cy5cbiAgdGhpcy5vYmplY3RNb2RlID0gISFvcHRpb25zLm9iamVjdE1vZGU7XG5cbiAgaWYgKGlzRHVwbGV4KSB0aGlzLm9iamVjdE1vZGUgPSB0aGlzLm9iamVjdE1vZGUgfHwgISFvcHRpb25zLndyaXRhYmxlT2JqZWN0TW9kZTtcblxuICAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggd3JpdGUoKSBzdGFydHMgcmV0dXJuaW5nIGZhbHNlXG4gIC8vIE5vdGU6IDAgaXMgYSB2YWxpZCB2YWx1ZSwgbWVhbnMgdGhhdCB3ZSBhbHdheXMgcmV0dXJuIGZhbHNlIGlmXG4gIC8vIHRoZSBlbnRpcmUgYnVmZmVyIGlzIG5vdCBmbHVzaGVkIGltbWVkaWF0ZWx5IG9uIHdyaXRlKClcbiAgdmFyIGh3bSA9IG9wdGlvbnMuaGlnaFdhdGVyTWFyaztcbiAgdmFyIHdyaXRhYmxlSHdtID0gb3B0aW9ucy53cml0YWJsZUhpZ2hXYXRlck1hcms7XG4gIHZhciBkZWZhdWx0SHdtID0gdGhpcy5vYmplY3RNb2RlID8gMTYgOiAxNiAqIDEwMjQ7XG5cbiAgaWYgKGh3bSB8fCBod20gPT09IDApIHRoaXMuaGlnaFdhdGVyTWFyayA9IGh3bTtlbHNlIGlmIChpc0R1cGxleCAmJiAod3JpdGFibGVId20gfHwgd3JpdGFibGVId20gPT09IDApKSB0aGlzLmhpZ2hXYXRlck1hcmsgPSB3cml0YWJsZUh3bTtlbHNlIHRoaXMuaGlnaFdhdGVyTWFyayA9IGRlZmF1bHRId207XG5cbiAgLy8gY2FzdCB0byBpbnRzLlxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSBNYXRoLmZsb29yKHRoaXMuaGlnaFdhdGVyTWFyayk7XG5cbiAgLy8gaWYgX2ZpbmFsIGhhcyBiZWVuIGNhbGxlZFxuICB0aGlzLmZpbmFsQ2FsbGVkID0gZmFsc2U7XG5cbiAgLy8gZHJhaW4gZXZlbnQgZmxhZy5cbiAgdGhpcy5uZWVkRHJhaW4gPSBmYWxzZTtcbiAgLy8gYXQgdGhlIHN0YXJ0IG9mIGNhbGxpbmcgZW5kKClcbiAgdGhpcy5lbmRpbmcgPSBmYWxzZTtcbiAgLy8gd2hlbiBlbmQoKSBoYXMgYmVlbiBjYWxsZWQsIGFuZCByZXR1cm5lZFxuICB0aGlzLmVuZGVkID0gZmFsc2U7XG4gIC8vIHdoZW4gJ2ZpbmlzaCcgaXMgZW1pdHRlZFxuICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG5cbiAgLy8gaGFzIGl0IGJlZW4gZGVzdHJveWVkXG4gIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG5cbiAgLy8gc2hvdWxkIHdlIGRlY29kZSBzdHJpbmdzIGludG8gYnVmZmVycyBiZWZvcmUgcGFzc2luZyB0byBfd3JpdGU/XG4gIC8vIHRoaXMgaXMgaGVyZSBzbyB0aGF0IHNvbWUgbm9kZS1jb3JlIHN0cmVhbXMgY2FuIG9wdGltaXplIHN0cmluZ1xuICAvLyBoYW5kbGluZyBhdCBhIGxvd2VyIGxldmVsLlxuICB2YXIgbm9EZWNvZGUgPSBvcHRpb25zLmRlY29kZVN0cmluZ3MgPT09IGZhbHNlO1xuICB0aGlzLmRlY29kZVN0cmluZ3MgPSAhbm9EZWNvZGU7XG5cbiAgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZ1xuICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuXG4gIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgdW5pdmVyc2UgdXNlcyAndXRmOCcsIHRob3VnaC5cbiAgdGhpcy5kZWZhdWx0RW5jb2RpbmcgPSBvcHRpb25zLmRlZmF1bHRFbmNvZGluZyB8fCAndXRmOCc7XG5cbiAgLy8gbm90IGFuIGFjdHVhbCBidWZmZXIgd2Uga2VlcCB0cmFjayBvZiwgYnV0IGEgbWVhc3VyZW1lbnRcbiAgLy8gb2YgaG93IG11Y2ggd2UncmUgd2FpdGluZyB0byBnZXQgcHVzaGVkIHRvIHNvbWUgdW5kZXJseWluZ1xuICAvLyBzb2NrZXQgb3IgZmlsZS5cbiAgdGhpcy5sZW5ndGggPSAwO1xuXG4gIC8vIGEgZmxhZyB0byBzZWUgd2hlbiB3ZSdyZSBpbiB0aGUgbWlkZGxlIG9mIGEgd3JpdGUuXG4gIHRoaXMud3JpdGluZyA9IGZhbHNlO1xuXG4gIC8vIHdoZW4gdHJ1ZSBhbGwgd3JpdGVzIHdpbGwgYmUgYnVmZmVyZWQgdW50aWwgLnVuY29yaygpIGNhbGxcbiAgdGhpcy5jb3JrZWQgPSAwO1xuXG4gIC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIG9ud3JpdGUgY2IgaXMgY2FsbGVkIGltbWVkaWF0ZWx5LFxuICAvLyBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWNhdXNlIGFueVxuICAvLyBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcImxhdGVyXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCB3cml0ZSBjYWxsLlxuICB0aGlzLnN5bmMgPSB0cnVlO1xuXG4gIC8vIGEgZmxhZyB0byBrbm93IGlmIHdlJ3JlIHByb2Nlc3NpbmcgcHJldmlvdXNseSBidWZmZXJlZCBpdGVtcywgd2hpY2hcbiAgLy8gbWF5IGNhbGwgdGhlIF93cml0ZSgpIGNhbGxiYWNrIGluIHRoZSBzYW1lIHRpY2ssIHNvIHRoYXQgd2UgZG9uJ3RcbiAgLy8gZW5kIHVwIGluIGFuIG92ZXJsYXBwZWQgb253cml0ZSBzaXR1YXRpb24uXG4gIHRoaXMuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlO1xuXG4gIC8vIHRoZSBjYWxsYmFjayB0aGF0J3MgcGFzc2VkIHRvIF93cml0ZShjaHVuayxjYilcbiAgdGhpcy5vbndyaXRlID0gZnVuY3Rpb24gKGVyKSB7XG4gICAgb253cml0ZShzdHJlYW0sIGVyKTtcbiAgfTtcblxuICAvLyB0aGUgY2FsbGJhY2sgdGhhdCB0aGUgdXNlciBzdXBwbGllcyB0byB3cml0ZShjaHVuayxlbmNvZGluZyxjYilcbiAgdGhpcy53cml0ZWNiID0gbnVsbDtcblxuICAvLyB0aGUgYW1vdW50IHRoYXQgaXMgYmVpbmcgd3JpdHRlbiB3aGVuIF93cml0ZSBpcyBjYWxsZWQuXG4gIHRoaXMud3JpdGVsZW4gPSAwO1xuXG4gIHRoaXMuYnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcbiAgdGhpcy5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcblxuICAvLyBudW1iZXIgb2YgcGVuZGluZyB1c2VyLXN1cHBsaWVkIHdyaXRlIGNhbGxiYWNrc1xuICAvLyB0aGlzIG11c3QgYmUgMCBiZWZvcmUgJ2ZpbmlzaCcgY2FuIGJlIGVtaXR0ZWRcbiAgdGhpcy5wZW5kaW5nY2IgPSAwO1xuXG4gIC8vIGVtaXQgcHJlZmluaXNoIGlmIHRoZSBvbmx5IHRoaW5nIHdlJ3JlIHdhaXRpbmcgZm9yIGlzIF93cml0ZSBjYnNcbiAgLy8gVGhpcyBpcyByZWxldmFudCBmb3Igc3luY2hyb25vdXMgVHJhbnNmb3JtIHN0cmVhbXNcbiAgdGhpcy5wcmVmaW5pc2hlZCA9IGZhbHNlO1xuXG4gIC8vIFRydWUgaWYgdGhlIGVycm9yIHdhcyBhbHJlYWR5IGVtaXR0ZWQgYW5kIHNob3VsZCBub3QgYmUgdGhyb3duIGFnYWluXG4gIHRoaXMuZXJyb3JFbWl0dGVkID0gZmFsc2U7XG5cbiAgLy8gY291bnQgYnVmZmVyZWQgcmVxdWVzdHNcbiAgdGhpcy5idWZmZXJlZFJlcXVlc3RDb3VudCA9IDA7XG5cbiAgLy8gYWxsb2NhdGUgdGhlIGZpcnN0IENvcmtlZFJlcXVlc3QsIHRoZXJlIGlzIGFsd2F5c1xuICAvLyBvbmUgYWxsb2NhdGVkIGFuZCBmcmVlIHRvIHVzZSwgYW5kIHdlIG1haW50YWluIGF0IG1vc3QgdHdvXG4gIHRoaXMuY29ya2VkUmVxdWVzdHNGcmVlID0gbmV3IENvcmtlZFJlcXVlc3QodGhpcyk7XG59XG5cbldyaXRhYmxlU3RhdGUucHJvdG90eXBlLmdldEJ1ZmZlciA9IGZ1bmN0aW9uIGdldEJ1ZmZlcigpIHtcbiAgdmFyIGN1cnJlbnQgPSB0aGlzLmJ1ZmZlcmVkUmVxdWVzdDtcbiAgdmFyIG91dCA9IFtdO1xuICB3aGlsZSAoY3VycmVudCkge1xuICAgIG91dC5wdXNoKGN1cnJlbnQpO1xuICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn07XG5cbihmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlU3RhdGUucHJvdG90eXBlLCAnYnVmZmVyJywge1xuICAgICAgZ2V0OiBpbnRlcm5hbFV0aWwuZGVwcmVjYXRlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QnVmZmVyKCk7XG4gICAgICB9LCAnX3dyaXRhYmxlU3RhdGUuYnVmZmVyIGlzIGRlcHJlY2F0ZWQuIFVzZSBfd3JpdGFibGVTdGF0ZS5nZXRCdWZmZXIgJyArICdpbnN0ZWFkLicsICdERVAwMDAzJylcbiAgICB9KTtcbiAgfSBjYXRjaCAoXykge31cbn0pKCk7XG5cbi8vIFRlc3QgX3dyaXRhYmxlU3RhdGUgZm9yIGluaGVyaXRhbmNlIHRvIGFjY291bnQgZm9yIER1cGxleCBzdHJlYW1zLFxuLy8gd2hvc2UgcHJvdG90eXBlIGNoYWluIG9ubHkgcG9pbnRzIHRvIFJlYWRhYmxlLlxudmFyIHJlYWxIYXNJbnN0YW5jZTtcbmlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5oYXNJbnN0YW5jZSAmJiB0eXBlb2YgRnVuY3Rpb24ucHJvdG90eXBlW1N5bWJvbC5oYXNJbnN0YW5jZV0gPT09ICdmdW5jdGlvbicpIHtcbiAgcmVhbEhhc0luc3RhbmNlID0gRnVuY3Rpb24ucHJvdG90eXBlW1N5bWJvbC5oYXNJbnN0YW5jZV07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZSwgU3ltYm9sLmhhc0luc3RhbmNlLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAgIGlmIChyZWFsSGFzSW5zdGFuY2UuY2FsbCh0aGlzLCBvYmplY3QpKSByZXR1cm4gdHJ1ZTtcbiAgICAgIGlmICh0aGlzICE9PSBXcml0YWJsZSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICByZXR1cm4gb2JqZWN0ICYmIG9iamVjdC5fd3JpdGFibGVTdGF0ZSBpbnN0YW5jZW9mIFdyaXRhYmxlU3RhdGU7XG4gICAgfVxuICB9KTtcbn0gZWxzZSB7XG4gIHJlYWxIYXNJbnN0YW5jZSA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0IGluc3RhbmNlb2YgdGhpcztcbiAgfTtcbn1cblxuZnVuY3Rpb24gV3JpdGFibGUob3B0aW9ucykge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIC8vIFdyaXRhYmxlIGN0b3IgaXMgYXBwbGllZCB0byBEdXBsZXhlcywgdG9vLlxuICAvLyBgcmVhbEhhc0luc3RhbmNlYCBpcyBuZWNlc3NhcnkgYmVjYXVzZSB1c2luZyBwbGFpbiBgaW5zdGFuY2VvZmBcbiAgLy8gd291bGQgcmV0dXJuIGZhbHNlLCBhcyBubyBgX3dyaXRhYmxlU3RhdGVgIHByb3BlcnR5IGlzIGF0dGFjaGVkLlxuXG4gIC8vIFRyeWluZyB0byB1c2UgdGhlIGN1c3RvbSBgaW5zdGFuY2VvZmAgZm9yIFdyaXRhYmxlIGhlcmUgd2lsbCBhbHNvIGJyZWFrIHRoZVxuICAvLyBOb2RlLmpzIExhenlUcmFuc2Zvcm0gaW1wbGVtZW50YXRpb24sIHdoaWNoIGhhcyBhIG5vbi10cml2aWFsIGdldHRlciBmb3JcbiAgLy8gYF93cml0YWJsZVN0YXRlYCB0aGF0IHdvdWxkIGxlYWQgdG8gaW5maW5pdGUgcmVjdXJzaW9uLlxuICBpZiAoIXJlYWxIYXNJbnN0YW5jZS5jYWxsKFdyaXRhYmxlLCB0aGlzKSAmJiAhKHRoaXMgaW5zdGFuY2VvZiBEdXBsZXgpKSB7XG4gICAgcmV0dXJuIG5ldyBXcml0YWJsZShvcHRpb25zKTtcbiAgfVxuXG4gIHRoaXMuX3dyaXRhYmxlU3RhdGUgPSBuZXcgV3JpdGFibGVTdGF0ZShvcHRpb25zLCB0aGlzKTtcblxuICAvLyBsZWdhY3kuXG4gIHRoaXMud3JpdGFibGUgPSB0cnVlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLndyaXRlID09PSAnZnVuY3Rpb24nKSB0aGlzLl93cml0ZSA9IG9wdGlvbnMud3JpdGU7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMud3JpdGV2ID09PSAnZnVuY3Rpb24nKSB0aGlzLl93cml0ZXYgPSBvcHRpb25zLndyaXRldjtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSB0aGlzLl9kZXN0cm95ID0gb3B0aW9ucy5kZXN0cm95O1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmZpbmFsID09PSAnZnVuY3Rpb24nKSB0aGlzLl9maW5hbCA9IG9wdGlvbnMuZmluYWw7XG4gIH1cblxuICBTdHJlYW0uY2FsbCh0aGlzKTtcbn1cblxuLy8gT3RoZXJ3aXNlIHBlb3BsZSBjYW4gcGlwZSBXcml0YWJsZSBzdHJlYW1zLCB3aGljaCBpcyBqdXN0IHdyb25nLlxuV3JpdGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0Nhbm5vdCBwaXBlLCBub3QgcmVhZGFibGUnKSk7XG59O1xuXG5mdW5jdGlvbiB3cml0ZUFmdGVyRW5kKHN0cmVhbSwgY2IpIHtcbiAgdmFyIGVyID0gbmV3IEVycm9yKCd3cml0ZSBhZnRlciBlbmQnKTtcbiAgLy8gVE9ETzogZGVmZXIgZXJyb3IgZXZlbnRzIGNvbnNpc3RlbnRseSBldmVyeXdoZXJlLCBub3QganVzdCB0aGUgY2JcbiAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICBwbmEubmV4dFRpY2soY2IsIGVyKTtcbn1cblxuLy8gQ2hlY2tzIHRoYXQgYSB1c2VyLXN1cHBsaWVkIGNodW5rIGlzIHZhbGlkLCBlc3BlY2lhbGx5IGZvciB0aGUgcGFydGljdWxhclxuLy8gbW9kZSB0aGUgc3RyZWFtIGlzIGluLiBDdXJyZW50bHkgdGhpcyBtZWFucyB0aGF0IGBudWxsYCBpcyBuZXZlciBhY2NlcHRlZFxuLy8gYW5kIHVuZGVmaW5lZC9ub24tc3RyaW5nIHZhbHVlcyBhcmUgb25seSBhbGxvd2VkIGluIG9iamVjdCBtb2RlLlxuZnVuY3Rpb24gdmFsaWRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgY2IpIHtcbiAgdmFyIHZhbGlkID0gdHJ1ZTtcbiAgdmFyIGVyID0gZmFsc2U7XG5cbiAgaWYgKGNodW5rID09PSBudWxsKSB7XG4gICAgZXIgPSBuZXcgVHlwZUVycm9yKCdNYXkgbm90IHdyaXRlIG51bGwgdmFsdWVzIHRvIHN0cmVhbScpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCAmJiAhc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGVyID0gbmV3IFR5cGVFcnJvcignSW52YWxpZCBub24tc3RyaW5nL2J1ZmZlciBjaHVuaycpO1xuICB9XG4gIGlmIChlcikge1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgICBwbmEubmV4dFRpY2soY2IsIGVyKTtcbiAgICB2YWxpZCA9IGZhbHNlO1xuICB9XG4gIHJldHVybiB2YWxpZDtcbn1cblxuV3JpdGFibGUucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHJldCA9IGZhbHNlO1xuICB2YXIgaXNCdWYgPSAhc3RhdGUub2JqZWN0TW9kZSAmJiBfaXNVaW50OEFycmF5KGNodW5rKTtcblxuICBpZiAoaXNCdWYgJiYgIUJ1ZmZlci5pc0J1ZmZlcihjaHVuaykpIHtcbiAgICBjaHVuayA9IF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gZW5jb2Rpbmc7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9XG5cbiAgaWYgKGlzQnVmKSBlbmNvZGluZyA9ICdidWZmZXInO2Vsc2UgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7XG5cbiAgaWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJykgY2IgPSBub3A7XG5cbiAgaWYgKHN0YXRlLmVuZGVkKSB3cml0ZUFmdGVyRW5kKHRoaXMsIGNiKTtlbHNlIGlmIChpc0J1ZiB8fCB2YWxpZENodW5rKHRoaXMsIHN0YXRlLCBjaHVuaywgY2IpKSB7XG4gICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgcmV0ID0gd3JpdGVPckJ1ZmZlcih0aGlzLCBzdGF0ZSwgaXNCdWYsIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5jb3JrID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIHN0YXRlLmNvcmtlZCsrO1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLnVuY29yayA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAoc3RhdGUuY29ya2VkKSB7XG4gICAgc3RhdGUuY29ya2VkLS07XG5cbiAgICBpZiAoIXN0YXRlLndyaXRpbmcgJiYgIXN0YXRlLmNvcmtlZCAmJiAhc3RhdGUuZmluaXNoZWQgJiYgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0KSBjbGVhckJ1ZmZlcih0aGlzLCBzdGF0ZSk7XG4gIH1cbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5zZXREZWZhdWx0RW5jb2RpbmcgPSBmdW5jdGlvbiBzZXREZWZhdWx0RW5jb2RpbmcoZW5jb2RpbmcpIHtcbiAgLy8gbm9kZTo6UGFyc2VFbmNvZGluZygpIHJlcXVpcmVzIGxvd2VyIGNhc2UuXG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnKSBlbmNvZGluZyA9IGVuY29kaW5nLnRvTG93ZXJDYXNlKCk7XG4gIGlmICghKFsnaGV4JywgJ3V0ZjgnLCAndXRmLTgnLCAnYXNjaWknLCAnYmluYXJ5JywgJ2Jhc2U2NCcsICd1Y3MyJywgJ3Vjcy0yJywgJ3V0ZjE2bGUnLCAndXRmLTE2bGUnLCAncmF3J10uaW5kZXhPZigoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKSkgPiAtMSkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZyk7XG4gIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVmYXVsdEVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZykge1xuICBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiYgc3RhdGUuZGVjb2RlU3RyaW5ncyAhPT0gZmFsc2UgJiYgdHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xuICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmssIGVuY29kaW5nKTtcbiAgfVxuICByZXR1cm4gY2h1bms7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZS5wcm90b3R5cGUsICd3cml0YWJsZUhpZ2hXYXRlck1hcmsnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIH1cbn0pO1xuXG4vLyBpZiB3ZSdyZSBhbHJlYWR5IHdyaXRpbmcgc29tZXRoaW5nLCB0aGVuIGp1c3QgcHV0IHRoaXNcbi8vIGluIHRoZSBxdWV1ZSwgYW5kIHdhaXQgb3VyIHR1cm4uICBPdGhlcndpc2UsIGNhbGwgX3dyaXRlXG4vLyBJZiB3ZSByZXR1cm4gZmFsc2UsIHRoZW4gd2UgbmVlZCBhIGRyYWluIGV2ZW50LCBzbyBzZXQgdGhhdCBmbGFnLlxuZnVuY3Rpb24gd3JpdGVPckJ1ZmZlcihzdHJlYW0sIHN0YXRlLCBpc0J1ZiwgY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBpZiAoIWlzQnVmKSB7XG4gICAgdmFyIG5ld0NodW5rID0gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZyk7XG4gICAgaWYgKGNodW5rICE9PSBuZXdDaHVuaykge1xuICAgICAgaXNCdWYgPSB0cnVlO1xuICAgICAgZW5jb2RpbmcgPSAnYnVmZmVyJztcbiAgICAgIGNodW5rID0gbmV3Q2h1bms7XG4gICAgfVxuICB9XG4gIHZhciBsZW4gPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcblxuICBzdGF0ZS5sZW5ndGggKz0gbGVuO1xuXG4gIHZhciByZXQgPSBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICAvLyB3ZSBtdXN0IGVuc3VyZSB0aGF0IHByZXZpb3VzIG5lZWREcmFpbiB3aWxsIG5vdCBiZSByZXNldCB0byBmYWxzZS5cbiAgaWYgKCFyZXQpIHN0YXRlLm5lZWREcmFpbiA9IHRydWU7XG5cbiAgaWYgKHN0YXRlLndyaXRpbmcgfHwgc3RhdGUuY29ya2VkKSB7XG4gICAgdmFyIGxhc3QgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSB7XG4gICAgICBjaHVuazogY2h1bmssXG4gICAgICBlbmNvZGluZzogZW5jb2RpbmcsXG4gICAgICBpc0J1ZjogaXNCdWYsXG4gICAgICBjYWxsYmFjazogY2IsXG4gICAgICBuZXh0OiBudWxsXG4gICAgfTtcbiAgICBpZiAobGFzdCkge1xuICAgICAgbGFzdC5uZXh0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICB9XG4gICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQgKz0gMTtcbiAgfSBlbHNlIHtcbiAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGZhbHNlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCB3cml0ZXYsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBzdGF0ZS53cml0ZWxlbiA9IGxlbjtcbiAgc3RhdGUud3JpdGVjYiA9IGNiO1xuICBzdGF0ZS53cml0aW5nID0gdHJ1ZTtcbiAgc3RhdGUuc3luYyA9IHRydWU7XG4gIGlmICh3cml0ZXYpIHN0cmVhbS5fd3JpdGV2KGNodW5rLCBzdGF0ZS5vbndyaXRlKTtlbHNlIHN0cmVhbS5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBzdGF0ZS5vbndyaXRlKTtcbiAgc3RhdGUuc3luYyA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZSwgc3luYywgZXIsIGNiKSB7XG4gIC0tc3RhdGUucGVuZGluZ2NiO1xuXG4gIGlmIChzeW5jKSB7XG4gICAgLy8gZGVmZXIgdGhlIGNhbGxiYWNrIGlmIHdlIGFyZSBiZWluZyBjYWxsZWQgc3luY2hyb25vdXNseVxuICAgIC8vIHRvIGF2b2lkIHBpbGluZyB1cCB0aGluZ3Mgb24gdGhlIHN0YWNrXG4gICAgcG5hLm5leHRUaWNrKGNiLCBlcik7XG4gICAgLy8gdGhpcyBjYW4gZW1pdCBmaW5pc2gsIGFuZCBpdCB3aWxsIGFsd2F5cyBoYXBwZW5cbiAgICAvLyBhZnRlciBlcnJvclxuICAgIHBuYS5uZXh0VGljayhmaW5pc2hNYXliZSwgc3RyZWFtLCBzdGF0ZSk7XG4gICAgc3RyZWFtLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICB9IGVsc2Uge1xuICAgIC8vIHRoZSBjYWxsZXIgZXhwZWN0IHRoaXMgdG8gaGFwcGVuIGJlZm9yZSBpZlxuICAgIC8vIGl0IGlzIGFzeW5jXG4gICAgY2IoZXIpO1xuICAgIHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgICAvLyB0aGlzIGNhbiBlbWl0IGZpbmlzaCwgYnV0IGZpbmlzaCBtdXN0XG4gICAgLy8gYWx3YXlzIGZvbGxvdyBlcnJvclxuICAgIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGVTdGF0ZVVwZGF0ZShzdGF0ZSkge1xuICBzdGF0ZS53cml0aW5nID0gZmFsc2U7XG4gIHN0YXRlLndyaXRlY2IgPSBudWxsO1xuICBzdGF0ZS5sZW5ndGggLT0gc3RhdGUud3JpdGVsZW47XG4gIHN0YXRlLndyaXRlbGVuID0gMDtcbn1cblxuZnVuY3Rpb24gb253cml0ZShzdHJlYW0sIGVyKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHN5bmMgPSBzdGF0ZS5zeW5jO1xuICB2YXIgY2IgPSBzdGF0ZS53cml0ZWNiO1xuXG4gIG9ud3JpdGVTdGF0ZVVwZGF0ZShzdGF0ZSk7XG5cbiAgaWYgKGVyKSBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZSwgc3luYywgZXIsIGNiKTtlbHNlIHtcbiAgICAvLyBDaGVjayBpZiB3ZSdyZSBhY3R1YWxseSByZWFkeSB0byBmaW5pc2gsIGJ1dCBkb24ndCBlbWl0IHlldFxuICAgIHZhciBmaW5pc2hlZCA9IG5lZWRGaW5pc2goc3RhdGUpO1xuXG4gICAgaWYgKCFmaW5pc2hlZCAmJiAhc3RhdGUuY29ya2VkICYmICFzdGF0ZS5idWZmZXJQcm9jZXNzaW5nICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCkge1xuICAgICAgY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuXG4gICAgaWYgKHN5bmMpIHtcbiAgICAgIC8qPHJlcGxhY2VtZW50PiovXG4gICAgICBhc3luY1dyaXRlKGFmdGVyV3JpdGUsIHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYik7XG4gICAgICAvKjwvcmVwbGFjZW1lbnQ+Ki9cbiAgICB9IGVsc2Uge1xuICAgICAgYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYikge1xuICBpZiAoIWZpbmlzaGVkKSBvbndyaXRlRHJhaW4oc3RyZWFtLCBzdGF0ZSk7XG4gIHN0YXRlLnBlbmRpbmdjYi0tO1xuICBjYigpO1xuICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbn1cblxuLy8gTXVzdCBmb3JjZSBjYWxsYmFjayB0byBiZSBjYWxsZWQgb24gbmV4dFRpY2ssIHNvIHRoYXQgd2UgZG9uJ3Rcbi8vIGVtaXQgJ2RyYWluJyBiZWZvcmUgdGhlIHdyaXRlKCkgY29uc3VtZXIgZ2V0cyB0aGUgJ2ZhbHNlJyByZXR1cm5cbi8vIHZhbHVlLCBhbmQgaGFzIGEgY2hhbmNlIHRvIGF0dGFjaCBhICdkcmFpbicgbGlzdGVuZXIuXG5mdW5jdGlvbiBvbndyaXRlRHJhaW4oc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLm5lZWREcmFpbikge1xuICAgIHN0YXRlLm5lZWREcmFpbiA9IGZhbHNlO1xuICAgIHN0cmVhbS5lbWl0KCdkcmFpbicpO1xuICB9XG59XG5cbi8vIGlmIHRoZXJlJ3Mgc29tZXRoaW5nIGluIHRoZSBidWZmZXIgd2FpdGluZywgdGhlbiBwcm9jZXNzIGl0XG5mdW5jdGlvbiBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKSB7XG4gIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSB0cnVlO1xuICB2YXIgZW50cnkgPSBzdGF0ZS5idWZmZXJlZFJlcXVlc3Q7XG5cbiAgaWYgKHN0cmVhbS5fd3JpdGV2ICYmIGVudHJ5ICYmIGVudHJ5Lm5leHQpIHtcbiAgICAvLyBGYXN0IGNhc2UsIHdyaXRlIGV2ZXJ5dGhpbmcgdXNpbmcgX3dyaXRldigpXG4gICAgdmFyIGwgPSBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudDtcbiAgICB2YXIgYnVmZmVyID0gbmV3IEFycmF5KGwpO1xuICAgIHZhciBob2xkZXIgPSBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWU7XG4gICAgaG9sZGVyLmVudHJ5ID0gZW50cnk7XG5cbiAgICB2YXIgY291bnQgPSAwO1xuICAgIHZhciBhbGxCdWZmZXJzID0gdHJ1ZTtcbiAgICB3aGlsZSAoZW50cnkpIHtcbiAgICAgIGJ1ZmZlcltjb3VudF0gPSBlbnRyeTtcbiAgICAgIGlmICghZW50cnkuaXNCdWYpIGFsbEJ1ZmZlcnMgPSBmYWxzZTtcbiAgICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgICAgIGNvdW50ICs9IDE7XG4gICAgfVxuICAgIGJ1ZmZlci5hbGxCdWZmZXJzID0gYWxsQnVmZmVycztcblxuICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgdHJ1ZSwgc3RhdGUubGVuZ3RoLCBidWZmZXIsICcnLCBob2xkZXIuZmluaXNoKTtcblxuICAgIC8vIGRvV3JpdGUgaXMgYWxtb3N0IGFsd2F5cyBhc3luYywgZGVmZXIgdGhlc2UgdG8gc2F2ZSBhIGJpdCBvZiB0aW1lXG4gICAgLy8gYXMgdGhlIGhvdCBwYXRoIGVuZHMgd2l0aCBkb1dyaXRlXG4gICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG4gICAgaWYgKGhvbGRlci5uZXh0KSB7XG4gICAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBob2xkZXIubmV4dDtcbiAgICAgIGhvbGRlci5uZXh0ID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlID0gbmV3IENvcmtlZFJlcXVlc3Qoc3RhdGUpO1xuICAgIH1cbiAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgLy8gU2xvdyBjYXNlLCB3cml0ZSBjaHVua3Mgb25lLWJ5LW9uZVxuICAgIHdoaWxlIChlbnRyeSkge1xuICAgICAgdmFyIGNodW5rID0gZW50cnkuY2h1bms7XG4gICAgICB2YXIgZW5jb2RpbmcgPSBlbnRyeS5lbmNvZGluZztcbiAgICAgIHZhciBjYiA9IGVudHJ5LmNhbGxiYWNrO1xuICAgICAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuXG4gICAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGZhbHNlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICAgICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICAgICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQtLTtcbiAgICAgIC8vIGlmIHdlIGRpZG4ndCBjYWxsIHRoZSBvbndyaXRlIGltbWVkaWF0ZWx5LCB0aGVuXG4gICAgICAvLyBpdCBtZWFucyB0aGF0IHdlIG5lZWQgdG8gd2FpdCB1bnRpbCBpdCBkb2VzLlxuICAgICAgLy8gYWxzbywgdGhhdCBtZWFucyB0aGF0IHRoZSBjaHVuayBhbmQgY2IgYXJlIGN1cnJlbnRseVxuICAgICAgLy8gYmVpbmcgcHJvY2Vzc2VkLCBzbyBtb3ZlIHRoZSBidWZmZXIgY291bnRlciBwYXN0IHRoZW0uXG4gICAgICBpZiAoc3RhdGUud3JpdGluZykge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZW50cnkgPT09IG51bGwpIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuICB9XG5cbiAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID0gZW50cnk7XG4gIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSBmYWxzZTtcbn1cblxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNiKG5ldyBFcnJvcignX3dyaXRlKCkgaXMgbm90IGltcGxlbWVudGVkJykpO1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZXYgPSBudWxsO1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAodHlwZW9mIGNodW5rID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBjaHVuaztcbiAgICBjaHVuayA9IG51bGw7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gZW5jb2Rpbmc7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9XG5cbiAgaWYgKGNodW5rICE9PSBudWxsICYmIGNodW5rICE9PSB1bmRlZmluZWQpIHRoaXMud3JpdGUoY2h1bmssIGVuY29kaW5nKTtcblxuICAvLyAuZW5kKCkgZnVsbHkgdW5jb3Jrc1xuICBpZiAoc3RhdGUuY29ya2VkKSB7XG4gICAgc3RhdGUuY29ya2VkID0gMTtcbiAgICB0aGlzLnVuY29yaygpO1xuICB9XG5cbiAgLy8gaWdub3JlIHVubmVjZXNzYXJ5IGVuZCgpIGNhbGxzLlxuICBpZiAoIXN0YXRlLmVuZGluZyAmJiAhc3RhdGUuZmluaXNoZWQpIGVuZFdyaXRhYmxlKHRoaXMsIHN0YXRlLCBjYik7XG59O1xuXG5mdW5jdGlvbiBuZWVkRmluaXNoKHN0YXRlKSB7XG4gIHJldHVybiBzdGF0ZS5lbmRpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9PT0gbnVsbCAmJiAhc3RhdGUuZmluaXNoZWQgJiYgIXN0YXRlLndyaXRpbmc7XG59XG5mdW5jdGlvbiBjYWxsRmluYWwoc3RyZWFtLCBzdGF0ZSkge1xuICBzdHJlYW0uX2ZpbmFsKGZ1bmN0aW9uIChlcnIpIHtcbiAgICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgICBpZiAoZXJyKSB7XG4gICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgIH1cbiAgICBzdGF0ZS5wcmVmaW5pc2hlZCA9IHRydWU7XG4gICAgc3RyZWFtLmVtaXQoJ3ByZWZpbmlzaCcpO1xuICAgIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucHJlZmluaXNoZWQgJiYgIXN0YXRlLmZpbmFsQ2FsbGVkKSB7XG4gICAgaWYgKHR5cGVvZiBzdHJlYW0uX2ZpbmFsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICAgIHN0YXRlLmZpbmFsQ2FsbGVkID0gdHJ1ZTtcbiAgICAgIHBuYS5uZXh0VGljayhjYWxsRmluYWwsIHN0cmVhbSwgc3RhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5wcmVmaW5pc2hlZCA9IHRydWU7XG4gICAgICBzdHJlYW0uZW1pdCgncHJlZmluaXNoJyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIG5lZWQgPSBuZWVkRmluaXNoKHN0YXRlKTtcbiAgaWYgKG5lZWQpIHtcbiAgICBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSk7XG4gICAgaWYgKHN0YXRlLnBlbmRpbmdjYiA9PT0gMCkge1xuICAgICAgc3RhdGUuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLmVtaXQoJ2ZpbmlzaCcpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmVlZDtcbn1cblxuZnVuY3Rpb24gZW5kV3JpdGFibGUoc3RyZWFtLCBzdGF0ZSwgY2IpIHtcbiAgc3RhdGUuZW5kaW5nID0gdHJ1ZTtcbiAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG4gIGlmIChjYikge1xuICAgIGlmIChzdGF0ZS5maW5pc2hlZCkgcG5hLm5leHRUaWNrKGNiKTtlbHNlIHN0cmVhbS5vbmNlKCdmaW5pc2gnLCBjYik7XG4gIH1cbiAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuICBzdHJlYW0ud3JpdGFibGUgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gb25Db3JrZWRGaW5pc2goY29ya1JlcSwgc3RhdGUsIGVycikge1xuICB2YXIgZW50cnkgPSBjb3JrUmVxLmVudHJ5O1xuICBjb3JrUmVxLmVudHJ5ID0gbnVsbDtcbiAgd2hpbGUgKGVudHJ5KSB7XG4gICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7XG4gICAgc3RhdGUucGVuZGluZ2NiLS07XG4gICAgY2IoZXJyKTtcbiAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gIH1cbiAgaWYgKHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSkge1xuICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZS5uZXh0ID0gY29ya1JlcTtcbiAgfSBlbHNlIHtcbiAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBjb3JrUmVxO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZS5wcm90b3R5cGUsICdkZXN0cm95ZWQnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl93cml0YWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIC8vIHdlIGlnbm9yZSB0aGUgdmFsdWUgaWYgdGhlIHN0cmVhbVxuICAgIC8vIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXRcbiAgICBpZiAoIXRoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB0aGUgdXNlciBpcyBleHBsaWNpdGx5XG4gICAgLy8gbWFuYWdpbmcgZGVzdHJveWVkXG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgfVxufSk7XG5cbldyaXRhYmxlLnByb3RvdHlwZS5kZXN0cm95ID0gZGVzdHJveUltcGwuZGVzdHJveTtcbldyaXRhYmxlLnByb3RvdHlwZS5fdW5kZXN0cm95ID0gZGVzdHJveUltcGwudW5kZXN0cm95O1xuV3JpdGFibGUucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcbiAgdGhpcy5lbmQoKTtcbiAgY2IoZXJyKTtcbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXI7XG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcblxuZnVuY3Rpb24gY29weUJ1ZmZlcihzcmMsIHRhcmdldCwgb2Zmc2V0KSB7XG4gIHNyYy5jb3B5KHRhcmdldCwgb2Zmc2V0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEJ1ZmZlckxpc3QoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJ1ZmZlckxpc3QpO1xuXG4gICAgdGhpcy5oZWFkID0gbnVsbDtcbiAgICB0aGlzLnRhaWwgPSBudWxsO1xuICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgfVxuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiBwdXNoKHYpIHtcbiAgICB2YXIgZW50cnkgPSB7IGRhdGE6IHYsIG5leHQ6IG51bGwgfTtcbiAgICBpZiAodGhpcy5sZW5ndGggPiAwKSB0aGlzLnRhaWwubmV4dCA9IGVudHJ5O2Vsc2UgdGhpcy5oZWFkID0gZW50cnk7XG4gICAgdGhpcy50YWlsID0gZW50cnk7XG4gICAgKyt0aGlzLmxlbmd0aDtcbiAgfTtcblxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24gdW5zaGlmdCh2KSB7XG4gICAgdmFyIGVudHJ5ID0geyBkYXRhOiB2LCBuZXh0OiB0aGlzLmhlYWQgfTtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHRoaXMudGFpbCA9IGVudHJ5O1xuICAgIHRoaXMuaGVhZCA9IGVudHJ5O1xuICAgICsrdGhpcy5sZW5ndGg7XG4gIH07XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUuc2hpZnQgPSBmdW5jdGlvbiBzaGlmdCgpIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybjtcbiAgICB2YXIgcmV0ID0gdGhpcy5oZWFkLmRhdGE7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAxKSB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO2Vsc2UgdGhpcy5oZWFkID0gdGhpcy5oZWFkLm5leHQ7XG4gICAgLS10aGlzLmxlbmd0aDtcbiAgICByZXR1cm4gcmV0O1xuICB9O1xuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtcbiAgICB0aGlzLmxlbmd0aCA9IDA7XG4gIH07XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUuam9pbiA9IGZ1bmN0aW9uIGpvaW4ocykge1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuICcnO1xuICAgIHZhciBwID0gdGhpcy5oZWFkO1xuICAgIHZhciByZXQgPSAnJyArIHAuZGF0YTtcbiAgICB3aGlsZSAocCA9IHAubmV4dCkge1xuICAgICAgcmV0ICs9IHMgKyBwLmRhdGE7XG4gICAgfXJldHVybiByZXQ7XG4gIH07XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0KG4pIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybiBCdWZmZXIuYWxsb2MoMCk7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAxKSByZXR1cm4gdGhpcy5oZWFkLmRhdGE7XG4gICAgdmFyIHJldCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuID4+PiAwKTtcbiAgICB2YXIgcCA9IHRoaXMuaGVhZDtcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKHApIHtcbiAgICAgIGNvcHlCdWZmZXIocC5kYXRhLCByZXQsIGkpO1xuICAgICAgaSArPSBwLmRhdGEubGVuZ3RoO1xuICAgICAgcCA9IHAubmV4dDtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfTtcblxuICByZXR1cm4gQnVmZmVyTGlzdDtcbn0oKTtcblxuaWYgKHV0aWwgJiYgdXRpbC5pbnNwZWN0ICYmIHV0aWwuaW5zcGVjdC5jdXN0b20pIHtcbiAgbW9kdWxlLmV4cG9ydHMucHJvdG90eXBlW3V0aWwuaW5zcGVjdC5jdXN0b21dID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBvYmogPSB1dGlsLmluc3BlY3QoeyBsZW5ndGg6IHRoaXMubGVuZ3RoIH0pO1xuICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLm5hbWUgKyAnICcgKyBvYmo7XG4gIH07XG59IiwiJ3VzZSBzdHJpY3QnO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgcG5hID0gcmVxdWlyZSgncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vLyB1bmRvY3VtZW50ZWQgY2IoKSBBUEksIG5lZWRlZCBmb3IgY29yZSwgbm90IGZvciBwdWJsaWMgQVBJXG5mdW5jdGlvbiBkZXN0cm95KGVyciwgY2IpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICB2YXIgcmVhZGFibGVEZXN0cm95ZWQgPSB0aGlzLl9yZWFkYWJsZVN0YXRlICYmIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICB2YXIgd3JpdGFibGVEZXN0cm95ZWQgPSB0aGlzLl93cml0YWJsZVN0YXRlICYmIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkO1xuXG4gIGlmIChyZWFkYWJsZURlc3Ryb3llZCB8fCB3cml0YWJsZURlc3Ryb3llZCkge1xuICAgIGlmIChjYikge1xuICAgICAgY2IoZXJyKTtcbiAgICB9IGVsc2UgaWYgKGVyciAmJiAoIXRoaXMuX3dyaXRhYmxlU3RhdGUgfHwgIXRoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkKSkge1xuICAgICAgcG5hLm5leHRUaWNrKGVtaXRFcnJvck5ULCB0aGlzLCBlcnIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHdlIHNldCBkZXN0cm95ZWQgdG8gdHJ1ZSBiZWZvcmUgZmlyaW5nIGVycm9yIGNhbGxiYWNrcyBpbiBvcmRlclxuICAvLyB0byBtYWtlIGl0IHJlLWVudHJhbmNlIHNhZmUgaW4gY2FzZSBkZXN0cm95KCkgaXMgY2FsbGVkIHdpdGhpbiBjYWxsYmFja3NcblxuICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSkge1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gdHJ1ZTtcbiAgfVxuXG4gIC8vIGlmIHRoaXMgaXMgYSBkdXBsZXggc3RyZWFtIG1hcmsgdGhlIHdyaXRhYmxlIHBhcnQgYXMgZGVzdHJveWVkIGFzIHdlbGxcbiAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IHRydWU7XG4gIH1cblxuICB0aGlzLl9kZXN0cm95KGVyciB8fCBudWxsLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKCFjYiAmJiBlcnIpIHtcbiAgICAgIHBuYS5uZXh0VGljayhlbWl0RXJyb3JOVCwgX3RoaXMsIGVycik7XG4gICAgICBpZiAoX3RoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICAgICAgX3RoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNiKSB7XG4gICAgICBjYihlcnIpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHRoaXM7XG59XG5cbmZ1bmN0aW9uIHVuZGVzdHJveSgpIHtcbiAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5kZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuZEVtaXR0ZWQgPSBmYWxzZTtcbiAgfVxuXG4gIGlmICh0aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmZpbmlzaGVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbWl0RXJyb3JOVChzZWxmLCBlcnIpIHtcbiAgc2VsZi5lbWl0KCdlcnJvcicsIGVycik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBkZXN0cm95OiBkZXN0cm95LFxuICB1bmRlc3Ryb3k6IHVuZGVzdHJveVxufTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9yZWFkYWJsZScpLlBhc3NUaHJvdWdoXG4iLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3JlYWRhYmxlLmpzJyk7XG5leHBvcnRzLlN0cmVhbSA9IGV4cG9ydHM7XG5leHBvcnRzLlJlYWRhYmxlID0gZXhwb3J0cztcbmV4cG9ydHMuV3JpdGFibGUgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzJyk7XG5leHBvcnRzLkR1cGxleCA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fZHVwbGV4LmpzJyk7XG5leHBvcnRzLlRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzJyk7XG5leHBvcnRzLlBhc3NUaHJvdWdoID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9wYXNzdGhyb3VnaC5qcycpO1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3JlYWRhYmxlJykuVHJhbnNmb3JtXG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fd3JpdGFibGUuanMnKTtcbiIsIi8qIGVzbGludC1kaXNhYmxlIG5vZGUvbm8tZGVwcmVjYXRlZC1hcGkgKi9cbnZhciBidWZmZXIgPSByZXF1aXJlKCdidWZmZXInKVxudmFyIEJ1ZmZlciA9IGJ1ZmZlci5CdWZmZXJcblxuLy8gYWx0ZXJuYXRpdmUgdG8gdXNpbmcgT2JqZWN0LmtleXMgZm9yIG9sZCBicm93c2Vyc1xuZnVuY3Rpb24gY29weVByb3BzIChzcmMsIGRzdCkge1xuICBmb3IgKHZhciBrZXkgaW4gc3JjKSB7XG4gICAgZHN0W2tleV0gPSBzcmNba2V5XVxuICB9XG59XG5pZiAoQnVmZmVyLmZyb20gJiYgQnVmZmVyLmFsbG9jICYmIEJ1ZmZlci5hbGxvY1Vuc2FmZSAmJiBCdWZmZXIuYWxsb2NVbnNhZmVTbG93KSB7XG4gIG1vZHVsZS5leHBvcnRzID0gYnVmZmVyXG59IGVsc2Uge1xuICAvLyBDb3B5IHByb3BlcnRpZXMgZnJvbSByZXF1aXJlKCdidWZmZXInKVxuICBjb3B5UHJvcHMoYnVmZmVyLCBleHBvcnRzKVxuICBleHBvcnRzLkJ1ZmZlciA9IFNhZmVCdWZmZXJcbn1cblxuZnVuY3Rpb24gU2FmZUJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuLy8gQ29weSBzdGF0aWMgbWV0aG9kcyBmcm9tIEJ1ZmZlclxuY29weVByb3BzKEJ1ZmZlciwgU2FmZUJ1ZmZlcilcblxuU2FmZUJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyJylcbiAgfVxuICByZXR1cm4gQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5TYWZlQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxuICB2YXIgYnVmID0gQnVmZmVyKHNpemUpXG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJykge1xuICAgICAgYnVmLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgfSBlbHNlIHtcbiAgICAgIGJ1Zi5maWxsKGZpbGwpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGJ1Zi5maWxsKDApXG4gIH1cbiAgcmV0dXJuIGJ1ZlxufVxuXG5TYWZlQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHJldHVybiBCdWZmZXIoc2l6ZSlcbn1cblxuU2FmZUJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlci5TbG93QnVmZmVyKHNpemUpXG59XG4iLCIoZnVuY3Rpb24gKGdsb2JhbCwgdW5kZWZpbmVkKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBpZiAoZ2xvYmFsLnNldEltbWVkaWF0ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG5leHRIYW5kbGUgPSAxOyAvLyBTcGVjIHNheXMgZ3JlYXRlciB0aGFuIHplcm9cbiAgICB2YXIgdGFza3NCeUhhbmRsZSA9IHt9O1xuICAgIHZhciBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSBmYWxzZTtcbiAgICB2YXIgZG9jID0gZ2xvYmFsLmRvY3VtZW50O1xuICAgIHZhciByZWdpc3RlckltbWVkaWF0ZTtcblxuICAgIGZ1bmN0aW9uIHNldEltbWVkaWF0ZShjYWxsYmFjaykge1xuICAgICAgLy8gQ2FsbGJhY2sgY2FuIGVpdGhlciBiZSBhIGZ1bmN0aW9uIG9yIGEgc3RyaW5nXG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBuZXcgRnVuY3Rpb24oXCJcIiArIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICAgIC8vIENvcHkgZnVuY3Rpb24gYXJndW1lbnRzXG4gICAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2kgKyAxXTtcbiAgICAgIH1cbiAgICAgIC8vIFN0b3JlIGFuZCByZWdpc3RlciB0aGUgdGFza1xuICAgICAgdmFyIHRhc2sgPSB7IGNhbGxiYWNrOiBjYWxsYmFjaywgYXJnczogYXJncyB9O1xuICAgICAgdGFza3NCeUhhbmRsZVtuZXh0SGFuZGxlXSA9IHRhc2s7XG4gICAgICByZWdpc3RlckltbWVkaWF0ZShuZXh0SGFuZGxlKTtcbiAgICAgIHJldHVybiBuZXh0SGFuZGxlKys7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xlYXJJbW1lZGlhdGUoaGFuZGxlKSB7XG4gICAgICAgIGRlbGV0ZSB0YXNrc0J5SGFuZGxlW2hhbmRsZV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcnVuKHRhc2spIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gdGFzay5jYWxsYmFjaztcbiAgICAgICAgdmFyIGFyZ3MgPSB0YXNrLmFyZ3M7XG4gICAgICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBjYWxsYmFjayhhcmdzWzBdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBjYWxsYmFjayhhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBjYWxsYmFjayhhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkodW5kZWZpbmVkLCBhcmdzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcnVuSWZQcmVzZW50KGhhbmRsZSkge1xuICAgICAgICAvLyBGcm9tIHRoZSBzcGVjOiBcIldhaXQgdW50aWwgYW55IGludm9jYXRpb25zIG9mIHRoaXMgYWxnb3JpdGhtIHN0YXJ0ZWQgYmVmb3JlIHRoaXMgb25lIGhhdmUgY29tcGxldGVkLlwiXG4gICAgICAgIC8vIFNvIGlmIHdlJ3JlIGN1cnJlbnRseSBydW5uaW5nIGEgdGFzaywgd2UnbGwgbmVlZCB0byBkZWxheSB0aGlzIGludm9jYXRpb24uXG4gICAgICAgIGlmIChjdXJyZW50bHlSdW5uaW5nQVRhc2spIHtcbiAgICAgICAgICAgIC8vIERlbGF5IGJ5IGRvaW5nIGEgc2V0VGltZW91dC4gc2V0SW1tZWRpYXRlIHdhcyB0cmllZCBpbnN0ZWFkLCBidXQgaW4gRmlyZWZveCA3IGl0IGdlbmVyYXRlZCBhXG4gICAgICAgICAgICAvLyBcInRvbyBtdWNoIHJlY3Vyc2lvblwiIGVycm9yLlxuICAgICAgICAgICAgc2V0VGltZW91dChydW5JZlByZXNlbnQsIDAsIGhhbmRsZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgdGFzayA9IHRhc2tzQnlIYW5kbGVbaGFuZGxlXTtcbiAgICAgICAgICAgIGlmICh0YXNrKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudGx5UnVubmluZ0FUYXNrID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBydW4odGFzayk7XG4gICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJJbW1lZGlhdGUoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudGx5UnVubmluZ0FUYXNrID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbE5leHRUaWNrSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHsgcnVuSWZQcmVzZW50KGhhbmRsZSk7IH0pO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNhblVzZVBvc3RNZXNzYWdlKCkge1xuICAgICAgICAvLyBUaGUgdGVzdCBhZ2FpbnN0IGBpbXBvcnRTY3JpcHRzYCBwcmV2ZW50cyB0aGlzIGltcGxlbWVudGF0aW9uIGZyb20gYmVpbmcgaW5zdGFsbGVkIGluc2lkZSBhIHdlYiB3b3JrZXIsXG4gICAgICAgIC8vIHdoZXJlIGBnbG9iYWwucG9zdE1lc3NhZ2VgIG1lYW5zIHNvbWV0aGluZyBjb21wbGV0ZWx5IGRpZmZlcmVudCBhbmQgY2FuJ3QgYmUgdXNlZCBmb3IgdGhpcyBwdXJwb3NlLlxuICAgICAgICBpZiAoZ2xvYmFsLnBvc3RNZXNzYWdlICYmICFnbG9iYWwuaW1wb3J0U2NyaXB0cykge1xuICAgICAgICAgICAgdmFyIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIG9sZE9uTWVzc2FnZSA9IGdsb2JhbC5vbm1lc3NhZ2U7XG4gICAgICAgICAgICBnbG9iYWwub25tZXNzYWdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cyA9IGZhbHNlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShcIlwiLCBcIipcIik7XG4gICAgICAgICAgICBnbG9iYWwub25tZXNzYWdlID0gb2xkT25NZXNzYWdlO1xuICAgICAgICAgICAgcmV0dXJuIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsUG9zdE1lc3NhZ2VJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgLy8gSW5zdGFsbHMgYW4gZXZlbnQgaGFuZGxlciBvbiBgZ2xvYmFsYCBmb3IgdGhlIGBtZXNzYWdlYCBldmVudDogc2VlXG4gICAgICAgIC8vICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vRE9NL3dpbmRvdy5wb3N0TWVzc2FnZVxuICAgICAgICAvLyAqIGh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL2NvbW1zLmh0bWwjY3Jvc3NEb2N1bWVudE1lc3NhZ2VzXG5cbiAgICAgICAgdmFyIG1lc3NhZ2VQcmVmaXggPSBcInNldEltbWVkaWF0ZSRcIiArIE1hdGgucmFuZG9tKCkgKyBcIiRcIjtcbiAgICAgICAgdmFyIG9uR2xvYmFsTWVzc2FnZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoZXZlbnQuc291cmNlID09PSBnbG9iYWwgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgZXZlbnQuZGF0YSA9PT0gXCJzdHJpbmdcIiAmJlxuICAgICAgICAgICAgICAgIGV2ZW50LmRhdGEuaW5kZXhPZihtZXNzYWdlUHJlZml4KSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJ1bklmUHJlc2VudCgrZXZlbnQuZGF0YS5zbGljZShtZXNzYWdlUHJlZml4Lmxlbmd0aCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIG9uR2xvYmFsTWVzc2FnZSwgZmFsc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2xvYmFsLmF0dGFjaEV2ZW50KFwib25tZXNzYWdlXCIsIG9uR2xvYmFsTWVzc2FnZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKG1lc3NhZ2VQcmVmaXggKyBoYW5kbGUsIFwiKlwiKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsTWVzc2FnZUNoYW5uZWxJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgdmFyIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICAgICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgdmFyIGhhbmRsZSA9IGV2ZW50LmRhdGE7XG4gICAgICAgICAgICBydW5JZlByZXNlbnQoaGFuZGxlKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgY2hhbm5lbC5wb3J0Mi5wb3N0TWVzc2FnZShoYW5kbGUpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxSZWFkeVN0YXRlQ2hhbmdlSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHZhciBodG1sID0gZG9jLmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIDxzY3JpcHQ+IGVsZW1lbnQ7IGl0cyByZWFkeXN0YXRlY2hhbmdlIGV2ZW50IHdpbGwgYmUgZmlyZWQgYXN5bmNocm9ub3VzbHkgb25jZSBpdCBpcyBpbnNlcnRlZFxuICAgICAgICAgICAgLy8gaW50byB0aGUgZG9jdW1lbnQuIERvIHNvLCB0aHVzIHF1ZXVpbmcgdXAgdGhlIHRhc2suIFJlbWVtYmVyIHRvIGNsZWFuIHVwIG9uY2UgaXQncyBiZWVuIGNhbGxlZC5cbiAgICAgICAgICAgIHZhciBzY3JpcHQgPSBkb2MuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtcbiAgICAgICAgICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcnVuSWZQcmVzZW50KGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgaHRtbC5yZW1vdmVDaGlsZChzY3JpcHQpO1xuICAgICAgICAgICAgICAgIHNjcmlwdCA9IG51bGw7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaHRtbC5hcHBlbmRDaGlsZChzY3JpcHQpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxTZXRUaW1lb3V0SW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KHJ1bklmUHJlc2VudCwgMCwgaGFuZGxlKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBJZiBzdXBwb3J0ZWQsIHdlIHNob3VsZCBhdHRhY2ggdG8gdGhlIHByb3RvdHlwZSBvZiBnbG9iYWwsIHNpbmNlIHRoYXQgaXMgd2hlcmUgc2V0VGltZW91dCBldCBhbC4gbGl2ZS5cbiAgICB2YXIgYXR0YWNoVG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKGdsb2JhbCk7XG4gICAgYXR0YWNoVG8gPSBhdHRhY2hUbyAmJiBhdHRhY2hUby5zZXRUaW1lb3V0ID8gYXR0YWNoVG8gOiBnbG9iYWw7XG5cbiAgICAvLyBEb24ndCBnZXQgZm9vbGVkIGJ5IGUuZy4gYnJvd3NlcmlmeSBlbnZpcm9ubWVudHMuXG4gICAgaWYgKHt9LnRvU3RyaW5nLmNhbGwoZ2xvYmFsLnByb2Nlc3MpID09PSBcIltvYmplY3QgcHJvY2Vzc11cIikge1xuICAgICAgICAvLyBGb3IgTm9kZS5qcyBiZWZvcmUgMC45XG4gICAgICAgIGluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGNhblVzZVBvc3RNZXNzYWdlKCkpIHtcbiAgICAgICAgLy8gRm9yIG5vbi1JRTEwIG1vZGVybiBicm93c2Vyc1xuICAgICAgICBpbnN0YWxsUG9zdE1lc3NhZ2VJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChnbG9iYWwuTWVzc2FnZUNoYW5uZWwpIHtcbiAgICAgICAgLy8gRm9yIHdlYiB3b3JrZXJzLCB3aGVyZSBzdXBwb3J0ZWRcbiAgICAgICAgaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoZG9jICYmIFwib25yZWFkeXN0YXRlY2hhbmdlXCIgaW4gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIikpIHtcbiAgICAgICAgLy8gRm9yIElFIDbigJM4XG4gICAgICAgIGluc3RhbGxSZWFkeVN0YXRlQ2hhbmdlSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEZvciBvbGRlciBicm93c2Vyc1xuICAgICAgICBpbnN0YWxsU2V0VGltZW91dEltcGxlbWVudGF0aW9uKCk7XG4gICAgfVxuXG4gICAgYXR0YWNoVG8uc2V0SW1tZWRpYXRlID0gc2V0SW1tZWRpYXRlO1xuICAgIGF0dGFjaFRvLmNsZWFySW1tZWRpYXRlID0gY2xlYXJJbW1lZGlhdGU7XG59KHR5cGVvZiBzZWxmID09PSBcInVuZGVmaW5lZFwiID8gdHlwZW9mIGdsb2JhbCA9PT0gXCJ1bmRlZmluZWRcIiA/IHRoaXMgOiBnbG9iYWwgOiBzZWxmKSk7XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxubW9kdWxlLmV4cG9ydHMgPSBTdHJlYW07XG5cbnZhciBFRSA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbmluaGVyaXRzKFN0cmVhbSwgRUUpO1xuU3RyZWFtLlJlYWRhYmxlID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3JlYWRhYmxlLmpzJyk7XG5TdHJlYW0uV3JpdGFibGUgPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vd3JpdGFibGUuanMnKTtcblN0cmVhbS5EdXBsZXggPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vZHVwbGV4LmpzJyk7XG5TdHJlYW0uVHJhbnNmb3JtID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3RyYW5zZm9ybS5qcycpO1xuU3RyZWFtLlBhc3NUaHJvdWdoID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3Bhc3N0aHJvdWdoLmpzJyk7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuNC54XG5TdHJlYW0uU3RyZWFtID0gU3RyZWFtO1xuXG5cblxuLy8gb2xkLXN0eWxlIHN0cmVhbXMuICBOb3RlIHRoYXQgdGhlIHBpcGUgbWV0aG9kICh0aGUgb25seSByZWxldmFudFxuLy8gcGFydCBvZiB0aGlzIGNsYXNzKSBpcyBvdmVycmlkZGVuIGluIHRoZSBSZWFkYWJsZSBjbGFzcy5cblxuZnVuY3Rpb24gU3RyZWFtKCkge1xuICBFRS5jYWxsKHRoaXMpO1xufVxuXG5TdHJlYW0ucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbihkZXN0LCBvcHRpb25zKSB7XG4gIHZhciBzb3VyY2UgPSB0aGlzO1xuXG4gIGZ1bmN0aW9uIG9uZGF0YShjaHVuaykge1xuICAgIGlmIChkZXN0LndyaXRhYmxlKSB7XG4gICAgICBpZiAoZmFsc2UgPT09IGRlc3Qud3JpdGUoY2h1bmspICYmIHNvdXJjZS5wYXVzZSkge1xuICAgICAgICBzb3VyY2UucGF1c2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzb3VyY2Uub24oJ2RhdGEnLCBvbmRhdGEpO1xuXG4gIGZ1bmN0aW9uIG9uZHJhaW4oKSB7XG4gICAgaWYgKHNvdXJjZS5yZWFkYWJsZSAmJiBzb3VyY2UucmVzdW1lKSB7XG4gICAgICBzb3VyY2UucmVzdW1lKCk7XG4gICAgfVxuICB9XG5cbiAgZGVzdC5vbignZHJhaW4nLCBvbmRyYWluKTtcblxuICAvLyBJZiB0aGUgJ2VuZCcgb3B0aW9uIGlzIG5vdCBzdXBwbGllZCwgZGVzdC5lbmQoKSB3aWxsIGJlIGNhbGxlZCB3aGVuXG4gIC8vIHNvdXJjZSBnZXRzIHRoZSAnZW5kJyBvciAnY2xvc2UnIGV2ZW50cy4gIE9ubHkgZGVzdC5lbmQoKSBvbmNlLlxuICBpZiAoIWRlc3QuX2lzU3RkaW8gJiYgKCFvcHRpb25zIHx8IG9wdGlvbnMuZW5kICE9PSBmYWxzZSkpIHtcbiAgICBzb3VyY2Uub24oJ2VuZCcsIG9uZW5kKTtcbiAgICBzb3VyY2Uub24oJ2Nsb3NlJywgb25jbG9zZSk7XG4gIH1cblxuICB2YXIgZGlkT25FbmQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gb25lbmQoKSB7XG4gICAgaWYgKGRpZE9uRW5kKSByZXR1cm47XG4gICAgZGlkT25FbmQgPSB0cnVlO1xuXG4gICAgZGVzdC5lbmQoKTtcbiAgfVxuXG5cbiAgZnVuY3Rpb24gb25jbG9zZSgpIHtcbiAgICBpZiAoZGlkT25FbmQpIHJldHVybjtcbiAgICBkaWRPbkVuZCA9IHRydWU7XG5cbiAgICBpZiAodHlwZW9mIGRlc3QuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgZGVzdC5kZXN0cm95KCk7XG4gIH1cblxuICAvLyBkb24ndCBsZWF2ZSBkYW5nbGluZyBwaXBlcyB3aGVuIHRoZXJlIGFyZSBlcnJvcnMuXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHtcbiAgICBjbGVhbnVwKCk7XG4gICAgaWYgKEVFLmxpc3RlbmVyQ291bnQodGhpcywgJ2Vycm9yJykgPT09IDApIHtcbiAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgc3RyZWFtIGVycm9yIGluIHBpcGUuXG4gICAgfVxuICB9XG5cbiAgc291cmNlLm9uKCdlcnJvcicsIG9uZXJyb3IpO1xuICBkZXN0Lm9uKCdlcnJvcicsIG9uZXJyb3IpO1xuXG4gIC8vIHJlbW92ZSBhbGwgdGhlIGV2ZW50IGxpc3RlbmVycyB0aGF0IHdlcmUgYWRkZWQuXG4gIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25kYXRhKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZCk7XG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG5cbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIGNsZWFudXApO1xuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBjbGVhbnVwKTtcblxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgY2xlYW51cCk7XG4gIH1cblxuICBzb3VyY2Uub24oJ2VuZCcsIGNsZWFudXApO1xuICBzb3VyY2Uub24oJ2Nsb3NlJywgY2xlYW51cCk7XG5cbiAgZGVzdC5vbignY2xvc2UnLCBjbGVhbnVwKTtcblxuICBkZXN0LmVtaXQoJ3BpcGUnLCBzb3VyY2UpO1xuXG4gIC8vIEFsbG93IGZvciB1bml4LWxpa2UgdXNhZ2U6IEEucGlwZShCKS5waXBlKEMpXG4gIHJldHVybiBkZXN0O1xufTtcbiIsIi8qXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG5cbnZhciBzdHlsZXNJbkRvbSA9IHt9O1xuXG52YXJcdG1lbW9pemUgPSBmdW5jdGlvbiAoZm4pIHtcblx0dmFyIG1lbW87XG5cblx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodHlwZW9mIG1lbW8gPT09IFwidW5kZWZpbmVkXCIpIG1lbW8gPSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdHJldHVybiBtZW1vO1xuXHR9O1xufTtcblxudmFyIGlzT2xkSUUgPSBtZW1vaXplKGZ1bmN0aW9uICgpIHtcblx0Ly8gVGVzdCBmb3IgSUUgPD0gOSBhcyBwcm9wb3NlZCBieSBCcm93c2VyaGFja3Ncblx0Ly8gQHNlZSBodHRwOi8vYnJvd3NlcmhhY2tzLmNvbS8jaGFjay1lNzFkODY5MmY2NTMzNDE3M2ZlZTcxNWMyMjJjYjgwNVxuXHQvLyBUZXN0cyBmb3IgZXhpc3RlbmNlIG9mIHN0YW5kYXJkIGdsb2JhbHMgaXMgdG8gYWxsb3cgc3R5bGUtbG9hZGVyXG5cdC8vIHRvIG9wZXJhdGUgY29ycmVjdGx5IGludG8gbm9uLXN0YW5kYXJkIGVudmlyb25tZW50c1xuXHQvLyBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJwYWNrLWNvbnRyaWIvc3R5bGUtbG9hZGVyL2lzc3Vlcy8xNzdcblx0cmV0dXJuIHdpbmRvdyAmJiBkb2N1bWVudCAmJiBkb2N1bWVudC5hbGwgJiYgIXdpbmRvdy5hdG9iO1xufSk7XG5cbnZhciBnZXRUYXJnZXQgPSBmdW5jdGlvbiAodGFyZ2V0LCBwYXJlbnQpIHtcbiAgaWYgKHBhcmVudCl7XG4gICAgcmV0dXJuIHBhcmVudC5xdWVyeVNlbGVjdG9yKHRhcmdldCk7XG4gIH1cbiAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGFyZ2V0KTtcbn07XG5cbnZhciBnZXRFbGVtZW50ID0gKGZ1bmN0aW9uIChmbikge1xuXHR2YXIgbWVtbyA9IHt9O1xuXG5cdHJldHVybiBmdW5jdGlvbih0YXJnZXQsIHBhcmVudCkge1xuICAgICAgICAgICAgICAgIC8vIElmIHBhc3NpbmcgZnVuY3Rpb24gaW4gb3B0aW9ucywgdGhlbiB1c2UgaXQgZm9yIHJlc29sdmUgXCJoZWFkXCIgZWxlbWVudC5cbiAgICAgICAgICAgICAgICAvLyBVc2VmdWwgZm9yIFNoYWRvdyBSb290IHN0eWxlIGkuZVxuICAgICAgICAgICAgICAgIC8vIHtcbiAgICAgICAgICAgICAgICAvLyAgIGluc2VydEludG86IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjZm9vXCIpLnNoYWRvd1Jvb3QgfVxuICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRhcmdldCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG1lbW9bdGFyZ2V0XSA9PT0gXCJ1bmRlZmluZWRcIikge1xuXHRcdFx0dmFyIHN0eWxlVGFyZ2V0ID0gZ2V0VGFyZ2V0LmNhbGwodGhpcywgdGFyZ2V0LCBwYXJlbnQpO1xuXHRcdFx0Ly8gU3BlY2lhbCBjYXNlIHRvIHJldHVybiBoZWFkIG9mIGlmcmFtZSBpbnN0ZWFkIG9mIGlmcmFtZSBpdHNlbGZcblx0XHRcdGlmICh3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQgJiYgc3R5bGVUYXJnZXQgaW5zdGFuY2VvZiB3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQpIHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHQvLyBUaGlzIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGFjY2VzcyB0byBpZnJhbWUgaXMgYmxvY2tlZFxuXHRcdFx0XHRcdC8vIGR1ZSB0byBjcm9zcy1vcmlnaW4gcmVzdHJpY3Rpb25zXG5cdFx0XHRcdFx0c3R5bGVUYXJnZXQgPSBzdHlsZVRhcmdldC5jb250ZW50RG9jdW1lbnQuaGVhZDtcblx0XHRcdFx0fSBjYXRjaChlKSB7XG5cdFx0XHRcdFx0c3R5bGVUYXJnZXQgPSBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRtZW1vW3RhcmdldF0gPSBzdHlsZVRhcmdldDtcblx0XHR9XG5cdFx0cmV0dXJuIG1lbW9bdGFyZ2V0XVxuXHR9O1xufSkoKTtcblxudmFyIHNpbmdsZXRvbiA9IG51bGw7XG52YXJcdHNpbmdsZXRvbkNvdW50ZXIgPSAwO1xudmFyXHRzdHlsZXNJbnNlcnRlZEF0VG9wID0gW107XG5cbnZhclx0Zml4VXJscyA9IHJlcXVpcmUoXCIuL3VybHNcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obGlzdCwgb3B0aW9ucykge1xuXHRpZiAodHlwZW9mIERFQlVHICE9PSBcInVuZGVmaW5lZFwiICYmIERFQlVHKSB7XG5cdFx0aWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJvYmplY3RcIikgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHN0eWxlLWxvYWRlciBjYW5ub3QgYmUgdXNlZCBpbiBhIG5vbi1icm93c2VyIGVudmlyb25tZW50XCIpO1xuXHR9XG5cblx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0b3B0aW9ucy5hdHRycyA9IHR5cGVvZiBvcHRpb25zLmF0dHJzID09PSBcIm9iamVjdFwiID8gb3B0aW9ucy5hdHRycyA6IHt9O1xuXG5cdC8vIEZvcmNlIHNpbmdsZS10YWcgc29sdXRpb24gb24gSUU2LTksIHdoaWNoIGhhcyBhIGhhcmQgbGltaXQgb24gdGhlICMgb2YgPHN0eWxlPlxuXHQvLyB0YWdzIGl0IHdpbGwgYWxsb3cgb24gYSBwYWdlXG5cdGlmICghb3B0aW9ucy5zaW5nbGV0b24gJiYgdHlwZW9mIG9wdGlvbnMuc2luZ2xldG9uICE9PSBcImJvb2xlYW5cIikgb3B0aW9ucy5zaW5nbGV0b24gPSBpc09sZElFKCk7XG5cblx0Ly8gQnkgZGVmYXVsdCwgYWRkIDxzdHlsZT4gdGFncyB0byB0aGUgPGhlYWQ+IGVsZW1lbnRcbiAgICAgICAgaWYgKCFvcHRpb25zLmluc2VydEludG8pIG9wdGlvbnMuaW5zZXJ0SW50byA9IFwiaGVhZFwiO1xuXG5cdC8vIEJ5IGRlZmF1bHQsIGFkZCA8c3R5bGU+IHRhZ3MgdG8gdGhlIGJvdHRvbSBvZiB0aGUgdGFyZ2V0XG5cdGlmICghb3B0aW9ucy5pbnNlcnRBdCkgb3B0aW9ucy5pbnNlcnRBdCA9IFwiYm90dG9tXCI7XG5cblx0dmFyIHN0eWxlcyA9IGxpc3RUb1N0eWxlcyhsaXN0LCBvcHRpb25zKTtcblxuXHRhZGRTdHlsZXNUb0RvbShzdHlsZXMsIG9wdGlvbnMpO1xuXG5cdHJldHVybiBmdW5jdGlvbiB1cGRhdGUgKG5ld0xpc3QpIHtcblx0XHR2YXIgbWF5UmVtb3ZlID0gW107XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGl0ZW0gPSBzdHlsZXNbaV07XG5cdFx0XHR2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXTtcblxuXHRcdFx0ZG9tU3R5bGUucmVmcy0tO1xuXHRcdFx0bWF5UmVtb3ZlLnB1c2goZG9tU3R5bGUpO1xuXHRcdH1cblxuXHRcdGlmKG5ld0xpc3QpIHtcblx0XHRcdHZhciBuZXdTdHlsZXMgPSBsaXN0VG9TdHlsZXMobmV3TGlzdCwgb3B0aW9ucyk7XG5cdFx0XHRhZGRTdHlsZXNUb0RvbShuZXdTdHlsZXMsIG9wdGlvbnMpO1xuXHRcdH1cblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbWF5UmVtb3ZlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgZG9tU3R5bGUgPSBtYXlSZW1vdmVbaV07XG5cblx0XHRcdGlmKGRvbVN0eWxlLnJlZnMgPT09IDApIHtcblx0XHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykgZG9tU3R5bGUucGFydHNbal0oKTtcblxuXHRcdFx0XHRkZWxldGUgc3R5bGVzSW5Eb21bZG9tU3R5bGUuaWRdO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn07XG5cbmZ1bmN0aW9uIGFkZFN0eWxlc1RvRG9tIChzdHlsZXMsIG9wdGlvbnMpIHtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgaXRlbSA9IHN0eWxlc1tpXTtcblx0XHR2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXTtcblxuXHRcdGlmKGRvbVN0eWxlKSB7XG5cdFx0XHRkb21TdHlsZS5yZWZzKys7XG5cblx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRkb21TdHlsZS5wYXJ0c1tqXShpdGVtLnBhcnRzW2pdKTtcblx0XHRcdH1cblxuXHRcdFx0Zm9yKDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0ZG9tU3R5bGUucGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdLCBvcHRpb25zKSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBwYXJ0cyA9IFtdO1xuXG5cdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRwYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0sIG9wdGlvbnMpKTtcblx0XHRcdH1cblxuXHRcdFx0c3R5bGVzSW5Eb21baXRlbS5pZF0gPSB7aWQ6IGl0ZW0uaWQsIHJlZnM6IDEsIHBhcnRzOiBwYXJ0c307XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIGxpc3RUb1N0eWxlcyAobGlzdCwgb3B0aW9ucykge1xuXHR2YXIgc3R5bGVzID0gW107XG5cdHZhciBuZXdTdHlsZXMgPSB7fTtcblxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgaXRlbSA9IGxpc3RbaV07XG5cdFx0dmFyIGlkID0gb3B0aW9ucy5iYXNlID8gaXRlbVswXSArIG9wdGlvbnMuYmFzZSA6IGl0ZW1bMF07XG5cdFx0dmFyIGNzcyA9IGl0ZW1bMV07XG5cdFx0dmFyIG1lZGlhID0gaXRlbVsyXTtcblx0XHR2YXIgc291cmNlTWFwID0gaXRlbVszXTtcblx0XHR2YXIgcGFydCA9IHtjc3M6IGNzcywgbWVkaWE6IG1lZGlhLCBzb3VyY2VNYXA6IHNvdXJjZU1hcH07XG5cblx0XHRpZighbmV3U3R5bGVzW2lkXSkgc3R5bGVzLnB1c2gobmV3U3R5bGVzW2lkXSA9IHtpZDogaWQsIHBhcnRzOiBbcGFydF19KTtcblx0XHRlbHNlIG5ld1N0eWxlc1tpZF0ucGFydHMucHVzaChwYXJ0KTtcblx0fVxuXG5cdHJldHVybiBzdHlsZXM7XG59XG5cbmZ1bmN0aW9uIGluc2VydFN0eWxlRWxlbWVudCAob3B0aW9ucywgc3R5bGUpIHtcblx0dmFyIHRhcmdldCA9IGdldEVsZW1lbnQob3B0aW9ucy5pbnNlcnRJbnRvKVxuXG5cdGlmICghdGFyZ2V0KSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiQ291bGRuJ3QgZmluZCBhIHN0eWxlIHRhcmdldC4gVGhpcyBwcm9iYWJseSBtZWFucyB0aGF0IHRoZSB2YWx1ZSBmb3IgdGhlICdpbnNlcnRJbnRvJyBwYXJhbWV0ZXIgaXMgaW52YWxpZC5cIik7XG5cdH1cblxuXHR2YXIgbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AgPSBzdHlsZXNJbnNlcnRlZEF0VG9wW3N0eWxlc0luc2VydGVkQXRUb3AubGVuZ3RoIC0gMV07XG5cblx0aWYgKG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwidG9wXCIpIHtcblx0XHRpZiAoIWxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wKSB7XG5cdFx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKHN0eWxlLCB0YXJnZXQuZmlyc3RDaGlsZCk7XG5cdFx0fSBlbHNlIGlmIChsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcC5uZXh0U2libGluZykge1xuXHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZShzdHlsZSwgbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AubmV4dFNpYmxpbmcpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0YXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuXHRcdH1cblx0XHRzdHlsZXNJbnNlcnRlZEF0VG9wLnB1c2goc3R5bGUpO1xuXHR9IGVsc2UgaWYgKG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwiYm90dG9tXCIpIHtcblx0XHR0YXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuXHR9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zLmluc2VydEF0ID09PSBcIm9iamVjdFwiICYmIG9wdGlvbnMuaW5zZXJ0QXQuYmVmb3JlKSB7XG5cdFx0dmFyIG5leHRTaWJsaW5nID0gZ2V0RWxlbWVudChvcHRpb25zLmluc2VydEF0LmJlZm9yZSwgdGFyZ2V0KTtcblx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKHN0eWxlLCBuZXh0U2libGluZyk7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiW1N0eWxlIExvYWRlcl1cXG5cXG4gSW52YWxpZCB2YWx1ZSBmb3IgcGFyYW1ldGVyICdpbnNlcnRBdCcgKCdvcHRpb25zLmluc2VydEF0JykgZm91bmQuXFxuIE11c3QgYmUgJ3RvcCcsICdib3R0b20nLCBvciBPYmplY3QuXFxuIChodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay1jb250cmliL3N0eWxlLWxvYWRlciNpbnNlcnRhdClcXG5cIik7XG5cdH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlU3R5bGVFbGVtZW50IChzdHlsZSkge1xuXHRpZiAoc3R5bGUucGFyZW50Tm9kZSA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuXHRzdHlsZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlKTtcblxuXHR2YXIgaWR4ID0gc3R5bGVzSW5zZXJ0ZWRBdFRvcC5pbmRleE9mKHN0eWxlKTtcblx0aWYoaWR4ID49IDApIHtcblx0XHRzdHlsZXNJbnNlcnRlZEF0VG9wLnNwbGljZShpZHgsIDEpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVN0eWxlRWxlbWVudCAob3B0aW9ucykge1xuXHR2YXIgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG5cblx0aWYob3B0aW9ucy5hdHRycy50eXBlID09PSB1bmRlZmluZWQpIHtcblx0XHRvcHRpb25zLmF0dHJzLnR5cGUgPSBcInRleHQvY3NzXCI7XG5cdH1cblxuXHRpZihvcHRpb25zLmF0dHJzLm5vbmNlID09PSB1bmRlZmluZWQpIHtcblx0XHR2YXIgbm9uY2UgPSBnZXROb25jZSgpO1xuXHRcdGlmIChub25jZSkge1xuXHRcdFx0b3B0aW9ucy5hdHRycy5ub25jZSA9IG5vbmNlO1xuXHRcdH1cblx0fVxuXG5cdGFkZEF0dHJzKHN0eWxlLCBvcHRpb25zLmF0dHJzKTtcblx0aW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMsIHN0eWxlKTtcblxuXHRyZXR1cm4gc3R5bGU7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUxpbmtFbGVtZW50IChvcHRpb25zKSB7XG5cdHZhciBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxpbmtcIik7XG5cblx0aWYob3B0aW9ucy5hdHRycy50eXBlID09PSB1bmRlZmluZWQpIHtcblx0XHRvcHRpb25zLmF0dHJzLnR5cGUgPSBcInRleHQvY3NzXCI7XG5cdH1cblx0b3B0aW9ucy5hdHRycy5yZWwgPSBcInN0eWxlc2hlZXRcIjtcblxuXHRhZGRBdHRycyhsaW5rLCBvcHRpb25zLmF0dHJzKTtcblx0aW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMsIGxpbmspO1xuXG5cdHJldHVybiBsaW5rO1xufVxuXG5mdW5jdGlvbiBhZGRBdHRycyAoZWwsIGF0dHJzKSB7XG5cdE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcblx0XHRlbC5zZXRBdHRyaWJ1dGUoa2V5LCBhdHRyc1trZXldKTtcblx0fSk7XG59XG5cbmZ1bmN0aW9uIGdldE5vbmNlKCkge1xuXHRpZiAodHlwZW9mIF9fd2VicGFja19ub25jZV9fID09PSAndW5kZWZpbmVkJykge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0cmV0dXJuIF9fd2VicGFja19ub25jZV9fO1xufVxuXG5mdW5jdGlvbiBhZGRTdHlsZSAob2JqLCBvcHRpb25zKSB7XG5cdHZhciBzdHlsZSwgdXBkYXRlLCByZW1vdmUsIHJlc3VsdDtcblxuXHQvLyBJZiBhIHRyYW5zZm9ybSBmdW5jdGlvbiB3YXMgZGVmaW5lZCwgcnVuIGl0IG9uIHRoZSBjc3Ncblx0aWYgKG9wdGlvbnMudHJhbnNmb3JtICYmIG9iai5jc3MpIHtcblx0ICAgIHJlc3VsdCA9IG9wdGlvbnMudHJhbnNmb3JtKG9iai5jc3MpO1xuXG5cdCAgICBpZiAocmVzdWx0KSB7XG5cdCAgICBcdC8vIElmIHRyYW5zZm9ybSByZXR1cm5zIGEgdmFsdWUsIHVzZSB0aGF0IGluc3RlYWQgb2YgdGhlIG9yaWdpbmFsIGNzcy5cblx0ICAgIFx0Ly8gVGhpcyBhbGxvd3MgcnVubmluZyBydW50aW1lIHRyYW5zZm9ybWF0aW9ucyBvbiB0aGUgY3NzLlxuXHQgICAgXHRvYmouY3NzID0gcmVzdWx0O1xuXHQgICAgfSBlbHNlIHtcblx0ICAgIFx0Ly8gSWYgdGhlIHRyYW5zZm9ybSBmdW5jdGlvbiByZXR1cm5zIGEgZmFsc3kgdmFsdWUsIGRvbid0IGFkZCB0aGlzIGNzcy5cblx0ICAgIFx0Ly8gVGhpcyBhbGxvd3MgY29uZGl0aW9uYWwgbG9hZGluZyBvZiBjc3Ncblx0ICAgIFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHQgICAgXHRcdC8vIG5vb3Bcblx0ICAgIFx0fTtcblx0ICAgIH1cblx0fVxuXG5cdGlmIChvcHRpb25zLnNpbmdsZXRvbikge1xuXHRcdHZhciBzdHlsZUluZGV4ID0gc2luZ2xldG9uQ291bnRlcisrO1xuXG5cdFx0c3R5bGUgPSBzaW5nbGV0b24gfHwgKHNpbmdsZXRvbiA9IGNyZWF0ZVN0eWxlRWxlbWVudChvcHRpb25zKSk7XG5cblx0XHR1cGRhdGUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGUsIHN0eWxlSW5kZXgsIGZhbHNlKTtcblx0XHRyZW1vdmUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGUsIHN0eWxlSW5kZXgsIHRydWUpO1xuXG5cdH0gZWxzZSBpZiAoXG5cdFx0b2JqLnNvdXJjZU1hcCAmJlxuXHRcdHR5cGVvZiBVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBVUkwuY3JlYXRlT2JqZWN0VVJMID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgVVJMLnJldm9rZU9iamVjdFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIEJsb2IgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBidG9hID09PSBcImZ1bmN0aW9uXCJcblx0KSB7XG5cdFx0c3R5bGUgPSBjcmVhdGVMaW5rRWxlbWVudChvcHRpb25zKTtcblx0XHR1cGRhdGUgPSB1cGRhdGVMaW5rLmJpbmQobnVsbCwgc3R5bGUsIG9wdGlvbnMpO1xuXHRcdHJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZSk7XG5cblx0XHRcdGlmKHN0eWxlLmhyZWYpIFVSTC5yZXZva2VPYmplY3RVUkwoc3R5bGUuaHJlZik7XG5cdFx0fTtcblx0fSBlbHNlIHtcblx0XHRzdHlsZSA9IGNyZWF0ZVN0eWxlRWxlbWVudChvcHRpb25zKTtcblx0XHR1cGRhdGUgPSBhcHBseVRvVGFnLmJpbmQobnVsbCwgc3R5bGUpO1xuXHRcdHJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZSk7XG5cdFx0fTtcblx0fVxuXG5cdHVwZGF0ZShvYmopO1xuXG5cdHJldHVybiBmdW5jdGlvbiB1cGRhdGVTdHlsZSAobmV3T2JqKSB7XG5cdFx0aWYgKG5ld09iaikge1xuXHRcdFx0aWYgKFxuXHRcdFx0XHRuZXdPYmouY3NzID09PSBvYmouY3NzICYmXG5cdFx0XHRcdG5ld09iai5tZWRpYSA9PT0gb2JqLm1lZGlhICYmXG5cdFx0XHRcdG5ld09iai5zb3VyY2VNYXAgPT09IG9iai5zb3VyY2VNYXBcblx0XHRcdCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHVwZGF0ZShvYmogPSBuZXdPYmopO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZW1vdmUoKTtcblx0XHR9XG5cdH07XG59XG5cbnZhciByZXBsYWNlVGV4dCA9IChmdW5jdGlvbiAoKSB7XG5cdHZhciB0ZXh0U3RvcmUgPSBbXTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gKGluZGV4LCByZXBsYWNlbWVudCkge1xuXHRcdHRleHRTdG9yZVtpbmRleF0gPSByZXBsYWNlbWVudDtcblxuXHRcdHJldHVybiB0ZXh0U3RvcmUuZmlsdGVyKEJvb2xlYW4pLmpvaW4oJ1xcbicpO1xuXHR9O1xufSkoKTtcblxuZnVuY3Rpb24gYXBwbHlUb1NpbmdsZXRvblRhZyAoc3R5bGUsIGluZGV4LCByZW1vdmUsIG9iaikge1xuXHR2YXIgY3NzID0gcmVtb3ZlID8gXCJcIiA6IG9iai5jc3M7XG5cblx0aWYgKHN0eWxlLnN0eWxlU2hlZXQpIHtcblx0XHRzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSByZXBsYWNlVGV4dChpbmRleCwgY3NzKTtcblx0fSBlbHNlIHtcblx0XHR2YXIgY3NzTm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcyk7XG5cdFx0dmFyIGNoaWxkTm9kZXMgPSBzdHlsZS5jaGlsZE5vZGVzO1xuXG5cdFx0aWYgKGNoaWxkTm9kZXNbaW5kZXhdKSBzdHlsZS5yZW1vdmVDaGlsZChjaGlsZE5vZGVzW2luZGV4XSk7XG5cblx0XHRpZiAoY2hpbGROb2Rlcy5sZW5ndGgpIHtcblx0XHRcdHN0eWxlLmluc2VydEJlZm9yZShjc3NOb2RlLCBjaGlsZE5vZGVzW2luZGV4XSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHN0eWxlLmFwcGVuZENoaWxkKGNzc05vZGUpO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBhcHBseVRvVGFnIChzdHlsZSwgb2JqKSB7XG5cdHZhciBjc3MgPSBvYmouY3NzO1xuXHR2YXIgbWVkaWEgPSBvYmoubWVkaWE7XG5cblx0aWYobWVkaWEpIHtcblx0XHRzdHlsZS5zZXRBdHRyaWJ1dGUoXCJtZWRpYVwiLCBtZWRpYSlcblx0fVxuXG5cdGlmKHN0eWxlLnN0eWxlU2hlZXQpIHtcblx0XHRzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3M7XG5cdH0gZWxzZSB7XG5cdFx0d2hpbGUoc3R5bGUuZmlyc3RDaGlsZCkge1xuXHRcdFx0c3R5bGUucmVtb3ZlQ2hpbGQoc3R5bGUuZmlyc3RDaGlsZCk7XG5cdFx0fVxuXG5cdFx0c3R5bGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XG5cdH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlTGluayAobGluaywgb3B0aW9ucywgb2JqKSB7XG5cdHZhciBjc3MgPSBvYmouY3NzO1xuXHR2YXIgc291cmNlTWFwID0gb2JqLnNvdXJjZU1hcDtcblxuXHQvKlxuXHRcdElmIGNvbnZlcnRUb0Fic29sdXRlVXJscyBpc24ndCBkZWZpbmVkLCBidXQgc291cmNlbWFwcyBhcmUgZW5hYmxlZFxuXHRcdGFuZCB0aGVyZSBpcyBubyBwdWJsaWNQYXRoIGRlZmluZWQgdGhlbiBsZXRzIHR1cm4gY29udmVydFRvQWJzb2x1dGVVcmxzXG5cdFx0b24gYnkgZGVmYXVsdC4gIE90aGVyd2lzZSBkZWZhdWx0IHRvIHRoZSBjb252ZXJ0VG9BYnNvbHV0ZVVybHMgb3B0aW9uXG5cdFx0ZGlyZWN0bHlcblx0Ki9cblx0dmFyIGF1dG9GaXhVcmxzID0gb3B0aW9ucy5jb252ZXJ0VG9BYnNvbHV0ZVVybHMgPT09IHVuZGVmaW5lZCAmJiBzb3VyY2VNYXA7XG5cblx0aWYgKG9wdGlvbnMuY29udmVydFRvQWJzb2x1dGVVcmxzIHx8IGF1dG9GaXhVcmxzKSB7XG5cdFx0Y3NzID0gZml4VXJscyhjc3MpO1xuXHR9XG5cblx0aWYgKHNvdXJjZU1hcCkge1xuXHRcdC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI2NjAzODc1XG5cdFx0Y3NzICs9IFwiXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxcIiArIGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSkgKyBcIiAqL1wiO1xuXHR9XG5cblx0dmFyIGJsb2IgPSBuZXcgQmxvYihbY3NzXSwgeyB0eXBlOiBcInRleHQvY3NzXCIgfSk7XG5cblx0dmFyIG9sZFNyYyA9IGxpbmsuaHJlZjtcblxuXHRsaW5rLmhyZWYgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuXG5cdGlmKG9sZFNyYykgVVJMLnJldm9rZU9iamVjdFVSTChvbGRTcmMpO1xufVxuIiwiXG4vKipcbiAqIFdoZW4gc291cmNlIG1hcHMgYXJlIGVuYWJsZWQsIGBzdHlsZS1sb2FkZXJgIHVzZXMgYSBsaW5rIGVsZW1lbnQgd2l0aCBhIGRhdGEtdXJpIHRvXG4gKiBlbWJlZCB0aGUgY3NzIG9uIHRoZSBwYWdlLiBUaGlzIGJyZWFrcyBhbGwgcmVsYXRpdmUgdXJscyBiZWNhdXNlIG5vdyB0aGV5IGFyZSByZWxhdGl2ZSB0byBhXG4gKiBidW5kbGUgaW5zdGVhZCBvZiB0aGUgY3VycmVudCBwYWdlLlxuICpcbiAqIE9uZSBzb2x1dGlvbiBpcyB0byBvbmx5IHVzZSBmdWxsIHVybHMsIGJ1dCB0aGF0IG1heSBiZSBpbXBvc3NpYmxlLlxuICpcbiAqIEluc3RlYWQsIHRoaXMgZnVuY3Rpb24gXCJmaXhlc1wiIHRoZSByZWxhdGl2ZSB1cmxzIHRvIGJlIGFic29sdXRlIGFjY29yZGluZyB0byB0aGUgY3VycmVudCBwYWdlIGxvY2F0aW9uLlxuICpcbiAqIEEgcnVkaW1lbnRhcnkgdGVzdCBzdWl0ZSBpcyBsb2NhdGVkIGF0IGB0ZXN0L2ZpeFVybHMuanNgIGFuZCBjYW4gYmUgcnVuIHZpYSB0aGUgYG5wbSB0ZXN0YCBjb21tYW5kLlxuICpcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjc3MpIHtcbiAgLy8gZ2V0IGN1cnJlbnQgbG9jYXRpb25cbiAgdmFyIGxvY2F0aW9uID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cubG9jYXRpb247XG5cbiAgaWYgKCFsb2NhdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcihcImZpeFVybHMgcmVxdWlyZXMgd2luZG93LmxvY2F0aW9uXCIpO1xuICB9XG5cblx0Ly8gYmxhbmsgb3IgbnVsbD9cblx0aWYgKCFjc3MgfHwgdHlwZW9mIGNzcyAhPT0gXCJzdHJpbmdcIikge1xuXHQgIHJldHVybiBjc3M7XG4gIH1cblxuICB2YXIgYmFzZVVybCA9IGxvY2F0aW9uLnByb3RvY29sICsgXCIvL1wiICsgbG9jYXRpb24uaG9zdDtcbiAgdmFyIGN1cnJlbnREaXIgPSBiYXNlVXJsICsgbG9jYXRpb24ucGF0aG5hbWUucmVwbGFjZSgvXFwvW15cXC9dKiQvLCBcIi9cIik7XG5cblx0Ly8gY29udmVydCBlYWNoIHVybCguLi4pXG5cdC8qXG5cdFRoaXMgcmVndWxhciBleHByZXNzaW9uIGlzIGp1c3QgYSB3YXkgdG8gcmVjdXJzaXZlbHkgbWF0Y2ggYnJhY2tldHMgd2l0aGluXG5cdGEgc3RyaW5nLlxuXG5cdCAvdXJsXFxzKlxcKCAgPSBNYXRjaCBvbiB0aGUgd29yZCBcInVybFwiIHdpdGggYW55IHdoaXRlc3BhY2UgYWZ0ZXIgaXQgYW5kIHRoZW4gYSBwYXJlbnNcblx0ICAgKCAgPSBTdGFydCBhIGNhcHR1cmluZyBncm91cFxuXHQgICAgICg/OiAgPSBTdGFydCBhIG5vbi1jYXB0dXJpbmcgZ3JvdXBcblx0ICAgICAgICAgW14pKF0gID0gTWF0Y2ggYW55dGhpbmcgdGhhdCBpc24ndCBhIHBhcmVudGhlc2VzXG5cdCAgICAgICAgIHwgID0gT1Jcblx0ICAgICAgICAgXFwoICA9IE1hdGNoIGEgc3RhcnQgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICg/OiAgPSBTdGFydCBhbm90aGVyIG5vbi1jYXB0dXJpbmcgZ3JvdXBzXG5cdCAgICAgICAgICAgICAgICAgW14pKF0rICA9IE1hdGNoIGFueXRoaW5nIHRoYXQgaXNuJ3QgYSBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgICAgIHwgID0gT1Jcblx0ICAgICAgICAgICAgICAgICBcXCggID0gTWF0Y2ggYSBzdGFydCBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgICAgICAgICBbXikoXSogID0gTWF0Y2ggYW55dGhpbmcgdGhhdCBpc24ndCBhIHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAgICAgXFwpICA9IE1hdGNoIGEgZW5kIHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICApICA9IEVuZCBHcm91cFxuICAgICAgICAgICAgICAqXFwpID0gTWF0Y2ggYW55dGhpbmcgYW5kIHRoZW4gYSBjbG9zZSBwYXJlbnNcbiAgICAgICAgICApICA9IENsb3NlIG5vbi1jYXB0dXJpbmcgZ3JvdXBcbiAgICAgICAgICAqICA9IE1hdGNoIGFueXRoaW5nXG4gICAgICAgKSAgPSBDbG9zZSBjYXB0dXJpbmcgZ3JvdXBcblx0IFxcKSAgPSBNYXRjaCBhIGNsb3NlIHBhcmVuc1xuXG5cdCAvZ2kgID0gR2V0IGFsbCBtYXRjaGVzLCBub3QgdGhlIGZpcnN0LiAgQmUgY2FzZSBpbnNlbnNpdGl2ZS5cblx0ICovXG5cdHZhciBmaXhlZENzcyA9IGNzcy5yZXBsYWNlKC91cmxcXHMqXFwoKCg/OlteKShdfFxcKCg/OlteKShdK3xcXChbXikoXSpcXCkpKlxcKSkqKVxcKS9naSwgZnVuY3Rpb24oZnVsbE1hdGNoLCBvcmlnVXJsKSB7XG5cdFx0Ly8gc3RyaXAgcXVvdGVzIChpZiB0aGV5IGV4aXN0KVxuXHRcdHZhciB1bnF1b3RlZE9yaWdVcmwgPSBvcmlnVXJsXG5cdFx0XHQudHJpbSgpXG5cdFx0XHQucmVwbGFjZSgvXlwiKC4qKVwiJC8sIGZ1bmN0aW9uKG8sICQxKXsgcmV0dXJuICQxOyB9KVxuXHRcdFx0LnJlcGxhY2UoL14nKC4qKSckLywgZnVuY3Rpb24obywgJDEpeyByZXR1cm4gJDE7IH0pO1xuXG5cdFx0Ly8gYWxyZWFkeSBhIGZ1bGwgdXJsPyBubyBjaGFuZ2Vcblx0XHRpZiAoL14oI3xkYXRhOnxodHRwOlxcL1xcL3xodHRwczpcXC9cXC98ZmlsZTpcXC9cXC9cXC98XFxzKiQpL2kudGVzdCh1bnF1b3RlZE9yaWdVcmwpKSB7XG5cdFx0ICByZXR1cm4gZnVsbE1hdGNoO1xuXHRcdH1cblxuXHRcdC8vIGNvbnZlcnQgdGhlIHVybCB0byBhIGZ1bGwgdXJsXG5cdFx0dmFyIG5ld1VybDtcblxuXHRcdGlmICh1bnF1b3RlZE9yaWdVcmwuaW5kZXhPZihcIi8vXCIpID09PSAwKSB7XG5cdFx0ICBcdC8vVE9ETzogc2hvdWxkIHdlIGFkZCBwcm90b2NvbD9cblx0XHRcdG5ld1VybCA9IHVucXVvdGVkT3JpZ1VybDtcblx0XHR9IGVsc2UgaWYgKHVucXVvdGVkT3JpZ1VybC5pbmRleE9mKFwiL1wiKSA9PT0gMCkge1xuXHRcdFx0Ly8gcGF0aCBzaG91bGQgYmUgcmVsYXRpdmUgdG8gdGhlIGJhc2UgdXJsXG5cdFx0XHRuZXdVcmwgPSBiYXNlVXJsICsgdW5xdW90ZWRPcmlnVXJsOyAvLyBhbHJlYWR5IHN0YXJ0cyB3aXRoICcvJ1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBwYXRoIHNob3VsZCBiZSByZWxhdGl2ZSB0byBjdXJyZW50IGRpcmVjdG9yeVxuXHRcdFx0bmV3VXJsID0gY3VycmVudERpciArIHVucXVvdGVkT3JpZ1VybC5yZXBsYWNlKC9eXFwuXFwvLywgXCJcIik7IC8vIFN0cmlwIGxlYWRpbmcgJy4vJ1xuXHRcdH1cblxuXHRcdC8vIHNlbmQgYmFjayB0aGUgZml4ZWQgdXJsKC4uLilcblx0XHRyZXR1cm4gXCJ1cmwoXCIgKyBKU09OLnN0cmluZ2lmeShuZXdVcmwpICsgXCIpXCI7XG5cdH0pO1xuXG5cdC8vIHNlbmQgYmFjayB0aGUgZml4ZWQgY3NzXG5cdHJldHVybiBmaXhlZENzcztcbn07XG4iLCJ2YXIgc2NvcGUgPSAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnbG9iYWwpIHx8XG4gICAgICAgICAgICAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZikgfHxcbiAgICAgICAgICAgIHdpbmRvdztcbnZhciBhcHBseSA9IEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseTtcblxuLy8gRE9NIEFQSXMsIGZvciBjb21wbGV0ZW5lc3NcblxuZXhwb3J0cy5zZXRUaW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldFRpbWVvdXQsIHNjb3BlLCBhcmd1bWVudHMpLCBjbGVhclRpbWVvdXQpO1xufTtcbmV4cG9ydHMuc2V0SW50ZXJ2YWwgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0SW50ZXJ2YWwsIHNjb3BlLCBhcmd1bWVudHMpLCBjbGVhckludGVydmFsKTtcbn07XG5leHBvcnRzLmNsZWFyVGltZW91dCA9XG5leHBvcnRzLmNsZWFySW50ZXJ2YWwgPSBmdW5jdGlvbih0aW1lb3V0KSB7XG4gIGlmICh0aW1lb3V0KSB7XG4gICAgdGltZW91dC5jbG9zZSgpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBUaW1lb3V0KGlkLCBjbGVhckZuKSB7XG4gIHRoaXMuX2lkID0gaWQ7XG4gIHRoaXMuX2NsZWFyRm4gPSBjbGVhckZuO1xufVxuVGltZW91dC5wcm90b3R5cGUudW5yZWYgPSBUaW1lb3V0LnByb3RvdHlwZS5yZWYgPSBmdW5jdGlvbigpIHt9O1xuVGltZW91dC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fY2xlYXJGbi5jYWxsKHNjb3BlLCB0aGlzLl9pZCk7XG59O1xuXG4vLyBEb2VzIG5vdCBzdGFydCB0aGUgdGltZSwganVzdCBzZXRzIHVwIHRoZSBtZW1iZXJzIG5lZWRlZC5cbmV4cG9ydHMuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSwgbXNlY3MpIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuICBpdGVtLl9pZGxlVGltZW91dCA9IG1zZWNzO1xufTtcblxuZXhwb3J0cy51bmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuICBpdGVtLl9pZGxlVGltZW91dCA9IC0xO1xufTtcblxuZXhwb3J0cy5fdW5yZWZBY3RpdmUgPSBleHBvcnRzLmFjdGl2ZSA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuXG4gIHZhciBtc2VjcyA9IGl0ZW0uX2lkbGVUaW1lb3V0O1xuICBpZiAobXNlY3MgPj0gMCkge1xuICAgIGl0ZW0uX2lkbGVUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uIG9uVGltZW91dCgpIHtcbiAgICAgIGlmIChpdGVtLl9vblRpbWVvdXQpXG4gICAgICAgIGl0ZW0uX29uVGltZW91dCgpO1xuICAgIH0sIG1zZWNzKTtcbiAgfVxufTtcblxuLy8gc2V0aW1tZWRpYXRlIGF0dGFjaGVzIGl0c2VsZiB0byB0aGUgZ2xvYmFsIG9iamVjdFxucmVxdWlyZShcInNldGltbWVkaWF0ZVwiKTtcbi8vIE9uIHNvbWUgZXhvdGljIGVudmlyb25tZW50cywgaXQncyBub3QgY2xlYXIgd2hpY2ggb2JqZWN0IGBzZXRpbW1lZGlhdGVgIHdhc1xuLy8gYWJsZSB0byBpbnN0YWxsIG9udG8uICBTZWFyY2ggZWFjaCBwb3NzaWJpbGl0eSBpbiB0aGUgc2FtZSBvcmRlciBhcyB0aGVcbi8vIGBzZXRpbW1lZGlhdGVgIGxpYnJhcnkuXG5leHBvcnRzLnNldEltbWVkaWF0ZSA9ICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBzZWxmLnNldEltbWVkaWF0ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2xvYmFsLnNldEltbWVkaWF0ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMgJiYgdGhpcy5zZXRJbW1lZGlhdGUpO1xuZXhwb3J0cy5jbGVhckltbWVkaWF0ZSA9ICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBzZWxmLmNsZWFySW1tZWRpYXRlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiICYmIGdsb2JhbC5jbGVhckltbWVkaWF0ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAodGhpcyAmJiB0aGlzLmNsZWFySW1tZWRpYXRlKTtcbiIsIlxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlcHJlY2F0ZTtcblxuLyoqXG4gKiBNYXJrIHRoYXQgYSBtZXRob2Qgc2hvdWxkIG5vdCBiZSB1c2VkLlxuICogUmV0dXJucyBhIG1vZGlmaWVkIGZ1bmN0aW9uIHdoaWNoIHdhcm5zIG9uY2UgYnkgZGVmYXVsdC5cbiAqXG4gKiBJZiBgbG9jYWxTdG9yYWdlLm5vRGVwcmVjYXRpb24gPSB0cnVlYCBpcyBzZXQsIHRoZW4gaXQgaXMgYSBuby1vcC5cbiAqXG4gKiBJZiBgbG9jYWxTdG9yYWdlLnRocm93RGVwcmVjYXRpb24gPSB0cnVlYCBpcyBzZXQsIHRoZW4gZGVwcmVjYXRlZCBmdW5jdGlvbnNcbiAqIHdpbGwgdGhyb3cgYW4gRXJyb3Igd2hlbiBpbnZva2VkLlxuICpcbiAqIElmIGBsb2NhbFN0b3JhZ2UudHJhY2VEZXByZWNhdGlvbiA9IHRydWVgIGlzIHNldCwgdGhlbiBkZXByZWNhdGVkIGZ1bmN0aW9uc1xuICogd2lsbCBpbnZva2UgYGNvbnNvbGUudHJhY2UoKWAgaW5zdGVhZCBvZiBgY29uc29sZS5lcnJvcigpYC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAtIHRoZSBmdW5jdGlvbiB0byBkZXByZWNhdGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBtc2cgLSB0aGUgc3RyaW5nIHRvIHByaW50IHRvIHRoZSBjb25zb2xlIHdoZW4gYGZuYCBpcyBpbnZva2VkXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IGEgbmV3IFwiZGVwcmVjYXRlZFwiIHZlcnNpb24gb2YgYGZuYFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBkZXByZWNhdGUgKGZuLCBtc2cpIHtcbiAgaWYgKGNvbmZpZygnbm9EZXByZWNhdGlvbicpKSB7XG4gICAgcmV0dXJuIGZuO1xuICB9XG5cbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBkZXByZWNhdGVkKCkge1xuICAgIGlmICghd2FybmVkKSB7XG4gICAgICBpZiAoY29uZmlnKCd0aHJvd0RlcHJlY2F0aW9uJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICB9IGVsc2UgaWYgKGNvbmZpZygndHJhY2VEZXByZWNhdGlvbicpKSB7XG4gICAgICAgIGNvbnNvbGUudHJhY2UobXNnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUud2Fybihtc2cpO1xuICAgICAgfVxuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICByZXR1cm4gZGVwcmVjYXRlZDtcbn1cblxuLyoqXG4gKiBDaGVja3MgYGxvY2FsU3RvcmFnZWAgZm9yIGJvb2xlYW4gdmFsdWVzIGZvciB0aGUgZ2l2ZW4gYG5hbWVgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGNvbmZpZyAobmFtZSkge1xuICAvLyBhY2Nlc3NpbmcgZ2xvYmFsLmxvY2FsU3RvcmFnZSBjYW4gdHJpZ2dlciBhIERPTUV4Y2VwdGlvbiBpbiBzYW5kYm94ZWQgaWZyYW1lc1xuICB0cnkge1xuICAgIGlmICghZ2xvYmFsLmxvY2FsU3RvcmFnZSkgcmV0dXJuIGZhbHNlO1xuICB9IGNhdGNoIChfKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB2YWwgPSBnbG9iYWwubG9jYWxTdG9yYWdlW25hbWVdO1xuICBpZiAobnVsbCA9PSB2YWwpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIFN0cmluZyh2YWwpLnRvTG93ZXJDYXNlKCkgPT09ICd0cnVlJztcbn1cbiIsInZhciBnO1xyXG5cclxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcclxuZyA9IChmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gdGhpcztcclxufSkoKTtcclxuXHJcbnRyeSB7XHJcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXHJcblx0ZyA9IGcgfHwgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpIHx8ICgxLCBldmFsKShcInRoaXNcIik7XHJcbn0gY2F0Y2ggKGUpIHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxyXG5cdGlmICh0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKSBnID0gd2luZG93O1xyXG59XHJcblxyXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXHJcbi8vIFdlIHJldHVybiB1bmRlZmluZWQsIGluc3RlYWQgb2Ygbm90aGluZyBoZXJlLCBzbyBpdCdzXHJcbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZztcclxuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvcmlnaW5hbE1vZHVsZSkge1xuXHRpZiAoIW9yaWdpbmFsTW9kdWxlLndlYnBhY2tQb2x5ZmlsbCkge1xuXHRcdHZhciBtb2R1bGUgPSBPYmplY3QuY3JlYXRlKG9yaWdpbmFsTW9kdWxlKTtcblx0XHQvLyBtb2R1bGUucGFyZW50ID0gdW5kZWZpbmVkIGJ5IGRlZmF1bHRcblx0XHRpZiAoIW1vZHVsZS5jaGlsZHJlbikgbW9kdWxlLmNoaWxkcmVuID0gW107XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJsb2FkZWRcIiwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBtb2R1bGUubDtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImlkXCIsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJleHBvcnRzXCIsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWVcblx0XHR9KTtcblx0XHRtb2R1bGUud2VicGFja1BvbHlmaWxsID0gMTtcblx0fVxuXHRyZXR1cm4gbW9kdWxlO1xufTtcbiIsImxldCBnZW5DdWJlID0gKCBfcHJvcHMgKSA9PiB7XG4gIGxldCBwcm9wcyA9IE9iamVjdC5hc3NpZ24oIHtcbiAgICBzaXplOiAxLjBcbiAgfSwgX3Byb3BzICk7XG5cbiAgbGV0IHBvcyA9IFtdO1xuICBsZXQgbm9yID0gW107XG4gIGxldCBpbmQgPSBbXTtcblxuICBjb25zdCBTID0gcHJvcHMuc2l6ZTtcblxuICBmb3IgKCBsZXQgaSA9IDA7IGkgPCA2OyBpICsrICkge1xuICAgIGxldCBwID0gW1xuICAgICAgWyAtUywgLVMsICBTIF0sXG4gICAgICBbICBTLCAtUywgIFMgXSxcbiAgICAgIFsgLVMsICBTLCAgUyBdLFxuICAgICAgWyAgUywgIFMsICBTIF1cbiAgICBdO1xuICAgIGxldCBuID0gW1xuICAgICAgWyAwLCAwLCAxIF0sXG4gICAgICBbIDAsIDAsIDEgXSxcbiAgICAgIFsgMCwgMCwgMSBdLFxuICAgICAgWyAwLCAwLCAxIF1cbiAgICBdO1xuICAgIGxldCBpZCA9IFtcbiAgICAgIDAsIDEsIDMsXG4gICAgICAwLCAzLCAyXG4gICAgXS5tYXAoICggdiApID0+IHYgKyBpICogNCApO1xuXG4gICAgaWYgKCBpICE9PSAwICkge1xuICAgICAgbGV0IGZ1bmMgPSAoIHYgKSA9PiB7XG4gICAgICAgIGlmICggaSA8IDQgKSB7XG4gICAgICAgICAgbGV0IHQgPSBpICogTWF0aC5QSSAvIDIuMDtcbiAgICAgICAgICBsZXQgeCA9IHZbIDAgXTtcbiAgICAgICAgICBsZXQgeiA9IHZbIDIgXTtcbiAgICAgICAgICB2WyAwIF0gPSBNYXRoLmNvcyggdCApICogeCAtIE1hdGguc2luKCB0ICkgKiB6O1xuICAgICAgICAgIHZbIDIgXSA9IE1hdGguc2luKCB0ICkgKiB4ICsgTWF0aC5jb3MoIHQgKSAqIHo7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGV0IHQgPSAoIGkgLSAwLjUgKSAqIE1hdGguUEk7XG4gICAgICAgICAgbGV0IHkgPSB2WyAxIF07XG4gICAgICAgICAgbGV0IHogPSB2WyAyIF07XG4gICAgICAgICAgdlsgMSBdID0gTWF0aC5jb3MoIHQgKSAqIHkgLSBNYXRoLnNpbiggdCApICogejtcbiAgICAgICAgICB2WyAyIF0gPSBNYXRoLnNpbiggdCApICogeSArIE1hdGguY29zKCB0ICkgKiB6O1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBwLm1hcCggZnVuYyApO1xuICAgICAgbi5tYXAoIGZ1bmMgKTtcbiAgICB9XG5cbiAgICBwLm1hcCggKCB2ICkgPT4gcG9zLnB1c2goIC4uLnYgKSApO1xuICAgIG4ubWFwKCAoIHYgKSA9PiBub3IucHVzaCggLi4udiApICk7XG4gICAgaW5kLnB1c2goIC4uLmlkICk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHBvc2l0aW9uOiBwb3MsXG4gICAgbm9ybWFsOiBub3IsXG4gICAgaW5kZXg6IGluZFxuICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBnZW5DdWJlOyIsImxldCBnZW5PY3RhaGVkcm9uID0gKCBfcHJvcHMgKSA9PiB7XG4gIGxldCBwcm9wcyA9IE9iamVjdC5hc3NpZ24oIHtcbiAgICBkaXY6IDEuMFxuICB9LCBfcHJvcHMgKTtcblxuICBsZXQgZGl2ID0gcGFyc2VJbnQoIE1hdGgubWF4KCAwLCBwcm9wcy5kaXYgKSApO1xuXG4gIGxldCBwb3MgPSBbXTtcbiAgbGV0IG5vciA9IFtdO1xuICBsZXQgaW5kID0gW107XG5cbiAgZm9yICggbGV0IGlpID0gMDsgaWkgPCAyOyBpaSArKyApIHtcbiAgICBmb3IgKCBsZXQgaXEgPSAwOyBpcSA8IDQ7IGlxICsrICkge1xuICAgICAgZm9yICggbGV0IGl5ID0gMDsgaXkgPCBkaXYgKyAxOyBpeSArKyApIHtcbiAgICAgICAgZm9yICggbGV0IGl4ID0gMDsgaXggPCBpeSArIDE7IGl4ICsrICkge1xuICAgICAgICAgIGxldCBsYXQwID0gKCBpaSAqIDIuMCArIGl5IC8gKCBkaXYgKyAxICkgKSAqIE1hdGguUEkgLyAyLjA7XG4gICAgICAgICAgbGV0IGxhdDEgPSAoIGlpICogMi4wICsgKCBpeSArIDEgKSAvICggZGl2ICsgMSApICkgKiBNYXRoLlBJIC8gMi4wO1xuXG4gICAgICAgICAgbGV0IGxvbjAgPSAoIGlpICogMi4wIC0gMS4wICkgKiAoICggaXggLSAxICkgLyBNYXRoLm1heCggMSwgaXkgKSArIGlxICkgKiBNYXRoLlBJIC8gMi4wO1xuICAgICAgICAgIGxldCBsb24xID0gKCBpaSAqIDIuMCAtIDEuMCApICogKCBpeCAvICggaXkgKyAxICkgKyBpcSApICogTWF0aC5QSSAvIDIuMDtcbiAgICAgICAgICBsZXQgbG9uMiA9ICggaWkgKiAyLjAgLSAxLjAgKSAqICggaXggLyBNYXRoLm1heCggMSwgaXkgKSArIGlxICkgKiBNYXRoLlBJIC8gMi4wO1xuICAgICAgICAgIGxldCBsb24zID0gKCBpaSAqIDIuMCAtIDEuMCApICogKCAoIGl4ICsgMSApIC8gKCBpeSArIDEgKSArIGlxICkgKiBNYXRoLlBJIC8gMi4wO1xuXG4gICAgICAgICAgaWYgKCBpeCAhPT0gMCApIHtcbiAgICAgICAgICAgIGluZC5wdXNoKFxuICAgICAgICAgICAgICBwb3MubGVuZ3RoIC8gMyxcbiAgICAgICAgICAgICAgcG9zLmxlbmd0aCAvIDMgKyAxLFxuICAgICAgICAgICAgICBwb3MubGVuZ3RoIC8gMyArIDJcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGxldCB4MSA9IE1hdGguc2luKCBsYXQwICkgKiBNYXRoLmNvcyggbG9uMCApO1xuICAgICAgICAgICAgbGV0IHkxID0gTWF0aC5jb3MoIGxhdDAgKTtcbiAgICAgICAgICAgIGxldCB6MSA9IE1hdGguc2luKCBsYXQwICkgKiBNYXRoLnNpbiggbG9uMCApO1xuXG4gICAgICAgICAgICBsZXQgeDIgPSBNYXRoLnNpbiggbGF0MSApICogTWF0aC5jb3MoIGxvbjEgKTtcbiAgICAgICAgICAgIGxldCB5MiA9IE1hdGguY29zKCBsYXQxICk7XG4gICAgICAgICAgICBsZXQgejIgPSBNYXRoLnNpbiggbGF0MSApICogTWF0aC5zaW4oIGxvbjEgKTtcblxuICAgICAgICAgICAgbGV0IHgzID0gTWF0aC5zaW4oIGxhdDAgKSAqIE1hdGguY29zKCBsb24yICk7XG4gICAgICAgICAgICBsZXQgeTMgPSBNYXRoLmNvcyggbGF0MCApO1xuICAgICAgICAgICAgbGV0IHozID0gTWF0aC5zaW4oIGxhdDAgKSAqIE1hdGguc2luKCBsb24yICk7XG5cbiAgICAgICAgICAgIHBvcy5wdXNoKFxuICAgICAgICAgICAgICB4MSwgeTEsIHoxLFxuICAgICAgICAgICAgICB4MiwgeTIsIHoyLFxuICAgICAgICAgICAgICB4MywgeTMsIHozXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGxldCB4ID0geDEgKyB4MiArIHgzO1xuICAgICAgICAgICAgICBsZXQgeSA9IHkxICsgeTIgKyB5MztcbiAgICAgICAgICAgICAgbGV0IHogPSB6MSArIHoyICsgejM7XG4gICAgICAgICAgICAgIGxldCBsID0gTWF0aC5zcXJ0KCB4ICogeCArIHkgKiB5ICsgeiAqIHogKTtcblxuICAgICAgICAgICAgICBmb3IgKCBsZXQgaSA9IDA7IGkgPCAzOyBpICsrICkge1xuICAgICAgICAgICAgICAgIG5vci5wdXNoKFxuICAgICAgICAgICAgICAgICAgeCAvIGwsXG4gICAgICAgICAgICAgICAgICB5IC8gbCxcbiAgICAgICAgICAgICAgICAgIHogLyBsXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGluZC5wdXNoKFxuICAgICAgICAgICAgICBwb3MubGVuZ3RoIC8gMyxcbiAgICAgICAgICAgICAgcG9zLmxlbmd0aCAvIDMgKyAxLFxuICAgICAgICAgICAgICBwb3MubGVuZ3RoIC8gMyArIDJcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGxldCB4MSA9IE1hdGguc2luKCBsYXQwICkgKiBNYXRoLmNvcyggbG9uMiApO1xuICAgICAgICAgICAgbGV0IHkxID0gTWF0aC5jb3MoIGxhdDAgKTtcbiAgICAgICAgICAgIGxldCB6MSA9IE1hdGguc2luKCBsYXQwICkgKiBNYXRoLnNpbiggbG9uMiApO1xuXG4gICAgICAgICAgICBsZXQgeDIgPSBNYXRoLnNpbiggbGF0MSApICogTWF0aC5jb3MoIGxvbjEgKTtcbiAgICAgICAgICAgIGxldCB5MiA9IE1hdGguY29zKCBsYXQxICk7XG4gICAgICAgICAgICBsZXQgejIgPSBNYXRoLnNpbiggbGF0MSApICogTWF0aC5zaW4oIGxvbjEgKTtcblxuICAgICAgICAgICAgbGV0IHgzID0gTWF0aC5zaW4oIGxhdDEgKSAqIE1hdGguY29zKCBsb24zICk7XG4gICAgICAgICAgICBsZXQgeTMgPSBNYXRoLmNvcyggbGF0MSApO1xuICAgICAgICAgICAgbGV0IHozID0gTWF0aC5zaW4oIGxhdDEgKSAqIE1hdGguc2luKCBsb24zICk7XG5cbiAgICAgICAgICAgIHBvcy5wdXNoKFxuICAgICAgICAgICAgICB4MSwgeTEsIHoxLFxuICAgICAgICAgICAgICB4MiwgeTIsIHoyLFxuICAgICAgICAgICAgICB4MywgeTMsIHozXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGxldCB4ID0geDEgKyB4MiArIHgzO1xuICAgICAgICAgICAgICBsZXQgeSA9IHkxICsgeTIgKyB5MztcbiAgICAgICAgICAgICAgbGV0IHogPSB6MSArIHoyICsgejM7XG4gICAgICAgICAgICAgIGxldCBsID0gTWF0aC5zcXJ0KCB4ICogeCArIHkgKiB5ICsgeiAqIHogKTtcblxuICAgICAgICAgICAgICBmb3IgKCBsZXQgaSA9IDA7IGkgPCAzOyBpICsrICkge1xuICAgICAgICAgICAgICAgIG5vci5wdXNoKFxuICAgICAgICAgICAgICAgICAgeCAvIGwsXG4gICAgICAgICAgICAgICAgICB5IC8gbCxcbiAgICAgICAgICAgICAgICAgIHogLyBsXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgcG9zaXRpb246IHBvcyxcbiAgICBub3JtYWw6IG5vcixcbiAgICBpbmRleDogaW5kXG4gIH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdlbk9jdGFoZWRyb247IiwibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFCQUFBQUFRQUNBSUFBQUR3Zjd6VUFBQUJHMmxVV0hSWVRVdzZZMjl0TG1Ga2IySmxMbmh0Y0FBQUFBQUFQRDk0Y0dGamEyVjBJR0psWjJsdVBTTHZ1NzhpSUdsa1BTSlhOVTB3VFhCRFpXaHBTSHB5WlZONlRsUmplbXRqT1dRaVB6NEtQSGc2ZUcxd2JXVjBZU0I0Yld4dWN6cDRQU0poWkc5aVpUcHVjenB0WlhSaEx5SWdlRHA0YlhCMGF6MGlXRTFRSUVOdmNtVWdOUzQxTGpBaVBnb2dQSEprWmpwU1JFWWdlRzFzYm5NNmNtUm1QU0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh4T1RrNUx6QXlMekl5TFhKa1ppMXplVzUwWVhndGJuTWpJajRLSUNBOGNtUm1Pa1JsYzJOeWFYQjBhVzl1SUhKa1pqcGhZbTkxZEQwaUlpOCtDaUE4TDNKa1pqcFNSRVkrQ2p3dmVEcDRiWEJ0WlhSaFBnbzhQM2h3WVdOclpYUWdaVzVrUFNKeUlqOCtHa3FyNmdBQUFZRnBRME5RYzFKSFFpQkpSVU0yTVRrMk5pMHlMakVBQUNpUmRaSFBLMFJSRk1jL000UHhZMFNSRkl0SldBMHhhbUpqTVJORFlURkdHV3htbnZtaDVzZnJ2WmswMlNyYktVcHMvRnJ3RjdCVjFrb1JLVmxZV1JNYnB1YzhvMFl5NTNidStkenZ2ZWQwNzdsZ0RTYVZsRjQxQUtsMFZndjR2Yzc1MElMVC9rUWRIYlFCTldGRlY2ZG54NE5VdFBkYkxHYTg3ak5yVlQ3M3J6VXNSM1VGTExYQ280cXFaWVVuaEtkV3M2ckpXOEt0U2lLOExId2k3TkxrZ3NJM3BoNHA4YlBKOFJKL21xd0ZBejZ3TmdzNzQ3ODQ4b3VWaEpZU2xwZlRuVXJtbEovN21DOXhSTk56c3hLN3hEdlJDZURIaTVOSnh2RGhZWkFSbVQzMDRhWmZWbFRJSC9qT255RWp1WXJNS25rMFZvaVRJSXRMMUp4VWowcU1pUjZWa1NSdjl2OXZYL1hZa0x0VTNlR0Y2a2ZEZU8wQit5WVVDNGJ4Y1dBWXhVT3dQY0I1dXB5ZjJZZmhOOUVMWmExN0Q1clc0ZlNpckVXMjRXd0QydS9Wc0JiK2xtemkxbGdNWG82aE1RUXRWMUMvV09yWnp6NUhkeEJjazYrNmhKMWQ2Slh6VFV0ZkdIRm53dXk5VXcwQUFBQUpjRWhaY3dBQUN4TUFBQXNUQVFDYW5CZ0FBQ0FBU1VSQlZIaWM3TjE1bUZ4Vm5UL2dUd2hKUXdNaEVBZ2hoZ0FoZ2hpR0FVRVlpVERpQUk3S0NEcTRqYU1zZ2hBUVJIK0M0Q0NJK3lpb2dLQnNnZ3ZJTG9zZ3EyQ1VWZGFoTy92U1NjaENRbWZwYk4yZFR0ZnZqNkxLN3E3cXBMT0IwZmQ5Nm5tNHVmZWNjOCs5VlFubmUrOVpFZ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFEK0x2VjZzeXNBOE9ZYmxBeEx0azRXSlpPU3VXOTJmVmhITmNud1pIQ1NaRll5S1dsNWsyc0VBTURmaHYyVFI1T1ZTYUgwYVVzZVNQWjZzeXZHMnFsSnprOWU3ZkNGRnBMWnlWZmU3SW9CQUx6NUxrdm1kVzRuOWZDek5May9HZmhtMTMvZGZTeHA2dVlhRzVNUHZ0blZZMDNWSnZkMi83dTlQYWw1czJ1NEhnMU03aytXcnRWZjRYbkpaVzkyL1lFM2tTNUE4QS9xbzhrdDYxYkNyNU9tNU8zSnB1dFdUbHV5TEZtV0xFbVdKa3VTSlVsVDBwUXNUT1luOVVuanVwMmlxajJTUHlmYkpVbm1ISFZVNDJjK1V6TjBhTXUwYVR0Y2ZmVjJEenlRWkdieUw4a3JHK0RVYkNDWEpaOVBrclQzN3ovdXZQTjZ2L09kU2RxZmV1cHQzLzUycjZhbUpOOUx6bjFUYTdnZVhaY2N0MjRsZkRTNWJiMVVCZGpZQ0FEZ0g5UzNrdjlKa293Ly8veEM3OTVybEhmSW5YZHUrY0lMUzVJdE4wVE5LclFsRGNuNHBDNFpuZHkzbm9xOU9mbFlrbVQ4QlJmc2R0NTVtMjc2ZWlEVDJ0bzYvYXRmSFg3eHhVbXVTVTVhVDZkalE5c3JlVGFwU1ZxSERwM3o0SU5EOTlpamZHanF5eThQUGV5dzNuUG5MazMyU2hyZXZFcXVSeThuZXlWTDl0MzNsYU9QWHFPTXZWYXUzT01iMzBqeTdlUzhEVk0zNEcrY0FBRCtRVjJVL0w4a3lZclcxajU5K3F4UjNobkhIYmZUTDM1UjNGNnl6ejdOTyt5d0xqWFpaUG55Mmpsek5wczJMUzA5R3FnNUxYa2t1U2w1YUYzT21zeEx0a3NXSFhSUXpTT1BiTGJaWmgwUExWbThlSk9ERHFxdHE1dVc3TEp1WitFTjg1M1MwLzM2VzI4ZGNjd3hYWTdXLytJWEk0NDdMc24vSk45NW82dTJRVXhLZGt0bUhIdnNUdGRmdjBZWlY2eFkwYWR2M3lRWEoxL2VJRlVEL3RhdDQ2dDc0Qi9kdExQUEh2SEpUNjU3T1lWQ1lkblNwY3VYTEdsZXNxUjE2ZElWaXhldlhMS2t2YW1wMTRJRm05ZlZEWHJzc2RxNnVtTEtuWk1Ua2hPU0Y1UHZKNzlacTlQdFZlcjhNL3Y5NzM5YjU5Wi9raTIzMm1yUys5NDN2SzV1cDJTZ1NZRTJFbnVXTmdhKys5MlZSL3NmY2toeDQrMXZWSDBBL21ZSkFJQk8ydHJhcHRmWHJ6ck5GZ3NXbExlM3UvSEdTYzgvMzk2Mzc0cGRkOTFrMTExM091Q0FMYmZhYWkzTzI2dFhyeTIyM0hLTExidnRWZFE0ZCs1cjQ4Zm40WWQzK2VVdmF4b2FrdXlUM0ppY21ud3plWEFOVDdkMWFXUGxOdHRVVGJCaXdJQWtteVQ5QkFBYmlYSVlWMXZ0RjFqZVdmdEcxV2RES3lSSitpNVlNT1dsbDFhZGN1aUlFZVVlYmdEQVA2NkxTdk9CdExhMkZqcFlNSDkrRHljU1dWeHRaOU4rKzQxLzRvbkNtbGl4WXNYYzJiTVhMVml3Y3VYS25xUnZhVzRlTjNwMHc0a25say9ha254ckRTKy9YOUtjRkpLR3ozNjI2bGxtZmZqRGhXVGhCcm4zYkJCWGxuNFBrMTk4c2ZJTG5mRGtrOFdqUDFxVE12ZEkzcGNjbmd6YlVMVmVldy8wZU02ZkJmUG5kN3dWcmEydHhmMFh2ZG1YQUFDOG9kWXhBR2hLUHBjOG5TeE5XcFAyamtkcmFtWTFOSFRYMXA4OWZmcUVwNTZxdS9YVytvc3VtbkxxcVkzdmVVOTd2MzdGak8yMXRZdjMyV2YyVVVlTk8vLzhzWTg4c3JpcGFkV1J3S1JubjUxMXpESGw4OTVYV3ZpcGg1NHQxWGJDVTA5MUtYbnNvNDhXeXh5OW9XNC82OThuUzcrRUdaLzhaSmRnc3EydHJSalJGWklQOWJqQVd6cjhxdHVUNzI3QXVxK05EM1kvaWEwQUFBQ29ZclVCd0V2SkQ3cjVuSnVNNkZ6YW9PU2pTVjJwekxyTEw2L2FaSysvNzc2ZVQxWGUzcS9mOUdPUEhYUC8vZTN0N2QzRkFPM3Q3Uy9mY3N2Sy92MkxXY2FzeVpqZHo1Wk90SHo0OFByNzdpczJHVmV1WEZsMzExMHRRNGNXa3BXbGFZTFlLTlFrejVlKzB5bWpScjMyNnF2Rkg4bTgyYk9ubm5SU2NmOFRQUzd0OUlvZjVQSmt3QWFzL3RvWWtaemIvZC9UbHdRQUFFQkhxdzBBZnJ2bVpmWlBsaWVGWk02SFB0U1RBS0E1bVpvOG50eVczSjM4T2FsTDVsUTB2R1lmZGRTRXA1L3VMZ1lvRkFwVDYrc1hIWGhnTWZHTGEvSWU0RGNkenRJNlpNaWNJNDlzSFR5NHZPZmFOYjhEdkxrT1RoWjJlQk0xLytDREY0d2NXYWlwS2U1cFRBN29jVkV2bFFvWjg5QkRZNy8xcldJSmF6YmQ1cHZ0dHdJQUFLQ2pEUkVBSkJtVEZKSkYrKysvNmdEZ3N1VEE3cGRsUFRUNVVmS1hwSzFEQTMzcUthY3NXcml3dXhoZ3dmejU4dzQvdkpqeXFhUi96MnBiazF5WnJLZ0lPVnFUeS82K1ZvMzl4M0ZFTXFIYUM2Vnh5WHQ3WE1nbnltOFNUajIxVUNpOC9PdGZGLy80a1ExWThmVlBBQUFBZExLQkFvQ25rMExTTm5EZ3FnT0EwM3BXMm51VFJ6dTA0Um9QUFhUMjlPbmR4UUNOYytjdUdEbXltUExYYTFMbnc1TWJraGVUYWNrTHlhK1RROWZtMHZsYjBUODVQM2trbVp4TVRoNU96a3Y2clVrSm8wcy91Y25QUHk4QUFBRCtUbXlnQU9EaGN2ZWU1dVoxRHdDS1BwRk1LaFc3Yk04OXA3ejBVbmN4d0tzelp5NGRNYUtRdENlZldhdjZ3MkdsUWUyempqbW0rTHNTQUFCL1p6WjVzeXNBL0YxWld0cG9hVzVlWDJYZWxMdzNlVEpKc3ZuWXNVTVBQM3phMkxGVlV3NGNQSGpHRlZjazZaWDg3OS9rMUkzOGphdEp2cDcwU3BJc09tMk5BbFdBallZQUFOZ3dDb1gxV05qMDVOK1RPNUlrdmVmTzNmcWtrNVlzWGx3MTVSNkhIREwrZ2d1U0RQcmJtN2VSdjMwL1RVWW1TVjQ3L1BEZFM0c0hBL3lkRVFBQUc0ZW01RDlMSy83MmYvenhWNy8ydFVJM01jYlFzODl1T3VDQUpFY2wrNzJCTldSajk1WGsrQ1JKeXk2N3RGNTU1U2FiK0Y4azhQZkp2MjdBeHVTa1pGcVNaTGRMTHFtLzlkYXFhVGF2cloxeHpqbEphcEp6M3NDNnNWSDdjSEpoa3FSUVd6dnQxNzhldk91dWIzS0ZBRGFZVGQvc0NnQ3NnZW5KcWNudHlXYkpzRzkrcytXb28ycHFxa3pYdWZ1UlJ6WWRlR0MvcDUvK1VMSmY4bHdQU3E1TlRrb09Td2FVWm8yOEpQbS85WDRCRzlpZzVOK1NuWkwrU2Y5a3k2UTVhVW9XSnBPVFI1STVhMXR5ditRL2tuY2tXeVVyazBuSjlVbGo2ZWlBNU9Ea2JjbU9TVnN5Sy9tL1pIVFNzc295YTVLM0o3c251eWFEa2w3SjdHUnFNajRaVzhwYmt4eVg3SlhVSkxPVGU1Sm5lMXpuQTVNVGtqMlRUWk9tNVBmSkpkMmtQQ0w1V1duaTEvcWYvblN2a1NON2ZCS0FqWThBQU5qSTNKZmNuQnliMU5iVjFkOTc3NGlQVkptYXBVK2ZQaFBPUFhmRTBVZjNUWTViWFFDd2YzSnk4cUZrWUllZEJ5WHZUVVltczBwN2praitKZGx5RFd1N01wbWMzSllzckRoMFZMSnZVcnU2RXBxVC8wdHVXMldhb2NuSnliOGwreVo5dTArMkluazV1UzM1NGVxYTVoMk5URDZYSEpsczIzbi94NU1Ea3Rya084a0p5VllWR2V1VGM1TGZkVlBtQmNtN2s4MjdPZW5TWkZveUxqbThjOG1uSjBldWJrSGYydVQ0NUpQSnZ5UzlPK3gvWDdKdGNrSG54UDJTN3lZbmx1N2JoSzkrZGEvUGREdUQxRmVTVXp2OGNaT2tPV2xJbHF5eVBwVmVTLzdRVFNUemdlU2R5UmFySzZFNWVUbXAvZ29NQUtDcURUUU42RjJsWWhjdFdMQytwZ0d0dEhmU25CU1MrUWNmM05iV1ZuVkswS1ZMbHJRTkhGaEl4blJUU0UxeVNqSzY4M0pqaFpxYTluNzkydnYxNjFMUE01S1YxWmFYNnVIbnlZcXpmMjhOUzdpOG02dW9UUzVNR3J2SjFUcDRjSGtkM0k2ZmlaMGJzbFgxUzg1TW5pck5pZG5wL3RUV2x1L1BtQzZGZHo1ZGEvTGxpZ3IvS0ZsV1dkdWFtcXBWTFg3YWEydkxYMHAzVC9HVDdKUDhMSmxkTlc5TlRmSEZUa2NmU01aMlNEbjE1Sk5icWsxZlc1NEdkRDErbXBMM1Y5VC8vQzUzZTNXZm42N3lHelFOS0FEUXlVWWRBQ1M1czNTaXNZOCtXalVBS0JRS0U3LzR4V0thTHYwNTlrb3VUMloyYmtzdEh6NjgvcUtMWms2WlVpZ1VKci80WW5IbkQwcFovcnpPRGI3RE85ZGgraHBtYjB3VlJ5ZmpPN2VoWjN6cVUzVTMzREMxdm43dTdObkxseTh2RkFwdGJXMExHaHVualI5ZmQ4TU4wNDQvdnR5TUxpUzNkN004MWdISnRjbXJuU3V3ZE1TSXVzc3VLeTdFVm4vdnZWMnExenBrU04wMTEweDU2YVZseTVZdG5EOS8wdlBQTjV4NDR1czN0a05MOS9ET0FjT3JIL3hnL1k5K1ZQKzczMDJ0cTF1eWVQR1NKVXVtMXRmWDMzTlAvY1VYVHp2KytPWERoNWRiOEZQcjZ1YS85bHE1MmwzVUpDY2tqMVlzNmp6ejR4K3YvLzN2aTB0U05IejJzNFhPNzJHK25MU1dVamJ2c2t2ZG5YZTJ0N2RYL1NGdGlBQ2drTnhRY1NGVjF6QmV4V2QrdGErdlRBQUFBSFN5c1FjQWg1VURnSzkvdmJzQVlNekREeGZUbEo4WmZ5WjV1RU96ci9pWmRjd3g5ZmZlVzJ3dUYxVUdBTVdWeUtaLyt0TXR6YzFyOUNtM2xiL1F1ZjdGMXc0VC85Ly9XMjBKWXkrOHNGaENGNmNseTB1WDBEWmdRTjJsbDg1LzdiWHVia1haN09uVEozemxLK1ZuN1g5SmRpOFZXSk9jbXZ5NTRwWEk5RTkvZXN4REQ3VzB0UHoxZSt3Y0FEU2NlT0xjMmJPcnRKdC8vdk5pZ2hlVEpDT1QrUjBDaHBkLzg1dVZLMWV1b3FydDdlMnpHaHJxNzc5L2FsMWRvVkNvR2dEc25seFNFVTAxNzdMTG1POTliOGJFaVIxTDZ4SUE5RXRhU3Vtbm5uenl2RGx6VmxHVHRyYTJxbDlOWWNhTVFsSVlQYnB0RFg4VnhmUCtxZUk3WFZLc3p5bW5yUDVYOGMxdkZndXBNZ0ttUkFBQWRNY1lBR0NqOUhBeUp4bVU3UERJSTduZ2dxcHBodXkvZjNGamp5VEo3WjFYY2wweFpNaWtVYU8yT09hWW9idnZ2dVBxVHRlV0pObGkyclNHNTU0Yi9FLy90T1ZXbFQzZXU1clYwREQvbVdjMis4dGZpbjljMXZsb2E3SjUwbS9jdUluMzN0dTdmLyt0ZDl0dHg1MTM3bExDeXBVcnA0OFpzK1c0Y2FrSUFMNmVuRmZxNEQ3bDlOTzNPUHZzRVVPR2xJOHVYclJvL3F4Wi9RWU8zR2JBZ0M1bER0cHBwMEhmKzk2VVQzeGkwS2MvWFZ0WHQzOXllL0tlWkVueVFQS3ZIVkkyRHg4K1pkU28vaC81eUU2NzdMS0t5NXp3UC8vejFtOStzMWV2WHBXSFJoeDNYTVBUVCs5eTVaWC9uQXhMTGt1MlNaSTBuSFRTRmhkZXVOZU9PeVlwRkFvVG4zeHl4Y1NKdlJzYTJtdHJDOE9HMWV5ODgxdEdqTmg4ODgxNzllcTE0ODQ3Vjk2V3NpT1RhenVQM0poejFGR05KNXd3N0xERDlxeGR6ZGlLdDVRNi9kZGZldW1JMDA5ZmRlTGV2WHYzN3QyN3lvRytmWlBreFJkWDdyTlAzeDc4SkpxYm02ZS84TUtLQ1JOR0pLazJES00xMlNMWmF0S2tpUTg4MEdlNzdZYjg4ei9YYnRGMU9FQmJXOXVNRHIrS25vL2xBQUQrMFczc2J3Q1NQRkE2MTJ1dnZ0cmRzOXZtWFhZcEpDOGsrM2Z1ZVZKM3h4MUxseXpwTGxmbEc0QTdPbVJ2cjYyZGRNWVpUUXNYZHBkOTVjcVZzejc4NFk3UHBGdVNvWjByLzVmT0Q2M2JCZ3dZKzRjL2RDeWs3dXFybCsrK2V6bkIrQTU1eisvd2VMN3VaejhyWjVrL2I5N1lyMzk5L3NFSGx4L3dOKzIzWDkwTk55eGJ1clN5a25ObnpacjcvdmVYbjZsL3VFdlBtZnZ1YTY3V0cvNzE3N0gwQm1ES3FGRXJWcXpvTGxuSGxOZVZDbi9sRTU4b0Q5dVlXbGMzKytpakszdTJMTjUzMy9yNzcrL1NJYWZ5RGNBZnk3L2h3WVBIWG5qaDFQcjZWZFNreXh1QXZVcDVYNzdxcW1uangzZjhWSFlFV2pCL2ZwYzAwOGFQbnpGK2ZQc1RUeFFMV1RsdzRJU3ZmS1hZUDZvN2RkZGZYeHlVVXY1VUxsUTN1dk45V0hqUVFVc1dMKzVZeUpTWFh1cjRxNWl3eXI4ZzNnQUFBSjM4SFFRQTN5NmRhOHpERDNmWDZwcnpvUThWa3BuSkI4c052cHR2WGtVcnJhZ3lBTmdycWUvU09Idlh1MTZaUExscTlnbFBQdGt4NWFMa2pJckt2eXVaMkxuQVNXZWUrZGZHNGwxM2RUdzBQZmxnS2VQN1NqMS8ybXRyNjI2L3ZaeGx6TU1QTDk5amo4ckdkQ0ZwUE9TUXFtM1R4cmx6bCt5OWR6SE45YVhFNDBhUFh1MzlLVGJyNXh4NTVQSmx5MWFkY3RMeno1ZERvR0pMdlZ5VEdSTW50ZzRaVXJYQ3IxLzFzY2QyN0hkVUdRQk1MTFdTRnpjMXJiYk9YUUtBZ2QyZnR6SXk3T0VZZ0FValJ5NW9iS3g2OXNWTlRTMURoNVpUdGlXL3F6WUIxTDZkQnlVWGtza3Z2UERYU3hnenBoalFsbjhWUjY3eUw0Z0FBT2lPaGNDQWpkVmpwWTMyc1dPN1M3TmsyTEFrMjNlWXpYUHpKNThjKzhBRFk3Ly8vWVpSbytwdXVHSEZpaFU5T1ZkZDhvN2t3OGxQa3JsSmtxMmZmTExYT2VjVXFxMUczRktxejVQSkI1SWRrMHNyMGp5WnZEVTVOUGxsYWMveVVvZWx4WXNXdmJYVUtlWGg1UGhrcitUZUpNbkE1UEprc3lUSm1LdXZMaytCV24vTk5Yc2VkdGhtNDhjbm1adjhJYmt4ZVNoWm5pVFpkdlRvcmQvM3Z0blRwbldwdzdiYmIvL3FMMzVSNk5jdkhRS010cGRlcXYvdGI4ZGZjTUhrTTg4Y2MrKzlWUzh3U2FGZnY1YUxMOTVzODgzbnYvWmEvYVdYanYvem42c21XejVwVW5IajlVazJMN2xrMEU0N0ZmZjArZUlYKzd6eVNwSm5reE9UM1pKM0pxY2t0NVk2WE8zMGkxOU11cnk3MlkrUzBwSndXei8zM0l3bm5xajcxYThtZi9HTDR5NjhzS0crZmhWWnl1WldHNE83ZG1Zbmk1SWsvUjkvZk5rcHA2eGN1Ykl5emZ6WnMvdE9uMTdjL3E5azkrVElpbDVoU1Y1STlrd09UUmFVOW16VG9XZlhabWVmWGRQUWtPVGwwdG9JVmFkWUJRQ283dS9nRGNDZzBybkdYbmhoZDg5OTZ5Kyt1SmhtV01VVDkrS243bzQ3S25OVnZnSG9hSENIdVhlNjlOc3BLai8ydnJvSFYzRkxxYWhwNDhjWHM5Zjk3R2ZGUFpXVFBQNjZsSGpLcUZIbG5pb05ZOFlVNS9acFM2NUwrbmRJdjBmeWVDbkxqUC8rNzZxejNOUi8vL3V2L3hLcTNaK3hqenhTSmN1OTk5WmRlbW1oVUpneGFWTDVtZlNNVDMycVN5ZWNKWXNYTDlwLy8wSnBhc3NGSTBlV0s3Q2dzYkhZVDJsS3RXR3NSNVNIQzlmVVRIem1tV0tXeWpjQXAxYXI4S0w5OSsvNDNxQ3NjaGFnbXVTVHlhWEpGY2tWSGI3VFZid0J1SzJVdVB3NUl4bVVETzR3dTFIZGpUZFducjI5dmIxcHYvMEt5ZHhWRHRzdG0xYThsZ01QL091UDZybm5pdVgvcFdjbHhCc0FBS0NMdjRNQUlLWFZBQ1o5NFF1VjUzcTk2WGJUVGNVemprdyswV0hhblBKbjdoRkhWT1phZFFDUTVQMmxaUUVhRHoyMGNpR0M1dWJtdGdFRENzbExxNnQvLytTMVlxTnp4SWhpNDNqWjBxWE53NFlWa2dYSmtNNko5eXhkNytKOTlsbFlhdEsxTkRmUFBlS0lZbTIvV3UwVXRjbi9yYko3ejd3NWMxYjI3MTlJR3F0TlFqLzdxS01xczB4Njl0bm01dVlGalkwTDMvV3Vqb25iYTJ2SGZPOTdEV1BHTEp3L2Y4SlRUODA3L1BEWDl5ZUZaTUpaWjNVOGFmSFEvZDNjbWMrWGYwZ0hIRkM4dzVVQlFFM3loeDRITFpVQlFCZS83MEVBVUdYTnVaSURTNHNidEE0WlVuVk9vVEhmL1c2eGtLTzZMNlRveUZKTkpweHp6bDkvazZlZlh0ejUwZFZsTHhNQUFOM1JCUWpZaUMxT2t0UTBWcDBsUDBrMkhUU291TEY5Y2xOeVVQS041THprMEdScWttU3JpbzR4UGZINzVQZEprbTBmZlhUaW43cE81MWhUVXpQam1HT1MvRlB5M2xXV2MxSlNuS1puNnNrbkZ5ZlNtZkxnZ3pWVHBpUzVKWG1sYytJdmxCNzlOcHg3N3RiYkZDZlV5Y1I3N3RuK3dRZVRQSlo4cDlvcGxpVS9MRzIzVmVzZXM5ME9PMHc4NDR3azJ5Wm5KdDlJdnBUc203eVdKTm15MnYzWmJiLzlhbXBxRm4zbEsxcy8rV1NTV2FWRmJYc3RXN2JuT2Vmcy9QYTNiNzN0dG0vOWwzL1o3cUdIa2pRa3hSbUNXa2VNS0pjd1lPREFGWU1ISjlrL0dWU3QyajhwOVcvcDk4d3pVNTZydnBSelMvTCtaRlR5N2VTekhWWWNXN2x3RmUzOERlWHA1TW9rU1o5WFhsbjRneXFSNDZidmVVOXhZN1V0K0JOS0c0VVBmYWk0TVhmV3JHRlhYWldrenVxL3dQb2dBQUEyWXNVQVlMTlhYKzB1UWUwT094UTN0azJTdkpCY2tIdzdlU3laa3lUcDIzM2VWZnRoVWtpU2JISDk5WlZIbXovNXlTUzlrbE5XV2NqSGkvK3BxUmx3OU5IRnplMnZ1U2JKaW9xbGYvc24vNWtrYVJrMmJOZ0h5ejMyczFtcDgzMUQ4cU51UHZ1VkUzY3pXS0x3ci85YTNIaExja0h5bytURlVnLzdQdDAwcHNmOThZODdYM05Oa2duSmZzazdreStVYm1sSGp5WGZMbTMzZWV0YnkvdDc5ZW8xNmZPZlR6SWd1VE1aWE8wVTE1UTIydSs5dDJvZGtyUWtQMHZPUzM2ZVRDNWZ6ckxLM3ZWdmhBdVM0b2lINFQvNXlheXBVN3NjM2ZrZDcxaTIxMTVKams2R2QxL0lrT1NJSk1taWd3NGFmdUNCeFozejdyd3pMUzFKYmx6dmxRWUEvbkg4ZlhRQkdsUHE5bDE1cnFLWlU2WVV6M2hTUmQ1SHVya0RoUjUwQVNwNnV0UlB2WEk2b0xhMnRrVUhIbGhJbGxSTUFGcjIzbExmbUliUGZyYVlhOHBMTHhYUCsxQkY0aStXdTVoZmNrbjVMQ3RYcml3dmw5dVR6NEtSSTZ2ZXBYS1AvRWM3bkxFNGVLQzlYNy9LOUMzTnpRdEdqaXdrSzVNUGQ4alNQemt0dVQ3NWJYSjVVbng4ZlVKNUVFTG5sYmtXTkRZdTIzUFA0cUhKSFI1N2Q5U1FGSkxtWFhacGJtNWV4VXJBUlllV2I5R1ZWMWJXZVVOM0FTbzZzMVRJK1BQT3E2ekR5Ny80UmZIb2xkMlhVSjdicXU3NjY0dTVXbHRibCs2MVZ5R1pYM3BmMUVPNkFBSGQ4UVlBMklnVkoxSnNyVmp1cXF4NVVYR0NsaW96cml3dmJiUTBONi9kMlgvOWV2NldwcHR2N25Lb2QrL2VNMGFOU3JKRmNtbzMyVDlYNmh1ei9OT2ZMdTVaVVNybkZ4V0pEeXB0OUQveXIzTS96cG95WmJQU05EczkwZi9aWjVjdlgxNWwvN2JiTGpqZ2dIU09WVnFUSkwyYW1pcW50Wm44cHovMWYvenhKTC9ySENndVRDNVBqa3Mrbkp5VzNKMGthU29kWGRiNVpVdi9iYmRkZVAvOWl3NDZLTW13NU5ya3o2V0gzMlhGUUtpbW9XSHFrMCt1OXVyS00rZjBXcnAwdFlrM2tKK1d1cGE5OWRKTDU4NmExZVhvcnYvNW44M0RoeWY1ZU1VQWo3TGllNTcyL3YwSGw3N29TYU5IMTliVkpiazM2YmF2RzhDYXNCSXdzQkVyTHI2NnZOVFBwMUpycVFmTDRvcEQ1WkNnWmZueW5xenNXK25hNUp4a2NETDhpaXVXZlA3elhRb1o4cUVQclJ3d29IZGo0OGVTQ3lwV2JCMll2TDlZc2YzMmUrdTczNTFrNFlJRnUxMTVaWkxKMWZwNS8xT1NwSG40OE1HNzdscmV1ZlgyMnplOC9QSWExWGx3MVJWdGsyVnZlY3MycGZ0WlZLNXdhMnZyNXB0djNqRnhvYlVZSGVTQkhweXgzT3B2ZmFYTG9JYnNPSFRvZ3J2dm52Uzk3dzIvN0xLMHRJeE03azhlUzM1WUdnQndZM0ppa21USUY3KzQ3QzF2S2VicXJoRTh0N1N4eVpzWEFMUWtQMCsrbWZScWFtcjg1UzhIbm5OT3g2TmJiTEZGL1ZsbmpUajU1SzJUczZ1dERuRk1hZFhxS1NlZU9Md1UxbTc1eTE4bUtTUlhiZkRxQS84b3ZBRUFObUpiSmtsYXVuOERzTEwwQnFBeUFDZy9DVzlkMnpjQXkwcmRVZnE4OGtyRDczL2Y1ZWpXMjJ3emVkU29KTHNtbjZqSWUwclNMMGt5L1hPZjY5MjdkNUpYN3JtbmQyTmprdHNxb29VQnlXNUprbG4vL3UvRnNjSkZXMjI5OVM1NzdiVkduNzU5KzFhOWx1YUJBMU9xVWxHNURpdEt6ZjFLaGU0T2RGQWVSTnkzV3F5eXpZQUJ3My93ZzZuUFBEUDdJeDlKMGlzNU5MazcrWE55VFBKb01qcEpzdVdMTHc2ODk5NWlyZTdxNWtTTnBmcjBmdk1DZ0NTWGxoYWQyUDFIUDFydzJtdGRqZzc5K01kYmh3NU44bC9Kd0lxOHg1VzNQdjc2OEpCWlU2ZnVkUFBOU1o1SnVnNDJCMWhiM2dBQUc2c2hwZVdsMnJiZHRyczBkUUd6THdBQUlBQkpSRUZVaFFXdmR3eXA3UHhkZmdPd1ltMERnQ1EvU1U1S05rc0cvL1NuaFk5K3RHUHJQRW5mVDN3aTMvcFdrdU1xZXZWOHJGaTkydG9kampvcVNYdDcrMDQvKzFtU3Bja1ZGV2ZadC9TUDliSUREdWk0Zjg2TUdZM2RyTUMxcHJhZE1TT2Rud21WVy8wcldsb3EwL2ZjOUdScXNtdnkxc3N1bTNQeXllV0Z3RHJhZGUrOUM3ZmROdTZQZit6LzR4OFB1dXV1WHNuSVpHVHlkSEpKTWk5NVIxS1RURXV1THEySlZxa2xhVTQyVDNvdldiSXVGVjVIVGNrdmszT1MzblBuenZyTmI3WXByZWxXdE5YV1c5ZWZkZGFJMDA4ZmtIdzVPYnZEb1dHbE9hUG12K2M5dSszMytzanRoWGZjTWJpbEpjbHYzcURxQXdCL3YvNE9CZ0dYcDB1disrbFBxNHhzTFJRS2hjS1k3M3lubUtaeUpPNmxwZXhUNitxNjVPcmhJT0NpZThxenRqLzVaR1VGWm4za0k0V2tMZW5ZY2kvWGZOSVpaeFNUamYvem4xY3h3dlhqM1V6a1AvNkpKM28rQXJnbm43b09KLzFOYWVmYzJiTzdmby8zM2xzOE5LcG4zOVQvbElmR25udHVkOS9VWHkvcThjZG5mdXhqNVNxMUpiY2t3M3Ayb3FiaUYzclNTWlhGdmpHRGdJc0dKdk9TUXRJeWRHalRva1ZkU3B2LzJtc3JCZzBxSkxNN3I5cjIvZkszY01NTnhaVExseTByRHZKK3RUVGNaWTBZQkF4MFJ4Y2dZR1AxcjZXTlRUdE1NTi9GRGc4OWxPUzFEajNSeTNyU2ZhVW55c3Y5YnZxclgxVWVYWERpaVVsNmQyNHJmN2EwMGY3SlR4WTMrdHh3UTNIam1sU3hSV21qejVaYmR0emY1WS9yYUdaeSt1cFRyWTBmSlZPU0pMdi84SWYxMTFTOXhML2EvYUNEQnQ5ODg2Um5ubm5sdi84N1NlL2tvOGxma25OV25TM0ordnRPMTlIYzBnUDd2dE9uVDcrMTY0Q09iUVlNbVBpbEx5VVpsSHl4dy83aThOK1ZBd2JzOUlFUEZQZE0rY01maW9PODc2bzJpaDFncmVrQ0JHeXM5aS8rcDZabXgzLzZwNm9KR3VmT0hmRG9vMGxlck9oVnZ4N2RuZnhmc25leTY3WFh2bnJ1dVRzTTZUUy95L0Qzdm5mNW5udHVQbmJzVWNtQXBERVptaHllSkZrNGNtUnhvdmU1czJidCt2T2ZKM21wdEw1WUYrVUFvRy9uY2NaOVN3SEE0OGtsNjNZVkM1UFJHK3d1TFV1K2tWeWI5RzVwR1hIU1NlTm16bnpyZWVmMTdtWTRjdEh3ZDc0enYvclYyT09PZThzNTUvUjc5dGx0ays4bXV5WW5iNWdhcm5jWEpjY20vWkxkZnZDRDVmLzFYMTFHVVcvL21jKzBmK2M3bXl4Y2VIenl2OG15NUpPbHR4eVRUejU1OS82dnZ4alk1dWMvVDdKeWxkT0dBcXdGYndDQWpWSk5zbmVTNUxYM3ZLZGYvLzVWMDd6NndndkZqZFZQSWJsdVhsK2VxYVdsOGJiYnVoenFXMU16NWJUVGtteFRXaFJzVktsQi8wcHA5ZDk1ZDl4UlhPYnBwbTdLTHdjQW0zVis1Tjl2MjIxVFU1T2tPYmwxM1Q0UGJjZ1lLY2t2a2krWFR2RzJyMy85bGM5OWJzNk1HYXZOdGVlLy9WdWZQLzZ4L3RKTDIvdjNUL0s1NVByU2NzaC80NllueFovQ1p1UEhUNzZyNjdqbDdYYllZY0tYdnBSa3ArUUxTWkpqUzRjMi9kakhYaTloM0xnZDc3Z2p5WitUNmlzaEE2d3RBUUN3VWZwZ2FYSGZ1Zi8yYjkybDZmM0VFOFdOcW8vVjE2TXJrK0pzTDhNdXY3eTVZcUw5Z2YvNW40WGEyaVRGN2o3SEpFbFdEaGd3NU1nams3UzJ0QXk3NG9vazg1T2ZkVk4rbjlKRzM4MDI2N2gvcTYyM25uL2dnVW4yWEE4WHNjSDlPRG0yMUF0LzU1Ly9mT0RlZTQrNTVKS2xxeHV3dTNsdDdZalRUNTkwNzcwckJ3NU1jbXozZCtsdnpVV2xtYVoydnVpaUZTdFdkRG02emZISEYzOFZKeVo3SnU5SmtyejJ2dmNOKytkL0xpWllWZ29tZi8yRzFCYjRoeUlBQURaSzVkVzErcjduUFZVVHRMUzA3SFQ3N1VsbWJ2ZzNBQXVUTzVNa20wMmFOUG1ocnN2NGJqOW8wSlNUVGtveUl2bDJNanhKTXVXa2svcHZzMDJTU1k4K3V2bllzVW51N242SWFubVdvdVpsWGJ1Q3YzYklJVWtHSjN1dFZjMFBTYTVMN3F5MlV2S0djSFB5NFdSc2ttU1RoUXZmZnVhWnZmN2xYK3AvKzl2S3RjYTYyUDJnZzZiKzduY3JCZzlPY214cERxVy9jV05MTTVadTlkeHpFeXBtaWQxaHlKQ0paNTZaWkZoeVhlbTF4cXNuRnBjOXlOSWxTM2I3NlUrVHpFaXFqQ3dCV0RjQ0FHRGpjM0RwaWVtckgvclE4SGUrczJxYVNmZmNVMXRmbitTUk42UktseWZGWjd6YlgxbWx3M2JoVTU4cWJwU25mZXhkNnVuUnY5VFBleFVQdHN2VDJqY3Y3cnFld1lyOVh4OEtjY0lhVnpuN0o3Y214eVZISlZjbGYreCtlZHIxWW85azkrU3haTi9rZ3RJN2s5cjYraEVmK2NpQ0QzNXd3dU9QcnpyNzhIZStjOHBOTnlYcGxaeTdJZXU1SGwxVStsWHNlUEhGbFVIT0ZpZWVXT3pCZFdDU3BHM1FvSjNmOTc3aW9ZWUhIdWd6YTFhU096ZHcxeXpnSDVNQUFOajRuSmtVQjVET1A3MzZ2RFZ0YlcwN1hYUlJrcGFlVGVXNTdsNU0vcGdrR1hqZmZWTktZdy9LZHR0Ly84YkREa3RwNG9WNVJ4d3hiTjk5azB3ZlAzN3dyYmNtZVNKNXV2dkN5NzFrV3B1YXVod2FldWloYllNR0pUbG16VHZIZjcyOEZsVk5UWkpEa3V2WHNJUWVPaldabFl4THhpZXprK09UYnlUN0pkZVhXcmZiUGZEQTd1OSs5NHhqajIwWU0yWVY1ZXh4OE1IVFB2dlpKUHRzc0FtTDFxL25TdDNQdGgwOWVzSWYvdERsNkZ0MjNYWFNxZVZYV1psMHlpbmx4YVIzdVBycUpDM0o1VzlNUllGL01BSUFZQ1B6bWVTb0pNbkNrU04zUC9UUXFta21QUGhndjZlZlRuSlA1N250TjZoclN4dnROOTdZNVZDdlhyM21uUHpYQ1d6S1BUMldsZWFJdkdHVkpaZGIvYTJOalYwT2JkV3YzNlJSbzVMc2xIeHBUV283TWlrK2JXNTg3M3Nibm50dXdjRUhKM24zbXBUUVE0T1RIeVU3bHY0NEtQbEJzbWN5UFRrK2VXL3lVR242enAxKytjdGQzdkdPU1dlZDFUaDNibmVsYlhMMjJjVnc1ZU1ib0tvYndzVko4Y24vZ0IvL3VGRG9PazlwMzVOUExsNU9rczArK3RIaXhwU1hYdHJ1Z1FlU1BKYU1mNlBxQ2Z4REVRQUFHNU85azR0TGovOW5YM2hoMWFra1Y2eFlzY1BGRnlkWjhjWXVkWFJUcWJtMjIxVlhWVFpoZDNuLysxdUhEazNTTm1qUUx2Lys3MG1XTEY1YzdPZjl5dW9ldlU4cWJmUjY4Y1hLbzF0KzZsT0ZmdjJTbkpQczErUGFubDE2SGZIcWw3Kzh5NGdSN1gzNnBNT3JodlhvbjBzTE5rODUvZlRKWjV5UlpNdmsrTkxSSjVJamtvOGt6eGIvM05JeS9LS0x0ampra1BIZHJIQzgwKzY3djNyNDRTa05wZmpiTnpvcFB2a2ZlTjk5bGQyY2h1NnhSOFB4eHllWmM5UlJ1N3o5N2NXZGJUZmZYTnk0L28ycUpQQ1BSZ0FBYkRScWsydVQ3WklrWTcvOTdUMjdtZjluMG85L1BPQVBmMGp5NENyNzFXd0l4WGs4ZXpVMXpmbHQxNVdVdDloaWk4bW5ucHBrMHFoUnhaNGVEYi8vZmJHZjl4MnI2K2RkVitveHYzMUZONUlrUTNiYmJjei8vbStTZnNuUHE2MTVYT21EeWZ1VEpQTVBPV1NQSTQ2WTFkQlF2R1BQOWlEdm1pcDNUR3I3eENlMi84WTNpckhLWVozVDNKbThNem1sRk9wc05uNzhIb2NkTnVhaWl5b2ZtU2RadFBmZVNRWW0vVFpBYlRlRUg1ZGVjV3gxMldXVlJ3dWpSaVZwUFA3MW1HalJnZ1c3WFhWVmtrbmRUd3NMc0k0RUFNREdZVWp5WUdueHJ6bEhIYlhibDc5Y05kbTRQLzV4ejY5OUxjbUM1THczc0hwRlZ5U0xraVM3L3VRbmxUTS9idjJ4ajZXbVp2T1BmalJKb1ZEWXNkVFArNG9lbEZ6c3lMVGQ2TkVMRnl5b1BMckhpU2ZPT2Zyb0pIc252eXN0S2RXZGtjbjFwYWxGNTV4MVZ1L2V2ZWYvNlUvRlF3LzJvQ2Jyb3QvV1cwLzcrTWVUL0hOcEdZZU9ya3plbWZ5cTJGeHVhWG43V1dmVlZ5eWptNlQxclc5TjBxc1VDcjZSMXU1L21mY2x4ZmxvQjk5eXkrVG5uKzl5ZE5lOTk1NDZhdFN3dzR1cncyWEd2ZmYyYm14TWN2dmFWeE5nTlFRQXdQcFU3cEhUYTVQMStjL0xQc2xEeWNna1NmTWVlL1Q2eVUvNjl1MWJtV3plN05tN25IaGlXbG9LeWRsSmxlNHlHOWpjNUo0a1NXMWQzYVNLcC9XRGQ5MTF6TGUrdGZPZWV5YVovTnh6QXg1K09Na2pQZXZuL1pmaWYxcGFaajc2YU9YUlRUZmR0TStWVjg0LzlOQWsvNVE4bVh5K20zTCtPL2xOcWVrODZjdGZmdHNIUHBCazIzdnVTZEx5aGp4eVh2WWYvNUZraytSVDFZNHVURDZUbkY2YVBPZHRYL2hDbGZYQ3RuaDlZYlEzYkNuN1hxVjFmTXZyTUIrZVBKOHNTWnFUaHVUYnF5dWgvT1IvMHl1cWhIc0R2Ly85eld0cmt4UUtoYmRjZFZXU1pSdlBjZ2ZBeGtnQUFLeFA1VFZyTnkrMW1kYmRGNUxmSjI5TGtpdzQrT0FGRHo2NHc1QXE4MVV1WGJLazdZd3pOcHMwS2NuMXlUV3JLN2I4ejE5bHJGSmNvRGNkNHBtZXU2STA2SFByYTYrdFBMckhGNy80K3RadmZsUDg3M1U5Sy9hWHBXNUNPMTV5U1h0N2UyV0NBUU1IOXJybGxubEhISkZrWUhKWk1qRzVQRGt0T1RyNWZQS2o1Sm5rVjhsT1NaSnBKNXl3ODNlK3M4a21tOHlmTjIvdzNYY25lVGFaMWFIQVhoVWJmejIwNmV0dDd5MHJEcTNXa0lNUEx2WUMrcTlrbDI3U1hGNjZMWnZPbWZQYWsxMVhjZWhWR2w5Uk9XTGg5Uyt5MnNpUTlPcVZWZjQvcjdXODBkcmE1VkR2Yll1THptVlFrdVJkeVMzSnZza1dTVTJ5Yy9MVjBzRDA3dHljRkovODczenR0ZFBHanUxeWRJdlNBcytUbm5sbW16LzlLY2xEU2NNcUN3UllGd0lBWUgwcUJnQnRnd1p0MnFmUGFwTDJ3RWVTNTVNZmx4cGVzNDg1cHRkZGQrMDR0RW92OTNtelp5OC81cGdkYjdzdHlZdmRQLy91YUdCcFkvT3R0KzV5cUtiZjY5M0xCNng1blo4czkvZTQ5ZGJLcGw1eDFQTDhlZk4ydSthYUpPT1MyM3BXYkYzeVFKTGloSktqUjFkTnM4MTIyMjF4eHgxanYvZTk0c1F5dzVOVGs1OGt2MDB1Uzg1TXlpc21OSng4OHZhWFh0cW5UNThrOHk2N0xDMHRTYm9zWUZaZWMzalRtcTd6aTI1ZUNzRGUyclBLZDlTdmYvK0pwNTJXWkVoeVZmZkpmbHphNkZOZjMrVlF6ZFNwU1FvVjY2WU5MZ1VrTGR0dlgxbGdjZWVXM1grbjVSVVdtaXNXSis2N3pUYkZqUU9UZHlWM0ovMlRKTE0rL3ZHcG8wWVZENzJqKzJzcEtqLzViN3VxMit2ZXBCUVcvbngxcFFFQXJMR0xra0pTU0ZwYld3c2RMSmcvdjdpLzZ5RFduaG1iRkpMRisrNWJxS2IrdnZ1S2hWK1hISlBzWHEyRW11VG81SnBrZk5KZXFtU2hwbWJjQlJjc1g3YXNhckZUNitxVzdyVlhNV1ZEc2svUHF2cFlxZVNXbHBZdUJTNXVhaXFXZHY5YTNZVFBscW85N3Z6enExYTQ3dXFyaXdrdVhKTmlEeXZka0xsSEhMRjgrZktxSlpkdnlJUnp6bGt4YUZDaGZBTkxuK21mL3ZUa0YxNG9weHozeHo4Vzk4L3NFQkVWUFZUS1VubXVKWXNYRjJwcUNzbkRQYWoyMGFWeXhqLytlRG43L0lNUEx1NzhiamU1QnBSeVRmNzg1enVlZXZueTVhMURoaFNTaVJWWmppaGxxZnZaejZyYzg4c3VLeDQ5dUpzelhsSEtQbTNjdUM1NVc1cWJsKzI1WitXZFhMRmlSZjNkZHhmL2VFWVBic1dZMGs5dTVwUXBsVFY4N2RWWDIydHJDK3R2NHRyZmxxcTZZUDc4amlkcWJXMHQ3bjhqNThnQ0FONThHeUlBT0t4VVpzTUpKMVJ0bUpZRGdQS25LWm1ZakU0ZVRWNUtwaWVMSzlxczA0NC9mdnI0OFZVTExCUUtZeDU4c0czZ3dHTEt2NnpKN0pBTnE0eFZpcTNNdFp1RnZTYVptaFNTdGdFREZuWnVleFVLaFJVclZqVHR0MS94MmdldFlja1BsKzdKMkc5OG83c2JVcloweVpJSlR6OWRmODg5TDE5M1hkMWRkMDE2L3ZuWFhuMjFZNEpGQ3hZczJYdnZRdEtlZktiaVhOT1RRdEplVzF1MThFWDc3MStzU2YvVjFia3lBQ2dVQ3RQR2ptMGJNS0M0Lzc1a3o0cGNsNVZ5dlh6VlZaMis3dnZ2TCs2dlhHLzVpK1VBNEs2N0tpdjg4aTIzRkkrZVhKR3g2SnZsZS92WVkxV3lYM2RkeDkva292MzNYOURZMk5iV1ZveGtXcXRkUXFVenk3Zml2UE9xbk9LcXE0cEh6KzlCVVQwaEFBQUFPbGt2QVVDeGs4a1hrd3M2dERZS3ljdTMzRksxMVZqLys5OVhQcFB1N3RNNlpNakVMMzJwWTZ1eGk5blRwNDg3Ly96aW8raENjbWNQR3FPMXliSEoveVpQbGM3eXlpYytVYlh3dVVjY1VVendlUEsveWFmV2NKM2Q3NWNibzlkZjM2WGtzWTgrV2p5MEZpTnVSeVJ6U3lXUGVlaWg3dTVNRDAzODBwZUtSWlhYTFJ1Y25KeDhQWG0wM0hZY09iSnEzaW1qUmhVVE5DZTNKOTlNM3R0Tm5hc0dBSVZDb2U3MjI4dmYzWUxrcHVScnljZVM0enY4bGxiMjd6OWo0c1J5bGlWTGxoUmpwN1lPRC9MM1M3NlNYTm5obHpQaHFhY3FLenoyc2NmS0NhNU96cTU0VS9UKzB0SDY3MysvNmlYWDMzUFAxSk5PbW5MYWFmWDMzTE5vNGNKQ29WQi83NzNsMzE1UDFDUlRpbUZWdjM2dnpwelpzZkMydHJiRisrNWJTQmF0ZVZqWUhRRUFBTkRKdWdjQVp5Y3JxalhjWjM3c1kwMkxGbFZ0UXJXM3Q4OS83YldwOWZWakhuNjQ3dnJyeDM3em05T09QMzdSZ1FjV2Ftb0tOVFhMOTloajd2dmYzM0RpaWZYZi8vNkVwNTVxYVc2dVdraWhVSmpWMEREK3ExOHQ5cGNvUHNDK3BBZVhmRkR5U2tWdFg3NzU1cXFuNlBMRXQ1Qk1TVWIwK1BZT1RaWVVIeFVmY0VCYlcxdkhrcWNkZDF5eHp0VVhNVjZkWTVPVnhkY0xBd2RXZlZiZFEzVjMzRkc4cnFtbHpqK25Ka3U3M0orYW1nbFBQMTAxKzh5cFV4ZnZzMC9IeE8zSlhkWENwTzRDZ0VLaE1PblpaeHNQUFhRVlFXRGREVGVVRTY5Y3VYTDh1ZWNXOTk5Y0t2ektwSzF6bGdValJ5NXVhcXFzOE1MNTh4ZSs2MTJkSXN6T1A1dWFwREVwSkkySEhOTGxLNnZxMVpremkzZGdSWEpRajcrKzg4cngyM2UvMjdHMGNueXlIaWRpRWdBQUFKMnNZd0JRVTlsWVRGWU1HalR1YTE5YlJjTzlPNjJ0clYycVVkWEtsU3NieG95WjhKV3ZsSnYraGFRaE9hVm5senk2YzIzYisvVWI4NzN2cmVKMFk3N3puWEkzbGVMbitqVzV3N2VXY25Wc3BzK2NPclg0MlB1Wk5TbXFpOHZMbDFCYlczZm5uV3Q2dHd1RlF0Mk5OeGFyMFpaOEpFbFNreXpzZkgrVzdibm55Ny82MVNvS21UVnQydlJqajIwWk9yUmpyc3F1OEtzSUFBcUZRa3R6YzkzbGwxY09WMWl5OTk3MTk5OWZUclp5NWNweDU1OWZQUFJxYWZxZzkxWDhBcGZ1dFZmVjd2VkZyMHlac3VpQUE3b0VMUjFIbE45ZERqeHV2SEhWTjNEK3ZIbmxZUXhyMUdUdmw4d3N4Vy96NTgwckY5aHc0b25GK25UM0ltVXRDQUFBZ0U3V01RQVlYRzdWZmZXcll4NTZhT3hqajgxcWFPakpjOU0xMWRiV05tM2N1SmQvODV0Slo1eXhmUGp3TG8va3Y1TFU5dmlTWDAwS3liekRENS93MUZOelpzeFkwWU9RbzYydDdkV1pNeWM4OWRTaUF3OHNKSSt2eVIwdWo5bWRmdXl4NVFMckw3cW9XUGt6MTZTb1N1VVlvRkJUTSs3ODh4YzBOdmJ3Zmk1YnRxeitCejhvTjMrL1ZTcHdyMUtCeFc1WERXUEc5Q1FrS3hRSzdlM3RjMTU1cGZ3KzRicUtxcTQ2QUNqZjU1bFRwNDU1NktHNks2Nm91L0hHOFU4OHNXVEprdkxSeVMrOE1QdW9vNHFGTkNWSGwwbyt2OXhldi9MS2hqRmppdDF5Vm10eFUxUERtREYxbDE1YXpOdng0ZjFCeWJMaVg0ckJnOGVOSHQxZENUT25USG4xZ3g4c1puK3FCeDNQdXJpK1ZPMzZ1Kzh1RmpoNyt2UmlQTForVjJJV0FBRGRlY1BXVVFIK3JwU25FRjZ4NDQ3Yjd2NzZkRDV6Wjg1YzZ3TGIyOXBhbXBwV05EV3RiR3BxWDdTbzE4S0Z2UmN1ckprMWEvRDk5dytkTXFWTDRrbkpsY2xscGFueGU2ZzRPZnlLcmJmZWNzY2QyOXZiNTgyZTNjT01XKzY0NDRxdHRzb2FUcHo4Y1BKczhzNWtwNXR1bW5uKytXOFpOcXg1K2ZMZHJyZ2l5ZHhWem9EWkU2Y2xqY2xYazk0dExYdDg0eHN0di81MS9iZSt0ZE1IUHRDdllrclRzcmEydG9tUFBETGtmLzduN2M4OWw2UXRPYi9ESkR6bC94bTA3cmpqTmtPR0pIbXR4L2NuU2QrM3ZLVkxPZDJwdisyMnpKdTN5ZTY3YjdQNzdqc01HVkpjY3FGMzc5NkRkOWxsOEM2NzVMRERPaWFlTjN2Mm9oLytjSGhwb3RLbTVMZ09IZTcvdXVyY2tDRjl0OWhpNmFKRlN4Y3Q2bEZ0dDlnaXBRcDNYRExnaWVRbnlWbEpuMW16OWpqODhMSGYrRWJmd3cvZmVhKzl5blBhTGxxd1lOYlZWNy90MjkvdTFkU1VwRDc1U01Wc3BLdFZYTTl1NVlBQmc5Lzk3dUtleGp2dkhOVFNrZzVkbXdBQTFyOTFmQU5RMjgwQWdBMzNhVXZHSnpjbEo2M2hlTnl5WjllNURtdmFQanU5M0F2b205OWMzTlJVZDl0dHhUOVd6bUN6ZGs0b3pkWHoraFA5ZnYwYVRqeXg3dmJiSnp6OTlJeEpreFkwTnM1NTVaV3BMNzg4NXVHSHg1MS8vdkxkZHkrbm5KK2MxTG1vZnNueTlmRTFmYldpa3VYQnRWTlBPV1hTbVdkMlRMeDhqejBtZi83ekwxOTMzYmpSbzZlODlOS3NhZE1XTkRZMmpCbFRmKys5ZFpkZU9tWFVxUEw4VG9Ya3NZcXU5aDliSHhXdW5EYnFxbzd6enlZdFE0ZE9PdlBNQ1dlZDFmaWU5NVJITFJlU1o3dVp4M2JWUGxuS1B2N2NjNHQvNDFxYW01ZnZzVWNobVpmMFcvTUNWOEViQUFDZ2szVWZCSHp0aG0vMHR5VGprOThrcHlmRDF2bVNqMCthMTZFeVM1SVBydUVaYTBzZHZqdCtXbnU4VWtGUERFZ3VMM1ZjNmNsblJYSlRONU9sWHI0bWQ2UHFaMHpuTHZWRmc5ZnR0aGVTaWNseDNkemVQNjFieWQydFkzQm1NcnY3WEhPU2M5WTJDcjIvVkVoNU5ZYnl4S2JYclZXQnF5QUFBTHFqQ3hDd2xqNmIvRHg1NjNyNmQ2UTlXWllzUzVZa1RVbFQwcGcwcm8rU3k2NUxua3IyS1MxWHZFWVdKeThrRTlZdzE3TGthOGxWbmZ1WlhKcTh1T1lWNkU1amNscHlSWEpzY2xpeWQrZHpkVFF0K1ZQeTgrVFJiaEtjbHZ3NjJXTnR2OURaeVZQVnZySlp5V25KMTVLZGt5UXprcHVTSmNrK3lZaGtXUGVuYTBrbUozY2svNys5K3cydHE3empBUDYxblNuVXRPc1dDYlZMSlN1U3NtV0lVaGdxdmxIY3d2cXVDbFpGeUt1KzBNMVhnNExJcGxhd01LZ0twVmdLbFE0VWhObU9nV3lOdm5NVW93alYvckZ0ckRGR1Z4dWF0czdxMWF3MWR5K3V0NmIySnMzTnZiZTNiVDRmem90enozbk9lWjV6NFlIbnh6blA4MXVmRkNvVktDUTl5ZTNKMHVTcUtsdGJMUDhoRlQyWGJFbFdKWGNsdDVZVEh2OG5HVXo2aytlU28xVldWL0tMOHRKUG96MDl5Mjc2TGd4Y3VHMWJrdkZrODR6dUNUQURBZ0JnNW5aVk9TKzI2UTRrQnk1dWpTOGtCNUpia2dYSldQSnUwdGVBV3ZZbmE1TWsxeWMzSmo5TkZpVUxrLzhsLzAxT0pnUFRpenJlVE41c1FQTzJKbHVUdHVUYjg3NlliMHR1VE5xVEJjbkNaSDV5S2hsT1Brd09UV09PUnlGNXJRRU5MdDM1cGVTbHV0N3o0YVFsU1RLeVpzMjFTWkpQRHgvdWVQbmxKUDNKVzNXdEMyQUtBZ0NBeG1yUXFMcWk0V1Q0WXRWVnJZcnZjNDVQL2tiaUN0T2UzSjhrT2QzUjBkblRVenA0YXZ2MjBrNTlJdzJBcVZXMXBnVUFNQk4vVE5xU0pBTnIxMTdUMnByazYwSmgyZWJOU1Q2ck1zVUVRSTI4QVFDQU9yZ3RXWmwwSm5PU2cwbmZoSzk2ZmwxZWR1bmI5dllsRHp4UU9qalkxOWM5TkpUa0g1Tk1jZ0JvRUFFQUFOUmtlZkpNOHJ0ejV5SS9tWHlXdkp1TUpMOU5mcElrT2ZqWVk5MXRiVW5HeHNhV1B2MTBrdFBKODgxb016Q2JDUUFBWU9hNmtwMUpaNlZUMXlYWFRmaDVaUFhxNVE4OVZOci80SlZYZnZYT08wbitudXhwZUJzQnppRUFBQ3FibXl5WjVGUnBwVTRneWNieTZQL0VIWGVNUFByb29xNnVPWFBuSHQrN2Q4N2JieTkrL2ZWRnU3NWJLT3VUM3Q3V0RSdEtTWVcvUEhYcWhuWHJrbnlWckt1dDlvVko2eVNuSmxzUUZnQ1lwUzZZQ0d5S3JiVDJZbnV6SHdHYTdyWnkydURSTys4c0ZBckY4eHdaR3RxM2ZmdEFmLy80K1BqWmcvczJiU3AxcFMwMVZOMmV2RGE5SEhBU2dRRUFTVzBCUUduYjF1eEhnS2I3ODlrc3lIMTk1NC8rS3hwODc3M1RpeGNYa3hPVkVpZFAzMStubmZCWUFBRDhnRStBZ0hPMHRMUWNmT3FwcWN0MDdOalJ1bnYzaW92VElMaUVkWlIzRml4Yk5wM3l3d01EUzFhdCt0SFJvMGsyMVphMG9kUUJ2N3o1NWsvdnZudnFrdGUzdE5SUUR3QndwWmpzRGNCMERQZjJGcFBEelg0RWFMcS9sUHZSb1YyN0x0aHhqZ3dOZmRYZFhTci90MlJlYlZVZlRvckpjRzl2dGYzWEd3QkFJakFBbUtIdmN6eS8rdXJVSlQvYXMrZWFlKytkdjM5L2twM0pnOGxZWTVzR01DbWZBTUVzTlY3ZUdlenZuM1AxMVZWZCsrTmp4eWJlQVdhdGZ5WWZKVDlQdXRhdjM3OWlSZmM5OTV4ZjV1VG82TEZubiszYXNDRmpZMG4rbmF5dXgraS9tQ1JwT1hseWNQZnVxaTRjUDNQbWhnbDNBQUJtaTk5UGV3YmhaTnUvbXYwSWNDbTRQemxkN2hRZlB2TEkwUHZ2ZjEwb0ZJdkYwWkdSZzIrOHNXL2p4bTg2TzgvMm1wMzFXejVyWjgxZCtBOTFhZ2tBY0hsWW5PeXJZZWh3SXZsTnN4OEJMaEdQSjJjbWRwQjU4eVlPK2t2Yng4bWF1bGE2TXZtaWhpNThhTUlNWm1DMnVlckNSWUFyMUx4a2VkSlcvWVdGNUZEeWVmMWJCSmVyKzVJbmt1V1ZUbjJldkpqOHFRRmRwajM1WlRLLytndVBKM3VUUXIzYkExd3VCQUFBVUFmems1WEpUY25Qa3Ria2VES1E3RTNla2prYkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFDdjRpbUlBQUFDQzBsRVFWUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBSUFtK2o5aTljeWNaK0N5c1FBQUFBQkpSVTVFcmtKZ2dnPT1cIiIsImNvbnN0IEpTWmlwID0gcmVxdWlyZSggJ2pzemlwJyApO1xuXG5jb25zdCBDYW52YXNTYXZlciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoIGNhbnZhcyApIHtcbiAgICB0aGlzLmNhbnZhcyA9IGNhbnZhcztcblxuICAgIHRoaXMucXVldWVTYXZlID0gZmFsc2U7XG4gICAgdGhpcy56aXAgPSBuZXcgSlNaaXAoKTtcbiAgICB0aGlzLmFuY2hvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdhJyApO1xuXG4gICAgdGhpcy5mcmFtZUNvdW50ID0gMDtcbiAgICB0aGlzLmluUHJvZ3Jlc3MgPSAwO1xuICB9XG5cbiAgY2FwdHVyZSgpIHtcbiAgICBpZiAoIHRoaXMucXVldWVTYXZlICkge1xuICAgICAgY29uc29sZS5lcnJvciggJ1lvdSBhbHJlYWR5IHF1ZXVlZCBzYXZlIGNvbW1hbmQhIEZ1cnRoZXIgY2FwdHVyZXMgYXJlIGlnbm9yZWQuJyApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGZpbGVuYW1lID0gKCAnMDAwMCcgKyB0aGlzLmZyYW1lQ291bnQgKS5zbGljZSggLTUgKSArICcucG5nJztcblxuICAgIHRoaXMuZnJhbWVDb3VudCArKztcbiAgICB0aGlzLmluUHJvZ3Jlc3MgKys7XG5cbiAgICB0aGlzLmNhbnZhcy50b0Jsb2IoICggYmxvYiApID0+IHtcbiAgICAgIHRoaXMuemlwLmZpbGUoIGZpbGVuYW1lLCBibG9iICk7XG4gICAgICB0aGlzLmluUHJvZ3Jlc3MgLS07XG4gICAgICB0aGlzLl9fZG9uZSgpO1xuICAgIH0gKTtcbiAgfVxuXG4gIHNhdmUoKSB7XG4gICAgdGhpcy5xdWV1ZVNhdmUgPSB0cnVlO1xuICAgIHRoaXMuX19kb25lKCk7XG4gIH1cblxuICBfX2RvbmUoKSB7XG4gICAgaWYgKCB0aGlzLnF1ZXVlU2F2ZSAmJiB0aGlzLmluUHJvZ3Jlc3MgPT09IDAgKSB7XG4gICAgICB0aGlzLnppcC5nZW5lcmF0ZUFzeW5jKCB7IHR5cGU6ICdibG9iJyB9ICkudGhlbiggKCBibG9iICkgPT4ge1xuICAgICAgICB0aGlzLmFuY2hvci5ocmVmID0gd2luZG93LlVSTC5jcmVhdGVPYmplY3RVUkwoIGJsb2IgKTtcbiAgICAgICAgdGhpcy5hbmNob3IuZG93bmxvYWQgPSAnY2FudmFzU2F2ZXItJyArIERhdGUubm93KCk7XG4gICAgICAgIHRoaXMuYW5jaG9yLmNsaWNrKCk7XG5cbiAgICAgICAgdGhpcy5mcmFtZUNvdW50ID0gMDtcbiAgICAgICAgdGhpcy5xdWV1ZVNhdmUgPSBmYWxzZTtcbiAgICAgIH0gKTtcbiAgICB9XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ2FudmFzU2F2ZXI7IiwiaW1wb3J0IFBhdGggZnJvbSAnLi9nbGNhdC1wYXRoJztcblxubGV0IHJlcXVpcmVkRmllbGRzID0gKCBvYmplY3QsIG5hbml0aGVmdWNrLCBmaWVsZHMgKSA9PiB7XG4gIGZpZWxkcy5tYXAoICggZmllbGQgKSA9PiB7XG4gICAgaWYgKCB0eXBlb2Ygb2JqZWN0WyBmaWVsZCBdID09PSAndW5kZWZpbmVkJyApIHtcbiAgICAgIHRocm93ICdHTENhdC1QYXRoOiAnICsgZmllbGQgKyAnIGlzIHJlcXVpcmVkIGZvciAnICsgbmFuaXRoZWZ1Y2s7XG4gICAgfVxuICB9ICk7XG59O1xuXG5sZXQgUGF0aEdVSSA9IGNsYXNzIGV4dGVuZHMgUGF0aCB7XG4gIGNvbnN0cnVjdG9yKCBnbENhdCwgcGFyYW1zICkge1xuICAgIHN1cGVyKCBnbENhdCwgcGFyYW1zICk7XG4gICAgbGV0IGl0ID0gdGhpcztcblxuICAgIHJlcXVpcmVkRmllbGRzKCBwYXJhbXMsICdwYXJhbXMnLCBbXG4gICAgICAnY2FudmFzJyxcbiAgICAgICdlbCdcbiAgICBdICk7XG5cbiAgICBpdC5ndWkgPSB7IHBhcmVudDogaXQucGFyYW1zLmVsIH07XG5cbiAgICBpdC5ndWkuaW5mbyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdzcGFuJyApO1xuICAgIGl0Lmd1aS5wYXJlbnQuYXBwZW5kQ2hpbGQoIGl0Lmd1aS5pbmZvICk7XG5cbiAgICBpdC5ndWkucmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnaW5wdXQnICk7XG4gICAgaXQuZ3VpLnJhbmdlLnR5cGUgPSAncmFuZ2UnO1xuICAgIGl0Lmd1aS5yYW5nZS5taW4gPSAwO1xuICAgIGl0Lmd1aS5yYW5nZS5tYXggPSAwO1xuICAgIGl0Lmd1aS5yYW5nZS5zdGVwID0gMTtcbiAgICBpdC5ndWkucGFyZW50LmFwcGVuZENoaWxkKCBpdC5ndWkucmFuZ2UgKTtcblxuICAgIGl0LmRhdGVMaXN0ID0gbmV3IEFycmF5KCAzMCApLmZpbGwoIDAgKTtcbiAgICBpdC5kYXRlTGlzdEluZGV4ID0gMDtcbiAgICBpdC50b3RhbEZyYW1lcyA9IDA7XG4gICAgaXQuZnBzID0gMDtcbiAgICBpdC5jdXJyZW50SW5kZXggPSAwO1xuICAgIGl0LnZpZXdOYW1lID0gJyc7XG4gICAgaXQudmlld0luZGV4ID0gMDtcblxuICAgIGxldCBnbCA9IGdsQ2F0LmdsO1xuICAgIGxldCB2Ym9RdWFkID0gZ2xDYXQuY3JlYXRlVmVydGV4YnVmZmVyKCBuZXcgRmxvYXQzMkFycmF5KCBbIC0xLCAtMSwgMSwgLTEsIC0xLCAxLCAxLCAxIF0gKSApO1xuICAgIGl0LmFkZCgge1xuICAgICAgX19QYXRoR3VpUmV0dXJuOiB7XG4gICAgICAgIHdpZHRoOiBpdC5wYXJhbXMuY2FudmFzLndpZHRoLFxuICAgICAgICBoZWlnaHQ6IGl0LnBhcmFtcy5jYW52YXMuaGVpZ2h0LFxuICAgICAgICB2ZXJ0OiAnYXR0cmlidXRlIHZlYzIgcDt2b2lkIG1haW4oKXtnbF9Qb3NpdGlvbj12ZWM0KHAsMCwxKTt9JyxcbiAgICAgICAgZnJhZzogJ3ByZWNpc2lvbiBoaWdocCBmbG9hdDt1bmlmb3JtIHZlYzIgcjt1bmlmb3JtIHNhbXBsZXIyRCBzO3ZvaWQgbWFpbigpe2dsX0ZyYWdDb2xvcj10ZXh0dXJlMkQocyxnbF9GcmFnQ29vcmQueHkvcik7fScsXG4gICAgICAgIGJsZW5kOiBbIGdsLk9ORSwgZ2wuT05FIF0sXG4gICAgICAgIGNsZWFyOiBbIDAuMCwgMC4wLCAwLjAsIDEuMCBdLFxuICAgICAgICBmdW5jOiAoIF9wLCBwYXJhbXMgKSA9PiB7XG4gICAgICAgICAgZ2wudmlld3BvcnQoIDAsIDAsIGl0LnBhcmFtcy5jYW52YXMud2lkdGgsIGl0LnBhcmFtcy5jYW52YXMuaGVpZ2h0ICk7XG4gICAgICAgICAgZ2xDYXQudW5pZm9ybTJmdiggJ3InLCBbIGl0LnBhcmFtcy5jYW52YXMud2lkdGgsIGl0LnBhcmFtcy5jYW52YXMuaGVpZ2h0IF0gKTtcblxuICAgICAgICAgIGdsQ2F0LmF0dHJpYnV0ZSggJ3AnLCB2Ym9RdWFkLCAyICk7XG4gICAgICAgICAgZ2xDYXQudW5pZm9ybVRleHR1cmUoICdzJywgcGFyYW1zLmlucHV0LCAwICk7XG4gICAgICAgICAgZ2wuZHJhd0FycmF5cyggZ2wuVFJJQU5HTEVfU1RSSVAsIDAsIDQgKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICB9ICk7XG4gIH1cblxuICBiZWdpbigpIHtcbiAgICBsZXQgaXQgPSB0aGlzO1xuXG4gICAgaXQuY3VycmVudEluZGV4ID0gMDtcbiAgfVxuXG4gIGVuZCgpIHtcbiAgICBsZXQgaXQgPSB0aGlzO1xuXG4gICAgaXQuZ3VpLnJhbmdlLm1heCA9IE1hdGgubWF4KCBpdC5ndWkucmFuZ2UubWF4LCBpdC5jdXJyZW50SW5kZXggKTtcbiAgICBpdC5jdXJyZW50SW5kZXggPSAwO1xuXG4gICAgbGV0IG5vdyA9ICtuZXcgRGF0ZSgpICogMUUtMztcbiAgICBpdC5kYXRlTGlzdFsgaXQuZGF0ZUxpc3RJbmRleCBdID0gbm93O1xuICAgIGl0LmRhdGVMaXN0SW5kZXggPSAoIGl0LmRhdGVMaXN0SW5kZXggKyAxICkgJSBpdC5kYXRlTGlzdC5sZW5ndGg7XG4gICAgaXQuZnBzID0gKFxuICAgICAgKCBpdC5kYXRlTGlzdC5sZW5ndGggLSAxIClcbiAgICAgIC8gKCBub3cgLSBpdC5kYXRlTGlzdFsgaXQuZGF0ZUxpc3RJbmRleCBdIClcbiAgICApLnRvRml4ZWQoIDEgKTtcblxuICAgIGl0LnRvdGFsRnJhbWVzICsrO1xuXG4gICAgaXQuZ3VpLmluZm8uaW5uZXJUZXh0ID0gKFxuICAgICAgJ1BhdGg6ICcgKyBpdC52aWV3TmFtZSArICcgKCcgKyBpdC52aWV3SW5kZXggKyAnKVxcbidcbiAgICAgICsgaXQuZnBzICsgJyBGUFNcXG4nXG4gICAgICArIGl0LnRvdGFsRnJhbWVzICsgJyBmcmFtZXNcXG4nXG4gICAgKTtcbiAgfVxuXG4gIHJlbmRlciggbmFtZSwgcGFyYW1zICkge1xuICAgIGxldCBpdCA9IHRoaXM7XG5cbiAgICBpdC5jdXJyZW50SW5kZXggKys7XG4gICAgbGV0IHZpZXcgPSBwYXJzZUludCggaXQuZ3VpLnJhbmdlLnZhbHVlICk7XG5cbiAgICBpZiAoIGl0LmN1cnJlbnRJbmRleCA8PSB2aWV3IHx8IHZpZXcgPT09IDAgKSB7XG4gICAgICBpdC52aWV3TmFtZSA9IHZpZXcgPT09IDAgPyAnKkZ1bGwqJyA6IG5hbWU7XG4gICAgICBpdC52aWV3SW5kZXggPSBpdC5jdXJyZW50SW5kZXg7XG5cbiAgICAgIHN1cGVyLnJlbmRlciggbmFtZSwgcGFyYW1zICk7XG5cbiAgICAgIGlmICggaXQuY3VycmVudEluZGV4ID09PSB2aWV3ICkge1xuICAgICAgICBsZXQgdCA9IChcbiAgICAgICAgICAoIHBhcmFtcyAmJiBwYXJhbXMudGFyZ2V0IClcbiAgICAgICAgICAgID8gcGFyYW1zLnRhcmdldFxuICAgICAgICAgICAgOiBpdC5wYXRoc1sgbmFtZSBdLmZyYW1lYnVmZmVyXG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKCB0ICYmIHQuZnJhbWVidWZmZXIgKSB7XG4gICAgICAgICAgbGV0IGkgPSB0LnRleHR1cmVzID8gdC50ZXh0dXJlc1sgMCBdIDogdC50ZXh0dXJlO1xuICAgICAgICAgIGlmICggaXQucGFyYW1zLnN0cmV0Y2ggKSB7XG4gICAgICAgICAgICBzdXBlci5yZW5kZXIoICdfX1BhdGhHdWlSZXR1cm4nLCB7XG4gICAgICAgICAgICAgIHRhcmdldDogUGF0aEdVSS5udWxsRmIsXG4gICAgICAgICAgICAgIGlucHV0OiBpLFxuICAgICAgICAgICAgICB3aWR0aDogaXQucGFyYW1zLmNhbnZhcy53aWR0aCxcbiAgICAgICAgICAgICAgaGVpZ2h0OiBpdC5wYXJhbXMuY2FudmFzLmhlaWdodFxuICAgICAgICAgICAgfSApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpdC5wYXJhbXMuY2FudmFzLndpZHRoID0gKCBwYXJhbXMgPyBwYXJhbXMud2lkdGggOiAwICkgfHwgaXQucGF0aHNbIG5hbWUgXS53aWR0aCB8fCBpdC5wYXJhbXMud2lkdGg7XG4gICAgICAgICAgICBpdC5wYXJhbXMuY2FudmFzLmhlaWdodCA9ICggcGFyYW1zID8gcGFyYW1zLmhlaWdodCA6IDAgKSB8fCBpdC5wYXRoc1sgbmFtZSBdLmhlaWdodCB8fCBpdC5wYXJhbXMuaGVpZ2h0O1xuICAgICAgICAgICAgc3VwZXIucmVuZGVyKCAnX19QYXRoR3VpUmV0dXJuJywge1xuICAgICAgICAgICAgICB0YXJnZXQ6IFBhdGhHVUkubnVsbEZiLFxuICAgICAgICAgICAgICBpbnB1dDogaVxuICAgICAgICAgICAgfSApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgUGF0aEdVSTsiLCJsZXQgcmVxdWlyZWRGaWVsZHMgPSAoIG9iamVjdCwgbmFuaXRoZWZ1Y2ssIGZpZWxkcyApID0+IHtcbiAgZmllbGRzLm1hcCggKCBmaWVsZCApID0+IHtcbiAgICBpZiAoIHR5cGVvZiBvYmplY3RbIGZpZWxkIF0gPT09ICd1bmRlZmluZWQnICkge1xuICAgICAgdGhyb3cgJ0dMQ2F0LVBhdGg6ICcgKyBmaWVsZCArICcgaXMgcmVxdWlyZWQgZm9yICcgKyBuYW5pdGhlZnVjaztcbiAgICB9XG4gIH0gKTtcbn07XG5cbmxldCBQYXRoID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvciggZ2xDYXQsIHBhcmFtcyApIHtcbiAgICBsZXQgaXQgPSB0aGlzO1xuXG4gICAgaXQuZ2xDYXQgPSBnbENhdDtcbiAgICBpdC5nbCA9IGdsQ2F0LmdsO1xuXG4gICAgaXQucGF0aHMgPSB7fTtcbiAgICBpdC5nbG9iYWxGdW5jID0gKCkgPT4ge307XG4gICAgaXQucGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICB9XG5cbiAgYWRkKCBwYXRocyApIHtcbiAgICBsZXQgaXQgPSB0aGlzO1xuXG4gICAgZm9yICggbGV0IG5hbWUgaW4gcGF0aHMgKSB7XG4gICAgICBsZXQgcGF0aCA9IHBhdGhzWyBuYW1lIF07XG4gICAgICByZXF1aXJlZEZpZWxkcyggcGF0aCwgJ3BhdGggb2JqZWN0JywgW1xuICAgICAgICAndmVydCcsXG4gICAgICAgICdmcmFnJ1xuICAgICAgXSApO1xuICAgICAgaXQucGF0aHNbIG5hbWUgXSA9IHBhdGg7XG5cbiAgICAgIGlmICggdHlwZW9mIHBhdGguZGVwdGhUZXN0ID09PSAndW5kZWZpbmVkJyApIHsgcGF0aC5kZXB0aFRlc3QgPSB0cnVlOyB9XG4gICAgICBpZiAoIHR5cGVvZiBwYXRoLmRlcHRoV3JpdGUgPT09ICd1bmRlZmluZWQnICkgeyBwYXRoLmRlcHRoV3JpdGUgPSB0cnVlOyB9XG4gICAgICBpZiAoIHR5cGVvZiBwYXRoLmJsZW5kID09PSAndW5kZWZpbmVkJyApIHsgcGF0aC5ibGVuZCA9IFsgaXQuZ2wuU1JDX0FMUEhBLCBpdC5nbC5PTkVfTUlOVVNfU1JDX0FMUEhBIF07IH1cbiAgICAgIGlmICggdHlwZW9mIHBhdGguY3VsbCA9PT0gJ3VuZGVmaW5lZCcgKSB7IHBhdGguY3VsbCA9IHRydWU7IH1cblxuICAgICAgaWYgKCBwYXRoLmZyYW1lYnVmZmVyICkge1xuICAgICAgICBpZiAoIHBhdGguZHJhd2J1ZmZlcnMgKSB7XG4gICAgICAgICAgcGF0aC5mcmFtZWJ1ZmZlciA9IGl0LmdsQ2F0LmNyZWF0ZURyYXdCdWZmZXJzKCBwYXRoLndpZHRoLCBwYXRoLmhlaWdodCwgcGF0aC5kcmF3YnVmZmVycyApO1xuICAgICAgICB9IGVsc2UgaWYgKCBwYXRoLmZsb2F0ICkge1xuICAgICAgICAgIHBhdGguZnJhbWVidWZmZXIgPSBpdC5nbENhdC5jcmVhdGVGbG9hdEZyYW1lYnVmZmVyKCBwYXRoLndpZHRoLCBwYXRoLmhlaWdodCApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhdGguZnJhbWVidWZmZXIgPSBpdC5nbENhdC5jcmVhdGVGcmFtZWJ1ZmZlciggcGF0aC53aWR0aCwgcGF0aC5oZWlnaHQgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBwYXRoLnByb2dyYW0gPSBpdC5nbENhdC5jcmVhdGVQcm9ncmFtKCBwYXRoLnZlcnQsIHBhdGguZnJhZyApO1xuICAgIH1cbiAgfVxuXG4gIHJlbmRlciggbmFtZSwgcGFyYW1zICkge1xuICAgIGxldCBpdCA9IHRoaXM7XG5cbiAgICBsZXQgcGF0aCA9IGl0LnBhdGhzWyBuYW1lIF07XG4gICAgaWYgKCAhcGF0aCApIHsgdGhyb3cgJ0dMQ2F0LVBhdGg6IFRoZSBwYXRoIGNhbGxlZCAnICsgbmFtZSArICcgaXMgbm90IGRlZmluZWQhJzsgfVxuXG4gICAgaWYgKCAhcGFyYW1zICkgeyBwYXJhbXMgPSB7fTsgfVxuICAgIHBhcmFtcy5mcmFtZWJ1ZmZlciA9IHR5cGVvZiBwYXJhbXMudGFyZ2V0ICE9PSAndW5kZWZpbmVkJyA/IHBhcmFtcy50YXJnZXQuZnJhbWVidWZmZXIgOiBwYXRoLmZyYW1lYnVmZmVyID8gcGF0aC5mcmFtZWJ1ZmZlci5mcmFtZWJ1ZmZlciA6IG51bGw7XG5cbiAgICBsZXQgd2lkdGggPSBwYXJhbXMud2lkdGggfHwgcGF0aC53aWR0aDtcbiAgICBsZXQgaGVpZ2h0ID0gcGFyYW1zLmhlaWdodCB8fCBwYXRoLmhlaWdodDtcblxuICAgIGlmICggIXdpZHRoIHx8ICFoZWlnaHQgKSB7XG4gICAgICB0aHJvdyAnR0xDYXQtUGF0aDogd2lkdGggb3IgaGVpZ2h0IGlzIGludmFsaWQnO1xuICAgIH1cblxuICAgIGl0LmdsLnZpZXdwb3J0KCAwLCAwLCB3aWR0aCwgaGVpZ2h0ICk7XG4gICAgaXQuZ2xDYXQudXNlUHJvZ3JhbSggcGF0aC5wcm9ncmFtICk7XG4gICAgcGF0aC5jdWxsID8gaXQuZ2wuZW5hYmxlKCBpdC5nbC5DVUxMX0ZBQ0UgKSA6IGl0LmdsLmRpc2FibGUoIGl0LmdsLkNVTExfRkFDRSApO1xuICAgIGl0LmdsLmJpbmRGcmFtZWJ1ZmZlciggaXQuZ2wuRlJBTUVCVUZGRVIsIHBhcmFtcy5mcmFtZWJ1ZmZlciApO1xuICAgIGlmICggaXQucGFyYW1zLmRyYXdidWZmZXJzICkge1xuICAgICAgaXQuZ2xDYXQuZHJhd0J1ZmZlcnMoIHBhdGguZHJhd2J1ZmZlcnMgPyBwYXRoLmRyYXdidWZmZXJzIDogcGFyYW1zLmZyYW1lYnVmZmVyID09PSBudWxsID8gWyBpdC5nbC5CQUNLIF0gOiBbIGl0LmdsLkNPTE9SX0FUVEFDSE1FTlQwIF0gKTtcbiAgICB9XG4gICAgaXQuZ2wuYmxlbmRGdW5jKCAuLi5wYXRoLmJsZW5kICk7XG4gICAgaWYgKCBwYXRoLmNsZWFyICkgeyBpdC5nbENhdC5jbGVhciggLi4ucGF0aC5jbGVhciApOyB9XG4gICAgcGF0aC5kZXB0aFRlc3QgPyBpdC5nbC5lbmFibGUoIGl0LmdsLkRFUFRIX1RFU1QgKSA6IGl0LmdsLmRpc2FibGUoIGl0LmdsLkRFUFRIX1RFU1QgKTtcbiAgICBwYXRoLmRlcHRoV3JpdGUgPyBpdC5nbC5kZXB0aE1hc2soIHRydWUgKSA6IGl0LmdsLmRlcHRoTWFzayggZmFsc2UgKTtcblxuICAgIGl0LmdsQ2F0LnVuaWZvcm0yZnYoICdyZXNvbHV0aW9uJywgWyB3aWR0aCwgaGVpZ2h0IF0gKTtcbiAgICBpdC5nbG9iYWxGdW5jKCBwYXRoLCBwYXJhbXMgKTtcblxuICAgIGlmICggcGF0aC5mdW5jICkgeyBwYXRoLmZ1bmMoIHBhdGgsIHBhcmFtcyApOyB9XG4gIH1cblxuICByZXBsYWNlUHJvZ3JhbSggbmFtZSwgdmVydCwgZnJhZyApIHtcbiAgICBjb25zdCBwYXRoID0gdGhpcy5wYXRoc1sgbmFtZSBdO1xuICAgIGlmICggIXBhdGggKSB7IHRocm93ICdHTENhdC1QYXRoOiBUaGUgcGF0aCBjYWxsZWQgJyArIG5hbWUgKyAnIGlzIG5vdCBkZWZpbmVkISc7IH1cblxuICAgIHRyeSB7XG4gICAgICBjb25zdCBwcmV2UHJvZ3JhbSA9IHBhdGgucHJvZ3JhbTtcbiAgICAgIGNvbnN0IG5ld1Byb2dyYW0gPSB0aGlzLmdsQ2F0LmNyZWF0ZVByb2dyYW0oIHZlcnQsIGZyYWcgKTtcbiAgICAgIGlmICggbmV3UHJvZ3JhbSApIHtcbiAgICAgICAgcGF0aC5wcm9ncmFtID0gbmV3UHJvZ3JhbTtcbiAgICAgICAgdGhpcy5nbC5kZWxldGVQcm9ncmFtKCBwcmV2UHJvZ3JhbS5wcm9ncmFtICk7XG4gICAgICAgIHRoaXMuZ2wuZGVsZXRlU2hhZGVyKCBwcmV2UHJvZ3JhbS52ZXJ0ICk7XG4gICAgICAgIHRoaXMuZ2wuZGVsZXRlU2hhZGVyKCBwcmV2UHJvZ3JhbS5mcmFnICk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoIGUgKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCBlICk7XG4gICAgfVxuICB9XG5cbiAgcmVzaXplKCBuYW1lLCB3aWR0aCwgaGVpZ2h0ICkge1xuICAgIGxldCBpdCA9IHRoaXM7XG5cbiAgICBsZXQgcGF0aCA9IGl0LnBhdGhzWyBuYW1lIF07XG5cbiAgICBwYXRoLndpZHRoID0gd2lkdGg7XG4gICAgcGF0aC5oZWlnaHQgPSBoZWlnaHQ7XG5cbiAgICBpZiAoIHBhdGguZnJhbWVidWZmZXIgKSB7XG4gICAgICBpZiAoIGl0LnBhcmFtcy5kcmF3YnVmZmVycyAmJiBwYXRoLmRyYXdidWZmZXJzICkge1xuICAgICAgICBwYXRoLmZyYW1lYnVmZmVyID0gaXQuZ2xDYXQuY3JlYXRlRHJhd0J1ZmZlcnMoIHBhdGgud2lkdGgsIHBhdGguaGVpZ2h0LCBwYXRoLmRyYXdidWZmZXJzICk7XG4gICAgICB9IGVsc2UgaWYgKCBwYXRoLmZsb2F0ICkge1xuICAgICAgICBpdC5nbENhdC5yZXNpemVGbG9hdEZyYW1lYnVmZmVyKCBwYXRoLmZyYW1lYnVmZmVyLCBwYXRoLndpZHRoLCBwYXRoLmhlaWdodCApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXQuZ2xDYXQucmVzaXplRnJhbWVidWZmZXIoIHBhdGguZnJhbWVidWZmZXIsIHBhdGgud2lkdGgsIHBhdGguaGVpZ2h0ICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCB0eXBlb2YgcGF0aC5vbnJlc2l6ZSA9PT0gJ2Z1bmN0aW9uJyApIHtcbiAgICAgIHBhdGgub25yZXNpemUoIHBhdGgsIHdpZHRoLCBoZWlnaHQgKTtcbiAgICB9XG4gIH1cblxuICBzZXRHbG9iYWxGdW5jKCBmdW5jICkgeyB0aGlzLmdsb2JhbEZ1bmMgPSBmdW5jOyB9XG5cbiAgZmIoIG5hbWUgKSB7XG4gICAgaWYgKCAhdGhpcy5wYXRoc1sgbmFtZSBdICkgeyB0aHJvdyAnZ2xjYXQtcGF0aC5mYjogcGF0aCBjYWxsZWQgJyArIG5hbWUgKyAnIGlzIG5vdCBkZWZpbmVkJzsgfVxuICAgIGlmICggIXRoaXMucGF0aHNbIG5hbWUgXS5mcmFtZWJ1ZmZlciApIHsgdGhyb3cgJ2dsY2F0LXBhdGguZmI6IHRoZXJlIGlzIG5vIGZyYW1lYnVmZmVyIGZvciB0aGUgcGF0aCAnICsgbmFtZTsgfVxuXG4gICAgcmV0dXJuIHRoaXMucGF0aHNbIG5hbWUgXS5mcmFtZWJ1ZmZlcjtcbiAgfVxufTtcblxuUGF0aC5udWxsRmIgPSB7IGZyYW1lYnVmZmVyOiBudWxsIH07XG5cbmV4cG9ydCBkZWZhdWx0IFBhdGg7IiwiLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBHTENhdFByb2dyYW1cbiAqIEBwcm9wZXJ0eSB7V2ViR0xQcm9ncmFtfSBwcm9ncmFtXG4gKiBAcHJvcGVydHkge09iamVjdDxzdHJpbmcsR0xpbnR8V2ViR0xVbmlmb3JtTG9jYXRpb24+fSBsb2NhdGlvbnNcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEdMQ2F0RnJhbWVidWZmZXJcbiAqIEBwcm9wZXJ0eSB7V2ViR0xGcmFtZWJ1ZmZlcn0gZnJhbWVidWZmZXJcbiAqIEBwcm9wZXJ0eSB7V2ViR0xSZW5kZXJidWZmZXJ9IGRlcHRoXG4gKiBAcHJvcGVydHkge1dlYkdMVGV4dHVyZX0gdGV4dHVyZVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gR0xDYXREcmF3QnVmZmVyc1xuICogQHByb3BlcnR5IHtXZWJHTEZyYW1lYnVmZmVyfSBmcmFtZWJ1ZmZlclxuICogQHByb3BlcnR5IHtXZWJHTFJlbmRlcmJ1ZmZlcn0gZGVwdGhcbiAqIEBwcm9wZXJ0eSB7V2ViR0xUZXh0dXJlW119IHRleHR1cmVzXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7SW1hZ2VCaXRtYXB8SW1hZ2VEYXRhfEhUTUxJbWFnZUVsZW1lbnR8SFRNTENhbnZhc0VsZW1lbnR8SFRNTFZpZGVvRWxlbWVudH0gUGl4ZWxhYmxlXG4gKi9cblxuLyoqXG4gKiBXZWJHTCB3cmFwcGVyIHdpdGggbG90cyBvZiByZXNwZWN0IHRvIHRoZSBvcmlnaW5hbCBBUEksIHN0YXJyaW5nIEZNU19DYXQuXG4gKi9cbmNvbnN0IEdMQ2F0ID0gY2xhc3Mge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IEdMQ2F0IGluc3RhbmNlLlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gX2dsIE9yaWdpbmFsIFdlYkdMIGNvbnRleHRcbiAgICovXG4gIGNvbnN0cnVjdG9yKCBfZ2wgKSB7XG4gICAgdGhpcy5nbCA9IF9nbDtcbiAgICBjb25zdCBnbCA9IHRoaXMuZ2w7XG5cbiAgICBnbC5lbmFibGUoIGdsLkRFUFRIX1RFU1QgKTtcbiAgICBnbC5kZXB0aEZ1bmMoIGdsLkxFUVVBTCApO1xuICAgIGdsLmVuYWJsZSggZ2wuQkxFTkQgKTtcbiAgICBnbC5ibGVuZEZ1bmMoIGdsLlNSQ19BTFBIQSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSApO1xuXG4gICAgLyoqXG4gICAgICogQ29udGFpbiBleHRlbnNpb25zLiAgXG4gICAgICogS2V5cyBhcmUgZXh0ZW5zaW9uIG5hbWUsIGFuZCB2YWx1ZXMgYXJlIGV4dGVuc2lvbiBvYmplY3QuXG4gICAgICogQHR5cGUge09iamVjdDxzdHJpbmcsV2ViR0xFeHRlbnNpb24+fVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICB0aGlzLl9fZXh0ZW5zaW9ucyA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogQ3VycmVudGx5IHVzaW5nIHByb2dyYW0uXG4gICAgICogQHR5cGUge1dlYkdMUHJvZ3JhbX1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgdGhpcy5fX2N1cnJlbnRQcm9ncmFtID0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYSBuZXcgb3IgZXhpc3RpbmcgZXh0ZW5zaW9uIG9iamVjdC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IF9uYW1lIE5hbWUgb2YgdGhlIGV4dGVuc2lvblxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtfdGhyb3c9ZmFsc2VdIElmIHRoaXMgaXMgdHJ1ZSwgZXhjZXB0aW9uIHdpbGwgYmUgdGhyb3dlZCB3aGVuIGl0IGlzIGZhaWxlZCB0byBnZXQgZXh0ZW5zaW9uXG4gICAqIEByZXR1cm5zIHtXZWJHTEV4dGVuc2lvbn0gRXh0ZW5zaW9uIG9iamVjdFxuICAgKi9cbiAgZ2V0RXh0ZW5zaW9uKCBfbmFtZSwgX3Rocm93ICkge1xuICAgIGNvbnN0IGdsID0gdGhpcy5nbDtcblxuICAgIGlmICggdHlwZW9mIF9uYW1lID09PSAnb2JqZWN0JyAmJiBfbmFtZS5pc0FycmF5KCkgKSB7XG4gICAgICByZXR1cm4gX25hbWUuZXZlcnkoICggbmFtZSApID0+IHRoaXMuZ2V0RXh0ZW5zaW9uKCBuYW1lLCBfdGhyb3cgKSApO1xuICAgIH0gZWxzZSBpZiAoIHR5cGVvZiBfbmFtZSA9PT0gJ3N0cmluZycgKSB7XG4gICAgICBpZiAoIHRoaXMuX19leHRlbnNpb25zWyBfbmFtZSBdICkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX2V4dGVuc2lvbnNbIF9uYW1lIF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9fZXh0ZW5zaW9uc1sgX25hbWUgXSA9IGdsLmdldEV4dGVuc2lvbiggX25hbWUgKTtcbiAgICAgICAgaWYgKCB0aGlzLl9fZXh0ZW5zaW9uc1sgX25hbWUgXSApIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fX2V4dGVuc2lvbnNbIF9uYW1lIF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCBfdGhyb3cgKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoICdUaGUgZXh0ZW5zaW9uIFwiJyArIF9uYW1lICsgJ1wiIGlzIG5vdCBzdXBwb3J0ZWQnICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvciggJ0dMQ2F0LmdldEV4dGVuc2lvbjogX25hbWUgbXVzdCBiZSBzdHJpbmcgb3IgYXJyYXknICk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBHTENhdCBwcm9ncmFtIG9iamVjdC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IF92ZXJ0IEdMU0wgc291cmNlIG9mIHRoZSB2ZXJ0ZXggc2hhZGVyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBfZnJhZyBHTFNMIHNvdXJjZSBvZiB0aGUgZnJhZ21lbnQgc2hhZGVyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtfb25FcnJvcl0gV2lsbCBiZSBjYWxsZWQgaWYgY29tcGlsZS9saW5rIGVycm9yIGlzIG9jY3VycmVkXG4gICAqIEByZXR1cm5zIHtHTENhdFByb2dyYW19IENyZWF0ZWQgcHJvZ3JhbVxuICAgKi9cbiAgY3JlYXRlUHJvZ3JhbSggX3ZlcnQsIF9mcmFnLCBfb25FcnJvciApIHtcbiAgICBjb25zdCBnbCA9IHRoaXMuZ2w7XG5cbiAgICBsZXQgZXJyb3I7XG4gICAgaWYgKCB0eXBlb2YgX29uRXJyb3IgPT09ICdmdW5jdGlvbicgKSB7XG4gICAgICBlcnJvciA9IF9vbkVycm9yO1xuICAgIH0gZWxzZSB7XG4gICAgICBlcnJvciA9ICggX3N0ciApID0+IHsgdGhyb3cgbmV3IEVycm9yKCBfc3RyICk7IH07XG4gICAgfVxuXG4gICAgY29uc3QgdmVydCA9IGdsLmNyZWF0ZVNoYWRlciggZ2wuVkVSVEVYX1NIQURFUiApO1xuICAgIGdsLnNoYWRlclNvdXJjZSggdmVydCwgX3ZlcnQgKTtcbiAgICBnbC5jb21waWxlU2hhZGVyKCB2ZXJ0ICk7XG4gICAgaWYgKCAhZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKCB2ZXJ0LCBnbC5DT01QSUxFX1NUQVRVUyApICkge1xuICAgICAgZXJyb3IoIGdsLmdldFNoYWRlckluZm9Mb2coIHZlcnQgKSApO1xuICAgICAgZ2wuZGVsZXRlU2hhZGVyKCB2ZXJ0ICk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCBmcmFnID0gZ2wuY3JlYXRlU2hhZGVyKCBnbC5GUkFHTUVOVF9TSEFERVIgKTtcbiAgICBnbC5zaGFkZXJTb3VyY2UoIGZyYWcsIF9mcmFnICk7XG4gICAgZ2wuY29tcGlsZVNoYWRlciggZnJhZyApO1xuICAgIGlmICggIWdsLmdldFNoYWRlclBhcmFtZXRlciggZnJhZywgZ2wuQ09NUElMRV9TVEFUVVMgKSApIHtcbiAgICAgIGVycm9yKCBnbC5nZXRTaGFkZXJJbmZvTG9nKCBmcmFnICkgKTtcbiAgICAgIGdsLmRlbGV0ZVNoYWRlciggdmVydCApO1xuICAgICAgZ2wuZGVsZXRlU2hhZGVyKCBmcmFnICk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCBwcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpO1xuICAgIGdsLmF0dGFjaFNoYWRlciggcHJvZ3JhbSwgdmVydCApO1xuICAgIGdsLmF0dGFjaFNoYWRlciggcHJvZ3JhbSwgZnJhZyApO1xuICAgIGdsLmxpbmtQcm9ncmFtKCBwcm9ncmFtICk7XG4gICAgaWYgKCBnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKCBwcm9ncmFtLCBnbC5MSU5LX1NUQVRVUyApICkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmVydDogdmVydCxcbiAgICAgICAgZnJhZzogZnJhZyxcbiAgICAgICAgcHJvZ3JhbTogcHJvZ3JhbSxcbiAgICAgICAgbG9jYXRpb25zOiB7fVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXJyb3IoIGdsLmdldFByb2dyYW1JbmZvTG9nKCBwcm9ncmFtICkgKTtcbiAgICAgIGdsLmRlbGV0ZVNoYWRlciggdmVydCApO1xuICAgICAgZ2wuZGVsZXRlU2hhZGVyKCBmcmFnICk7XG4gICAgICBnbC5kZWxldGVQcm9ncmFtKCBwcm9ncmFtICk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU3BlY2l0eSBhIHByb2dyYW0gdG8gdXNlLlxuICAgKiBAcGFyYW0ge0dMQ2F0UHJvZ3JhbX0gX3Byb2dyYW0gUHJvZ3JhbSB5b3Ugd2FudCB0byB1c2VcbiAgICogQHJldHVybnMge3ZvaWR9IHZvaWRcbiAgICovXG4gIHVzZVByb2dyYW0oIF9wcm9ncmFtICkge1xuICAgIGNvbnN0IGdsID0gdGhpcy5nbDtcblxuICAgIGdsLnVzZVByb2dyYW0oIF9wcm9ncmFtLnByb2dyYW0gKTtcbiAgICB0aGlzLl9fY3VycmVudFByb2dyYW0gPSBfcHJvZ3JhbTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgdmVydGV4IGJ1ZmZlci5cbiAgICogQHBhcmFtIHtBcnJheUJ1ZmZlcnxBcnJheUJ1ZmZlclZpZXd9IF9zb3VyY2UgU291cmNlIG9mIHRoZSBkYXRhXG4gICAqIEByZXR1cm5zIHtXZWJHTEJ1ZmZlcn0gR2VuZXJhdGVkIHZlcnRleCBidWZmZXJcbiAgICovXG4gIGNyZWF0ZVZlcnRleGJ1ZmZlciggX3NvdXJjZSApIHtcbiAgICBjb25zdCBnbCA9IHRoaXMuZ2w7XG5cbiAgICBjb25zdCBidWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcblxuICAgIGlmICggX3NvdXJjZSApIHsgdGhpcy5zZXRWZXJ0ZXhidWZmZXIoIGJ1ZmZlciwgX3NvdXJjZSApOyB9XG5cbiAgICByZXR1cm4gYnVmZmVyO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCBuZXcgZGF0YSBpbnRvIGEgdmVydGV4IGJ1ZmZlci5cbiAgICogQHBhcmFtIHtXZWJHTEJ1ZmZlcn0gX3RhcmdldCBUYXJnZXQgdmVydGV4IGJ1ZmZlclxuICAgKiBAcGFyYW0ge0FycmF5QnVmZmVyfEFycmF5QnVmZmVyVmlld30gX3NvdXJjZSBTb3VyY2Ugb2YgdGhlIGRhdGFcbiAgICogQHBhcmFtIHtHTGVudW19IFtfdXNhZ2U9Z2wuU1RBVElDX0RSQVddIFVzYWdlIG9mIHRoZSBidWZmZXJcbiAgICogQHJldHVybnMge3ZvaWR9IHZvaWRcbiAgICovXG4gIHNldFZlcnRleGJ1ZmZlciggX3RhcmdldCwgX3NvdXJjZSwgX3VzYWdlICkge1xuICAgIGNvbnN0IGdsID0gdGhpcy5nbDtcblxuICAgIGNvbnN0IHVzYWdlID0gX3VzYWdlIHx8IGdsLlNUQVRJQ19EUkFXO1xuXG4gICAgZ2wuYmluZEJ1ZmZlciggZ2wuQVJSQVlfQlVGRkVSLCBfdGFyZ2V0ICk7XG4gICAgZ2wuYnVmZmVyRGF0YSggZ2wuQVJSQVlfQlVGRkVSLCBfc291cmNlLCB1c2FnZSApO1xuICAgIGdsLmJpbmRCdWZmZXIoIGdsLkFSUkFZX0JVRkZFUiwgbnVsbCApO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBpbmRleCBidWZmZXIuXG4gICAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ8QXJyYXlCdWZmZXJWaWV3fSBfc291cmNlIFNvdXJjZSBvZiB0aGUgZGF0YVxuICAgKiBAcmV0dXJucyB7V2ViR0xCdWZmZXJ9IEdlbmVyYXRlZCBpbmRleCBidWZmZXJcbiAgICovXG4gIGNyZWF0ZUluZGV4YnVmZmVyKCBfc291cmNlICkge1xuICAgIGNvbnN0IGdsID0gdGhpcy5nbDtcblxuICAgIGNvbnN0IGJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuXG4gICAgaWYgKCBfc291cmNlICkgeyB0aGlzLnNldEluZGV4YnVmZmVyKCBidWZmZXIsIF9zb3VyY2UgKTsgfVxuXG4gICAgcmV0dXJuIGJ1ZmZlcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgbmV3IGRhdGEgaW50byBhIGluZGV4IGJ1ZmZlci5cbiAgICogQHBhcmFtIHtXZWJHTEJ1ZmZlcn0gX3RhcmdldCBUYXJnZXQgaW5kZXggYnVmZmVyXG4gICAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ8QXJyYXlCdWZmZXJWaWV3fSBfc291cmNlIFNvdXJjZSBvZiB0aGUgZGF0YVxuICAgKiBAcGFyYW0ge0dMZW51bX0gW191c2FnZT1nbC5TVEFUSUNfRFJBV10gVXNhZ2Ugb2YgdGhlIGJ1ZmZlclxuICAgKiBAcmV0dXJucyB7dm9pZH0gdm9pZFxuICAgKi9cbiAgc2V0SW5kZXhidWZmZXIoIF90YXJnZXQsIF9zb3VyY2UsIF91c2FnZSApIHtcbiAgICBjb25zdCBnbCA9IHRoaXMuZ2w7XG5cbiAgICBjb25zdCB1c2FnZSA9IF91c2FnZSB8fCBnbC5TVEFUSUNfRFJBVztcblxuICAgIGdsLmJpbmRCdWZmZXIoIGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBfdGFyZ2V0ICk7XG4gICAgZ2wuYnVmZmVyRGF0YSggZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIF9zb3VyY2UsIHVzYWdlICk7XG4gICAgZ2wuYmluZEJ1ZmZlciggZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIG51bGwgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgbG9jYXRpb24gZm9yIGdpdmVuIGF0dHJpYnV0ZSB2YXJpYWJsZSBuYW1lIGZvciBjdXJyZW50IHByb2dyYW0uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBfbmFtZSBOYW1lIG9mIHRoZSBhdHRyaWJ1dGUgdmFyaWFibGVcbiAgICogQHJldHVybnMge0dMaW50fSBMb2NhdGlvbiBvZiB0aGUgYXR0cmlidXRlIHZhcmlhYmxlXG4gICAqL1xuICBnZXRBdHRyaWJMb2NhdGlvbiggX25hbWUgKSB7XG4gICAgY29uc3QgZ2wgPSB0aGlzLmdsO1xuXG4gICAgbGV0IGxvY2F0aW9uO1xuICAgIGlmICggdGhpcy5fX2N1cnJlbnRQcm9ncmFtLmxvY2F0aW9uc1sgX25hbWUgXSApIHtcbiAgICAgIGxvY2F0aW9uID0gdGhpcy5fX2N1cnJlbnRQcm9ncmFtLmxvY2F0aW9uc1sgX25hbWUgXTtcbiAgICB9IGVsc2Uge1xuICAgICAgbG9jYXRpb24gPSBnbC5nZXRBdHRyaWJMb2NhdGlvbiggdGhpcy5fX2N1cnJlbnRQcm9ncmFtLnByb2dyYW0sIF9uYW1lICk7XG4gICAgICB0aGlzLl9fY3VycmVudFByb2dyYW0ubG9jYXRpb25zWyBfbmFtZSBdID0gbG9jYXRpb247XG4gICAgfVxuXG4gICAgcmV0dXJuIGxvY2F0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIEF0dGFjaCBhbiB2ZXJ0ZXggYnVmZmVyIGFzIGF0dHJpYnV0ZSB2YXJpYWJsZSB0byB0aGUgY3VycmVudCBwcm9ncmFtLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gX25hbWUgTmFtZSBvZiB0aGUgYXR0cmlidXRlIHZhcmlhYmxlXG4gICAqIEBwYXJhbSB7V2ViR0xCdWZmZXJ9IF9idWZmZXIgVmVydGV4IGJ1ZmZlclxuICAgKiBAcGFyYW0ge0dMaW50fSBfc2l6ZSBOdW1iZXIgb2YgY29tcG9uZW50cyBwZXIgdmVydGV4LiBNdXN0IGJlIDEsIDIsIDMgb3IgNFxuICAgKiBAcGFyYW0ge0dMZW51bX0gW190eXBlPWdsLkZMT0FUXSBEYXRhIHR5cGUgb2YgZWFjaCBjb21wb25lbnRcbiAgICogQHBhcmFtIHtHTHNpemVpfSBbX3N0cmlkZT0wXSBTdHJpZGUgaW4gYnl0ZXNcbiAgICogQHBhcmFtIHtHTGludHB0cn0gW19vZmZzZXQ9MF0gT2Zmc2V0IGluIGJ5dGVzXG4gICAqIEByZXR1cm5zIHt2b2lkfSB2b2lkXG4gICAqL1xuICBhdHRyaWJ1dGUoIF9uYW1lLCBfYnVmZmVyLCBfc2l6ZSwgX3R5cGUsIF9zdHJpZGUsIF9vZmZzZXQgKSB7XG4gICAgY29uc3QgZ2wgPSB0aGlzLmdsO1xuXG4gICAgY29uc3QgbG9jYXRpb24gPSB0aGlzLmdldEF0dHJpYkxvY2F0aW9uKCBfbmFtZSApO1xuICAgIGlmICggbG9jYXRpb24gPT09IC0xICkgeyByZXR1cm47IH1cblxuICAgIGdsLmJpbmRCdWZmZXIoIGdsLkFSUkFZX0JVRkZFUiwgX2J1ZmZlciApO1xuICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KCBsb2NhdGlvbiApO1xuICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoIGxvY2F0aW9uLCBfc2l6ZSwgX3R5cGUgfHwgZ2wuRkxPQVQsIGZhbHNlLCBfc3RyaWRlIHx8IDAsIF9vZmZzZXQgfHwgMCApO1xuXG4gICAgY29uc3QgZXh0ID0gdGhpcy5nZXRFeHRlbnNpb24oICdBTkdMRV9pbnN0YW5jZWRfYXJyYXlzJyApO1xuICAgIGlmICggZXh0ICkge1xuICAgICAgZXh0LnZlcnRleEF0dHJpYkRpdmlzb3JBTkdMRSggbG9jYXRpb24sIDAgKTtcbiAgICB9XG5cbiAgICBnbC5iaW5kQnVmZmVyKCBnbC5BUlJBWV9CVUZGRVIsIG51bGwgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBdHRhY2ggYW4gdmVydGV4IGJ1ZmZlciBhcyBhdHRyaWJ1dGUgdmFyaWFibGUgdG8gdGhlIGN1cnJlbnQgcHJvZ3JhbS4gIFxuICAgKiBDYW4gc2V0IGRpdmlzb3IgYXQgNHRoIGFyZ3VtZW50IGZvciB1c2Ugb2YgaW5zdGFuY2luZy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IF9uYW1lIE5hbWUgb2YgdGhlIGF0dHJpYnV0ZSB2YXJpYWJsZVxuICAgKiBAcGFyYW0ge1dlYkdMQnVmZmVyfSBfYnVmZmVyIFZlcnRleCBidWZmZXJcbiAgICogQHBhcmFtIHtHTGludH0gX3NpemUgTnVtYmVyIG9mIGNvbXBvbmVudHMgcGVyIHZlcnRleC4gTXVzdCBiZSAxLCAyLCAzIG9yIDRcbiAgICogQHBhcmFtIHtHTHVpbnR9IF9kaXYgRGl2aXNvciBvZiB0aGUgYXR0cmlidXRlXG4gICAqIEBwYXJhbSB7R0xlbnVtfSBbX3R5cGU9Z2wuRkxPQVRdIERhdGEgdHlwZSBvZiBlYWNoIGNvbXBvbmVudFxuICAgKiBAcGFyYW0ge0dMc2l6ZWl9IFtfc3RyaWRlPTBdIFN0cmlkZSBpbiBieXRlc1xuICAgKiBAcGFyYW0ge0dMaW50cHRyfSBbX29mZnNldD0wXSBPZmZzZXQgaW4gYnl0ZXNcbiAgICogQHJldHVybnMge3ZvaWR9IHZvaWRcbiAgICovXG4gIGF0dHJpYnV0ZURpdmlzb3IoIF9uYW1lLCBfYnVmZmVyLCBfc2l6ZSwgX2RpdiwgX3R5cGUsIF9zdHJpZGUsIF9vZmZzZXQgKSB7XG4gICAgY29uc3QgZ2wgPSB0aGlzLmdsO1xuXG4gICAgdGhpcy5nZXRFeHRlbnNpb24oICdBTkdMRV9pbnN0YW5jZWRfYXJyYXlzJywgdHJ1ZSApO1xuXG4gICAgY29uc3QgbG9jYXRpb24gPSB0aGlzLmdldEF0dHJpYkxvY2F0aW9uKCBfbmFtZSApO1xuICAgIGlmICggbG9jYXRpb24gPT09IC0xICkgeyByZXR1cm47IH1cblxuICAgIGdsLmJpbmRCdWZmZXIoIGdsLkFSUkFZX0JVRkZFUiwgX2J1ZmZlciApO1xuICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KCBsb2NhdGlvbiApO1xuICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoIGxvY2F0aW9uLCBfc2l6ZSwgX3R5cGUgfHwgZ2wuRkxPQVQsIGZhbHNlLCBfc3RyaWRlIHx8IDAsIF9vZmZzZXQgfHwgMCApO1xuXG4gICAgY29uc3QgZXh0ID0gdGhpcy5nZXRFeHRlbnNpb24oICdBTkdMRV9pbnN0YW5jZWRfYXJyYXlzJyApO1xuICAgIGlmICggZXh0ICkge1xuICAgICAgZXh0LnZlcnRleEF0dHJpYkRpdmlzb3JBTkdMRSggbG9jYXRpb24sIF9kaXYgKTtcbiAgICB9XG5cbiAgICBnbC5iaW5kQnVmZmVyKCBnbC5BUlJBWV9CVUZGRVIsIG51bGwgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgbG9jYXRpb24gZm9yIGdpdmVuIHVuaWZvcm0gdmFyaWFibGUgbmFtZSBmb3IgY3VycmVudCBwcm9ncmFtLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gX25hbWUgTmFtZSBvZiB0aGUgdW5pZm9ybSB2YXJpYWJsZVxuICAgKiBAcmV0dXJucyB7V2ViR0xVbmlmb3JtTG9jYXRpb259IExvY2F0aW9uIG9mIHRoZSB1bmlmb3JtIHZhcmlhYmxlXG4gICAqL1xuICBnZXRVbmlmb3JtTG9jYXRpb24oIF9uYW1lICkge1xuICAgIGNvbnN0IGdsID0gdGhpcy5nbDtcblxuICAgIGxldCBsb2NhdGlvbjtcblxuICAgIGlmICggdHlwZW9mIHRoaXMuX19jdXJyZW50UHJvZ3JhbS5sb2NhdGlvbnNbIF9uYW1lIF0gIT09ICd1bmRlZmluZWQnICkge1xuICAgICAgbG9jYXRpb24gPSB0aGlzLl9fY3VycmVudFByb2dyYW0ubG9jYXRpb25zWyBfbmFtZSBdO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2NhdGlvbiA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggdGhpcy5fX2N1cnJlbnRQcm9ncmFtLnByb2dyYW0sIF9uYW1lICk7XG4gICAgICB0aGlzLl9fY3VycmVudFByb2dyYW0ubG9jYXRpb25zWyBfbmFtZSBdID0gbG9jYXRpb247XG4gICAgfVxuXG4gICAgcmV0dXJuIGxvY2F0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIEF0dGFjaCBhbiB1bmlmb3JtIHZhcmlhYmxlLiAgXG4gICAqIEZpbmFsbHksIGxhemluZXNzIHdvbi5cbiAgICogQHBhcmFtIHtzdHJpbmd9IF90eXBlIFR5cGUgb2YgdGhlIHVuaWZvcm0gdmFyaWFibGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IF9uYW1lIE5hbWUgb2YgdGhlIHVuaWZvcm0gdmFyaWFibGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IF92YWx1ZSBWYWx1ZVxuICAgKiBAcmV0dXJucyB7dm9pZH0gdm9pZFxuICAgKi9cbiAgdW5pZm9ybSggX3R5cGUsIF9uYW1lLCBfdmFsdWUgKSB7XG4gICAgY29uc3QgZ2wgPSB0aGlzLmdsO1xuXG4gICAgY29uc3QgbG9jYXRpb24gPSB0aGlzLmdldFVuaWZvcm1Mb2NhdGlvbiggX25hbWUgKTtcbiAgICBnbFsgJ3VuaWZvcm0nICsgX3R5cGUgXSggbG9jYXRpb24sIF92YWx1ZSApO1xuICB9XG5cbiAgLyoqXG4gICAqIEF0dGFjaCBhbiBgaW50YCB0eXBlIHVuaWZvcm0gdmFyaWFibGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBfbmFtZSBOYW1lIG9mIHRoZSB1bmlmb3JtIHZhcmlhYmxlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBfdmFsdWUgYGludGAgdmFsdWVcbiAgICogQHJldHVybnMge3ZvaWR9IHZvaWRcbiAgICovXG4gIHVuaWZvcm0xaSggX25hbWUsIF92YWx1ZSApIHtcbiAgICBjb25zdCBnbCA9IHRoaXMuZ2w7XG5cbiAgICBjb25zdCBsb2NhdGlvbiA9IHRoaXMuZ2V0VW5pZm9ybUxvY2F0aW9uKCBfbmFtZSApO1xuICAgIGdsLnVuaWZvcm0xaSggbG9jYXRpb24sIF92YWx1ZSApO1xuICB9XG5cbiAgLyoqXG4gICAqIEF0dGFjaCBhIGBmbG9hdGAgdHlwZSB1bmlmb3JtIHZhcmlhYmxlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gX25hbWUgTmFtZSBvZiB0aGUgdW5pZm9ybSB2YXJpYWJsZVxuICAgKiBAcGFyYW0ge251bWJlcn0gX3ZhbHVlIGBmbG9hdGAgdmFsdWVcbiAgICogQHJldHVybnMge3ZvaWR9IHZvaWRcbiAgICovXG4gIHVuaWZvcm0xZiggX25hbWUsIF92YWx1ZSApIHtcbiAgICBjb25zdCBnbCA9IHRoaXMuZ2w7XG5cbiAgICBjb25zdCBsb2NhdGlvbiA9IHRoaXMuZ2V0VW5pZm9ybUxvY2F0aW9uKCBfbmFtZSApO1xuICAgIGdsLnVuaWZvcm0xZiggbG9jYXRpb24sIF92YWx1ZSApO1xuICB9XG5cbiAgLyoqXG4gICAqIEF0dGFjaCBhbiBhcnJheSBvZiBgdmVjMmAgdHlwZSB1bmlmb3JtIHZhcmlhYmxlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gX25hbWUgTmFtZSBvZiB0aGUgdW5pZm9ybSB2YXJpYWJsZVxuICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxudW1iZXJbXX0gX3ZhbHVlIEFycmF5IG9mIGB2ZWMyYCB2YWx1ZVxuICAgKiBAcmV0dXJucyB7dm9pZH0gdm9pZFxuICAgKi9cbiAgdW5pZm9ybTJmdiggX25hbWUsIF92YWx1ZSApIHtcbiAgICBjb25zdCBnbCA9IHRoaXMuZ2w7XG5cbiAgICBjb25zdCBsb2NhdGlvbiA9IHRoaXMuZ2V0VW5pZm9ybUxvY2F0aW9uKCBfbmFtZSApO1xuICAgIGdsLnVuaWZvcm0yZnYoIGxvY2F0aW9uLCBfdmFsdWUgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBdHRhY2ggYW4gYXJyYXkgb2YgYHZlYzNgIHR5cGUgdW5pZm9ybSB2YXJpYWJsZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IF9uYW1lIE5hbWUgb2YgdGhlIHVuaWZvcm0gdmFyaWFibGVcbiAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8bnVtYmVyW119IF92YWx1ZSBBcnJheSBvZiBgdmVjM2AgdmFsdWVcbiAgICogQHJldHVybnMge3ZvaWR9IHZvaWRcbiAgICovXG4gIHVuaWZvcm0zZnYoIF9uYW1lLCBfdmFsdWUgKSB7XG4gICAgY29uc3QgZ2wgPSB0aGlzLmdsO1xuXG4gICAgY29uc3QgbG9jYXRpb24gPSB0aGlzLmdldFVuaWZvcm1Mb2NhdGlvbiggX25hbWUgKTtcbiAgICBnbC51bmlmb3JtM2Z2KCBsb2NhdGlvbiwgX3ZhbHVlICk7XG4gIH1cblxuICAvKipcbiAgICogQXR0YWNoIGFuIGFycmF5IG9mIGB2ZWM0YCB0eXBlIHVuaWZvcm0gdmFyaWFibGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBfbmFtZSBOYW1lIG9mIHRoZSB1bmlmb3JtIHZhcmlhYmxlXG4gICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fG51bWJlcltdfSBfdmFsdWUgQXJyYXkgb2YgYHZlYzRgIHZhbHVlXG4gICAqIEByZXR1cm5zIHt2b2lkfSB2b2lkXG4gICAqL1xuICB1bmlmb3JtNGZ2KCBfbmFtZSwgX3ZhbHVlICkge1xuICAgIGNvbnN0IGdsID0gdGhpcy5nbDtcblxuICAgIGNvbnN0IGxvY2F0aW9uID0gdGhpcy5nZXRVbmlmb3JtTG9jYXRpb24oIF9uYW1lICk7XG4gICAgZ2wudW5pZm9ybTRmdiggbG9jYXRpb24sIF92YWx1ZSApO1xuICB9XG5cbiAgLyoqXG4gICAqIEF0dGFjaCBhbiBhcnJheSBvZiBgbWF0NGAgdHlwZSB1bmlmb3JtIHZhcmlhYmxlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gX25hbWUgTmFtZSBvZiB0aGUgdW5pZm9ybSB2YXJpYWJsZVxuICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxudW1iZXJbXX0gX3ZhbHVlIEFycmF5IG9mIGBtYXQ0YCB2YWx1ZVxuICAgKiBAcGFyYW0ge0dMYm9vbGVhbn0gW190cmFuc3Bvc2U9ZmFsc2VdIFNwZWNpZnkgd2hldGhlciB0byB0cmFuc3Bvc2UgdGhlIG1hdHJpeFxuICAgKiBAcmV0dXJucyB7dm9pZH0gdm9pZFxuICAgKi9cbiAgdW5pZm9ybU1hdHJpeDRmdiggX25hbWUsIF92YWx1ZSwgX3RyYW5zcG9zZSApIHtcbiAgICBjb25zdCBnbCA9IHRoaXMuZ2w7XG5cbiAgICBjb25zdCBsb2NhdGlvbiA9IHRoaXMuZ2V0VW5pZm9ybUxvY2F0aW9uKCBfbmFtZSApO1xuICAgIGdsLnVuaWZvcm1NYXRyaXg0ZnYoIGxvY2F0aW9uLCBfdHJhbnNwb3NlIHx8IGZhbHNlLCBfdmFsdWUgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBdHRhY2ggYSBgc2FtcGxlcjJEYCB0eXBlIHVuaWZvcm0gdGV4dHVyZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IF9uYW1lIE5hbWUgb2YgdGhlIHVuaWZvcm0gdGV4dHVyZVxuICAgKiBAcGFyYW0ge1dlYkdMVGV4dHVyZX0gX3RleHR1cmUgVGV4dHVyZSBvYmplY3RcbiAgICogQHBhcmFtIHtudW1iZXJ9IF9udW1iZXIgU3BlY2lmeSBhIHRleHR1cmUgdW5pdCwgaW4gaW50ZWdlclxuICAgKiBAcmV0dXJucyB7dm9pZH0gdm9pZFxuICAgKi9cbiAgdW5pZm9ybVRleHR1cmUoIF9uYW1lLCBfdGV4dHVyZSwgX251bWJlciApIHtcbiAgICBjb25zdCBnbCA9IHRoaXMuZ2w7XG5cbiAgICBjb25zdCBsb2NhdGlvbiA9IHRoaXMuZ2V0VW5pZm9ybUxvY2F0aW9uKCBfbmFtZSApO1xuICAgIGdsLmFjdGl2ZVRleHR1cmUoIGdsLlRFWFRVUkUwICsgX251bWJlciApO1xuICAgIGdsLmJpbmRUZXh0dXJlKCBnbC5URVhUVVJFXzJELCBfdGV4dHVyZSApO1xuICAgIGdsLnVuaWZvcm0xaSggbG9jYXRpb24sIF9udW1iZXIgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBdHRhY2ggYSBgc2FtcGxlckN1YmVgIHR5cGUgdW5pZm9ybSB0ZXh0dXJlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gX25hbWUgTmFtZSBvZiB0aGUgdW5pZm9ybSB0ZXh0dXJlXG4gICAqIEBwYXJhbSB7V2ViR0xUZXh0dXJlfSBfdGV4dHVyZSBUZXh0dXJlIG9iamVjdFxuICAgKiBAcGFyYW0ge251bWJlcn0gX251bWJlciBTcGVjaWZ5IGEgdGV4dHVyZSB1bml0LCBpbiBpbnRlZ2VyXG4gICAqIEByZXR1cm5zIHt2b2lkfSB2b2lkXG4gICAqL1xuICB1bmlmb3JtQ3ViZW1hcCggX25hbWUsIF90ZXh0dXJlLCBfbnVtYmVyICkge1xuICAgIGNvbnN0IGdsID0gdGhpcy5nbDtcblxuICAgIGNvbnN0IGxvY2F0aW9uID0gdGhpcy5nZXRVbmlmb3JtTG9jYXRpb24oIF9uYW1lICk7XG4gICAgZ2wuYWN0aXZlVGV4dHVyZSggZ2wuVEVYVFVSRTAgKyBfbnVtYmVyICk7XG4gICAgZ2wuYmluZFRleHR1cmUoIGdsLlRFWFRVUkVfQ1VCRV9NQVAsIF90ZXh0dXJlICk7XG4gICAgZ2wudW5pZm9ybTFpKCBsb2NhdGlvbiwgX251bWJlciApO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHRleHR1cmUgb2JqZWN0LlxuICAgKiBAcmV0dXJucyB7V2ViR0xUZXh0dXJlfSBUZXh0dXJlIG9iamVjdFxuICAgKi9cbiAgY3JlYXRlVGV4dHVyZSgpIHtcbiAgICBjb25zdCBnbCA9IHRoaXMuZ2w7XG5cbiAgICBjb25zdCB0ZXh0dXJlID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xuICAgIGdsLmJpbmRUZXh0dXJlKCBnbC5URVhUVVJFXzJELCB0ZXh0dXJlICk7XG4gICAgZ2wudGV4UGFyYW1ldGVyaSggZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5MSU5FQVIgKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKCBnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLkxJTkVBUiApO1xuICAgIGdsLnRleFBhcmFtZXRlcmkoIGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFICk7XG4gICAgZ2wudGV4UGFyYW1ldGVyaSggZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UgKTtcbiAgICBnbC5iaW5kVGV4dHVyZSggZ2wuVEVYVFVSRV8yRCwgbnVsbCApO1xuXG4gICAgcmV0dXJuIHRleHR1cmU7XG4gIH1cblxuICAvKipcbiAgICogU3BlY2lmeSBob3cgdG8gZmlsdGVyIHRoZSB0ZXh0dXJlLlxuICAgKiBAcGFyYW0ge1dlYkdMVGV4dHVyZX0gX3RleHR1cmUgVGV4dHVyZSBvYmplY3RcbiAgICogQHBhcmFtIHtHTGVudW19IF9maWx0ZXIgVGV4dHVyZSBmaWx0ZXJcbiAgICogQHJldHVybnMge3ZvaWR9IHZvaWRcbiAgICovXG4gIHRleHR1cmVGaWx0ZXIoIF90ZXh0dXJlLCBfZmlsdGVyICkge1xuICAgIGNvbnN0IGdsID0gdGhpcy5nbDtcblxuICAgIGdsLmJpbmRUZXh0dXJlKCBnbC5URVhUVVJFXzJELCBfdGV4dHVyZSApO1xuICAgIGdsLnRleFBhcmFtZXRlcmkoIGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgX2ZpbHRlciApO1xuICAgIGdsLnRleFBhcmFtZXRlcmkoIGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgX2ZpbHRlciApO1xuICAgIGdsLmJpbmRUZXh0dXJlKCBnbC5URVhUVVJFXzJELCBudWxsICk7XG4gIH1cblxuICAvKipcbiAgICogU3BlY2lmeSBob3cgdG8gd3JhcCB0aGUgdGV4dHVyZS5cbiAgICogQHBhcmFtIHtXZWJHTFRleHR1cmV9IF90ZXh0dXJlIFRleHR1cmUgb2JqZWN0XG4gICAqIEBwYXJhbSB7R0xlbnVtfSBfZmlsdGVyIFdyYXBwaW5nIGZ1bmN0aW9uIGZvciB0aGUgdGV4dHVyZVxuICAgKiBAcmV0dXJucyB7dm9pZH0gdm9pZFxuICAgKi9cbiAgdGV4dHVyZVdyYXAoIF90ZXh0dXJlLCBfd3JhcCApIHtcbiAgICBjb25zdCBnbCA9IHRoaXMuZ2w7XG5cbiAgICBnbC5iaW5kVGV4dHVyZSggZ2wuVEVYVFVSRV8yRCwgX3RleHR1cmUgKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKCBnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgX3dyYXAgKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKCBnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgX3dyYXAgKTtcbiAgICBnbC5iaW5kVGV4dHVyZSggZ2wuVEVYVFVSRV8yRCwgbnVsbCApO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCBuZXcgZGF0YSBpbnRvIGEgdGV4dHVyZSBvYmplY3QuICBcbiAgICogVGhpcyBmdW5jdGlvbiB1c2VzIGltYWdlIGRhdGEuIElmIHlvdSB3YW50IHRvIHNvdXJjZSBgVWludDhBcnJheWAsIHVzZSBgR0xDYXQuc2V0VGV4dHVyZUZyb21BcnJheSgpYCBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge1dlYkdMVGV4dHVyZX0gX3RleHR1cmUgVGV4dHVyZSBvYmplY3RcbiAgICogQHBhcmFtIHtQaXhlbGFibGV9IF9zb3VyY2UgU291cmNlIGltYWdlIG9mIHRoZSBwaXhlbCBkYXRhXG4gICAqIEByZXR1cm5zIHt2b2lkfSB2b2lkXG4gICAqL1xuICBzZXRUZXh0dXJlKCBfdGV4dHVyZSwgX3NvdXJjZSApIHtcbiAgICBjb25zdCBnbCA9IHRoaXMuZ2w7XG5cbiAgICBnbC5iaW5kVGV4dHVyZSggZ2wuVEVYVFVSRV8yRCwgX3RleHR1cmUgKTtcbiAgICBnbC50ZXhJbWFnZTJEKCBnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBfc291cmNlICk7XG4gICAgZ2wuYmluZFRleHR1cmUoIGdsLlRFWFRVUkVfMkQsIG51bGwgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgbmV3IGRhdGEgaW50byBhIHRleHR1cmUgb2JqZWN0LiAgXG4gICAqIFRoaXMgZnVuY3Rpb24gdXNlcyBgVWludDhBcnJheWAuIElmIHlvdSB3YW50IHRvIHNvdXJjZSBpbWFnZSBkYXRhLCB1c2UgYEdMQ2F0LnNldFRleHR1cmUoKWAgaW5zdGVhZC4gIFxuICAgKiBPciB5b3Ugd2FudCB0byB1c2UgZmxvYXQgdGV4dHVyZT8gVHJ5IHRoaXM6IGBHTENhdC5zZXRUZXh0dXJlRnJvbUZsb2F0QXJyYXkoKWBcbiAgICogQHBhcmFtIHtXZWJHTFRleHR1cmV9IF90ZXh0dXJlIFRleHR1cmUgb2JqZWN0XG4gICAqIEBwYXJhbSB7R0xzaXplaX0gX3dpZHRoIFdpZHRoIG9mIHRoZSB0ZXh0dXJlXG4gICAqIEBwYXJhbSB7R0xzaXplaX0gX2hlaWdodCBIZWlnaHQgb2YgdGhlIHRleHR1cmVcbiAgICogQHBhcmFtIHtVaW50OEFycmF5fSBfc291cmNlIFNvdXJjZSBidWZmZXIgb2YgdGhlIHBpeGVsIGRhdGFcbiAgICogQHJldHVybnMge3ZvaWR9IHZvaWRcbiAgICovXG4gIHNldFRleHR1cmVGcm9tQXJyYXkoIF90ZXh0dXJlLCBfd2lkdGgsIF9oZWlnaHQsIF9zb3VyY2UgKSB7XG4gICAgY29uc3QgZ2wgPSB0aGlzLmdsO1xuXG4gICAgZ2wuYmluZFRleHR1cmUoIGdsLlRFWFRVUkVfMkQsIF90ZXh0dXJlICk7XG4gICAgZ2wudGV4SW1hZ2UyRCggZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgX3dpZHRoLCBfaGVpZ2h0LCAwLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBuZXcgVWludDhBcnJheSggX3NvdXJjZSApICk7XG4gICAgZ2wuYmluZFRleHR1cmUoIGdsLlRFWFRVUkVfMkQsIG51bGwgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgbmV3IGRhdGEgaW50byBhIHRleHR1cmUgb2JqZWN0LiAgXG4gICAqIFRoaXMgZnVuY3Rpb24gdXNlcyBgRmxvYXQzMkFycmF5YC4gIFxuICAgKiBJZiB5b3UgY2FuJ3QgZ3JhYiBgT0VTX3RleHR1cmVfZmxvYXRgIGV4dGVuc2lvbiBoZXJlLCB5b3Ugd2lsbCBkaWUgYXQgdGhpcyBwb2ludC5cbiAgICogQHBhcmFtIHtXZWJHTFRleHR1cmV9IF90ZXh0dXJlIFRleHR1cmUgb2JqZWN0XG4gICAqIEBwYXJhbSB7R0xzaXplaX0gX3dpZHRoIFdpZHRoIG9mIHRoZSB0ZXh0dXJlXG4gICAqIEBwYXJhbSB7R0xzaXplaX0gX2hlaWdodCBIZWlnaHQgb2YgdGhlIHRleHR1cmVcbiAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl9IF9zb3VyY2UgU291cmNlIGJ1ZmZlciBvZiB0aGUgcGl4ZWwgZGF0YVxuICAgKiBAcmV0dXJucyB7dm9pZH0gdm9pZFxuICAgKi9cbiAgc2V0VGV4dHVyZUZyb21GbG9hdEFycmF5KCBfdGV4dHVyZSwgX3dpZHRoLCBfaGVpZ2h0LCBfc291cmNlICkge1xuICAgIGNvbnN0IGdsID0gdGhpcy5nbDtcblxuICAgIHRoaXMuZ2V0RXh0ZW5zaW9uKCAnT0VTX3RleHR1cmVfZmxvYXQnLCB0cnVlICk7XG5cbiAgICBnbC5iaW5kVGV4dHVyZSggZ2wuVEVYVFVSRV8yRCwgX3RleHR1cmUgKTtcbiAgICBnbC50ZXhJbWFnZTJEKCBnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCBfd2lkdGgsIF9oZWlnaHQsIDAsIGdsLlJHQkEsIGdsLkZMT0FULCBuZXcgRmxvYXQzMkFycmF5KCBfc291cmNlICkgKTtcbiAgICBpZiAoICF0aGlzLmdldEV4dGVuc2lvbiggJ09FU190ZXh0dXJlX2Zsb2F0X2xpbmVhcicgKSApIHsgdGhpcy50ZXh0dXJlRmlsdGVyKCBfdGV4dHVyZSwgZ2wuTkVBUkVTVCApOyB9XG4gICAgZ2wuYmluZFRleHR1cmUoIGdsLlRFWFRVUkVfMkQsIG51bGwgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb3B5IHBpeGVscyBmcm9tIGN1cnJlbnQgZnJhbWVidWZmZXIgdG8gZ2l2ZW4gdGV4dHVyZS5cbiAgICogQHBhcmFtIHtXZWJHTFRleHR1cmV9IF90ZXh0dXJlIFRhcmdldCB0ZXh0dXJlIG9iamVjdFxuICAgKiBAcGFyYW0ge0dMc2l6ZWl9IF93aWR0aCBXaWR0aCBvZiB0aGUgdGV4dHVyZVxuICAgKiBAcGFyYW0ge0dMc2l6ZWl9IF9oZWlnaHQgSGVpZ2h0IG9mIHRoZSB0ZXh0dXJlXG4gICAqIEByZXR1cm5zIHt2b2lkfSB2b2lkXG4gICAqL1xuICBjb3B5VGV4dHVyZSggX3RleHR1cmUsIF93aWR0aCwgX2hlaWdodCApIHtcbiAgICBjb25zdCBnbCA9IHRoaXMuZ2w7XG5cbiAgICBnbC5iaW5kVGV4dHVyZSggZ2wuVEVYVFVSRV8yRCwgX3RleHR1cmUgKTtcbiAgICBnbC5jb3B5VGV4SW1hZ2UyRCggZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgMCwgMCwgX3dpZHRoLCBfaGVpZ2h0LCAwICk7XG4gICAgZ2wuYmluZFRleHR1cmUoIGdsLlRFWFRVUkVfMkQsIG51bGwgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBjdWJlbWFwIHRleHR1cmUgb2JqZWN0LlxuICAgKiBAcGFyYW0ge1BpeGVsYWJsZVtdfSBfYXJyYXlPZkltYWdlIEFycmF5IG9mIGlhbWdlcy4gT3JkZXI6IGBYK2AsIGBYLWAsIGBZK2AsIGBZLWAsIGBaK2AsIGBaLWBcbiAgICogQHJldHVybnMge1dlYkdMVGV4dHVyZX0gVGV4dHVyZSBvYmplY3RcbiAgICovXG4gIGNyZWF0ZUN1YmVtYXAoIF9hcnJheU9mSW1hZ2UgKSB7XG4gICAgY29uc3QgZ2wgPSB0aGlzLmdsO1xuXG4gICAgY29uc3QgdGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcblxuICAgIGdsLmJpbmRUZXh0dXJlKCBnbC5URVhUVVJFX0NVQkVfTUFQLCB0ZXh0dXJlICk7XG4gICAgZm9yICggbGV0IGkgPSAwOyBpIDwgNjsgaSArKyApIHtcbiAgICAgIGdsLnRleEltYWdlMkQoIGdsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCArIGksIDAsIGdsLlJHQkEsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIF9hcnJheU9mSW1hZ2VbIGkgXSApO1xuICAgIH1cbiAgICBnbC50ZXhQYXJhbWV0ZXJpKCBnbC5URVhUVVJFX0NVQkVfTUFQLCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLkxJTkVBUiApO1xuICAgIGdsLnRleFBhcmFtZXRlcmkoIGdsLlRFWFRVUkVfQ1VCRV9NQVAsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTElORUFSICk7XG4gICAgZ2wudGV4UGFyYW1ldGVyaSggZ2wuVEVYVFVSRV9DVUJFX01BUCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLkNMQU1QX1RPX0VER0UgKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKCBnbC5URVhUVVJFX0NVQkVfTUFQLCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSApO1xuICAgIGdsLmJpbmRUZXh0dXJlKCBnbC5URVhUVVJFX0NVQkVfTUFQLCBudWxsICk7XG5cbiAgICByZXR1cm4gdGV4dHVyZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBmcmFtZWJ1ZmZlciBvYmplY3QuXG4gICAqIEBwYXJhbSB7R0xzaXplaX0gX3dpZHRoIFdpZHRoIG9mIHRoZSBmcmFtZWJ1ZmZlclxuICAgKiBAcGFyYW0ge0dMc2l6ZWl9IF9oZWlnaHQgSGVpZ2h0IG9mIHRoZSBmcmFtZWJ1ZmZlclxuICAgKiBAcmV0dXJucyB7R0xDYXRGcmFtZWJ1ZmZlcn0gRnJhbWVidWZmZXIgb2JqZWN0XG4gICAqL1xuICBjcmVhdGVGcmFtZWJ1ZmZlciggX3dpZHRoLCBfaGVpZ2h0ICkge1xuICAgIGNvbnN0IGdsID0gdGhpcy5nbDtcblxuICAgIGNvbnN0IGZyYW1lYnVmZmVyID0ge307XG4gICAgZnJhbWVidWZmZXIuZnJhbWVidWZmZXIgPSBnbC5jcmVhdGVGcmFtZWJ1ZmZlcigpO1xuICAgIGdsLmJpbmRGcmFtZWJ1ZmZlciggZ2wuRlJBTUVCVUZGRVIsIGZyYW1lYnVmZmVyLmZyYW1lYnVmZmVyICk7XG5cbiAgICBmcmFtZWJ1ZmZlci5kZXB0aCA9IGdsLmNyZWF0ZVJlbmRlcmJ1ZmZlcigpO1xuICAgIGdsLmJpbmRSZW5kZXJidWZmZXIoIGdsLlJFTkRFUkJVRkZFUiwgZnJhbWVidWZmZXIuZGVwdGggKTtcbiAgICBnbC5yZW5kZXJidWZmZXJTdG9yYWdlKCBnbC5SRU5ERVJCVUZGRVIsIGdsLkRFUFRIX0NPTVBPTkVOVDE2LCBfd2lkdGgsIF9oZWlnaHQgKTtcbiAgICBnbC5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlciggZ2wuRlJBTUVCVUZGRVIsIGdsLkRFUFRIX0FUVEFDSE1FTlQsIGdsLlJFTkRFUkJVRkZFUiwgZnJhbWVidWZmZXIuZGVwdGggKTtcblxuICAgIGZyYW1lYnVmZmVyLnRleHR1cmUgPSB0aGlzLmNyZWF0ZVRleHR1cmUoKTtcbiAgICBnbC5iaW5kVGV4dHVyZSggZ2wuVEVYVFVSRV8yRCwgZnJhbWVidWZmZXIudGV4dHVyZSApO1xuICAgIGdsLnRleEltYWdlMkQoIGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIF93aWR0aCwgX2hlaWdodCwgMCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgbnVsbCApO1xuICAgIGdsLmJpbmRUZXh0dXJlKCBnbC5URVhUVVJFXzJELCBudWxsICk7XG5cbiAgICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRCggZ2wuRlJBTUVCVUZGRVIsIGdsLkNPTE9SX0FUVEFDSE1FTlQwLCBnbC5URVhUVVJFXzJELCBmcmFtZWJ1ZmZlci50ZXh0dXJlLCAwICk7XG4gICAgZ2wuYmluZEZyYW1lYnVmZmVyKCBnbC5GUkFNRUJVRkZFUiwgbnVsbCApO1xuXG4gICAgcmV0dXJuIGZyYW1lYnVmZmVyO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc2l6ZSBhIGZyYW1lYnVmZmVyIG9iamVjdC5cbiAgICogQHBhcmFtIHtHTENhdEZyYW1lYnVmZmVyfSBGcmFtZWJ1ZmZlciBvYmplY3RcbiAgICogQHBhcmFtIHtHTHNpemVpfSBfd2lkdGggV2lkdGggb2YgdGhlIGZyYW1lYnVmZmVyXG4gICAqIEBwYXJhbSB7R0xzaXplaX0gX2hlaWdodCBIZWlnaHQgb2YgdGhlIGZyYW1lYnVmZmVyXG4gICAqIEByZXR1cm5zIHt2b2lkfSB2b2lkXG4gICAqL1xuICByZXNpemVGcmFtZWJ1ZmZlciggX2ZyYW1lYnVmZmVyLCBfd2lkdGgsIF9oZWlnaHQgKSB7XG4gICAgbGV0IGl0ID0gdGhpcztcbiAgICBsZXQgZ2wgPSBpdC5nbDtcblxuICAgIGdsLmJpbmRGcmFtZWJ1ZmZlciggZ2wuRlJBTUVCVUZGRVIsIF9mcmFtZWJ1ZmZlci5mcmFtZWJ1ZmZlciApO1xuXG4gICAgZ2wuYmluZFJlbmRlcmJ1ZmZlciggZ2wuUkVOREVSQlVGRkVSLCBfZnJhbWVidWZmZXIuZGVwdGggKTtcbiAgICBnbC5yZW5kZXJidWZmZXJTdG9yYWdlKCBnbC5SRU5ERVJCVUZGRVIsIGdsLkRFUFRIX0NPTVBPTkVOVDE2LCBfd2lkdGgsIF9oZWlnaHQgKTtcbiAgICBnbC5iaW5kUmVuZGVyYnVmZmVyKCBnbC5SRU5ERVJCVUZGRVIsIG51bGwgKTtcblxuICAgIGdsLmJpbmRUZXh0dXJlKCBnbC5URVhUVVJFXzJELCBfZnJhbWVidWZmZXIudGV4dHVyZSApO1xuICAgIGdsLnRleEltYWdlMkQoIGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIF93aWR0aCwgX2hlaWdodCwgMCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgbnVsbCApO1xuICAgIGdsLmJpbmRUZXh0dXJlKCBnbC5URVhUVVJFXzJELCBudWxsICk7XG5cbiAgICBnbC5iaW5kRnJhbWVidWZmZXIoIGdsLkZSQU1FQlVGRkVSLCBudWxsICk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgZnJhbWVidWZmZXIgb2JqZWN0LCBidXQgRmxvYXQzMiBvbmUuXG4gICAqIEBwYXJhbSB7R0xzaXplaX0gX3dpZHRoIFdpZHRoIG9mIHRoZSBmcmFtZWJ1ZmZlclxuICAgKiBAcGFyYW0ge0dMc2l6ZWl9IF9oZWlnaHQgSGVpZ2h0IG9mIHRoZSBmcmFtZWJ1ZmZlclxuICAgKiBAcmV0dXJucyB7R0xDYXRGcmFtZWJ1ZmZlcn0gRnJhbWVidWZmZXIgb2JqZWN0XG4gICAqL1xuICBjcmVhdGVGbG9hdEZyYW1lYnVmZmVyKCBfd2lkdGgsIF9oZWlnaHQgKSB7XG4gICAgbGV0IGl0ID0gdGhpcztcbiAgICBsZXQgZ2wgPSBpdC5nbDtcblxuICAgIGl0LmdldEV4dGVuc2lvbiggJ09FU190ZXh0dXJlX2Zsb2F0JywgdHJ1ZSApO1xuXG4gICAgbGV0IGZyYW1lYnVmZmVyID0ge307XG4gICAgZnJhbWVidWZmZXIuZnJhbWVidWZmZXIgPSBnbC5jcmVhdGVGcmFtZWJ1ZmZlcigpO1xuICAgIGdsLmJpbmRGcmFtZWJ1ZmZlciggZ2wuRlJBTUVCVUZGRVIsIGZyYW1lYnVmZmVyLmZyYW1lYnVmZmVyICk7XG5cbiAgICBmcmFtZWJ1ZmZlci5kZXB0aCA9IGdsLmNyZWF0ZVJlbmRlcmJ1ZmZlcigpO1xuICAgIGdsLmJpbmRSZW5kZXJidWZmZXIoIGdsLlJFTkRFUkJVRkZFUiwgZnJhbWVidWZmZXIuZGVwdGggKTtcbiAgICBnbC5yZW5kZXJidWZmZXJTdG9yYWdlKCBnbC5SRU5ERVJCVUZGRVIsIGdsLkRFUFRIX0NPTVBPTkVOVDE2LCBfd2lkdGgsIF9oZWlnaHQgKTtcbiAgICBnbC5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlciggZ2wuRlJBTUVCVUZGRVIsIGdsLkRFUFRIX0FUVEFDSE1FTlQsIGdsLlJFTkRFUkJVRkZFUiwgZnJhbWVidWZmZXIuZGVwdGggKTtcblxuICAgIGZyYW1lYnVmZmVyLnRleHR1cmUgPSBpdC5jcmVhdGVUZXh0dXJlKCk7XG4gICAgZ2wuYmluZFRleHR1cmUoIGdsLlRFWFRVUkVfMkQsIGZyYW1lYnVmZmVyLnRleHR1cmUgKTtcbiAgICBnbC50ZXhJbWFnZTJEKCBnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCBfd2lkdGgsIF9oZWlnaHQsIDAsIGdsLlJHQkEsIGdsLkZMT0FULCBudWxsICk7XG4gICAgaWYgKCAhaXQuZ2V0RXh0ZW5zaW9uKCAnT0VTX3RleHR1cmVfZmxvYXRfbGluZWFyJyApICkgeyBpdC50ZXh0dXJlRmlsdGVyKCBmcmFtZWJ1ZmZlci50ZXh0dXJlLCBnbC5ORUFSRVNUICk7IH1cbiAgICBnbC5iaW5kVGV4dHVyZSggZ2wuVEVYVFVSRV8yRCwgbnVsbCApO1xuXG4gICAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoIGdsLkZSQU1FQlVGRkVSLCBnbC5DT0xPUl9BVFRBQ0hNRU5UMCwgZ2wuVEVYVFVSRV8yRCwgZnJhbWVidWZmZXIudGV4dHVyZSwgMCApO1xuICAgIGdsLmJpbmRGcmFtZWJ1ZmZlciggZ2wuRlJBTUVCVUZGRVIsIG51bGwgKTtcblxuICAgIHJldHVybiBmcmFtZWJ1ZmZlcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNpemUgYSBmbG9hdCBmcmFtZWJ1ZmZlciBvYmplY3QuXG4gICAqIEBwYXJhbSB7R0xDYXRGcmFtZWJ1ZmZlcn0gRnJhbWVidWZmZXIgb2JqZWN0XG4gICAqIEBwYXJhbSB7R0xzaXplaX0gX3dpZHRoIFdpZHRoIG9mIHRoZSBmcmFtZWJ1ZmZlclxuICAgKiBAcGFyYW0ge0dMc2l6ZWl9IF9oZWlnaHQgSGVpZ2h0IG9mIHRoZSBmcmFtZWJ1ZmZlclxuICAgKiBAcmV0dXJucyB7dm9pZH0gdm9pZFxuICAgKi9cbiAgcmVzaXplRmxvYXRGcmFtZWJ1ZmZlciggX2ZyYW1lYnVmZmVyLCBfd2lkdGgsIF9oZWlnaHQgKSB7XG4gICAgbGV0IGl0ID0gdGhpcztcbiAgICBsZXQgZ2wgPSBpdC5nbDtcblxuICAgIGdsLmJpbmRGcmFtZWJ1ZmZlciggZ2wuRlJBTUVCVUZGRVIsIF9mcmFtZWJ1ZmZlci5mcmFtZWJ1ZmZlciApO1xuXG4gICAgZ2wuYmluZFJlbmRlcmJ1ZmZlciggZ2wuUkVOREVSQlVGRkVSLCBfZnJhbWVidWZmZXIuZGVwdGggKTtcbiAgICBnbC5yZW5kZXJidWZmZXJTdG9yYWdlKCBnbC5SRU5ERVJCVUZGRVIsIGdsLkRFUFRIX0NPTVBPTkVOVDE2LCBfd2lkdGgsIF9oZWlnaHQgKTtcbiAgICBnbC5iaW5kUmVuZGVyYnVmZmVyKCBnbC5SRU5ERVJCVUZGRVIsIG51bGwgKTtcblxuICAgIGdsLmJpbmRUZXh0dXJlKCBnbC5URVhUVVJFXzJELCBfZnJhbWVidWZmZXIudGV4dHVyZSApO1xuICAgIGdsLnRleEltYWdlMkQoIGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIF93aWR0aCwgX2hlaWdodCwgMCwgZ2wuUkdCQSwgZ2wuRkxPQVQsIG51bGwgKTtcbiAgICBnbC5iaW5kVGV4dHVyZSggZ2wuVEVYVFVSRV8yRCwgbnVsbCApO1xuXG4gICAgZ2wuYmluZEZyYW1lYnVmZmVyKCBnbC5GUkFNRUJVRkZFUiwgbnVsbCApO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIGRyYXcgYnVmZmVycyBvYmplY3QuICBcbiAgICogSWYgeW91IGNhbid0IGdyYWIgYFdFQkdMX2RyYXdfYnVmZmVyc2AgZXh0ZW5zaW9uLCB5b3Ugd2lsbCBkaWUgaW5zdGFudGx5LiAgXG4gICAqIEZvcm1hdCBvZiBpdHMgdGV4dHVyZXMgd2lsbCBiZSBGbG9hdDMyLlxuICAgKiBAcGFyYW0ge0dMc2l6ZWl9IF93aWR0aCBXaWR0aCBvZiB0aGUgZHJhdyBidWZmZXJzXG4gICAqIEBwYXJhbSB7R0xzaXplaX0gX2hlaWdodCBIZWlnaHQgb2YgdGhlIGRyYXcgYnVmZmVyc1xuICAgKiBAcGFyYW0ge251bWJlcn0gU3BlY2lmeSBob3cgbWFueSB0ZXh0dXJlcyBpdCBoYXNcbiAgICogQHJldHVybnMge0dMQ2F0RHJhd0J1ZmZlcnN9IERyYXcgYnVmZmVycyBvYmplY3RcbiAgICovXG4gIGNyZWF0ZURyYXdCdWZmZXJzKCBfd2lkdGgsIF9oZWlnaHQsIF9udW1EcmF3QnVmZmVycyApIHtcbiAgICBsZXQgaXQgPSB0aGlzO1xuICAgIGxldCBnbCA9IGl0LmdsO1xuXG4gICAgaXQuZ2V0RXh0ZW5zaW9uKCAnT0VTX3RleHR1cmVfZmxvYXQnLCB0cnVlICk7XG4gICAgbGV0IGV4dCA9IGl0LmdldEV4dGVuc2lvbiggJ1dFQkdMX2RyYXdfYnVmZmVycycsIHRydWUgKTtcblxuICAgIGlmICggZXh0Lk1BWF9EUkFXX0JVRkZFUlNfV0VCR0wgPCBfbnVtRHJhd0J1ZmZlcnMgKSB7XG4gICAgICB0aHJvdyAnY3JlYXRlRHJhd0J1ZmZlcnM6IE1BWF9EUkFXX0JVRkZFUlNfV0VCR0wgaXMgJyArIGV4dC5NQVhfRFJBV19CVUZGRVJTX1dFQkdMO1xuICAgIH1cblxuICAgIGxldCBkcmF3YnVmZmVycyA9IHt9O1xuICAgIGRyYXdidWZmZXJzLmZyYW1lYnVmZmVyID0gZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTtcbiAgICBnbC5iaW5kRnJhbWVidWZmZXIoIGdsLkZSQU1FQlVGRkVSLCBkcmF3YnVmZmVycy5mcmFtZWJ1ZmZlciApO1xuXG4gICAgZHJhd2J1ZmZlcnMuZGVwdGggPSBnbC5jcmVhdGVSZW5kZXJidWZmZXIoKTtcbiAgICBnbC5iaW5kUmVuZGVyYnVmZmVyKCBnbC5SRU5ERVJCVUZGRVIsIGRyYXdidWZmZXJzLmRlcHRoICk7XG4gICAgZ2wucmVuZGVyYnVmZmVyU3RvcmFnZSggZ2wuUkVOREVSQlVGRkVSLCBnbC5ERVBUSF9DT01QT05FTlQxNiwgX3dpZHRoLCBfaGVpZ2h0ICk7XG4gICAgZ2wuZnJhbWVidWZmZXJSZW5kZXJidWZmZXIoIGdsLkZSQU1FQlVGRkVSLCBnbC5ERVBUSF9BVFRBQ0hNRU5ULCBnbC5SRU5ERVJCVUZGRVIsIGRyYXdidWZmZXJzLmRlcHRoICk7XG5cbiAgICBkcmF3YnVmZmVycy50ZXh0dXJlcyA9IFtdO1xuICAgIGZvciAoIGxldCBpID0gMDsgaSA8IF9udW1EcmF3QnVmZmVyczsgaSArKyApIHtcbiAgICAgIGRyYXdidWZmZXJzLnRleHR1cmVzWyBpIF0gPSBpdC5jcmVhdGVUZXh0dXJlKCk7XG4gICAgICBnbC5iaW5kVGV4dHVyZSggZ2wuVEVYVFVSRV8yRCwgZHJhd2J1ZmZlcnMudGV4dHVyZXNbIGkgXSApO1xuICAgICAgZ2wudGV4SW1hZ2UyRCggZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgX3dpZHRoLCBfaGVpZ2h0LCAwLCBnbC5SR0JBLCBnbC5GTE9BVCwgbnVsbCApO1xuICAgICAgaWYgKCAhaXQuZ2V0RXh0ZW5zaW9uKCAnT0VTX3RleHR1cmVfZmxvYXRfbGluZWFyJyApICkgeyBpdC50ZXh0dXJlRmlsdGVyKCBkcmF3YnVmZmVycy50ZXh0dXJlc1sgaSBdLCBnbC5ORUFSRVNUICk7IH1cbiAgICAgIGdsLmJpbmRUZXh0dXJlKCBnbC5URVhUVVJFXzJELCBudWxsICk7XG5cbiAgICAgIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKCBnbC5GUkFNRUJVRkZFUiwgZXh0LkNPTE9SX0FUVEFDSE1FTlQwX1dFQkdMICsgaSwgZ2wuVEVYVFVSRV8yRCwgZHJhd2J1ZmZlcnMudGV4dHVyZXNbIGkgXSwgMCApO1xuICAgIH1cblxuICAgIGxldCBzdGF0dXMgPSBnbC5jaGVja0ZyYW1lYnVmZmVyU3RhdHVzKCBnbC5GUkFNRUJVRkZFUiApO1xuICAgIGlmICggc3RhdHVzICE9PSBnbC5GUkFNRUJVRkZFUl9DT01QTEVURSApIHtcbiAgICAgIHRocm93ICdjcmVhdGVEcmF3QnVmZmVyczogZ2wuY2hlY2tGcmFtZWJ1ZmZlclN0YXR1cyggZ2wuRlJBTUVCVUZGRVIgKSByZXR1cm5zICcgKyBzdGF0dXM7XG4gICAgfVxuICAgIGdsLmJpbmRGcmFtZWJ1ZmZlciggZ2wuRlJBTUVCVUZGRVIsIG51bGwgKTtcblxuICAgIHJldHVybiBkcmF3YnVmZmVycztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNpemUgYSBkcmF3IGJ1ZmZlcnMgb2JqZWN0LlxuICAgKiBAcGFyYW0ge0dMQ2F0RHJhd0J1ZmZlcnN9IERyYXcgYnVmZmVycyBvYmplY3RcbiAgICogQHBhcmFtIHtHTHNpemVpfSBfd2lkdGggV2lkdGggb2YgdGhlIGRyYXcgYnVmZmVyc1xuICAgKiBAcGFyYW0ge0dMc2l6ZWl9IF9oZWlnaHQgSGVpZ2h0IG9mIHRoZSBkcmF3IGJ1ZmZlcnNcbiAgICogQHJldHVybnMge3ZvaWR9IHZvaWRcbiAgICovXG4gIHJlc2l6ZURyYXdCdWZmZXJzKCBfZnJhbWVidWZmZXIsIF93aWR0aCwgX2hlaWdodCApIHtcbiAgICBsZXQgaXQgPSB0aGlzO1xuICAgIGxldCBnbCA9IGl0LmdsO1xuXG4gICAgZ2wuYmluZEZyYW1lYnVmZmVyKCBnbC5GUkFNRUJVRkZFUiwgX2ZyYW1lYnVmZmVyLmZyYW1lYnVmZmVyICk7XG5cbiAgICBnbC5iaW5kUmVuZGVyYnVmZmVyKCBnbC5SRU5ERVJCVUZGRVIsIF9mcmFtZWJ1ZmZlci5kZXB0aCApO1xuICAgIGdsLnJlbmRlcmJ1ZmZlclN0b3JhZ2UoIGdsLlJFTkRFUkJVRkZFUiwgZ2wuREVQVEhfQ09NUE9ORU5UMTYsIF93aWR0aCwgX2hlaWdodCApO1xuICAgIGdsLmJpbmRSZW5kZXJidWZmZXIoIGdsLlJFTkRFUkJVRkZFUiwgbnVsbCApO1xuXG4gICAgZm9yICggbGV0IGkgPSAwOyBpIDwgX2ZyYW1lYnVmZmVyLnRleHR1cmVzLmxlbmd0aDsgaSArKyApIHtcbiAgICAgIGdsLmJpbmRUZXh0dXJlKCBnbC5URVhUVVJFXzJELCBfZnJhbWVidWZmZXIudGV4dHVyZXNbIGkgXSApO1xuICAgICAgZ2wudGV4SW1hZ2UyRCggZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgX3dpZHRoLCBfaGVpZ2h0LCAwLCBnbC5SR0JBLCBnbC5GTE9BVCwgbnVsbCApO1xuICAgICAgZ2wuYmluZFRleHR1cmUoIGdsLlRFWFRVUkVfMkQsIG51bGwgKTtcbiAgICB9XG5cbiAgICBnbC5iaW5kRnJhbWVidWZmZXIoIGdsLkZSQU1FQlVGRkVSLCBudWxsICk7XG4gIH1cblxuICAvKipcbiAgICogQ2FsbCB0aGlzIGJlZm9yZSB5b3UgYXJlIGdvaW5nIHRvIHVzZSBkcmF3IGJ1ZmZlcnMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBTcGVjaWZ5IGhvdyBtYW55IGRyYXcgYnVmZmVycyB5b3UgYXJlIGdvaW5nIHRvIHVzZVxuICAgKiBAcmV0dXJucyB7dm9pZH0gdm9pZFxuICAgKi9cbiAgZHJhd0J1ZmZlcnMoIF9udW1EcmF3QnVmZmVycyApIHtcbiAgICBsZXQgaXQgPSB0aGlzO1xuICAgIGxldCBnbCA9IGl0LmdsO1xuXG4gICAgbGV0IGV4dCA9IGl0LmdldEV4dGVuc2lvbiggJ1dFQkdMX2RyYXdfYnVmZmVycycsIHRydWUgKTtcblxuICAgIGxldCBhcnJheSA9IFtdO1xuICAgIGlmICggdHlwZW9mIF9udW1EcmF3QnVmZmVycyA9PT0gJ251bWJlcicgKSB7XG4gICAgICBmb3IgKCBsZXQgaSA9IDA7IGkgPCBfbnVtRHJhd0J1ZmZlcnM7IGkgKysgKSB7XG4gICAgICAgIGFycmF5LnB1c2goIGV4dC5DT0xPUl9BVFRBQ0hNRU5UMF9XRUJHTCArIGkgKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgYXJyYXkgPSBhcnJheS5jb25jYXQoIF9udW1EcmF3QnVmZmVycyApO1xuICAgIH1cbiAgICBleHQuZHJhd0J1ZmZlcnNXRUJHTCggYXJyYXkgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhciBjdXJyZW50IGZyYW1lYnVmZmVyLlxuICAgKiBAcGFyYW0ge0dMY2xhbXBmfSBbX3I9MC4wXSBSZWQgYW1vdW50IG9mIGNsZWFyaW5nIGNvbG9yXG4gICAqIEBwYXJhbSB7R0xjbGFtcGZ9IFtfZz0wLjBdIEdyZWVuIGFtb3VudCBvZiBjbGVhcmluZyBjb2xvclxuICAgKiBAcGFyYW0ge0dMY2xhbXBmfSBbX2I9MC4wXSBCbHVlIGFtb3VudCBvZiBjbGVhcmluZyBjb2xvclxuICAgKiBAcGFyYW0ge0dMY2xhbXBmfSBbX2E9MS4wXSBBbHBoYSBhbW91bnQgb2YgY2xlYXJpbmcgY29sb3JcbiAgICogQHBhcmFtIHtHTGNsYW1wZn0gW19kZXB0aD0xLjBdIENsZWFyaW5nIGRlcHRoXG4gICAqIEByZXR1cm5zIHt2b2lkfSB2b2lkXG4gICAqL1xuICBjbGVhciggX3IsIF9nLCBfYiwgX2EsIF9kZXB0aCApIHtcbiAgICBsZXQgaXQgPSB0aGlzO1xuICAgIGxldCBnbCA9IGl0LmdsO1xuXG4gICAgbGV0IHIgPSBfciB8fCAwLjA7XG4gICAgbGV0IGcgPSBfZyB8fCAwLjA7XG4gICAgbGV0IGIgPSBfYiB8fCAwLjA7XG4gICAgbGV0IGEgPSB0eXBlb2YgX2EgPT09ICdudW1iZXInID8gX2EgOiAxLjA7XG4gICAgbGV0IGRlcHRoID0gdHlwZW9mIF9kZXB0aCA9PT0gJ251bWJlcicgPyBfZGVwdGggOiAxLjA7XG5cbiAgICBnbC5jbGVhckNvbG9yKCByLCBnLCBiLCBhICk7XG4gICAgZ2wuY2xlYXJEZXB0aCggZGVwdGggKTtcbiAgICBnbC5jbGVhciggZ2wuQ09MT1JfQlVGRkVSX0JJVCB8IGdsLkRFUFRIX0JVRkZFUl9CSVQgKTtcbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgR0xDYXQ7IiwiLy8g44Gr44KD44O844KTXG5cbmNvbnN0IE1hdGhDYXQgPSB7fTtcblxuLyoqXG4gKiBBZGQgdHdvIHZlY3MuXG4gKiBAcGFyYW0ge251bWJlcltdfSBhIHZlY05cbiAqIEBwYXJhbSB7bnVtYmVyW119IGIgdmVjTlxuICogQHJldHVybnMge251bWJlcltdfSB2ZWNOLCBgYSArIGJgXG4gKiBAc3RhdGljXG4gKi9cbk1hdGhDYXQudmVjQWRkID0gKCBhLCBiICkgPT4gYS5tYXAoICggZSwgaSApID0+IGUgKyBiWyBpIF0gKTtcblxuLyoqXG4gKiBTdWJzdHJhY3QgYSB2ZWMgZnJvbSBhbiBhbm90aGVyIHZlYy5cbiAqIEBwYXJhbSB7bnVtYmVyW119IGEgdmVjTlxuICogQHBhcmFtIHtudW1iZXJbXX0gYiB2ZWNOXG4gKiBAcmV0dXJucyB7bnVtYmVyW119IHZlY04sIGBhIC0gYmBcbiAqIEBzdGF0aWNcbiAqL1xuTWF0aENhdC52ZWNTdWIgPSAoIGEsIGIgKSA9PiBhLm1hcCggKCBlLCBpICkgPT4gZSAtIGJbIGkgXSApO1xuXG5cbi8qKlxuICogTXVsdGlwbHkgdHdvIHZlY3MuXG4gKiBAcGFyYW0ge251bWJlcltdfSBhIHZlY05cbiAqIEBwYXJhbSB7bnVtYmVyW119IGIgdmVjTlxuICogQHJldHVybnMge251bWJlcltdfSB2ZWNOLCBgYSAqIGJgXG4gKiBAc3RhdGljXG4gKi9cbk1hdGhDYXQudmVjTXVsID0gKCBhLCBiICkgPT4gYS5tYXAoICggZSwgaSApID0+IGUgLSBiWyBpIF0gKTtcblxuLyoqXG4gKiBSZXR1cm4gYSBjcm9zcyBvZiB0d28gdmVjM3MuXG4gKiBAcGFyYW0ge251bWJlcltdfSBhIHZlYzNcbiAqIEBwYXJhbSB7bnVtYmVyW119IGIgdmVjM1xuICogQHJldHVybnMge251bWJlcltdfSB2ZWMzLCBjcm9zcyBwcm9kdWN0IG9mIGBhYCBhbmQgYGJgXG4gKiBAc3RhdGljXG4gKi9cbk1hdGhDYXQudmVjM0Nyb3NzID0gKCBhLCBiICkgPT4gW1xuICBhWyAxIF0gKiBiWyAyIF0gLSBhWyAyIF0gKiBiWyAxIF0sXG4gIGFbIDIgXSAqIGJbIDAgXSAtIGFbIDAgXSAqIGJbIDIgXSxcbiAgYVsgMCBdICogYlsgMSBdIC0gYVsgMSBdICogYlsgMCBdXG5dO1xuXG4vKipcbiAqIFNjYWxlIGEgdmVjIGJ5IHNjYWxhci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzIHNjYWxhclxuICogQHBhcmFtIHtudW1iZXJbXX0gdiB2ZWNOXG4gKiBAcmV0dXJucyB7bnVtYmVyW119IHZlY04sIGBzICogdmBcbiAqIEBzdGF0aWNcbiAqL1xuTWF0aENhdC52ZWNTY2FsZSA9ICggcywgdiApID0+IHYubWFwKCAoIGUgKSA9PiBlICogcyApO1xuXG4vKipcbiAqIERvdCB0d28gdmVjdG9ycy5cbiAqIEBwYXJhbSB7bnVtYmVyW119IGEgdmVjTlxuICogQHBhcmFtIHtudW1iZXJbXX0gYiB2ZWNOXG4gKiBAcmV0dXJucyB7bnVtYmVyW119IHZlY04sIERvdCBvZiBgYWAgYW5kIGBiYFxuICogQHN0YXRpY1xuICovXG5NYXRoQ2F0LnZlY0RvdCA9ICggYSwgYiApID0+IGEucmVkdWNlKCAoIHAsIGUsIGkgKSA9PiBwICsgZSAqIGJbIGkgXSwgMC4wICk7XG5cbi8qKlxuICogUmV0dXJuIGxlbmd0aCBvZiBhIHZlYy5cbiAqIEBwYXJhbSB7bnVtYmVyW119IHYgdmVjTlxuICogQHJldHVybnMge251bWJlcn0gc2NhbGFyLCBsZW5ndGggb2YgYHZgXG4gKiBAc3RhdGljXG4gKi9cbk1hdGhDYXQudmVjTGVuZ3RoID0gKCB2ICkgPT4gTWF0aC5zcXJ0KCB2LnJlZHVjZSggKCBwLCBjICkgPT4gcCArIGMgKiBjLCAwLjAgKSApO1xuXG4vKipcbiAqIE5vcm1hbGl6ZSBhIHZlYy5cbiAqIEBwYXJhbSB7bnVtYmVyW119IHYgdmVjTlxuICogQHJldHVybnMge251bWJlcltdfSB2ZWMsIG5vcm1hbGl6ZWQgYHZgXG4gKiBAc3RhdGljXG4gKi9cbk1hdGhDYXQudmVjTm9ybWFsaXplID0gKCB2ICkgPT4gTWF0aENhdC52ZWNTY2FsZSggMS4wIC8gTWF0aENhdC52ZWNMZW5ndGgoIHYgKSwgdiApO1xuXG4vKipcbiAqIE11bHRpcGx5IHR3byBxdWF0cy5cbiAqIEBwYXJhbSB7bnVtYmVyW119IHEgcXVhdFxuICogQHBhcmFtIHtudW1iZXJbXX0gciBxdWF0XG4gKiBAcmV0dXJucyB7bnVtYmVyW119IHF1YXQsIHByb2R1Y3Qgb2YgYGFgIGFuZCBgYmBcbiAqIEBzdGF0aWNcbiAqL1xuTWF0aENhdC5xdWF0TXVsID0gKCBxLCByICkgPT4gW1xuICBxWyAzIF0gKiByWyAwIF0gKyBxWyAwIF0gKiByWyAzIF0gKyBxWyAxIF0gKiByWyAyIF0gLSBxWyAyIF0gKiByWyAxIF0sXG4gIHFbIDMgXSAqIHJbIDEgXSAtIHFbIDAgXSAqIHJbIDIgXSArIHFbIDEgXSAqIHJbIDMgXSArIHFbIDIgXSAqIHJbIDAgXSxcbiAgcVsgMyBdICogclsgMiBdICsgcVsgMCBdICogclsgMSBdIC0gcVsgMSBdICogclsgMCBdICsgcVsgMiBdICogclsgMyBdLFxuICBxWyAzIF0gKiByWyAzIF0gLSBxWyAwIF0gKiByWyAwIF0gLSBxWyAxIF0gKiByWyAxIF0gLSBxWyAyIF0gKiByWyAyIF1cbl07XG5cbi8qKlxuICogSW52ZXJzZSBhIHF1YXQuXG4gKiBAcGFyYW0ge251bWJlcltdfSBxIHF1YXRcbiAqIEByZXR1cm5zIHtudW1iZXJbXX0gcXVhdCwgYC1xYFxuICogQHN0YXRpY1xuICovXG5NYXRoQ2F0LnF1YXRJbnYgPSAoIHEgKSA9PiBbIC1xWyAwIF0sIC1xWyAxIF0sIC1xWyAyIF0sIHFbIDMgXSBdO1xuXG4vKipcbiAqIFJvdGF0ZSBhIHZlYzMgdXNpbmcgb25lIHF1YXQuXG4gKiBAcGFyYW0ge251bWJlcltdfSB2IHZlYzNcbiAqIEBwYXJhbSB7bnVtYmVyW119IHEgcXVhdFxuICogQHJldHVybnMge251bWJlcltdfSB2ZWMzLCByb3RhdGVkIHZlY3RvclxuICogQHN0YXRpY1xuICovXG5NYXRoQ2F0LnJvdGF0ZVZlY0J5UXVhdCA9ICggdiwgcSApID0+IHtcbiAgY29uc3QgcCA9IFsgdlsgMCBdLCB2WyAxIF0sIHZbIDIgXSwgMC4wIF07XG4gIGNvbnN0IHIgPSBNYXRoQ2F0LnF1YXRJbnYoIHEgKTtcbiAgY29uc3QgcmVzID0gTWF0aENhdC5xdWF0TXVsKCBNYXRoQ2F0LnF1YXRNdWwoIHEsIHAgKSwgciApO1xuICByZXR1cm4gWyByZXNbIDAgXSwgcmVzWyAxIF0sIHJlc1sgMiBdIF07XG59O1xuXG4vKipcbiAqIENvbnZlcnQgcXVhdCBpbnRvIG1hdDQuXG4gKiBAcGFyYW0ge251bWJlcltdfSBxIHF1YXRcbiAqIEByZXR1cm5zIHtudW1iZXJbXX0gbWF0NCwgcm90YXRpb24gbWF0cml4IG1hZGUgZnJvbSBxdWF0XG4gKiBAc3RhdGljXG4gKi9cbk1hdGhDYXQucXVhdFRvTWF0NCA9ICggcSApID0+IHtcbiAgY29uc3QgeCA9IE1hdGhDYXQucm90YXRlVmVjQnlRdWF0KCBbIDEuMCwgMC4wLCAwLjAgXSwgcSApO1xuICBjb25zdCB5ID0gTWF0aENhdC5yb3RhdGVWZWNCeVF1YXQoIFsgMC4wLCAxLjAsIDAuMCBdLCBxICk7XG4gIGNvbnN0IHogPSBNYXRoQ2F0LnJvdGF0ZVZlY0J5UXVhdCggWyAwLjAsIDAuMCwgMS4wIF0sIHEgKTtcblxuICByZXR1cm4gW1xuICAgIHhbIDAgXSwgeVsgMCBdLCB6WyAwIF0sIDAuMCxcbiAgICB4WyAxIF0sIHlbIDEgXSwgelsgMSBdLCAwLjAsXG4gICAgeFsgMiBdLCB5WyAyIF0sIHpbIDIgXSwgMC4wLFxuICAgIDAuMCwgMC4wLCAwLjAsIDEuMFxuICBdO1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZSBxdWF0IGZyb20gYW5nbGUgYW5kIGF4aXMuXG4gKiBAcGFyYW0ge251bWJlcn0gYW5nbGUgc2NhbGFyLCBSb3RhdGlvbiBhbmdsZSBpbiByYWRpYW5cbiAqIEBwYXJhbSB7bnVtYmVyW119IGF4aXMgdmVjMywgUm90YXRpb24gYXhpc1xuICogQHJldHVybnMge251bWJlcltdfSBxdWF0LCBHZW5lcmF0ZWQgcXVhdGVybmlvblxuICogQHN0YXRpY1xuICovXG5NYXRoQ2F0LnF1YXRBbmdsZUF4aXMgPSAoIGFuZ2xlLCBheGlzICkgPT4ge1xuICBjb25zdCBoYSA9IGFuZ2xlIC8gMi4wO1xuICBjb25zdCBzaGEgPSBNYXRoLnNpbiggaGEgKTtcbiAgcmV0dXJuIFtcbiAgICBheGlzWyAwIF0gKiBzaGEsXG4gICAgYXhpc1sgMSBdICogc2hhLFxuICAgIGF4aXNbIDIgXSAqIHNoYSxcbiAgICBNYXRoLmNvcyggaGEgKVxuICBdO1xufTtcblxuLyoqXG4gKiBBcHBseSB0d28gbWF0NHMuXG4gKiBAcGFyYW0ge251bWJlcltdfSBhIG1hdDRcbiAqIEBwYXJhbSB7bnVtYmVyW119IGIgbWF0NFxuICogQHJldHVybnMge251bWJlcltdfSBtYXQ0LCBBcHBsaWVkIG1hdHJpeFxuICogQHN0YXRpY1xuICovXG5NYXRoQ2F0Lm1hdDRBcHBseSA9ICggYSwgYiApID0+IHtcbiAgcmV0dXJuIFtcbiAgICBhWyAwIF0gKiBiWyAwIF0gKyBhWyA0IF0gKiBiWyAxIF0gKyBhWyA4IF0gKiBiWyAyIF0gKyBhWyAxMiBdICogYlsgMyBdLFxuICAgIGFbIDEgXSAqIGJbIDAgXSArIGFbIDUgXSAqIGJbIDEgXSArIGFbIDkgXSAqIGJbIDIgXSArIGFbIDEzIF0gKiBiWyAzIF0sXG4gICAgYVsgMiBdICogYlsgMCBdICsgYVsgNiBdICogYlsgMSBdICsgYVsgMTAgXSAqIGJbIDIgXSArIGFbIDE0IF0gKiBiWyAzIF0sXG4gICAgYVsgMyBdICogYlsgMCBdICsgYVsgNyBdICogYlsgMSBdICsgYVsgMTEgXSAqIGJbIDIgXSArIGFbIDE1IF0gKiBiWyAzIF0sXG5cbiAgICBhWyAwIF0gKiBiWyA0IF0gKyBhWyA0IF0gKiBiWyA1IF0gKyBhWyA4IF0gKiBiWyA2IF0gKyBhWyAxMiBdICogYlsgNyBdLFxuICAgIGFbIDEgXSAqIGJbIDQgXSArIGFbIDUgXSAqIGJbIDUgXSArIGFbIDkgXSAqIGJbIDYgXSArIGFbIDEzIF0gKiBiWyA3IF0sXG4gICAgYVsgMiBdICogYlsgNCBdICsgYVsgNiBdICogYlsgNSBdICsgYVsgMTAgXSAqIGJbIDYgXSArIGFbIDE0IF0gKiBiWyA3IF0sXG4gICAgYVsgMyBdICogYlsgNCBdICsgYVsgNyBdICogYlsgNSBdICsgYVsgMTEgXSAqIGJbIDYgXSArIGFbIDE1IF0gKiBiWyA3IF0sXG5cbiAgICBhWyAwIF0gKiBiWyA4IF0gKyBhWyA0IF0gKiBiWyA5IF0gKyBhWyA4IF0gKiBiWyAxMCBdICsgYVsgMTIgXSAqIGJbIDExIF0sXG4gICAgYVsgMSBdICogYlsgOCBdICsgYVsgNSBdICogYlsgOSBdICsgYVsgOSBdICogYlsgMTAgXSArIGFbIDEzIF0gKiBiWyAxMSBdLFxuICAgIGFbIDIgXSAqIGJbIDggXSArIGFbIDYgXSAqIGJbIDkgXSArIGFbIDEwIF0gKiBiWyAxMCBdICsgYVsgMTQgXSAqIGJbIDExIF0sXG4gICAgYVsgMyBdICogYlsgOCBdICsgYVsgNyBdICogYlsgOSBdICsgYVsgMTEgXSAqIGJbIDEwIF0gKyBhWyAxNSBdICogYlsgMTEgXSxcblxuICAgIGFbIDAgXSAqIGJbIDEyIF0gKyBhWyA0IF0gKiBiWyAxMyBdICsgYVsgOCBdICogYlsgMTQgXSArIGFbIDEyIF0gKiBiWyAxNSBdLFxuICAgIGFbIDEgXSAqIGJbIDEyIF0gKyBhWyA1IF0gKiBiWyAxMyBdICsgYVsgOSBdICogYlsgMTQgXSArIGFbIDEzIF0gKiBiWyAxNSBdLFxuICAgIGFbIDIgXSAqIGJbIDEyIF0gKyBhWyA2IF0gKiBiWyAxMyBdICsgYVsgMTAgXSAqIGJbIDE0IF0gKyBhWyAxNCBdICogYlsgMTUgXSxcbiAgICBhWyAzIF0gKiBiWyAxMiBdICsgYVsgNyBdICogYlsgMTMgXSArIGFbIDExIF0gKiBiWyAxNCBdICsgYVsgMTUgXSAqIGJbIDE1IF1cbiAgXTtcbn07XG5cbi8qKlxuICogSW52ZXJ0IGEgbWF0NC5cbiAqIEBwYXJhbSB7bnVtYmVyW119IG0gbWF0NFxuICogQHJldHVybnMge251bWJlcltdfSBtYXQ0LCBJbnZlcnRlZCBtYXRyaXhcbiAqIEBzdGF0aWNcbiAqL1xuTWF0aENhdC5tYXQ0SW52ZXJzZSA9ICggbSApID0+IHtcbiAgY29uc3RcbiAgICBhMDAgPSBtWyAgMCBdLCBhMDEgPSBtWyAgMSBdLCBhMDIgPSBtWyAgMiBdLCBhMDMgPSBtWyAgMyBdLFxuICAgIGExMCA9IG1bICA0IF0sIGExMSA9IG1bICA1IF0sIGExMiA9IG1bICA2IF0sIGExMyA9IG1bICA3IF0sXG4gICAgYTIwID0gbVsgIDggXSwgYTIxID0gbVsgIDkgXSwgYTIyID0gbVsgMTAgXSwgYTIzID0gbVsgMTEgXSxcbiAgICBhMzAgPSBtWyAxMiBdLCBhMzEgPSBtWyAxMyBdLCBhMzIgPSBtWyAxNCBdLCBhMzMgPSBtWyAxNSBdLFxuICAgIGIwMCA9IGEwMCAqIGExMSAtIGEwMSAqIGExMCwgIGIwMSA9IGEwMCAqIGExMiAtIGEwMiAqIGExMCxcbiAgICBiMDIgPSBhMDAgKiBhMTMgLSBhMDMgKiBhMTAsICBiMDMgPSBhMDEgKiBhMTIgLSBhMDIgKiBhMTEsXG4gICAgYjA0ID0gYTAxICogYTEzIC0gYTAzICogYTExLCAgYjA1ID0gYTAyICogYTEzIC0gYTAzICogYTEyLFxuICAgIGIwNiA9IGEyMCAqIGEzMSAtIGEyMSAqIGEzMCwgIGIwNyA9IGEyMCAqIGEzMiAtIGEyMiAqIGEzMCxcbiAgICBiMDggPSBhMjAgKiBhMzMgLSBhMjMgKiBhMzAsICBiMDkgPSBhMjEgKiBhMzIgLSBhMjIgKiBhMzEsXG4gICAgYjEwID0gYTIxICogYTMzIC0gYTIzICogYTMxLCAgYjExID0gYTIyICogYTMzIC0gYTIzICogYTMyO1xuXG4gIHJldHVybiBNYXRoQ2F0LnZlY1NjYWxlKCAxLjAgLyBiMDAgKiBiMTEgLSBiMDEgKiBiMTAgKyBiMDIgKiBiMDkgKyBiMDMgKiBiMDggLSBiMDQgKiBiMDcgKyBiMDUgKiBiMDYsIFtcbiAgICBhMTEgKiBiMTEgLSBhMTIgKiBiMTAgKyBhMTMgKiBiMDksXG4gICAgYTAyICogYjEwIC0gYTAxICogYjExIC0gYTAzICogYjA5LFxuICAgIGEzMSAqIGIwNSAtIGEzMiAqIGIwNCArIGEzMyAqIGIwMyxcbiAgICBhMjIgKiBiMDQgLSBhMjEgKiBiMDUgLSBhMjMgKiBiMDMsXG4gICAgYTEyICogYjA4IC0gYTEwICogYjExIC0gYTEzICogYjA3LFxuICAgIGEwMCAqIGIxMSAtIGEwMiAqIGIwOCArIGEwMyAqIGIwNyxcbiAgICBhMzIgKiBiMDIgLSBhMzAgKiBiMDUgLSBhMzMgKiBiMDEsXG4gICAgYTIwICogYjA1IC0gYTIyICogYjAyICsgYTIzICogYjAxLFxuICAgIGExMCAqIGIxMCAtIGExMSAqIGIwOCArIGExMyAqIGIwNixcbiAgICBhMDEgKiBiMDggLSBhMDAgKiBiMTAgLSBhMDMgKiBiMDYsXG4gICAgYTMwICogYjA0IC0gYTMxICogYjAyICsgYTMzICogYjAwLFxuICAgIGEyMSAqIGIwMiAtIGEyMCAqIGIwNCAtIGEyMyAqIGIwMCxcbiAgICBhMTEgKiBiMDcgLSBhMTAgKiBiMDkgLSBhMTIgKiBiMDYsXG4gICAgYTAwICogYjA5IC0gYTAxICogYjA3ICsgYTAyICogYjA2LFxuICAgIGEzMSAqIGIwMSAtIGEzMCAqIGIwMyAtIGEzMiAqIGIwMCxcbiAgICBhMjAgKiBiMDMgLSBhMjEgKiBiMDEgKyBhMjIgKiBiMDBcbiAgXSApO1xufTtcblxuLyoqXG4gKiBBcHBseSBhIG1hdDQgdG8gYSB2ZWM0LlxuICogQHBhcmFtIHtudW1iZXJbXX0gbSBtYXQ0XG4gKiBAcGFyYW0ge251bWJlcltdfSB2IHZlYzRcbiAqIEByZXR1cm5zIHtudW1iZXJbXX0gdmVjNCwgQXBwbGllZCB2ZWN0b3JcbiAqIEBzdGF0aWNcbiAqL1xuTWF0aENhdC5tYXQ0QXBwbHlUb1ZlYzQgPSAoIG0sIHYgKSA9PiB7XG4gIHJldHVybiBbXG4gICAgbVsgMCBdICogdlsgMCBdICsgbVsgNCBdICogdlsgMSBdICsgbVsgOCBdICogdlsgMiBdICsgbVsgMTIgXSAqIHZbIDMgXSxcbiAgICBtWyAxIF0gKiB2WyAwIF0gKyBtWyA1IF0gKiB2WyAxIF0gKyBtWyA5IF0gKiB2WyAyIF0gKyBtWyAxMyBdICogdlsgMyBdLFxuICAgIG1bIDIgXSAqIHZbIDAgXSArIG1bIDYgXSAqIHZbIDEgXSArIG1bIDEwIF0gKiB2WyAyIF0gKyBtWyAxNCBdICogdlsgMyBdLFxuICAgIG1bIDMgXSAqIHZbIDAgXSArIG1bIDcgXSAqIHZbIDEgXSArIG1bIDExIF0gKiB2WyAyIF0gKyBtWyAxNSBdICogdlsgMyBdXG4gIF07XG59O1xuXG4vKipcbiAqIFRyYW5zcG9zZSBhIG1hdDQuXG4gKiBAcGFyYW0ge251bWJlcltdfSBtIG1hdDRcbiAqIEByZXR1cm5zIHtudW1iZXJbXX0gbWF0NCwgVHJhbnNwb3NlZCBtYXRyaXhcbiAqIEBzdGF0aWNcbiAqL1xuTWF0aENhdC5tYXQ0VHJhbnNwb3NlID0gKCBtICkgPT4gW1xuICBtWyAwIF0sIG1bIDQgXSwgbVsgOCBdLCBtWyAxMiBdLFxuICBtWyAxIF0sIG1bIDUgXSwgbVsgOSBdLCBtWyAxMyBdLFxuICBtWyAyIF0sIG1bIDYgXSwgbVsgMTAgXSwgbVsgMTQgXSxcbiAgbVsgMyBdLCBtWyA3IF0sIG1bIDExIF0sIG1bIDE1IF1cbl07XG5cbi8qKlxuICogR2VuZXJhdGUgYW4gaW5kZW50aXR5IG1hdDQuXG4gKiBAcmV0dXJucyB7bnVtYmVyW119IG1hdDQsIElkZW50aXR5IG1hdHJpeFxuICogQHN0YXRpY1xuICovXG5NYXRoQ2F0Lm1hdDRJZGVudGl0eSA9ICgpID0+IFsgMSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMSBdO1xuXG4vKipcbiAqIEdlbmVyYXRlIGEgM2QgdHJhbnNsYXRlIG1hdHJpeC5cbiAqIEBwYXJhbSB7bnVtYmVyW119IHYgdmVjMywgVHJhbnNsYXRpb25cbiAqIEByZXR1cm5zIHtudW1iZXJbXX0gbWF0NCwgR2VuZXJhdGVkIG1hdHJpeFxuICogQHN0YXRpY1xuICovXG5NYXRoQ2F0Lm1hdDRUcmFuc2xhdGUgPSAoIHYgKSA9PiBbXG4gIDEsIDAsIDAsIDAsXG4gIDAsIDEsIDAsIDAsXG4gIDAsIDAsIDEsIDAsXG4gIHZbIDAgXSwgdlsgMSBdLCB2WyAyIF0sIDFcbl07XG5cbi8qKlxuICogR2VuZXJhdGUgYSAzZCBzY2FsZSBtYXRyaXguICBcbiAqIFNlZSBhbHNvOiB7QGxpbmsgTWF0aENhdCNtYXQ0U2NhbGVYWVp9XG4gKiBAcGFyYW0ge251bWJlcltdfSB2IHZlYzMsIFNjYWxpbmdcbiAqIEByZXR1cm5zIHtudW1iZXJbXX0gbWF0NCwgR2VuZXJhdGVkIG1hdHJpeFxuICogQHN0YXRpY1xuICovXG5NYXRoQ2F0Lm1hdDRTY2FsZSA9ICggdiApID0+IFtcbiAgdlsgMCBdLCAwLCAwLCAwLFxuICAwLCB2WyAxIF0sIDAsIDAsXG4gIDAsIDAsIHZbIDIgXSwgMCxcbiAgMCwgMCwgMCwgMVxuXTtcblxuLyoqXG4gKiBHZW5lcmF0ZSBhIDNkIHNjYWxlIG1hdHJpeC4gIFxuICogU2VlIGFsc286IHtAbGluayBNYXRoQ2F0I21hdDRTY2FsZX1cbiAqIEBwYXJhbSB7bnVtYmVyW119IHMgc2NhbGFyLCBTY2FsaW5nXG4gKiBAcmV0dXJucyB7bnVtYmVyW119IG1hdDQsIEdlbmVyYXRlZCBtYXRyaXhcbiAqIEBzdGF0aWNcbiAqL1xuTWF0aENhdC5tYXQ0U2NhbGVYWVogPSAoIHMgKSA9PiBbXG4gIHMsIDAsIDAsIDAsXG4gIDAsIHMsIDAsIDAsXG4gIDAsIDAsIHMsIDAsXG4gIDAsIDAsIDAsIDFcbl07XG5cbi8qKlxuICogR2VuZXJhdGUgYSAzZCByb3RhdGlvbiBtYXRyaXguICBcbiAqIDJkIHJvdGF0aW9uIGFyb3VuZCB4IGF4aXMuXG4gKiBAcGFyYW0ge251bWJlcltdfSB0IHNjYWxhciwgUm90YXRpb24gYW5nbGUgaW4gcmFkaWFuc1xuICogQHJldHVybnMge251bWJlcltdfSBtYXQ0LCBHZW5lcmF0ZWQgbWF0cml4XG4gKiBAc3RhdGljXG4gKi9cbk1hdGhDYXQubWF0NFJvdGF0ZVggPSAoIHQgKSA9PiBbXG4gIDEsIDAsIDAsIDAsXG4gIDAsIE1hdGguY29zKCB0ICksIC1NYXRoLnNpbiggdCApLCAwLFxuICAwLCBNYXRoLnNpbiggdCApLCBNYXRoLmNvcyggdCApLCAwLFxuICAwLCAwLCAwLCAxXG5dO1xuXG4vKipcbiAqIEdlbmVyYXRlIGEgM2Qgcm90YXRpb24gbWF0cml4LiAgXG4gKiAyZCByb3RhdGlvbiBhcm91bmQgeSBheGlzLlxuICogQHBhcmFtIHtudW1iZXJbXX0gdCBzY2FsYXIsIFJvdGF0aW9uIGFuZ2xlIGluIHJhZGlhbnNcbiAqIEByZXR1cm5zIHtudW1iZXJbXX0gbWF0NCwgR2VuZXJhdGVkIG1hdHJpeFxuICogQHN0YXRpY1xuICovXG5NYXRoQ2F0Lm1hdDRSb3RhdGVZID0gKCB0ICkgPT4gW1xuICBNYXRoLmNvcyggdCApLCAwLCBNYXRoLnNpbiggdCApLCAwLFxuICAwLCAxLCAwLCAwLFxuICAtTWF0aC5zaW4oIHQgKSwgMCwgTWF0aC5jb3MoIHQgKSwgMCxcbiAgMCwgMCwgMCwgMVxuXTtcblxuLyoqXG4gKiBHZW5lcmF0ZSBhIDNkIHJvdGF0aW9uIG1hdHJpeC4gIFxuICogMmQgcm90YXRpb24gYXJvdW5kIHogYXhpcy5cbiAqIEBwYXJhbSB7bnVtYmVyW119IHQgc2NhbGFyLCBSb3RhdGlvbiBhbmdsZSBpbiByYWRpYW5zXG4gKiBAcmV0dXJucyB7bnVtYmVyW119IG1hdDQsIEdlbmVyYXRlZCBtYXRyaXhcbiAqIEBzdGF0aWNcbiAqL1xuTWF0aENhdC5tYXQ0Um90YXRlWiA9ICggdCApID0+IFtcbiAgTWF0aC5jb3MoIHQgKSwgLU1hdGguc2luKCB0ICksIDAsIDAsXG4gIE1hdGguc2luKCB0ICksIE1hdGguY29zKCB0ICksIDAsIDAsXG4gIDAsIDAsIDEsIDAsXG4gIDAsIDAsIDAsIDFcbl07XG5cbi8qKlxuICogR2VuZXJhdGUgYSBcIkxvb2tBdFwiIHZpZXcgbWF0cml4LlxuICogQHBhcmFtIHtudW1iZXJbXX0gcG9zIHZlYzMsIFBvc2l0aW9uXG4gKiBAcGFyYW0ge251bWJlcltdfSB0YXIgdmVjMywgVGFyZ2V0XG4gKiBAcGFyYW0ge251bWJlcltdfSBbYWlyPVsgMC4wLCAxLjAsIDAuMCBdXSB2ZWMzLCBVcCB2ZWN0b3JcbiAqIEBwYXJhbSB7bnVtYmVyfSBbcm90PTAuMF0gc2NhbGFyLCBSb2xsLiB5ZWFoaGhoIEkgdGhpbmsgc3VjaCBsb29rQXQgZ2VuZXJhdG9yIHNob3VsZCBoYXZlIHJvbGwgcGFyYW1ldGVyXG4gKiBAcmV0dXJucyB7bnVtYmVyW119IG1hdDQsIEdlbmVyYXRlZCBtYXRyaXhcbiAqIEBzdGF0aWNcbiAqL1xuTWF0aENhdC5tYXQ0TG9va0F0ID0gKCBwb3MsIHRhciwgYWlyLCByb3QgKSA9PiB7XG4gIGNvbnN0IGRpciA9IE1hdGhDYXQudmVjTm9ybWFsaXplKCBNYXRoQ2F0LnZlY1N1YiggdGFyLCBwb3MgKSApO1xuICBsZXQgc2lkID0gTWF0aENhdC52ZWNOb3JtYWxpemUoIE1hdGhDYXQudmVjM0Nyb3NzKCBkaXIsIGFpciB8fCBbIDAuMCwgMS4wLCAwLjAgXSApICk7XG4gIGxldCB0b3AgPSBNYXRoQ2F0LnZlYzNDcm9zcyggc2lkLCBkaXIgKTtcbiAgc2lkID0gTWF0aENhdC52ZWNBZGQoXG4gICAgTWF0aENhdC52ZWNTY2FsZSggTWF0aC5jb3MoIHJvdCB8fCAwLjAgKSwgc2lkICksXG4gICAgTWF0aENhdC52ZWNTY2FsZSggTWF0aC5zaW4oIHJvdCB8fCAwLjAgKSwgdG9wIClcbiAgKTtcbiAgdG9wID0gTWF0aENhdC52ZWMzQ3Jvc3MoIHNpZCwgZGlyICk7XG5cbiAgcmV0dXJuIFtcbiAgICBzaWRbIDAgXSwgdG9wWyAwIF0sIGRpclsgMCBdLCAwLjAsXG4gICAgc2lkWyAxIF0sIHRvcFsgMSBdLCBkaXJbIDEgXSwgMC4wLFxuICAgIHNpZFsgMiBdLCB0b3BbIDIgXSwgZGlyWyAyIF0sIDAuMCxcbiAgICAtc2lkWyAwIF0gKiBwb3NbIDAgXSAtIHNpZFsgMSBdICogcG9zWyAxIF0gLSBzaWRbIDIgXSAqIHBvc1sgMiBdLFxuICAgIC10b3BbIDAgXSAqIHBvc1sgMCBdIC0gdG9wWyAxIF0gKiBwb3NbIDEgXSAtIHRvcFsgMiBdICogcG9zWyAyIF0sXG4gICAgLWRpclsgMCBdICogcG9zWyAwIF0gLSBkaXJbIDEgXSAqIHBvc1sgMSBdIC0gZGlyWyAyIF0gKiBwb3NbIDIgXSxcbiAgICAxLjBcbiAgXTtcbn07XG5cbi8qKlxuICogR2VuZXJhdGUgYSBcIlBlcnNwZWN0aXZlXCIgcHJvamVjdGlvbiBtYXRyaXguICBcbiAqIEl0IHdvbid0IGluY2x1ZGUgYXNwZWN0IVxuICogQHBhcmFtIHtudW1iZXJ9IGZvdiBzY2FsYXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBuZWFyIHNjYWxhclxuICogQHBhcmFtIHtudW1iZXJ9IGZhciBzY2FsYXJcbiAqIEByZXR1cm5zIHtudW1iZXJbXX0gbWF0NCwgR2VuZXJhdGVkIG1hdHJpeFxuICogQHN0YXRpY1xuICovXG5NYXRoQ2F0Lm1hdDRQZXJzcGVjdGl2ZSA9ICggZm92LCBuZWFyLCBmYXIgKSA9PiB7XG4gIGNvbnN0IHAgPSAxLjAgLyBNYXRoLnRhbiggZm92ICogTWF0aC5QSSAvIDM2MC4wICk7XG4gIGNvbnN0IGQgPSAoIGZhciAtIG5lYXIgKTtcbiAgcmV0dXJuIFtcbiAgICBwLCAwLjAsIDAuMCwgMC4wLFxuICAgIDAuMCwgcCwgMC4wLCAwLjAsXG4gICAgMC4wLCAwLjAsICggZmFyICsgbmVhciApIC8gZCwgMS4wLFxuICAgIDAuMCwgMC4wLCAtMiAqIGZhciAqIG5lYXIgLyBkLCAwLjBcbiAgXTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IE1hdGhDYXQ7IiwiLy8g44GK5YmN44CB44OK44Oz44OH44Oi44Ki44Oq44GL44KI77yBXG5cbmNvbnN0IFVsdHJhQ2F0ID0ge307XG5cblVsdHJhQ2F0LnRyaWFuZ2xlU3RyaXBRdWFkID0gWyAtMSwgLTEsIDEsIC0xLCAtMSwgMSwgMSwgMSBdO1xuVWx0cmFDYXQudHJpYW5nbGVTdHJpcFF1YWQzID0gWyAtMSwgLTEsIDAsIDEsIC0xLCAwLCAtMSwgMSwgMCwgMSwgMSwgMCBdO1xuVWx0cmFDYXQudHJpYW5nbGVTdHJpcFF1YWROb3IgPSBbIDAsIDAsIDEsIDAsIDAsIDEsIDAsIDAsIDEsIDAsIDAsIDEgXTtcblVsdHJhQ2F0LnRyaWFuZ2xlU3RyaXBRdWFkVVYgPSBbIDAsIDAsIDEsIDAsIDAsIDEsIDEsIDEgXTtcblxuLy8gZGVzdHJ1Y3RpdmVcblVsdHJhQ2F0LnNodWZmbGVBcnJheUQgPSAoIGFycmF5LCBkaWNlICkgPT4ge1xuICBjb25zdCBmID0gZGljZSA/IGRpY2UgOiAoKSA9PiBNYXRoLnJhbmRvbSgpO1xuICBmb3IgKCBsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGggLSAxOyBpICsrICkge1xuICAgIGNvbnN0IGlyID0gaSArIE1hdGguZmxvb3IoIGYoKSAqICggYXJyYXkubGVuZ3RoIC0gaSApICk7XG4gICAgY29uc3QgdGVtcCA9IGFycmF5WyBpciBdO1xuICAgIGFycmF5WyBpciBdID0gYXJyYXlbIGkgXTtcbiAgICBhcnJheVsgaSBdID0gdGVtcDtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59O1xuXG5VbHRyYUNhdC50cmlJbmRleFRvTGluZUluZGV4ID0gKCBhcnJheSApID0+IHtcbiAgbGV0IHJldCA9IFtdO1xuICBmb3IgKCBsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGggLyAzOyBpICsrICkge1xuICAgIGNvbnN0IGhlYWQgPSBpICogMztcbiAgICByZXQucHVzaChcbiAgICAgIGFycmF5WyBoZWFkICAgICBdLCBhcnJheVsgaGVhZCArIDEgXSxcbiAgICAgIGFycmF5WyBoZWFkICsgMSBdLCBhcnJheVsgaGVhZCArIDIgXSxcbiAgICAgIGFycmF5WyBoZWFkICsgMiBdLCBhcnJheVsgaGVhZCAgICAgXVxuICAgICk7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn07XG5cblVsdHJhQ2F0Lm1hdHJpeDJkID0gKCB3LCBoICkgPT4ge1xuICBsZXQgYXJyID0gW107XG4gIGZvciAoIGxldCBpeSA9IDA7IGl5IDwgaDsgaXkgKysgKSB7XG4gICAgZm9yICggbGV0IGl4ID0gMDsgaXggPCB3OyBpeCArKyApIHtcbiAgICAgIGFyci5wdXNoKCBpeCwgaXkgKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFycjtcbn07XG5cblVsdHJhQ2F0LmxlcnAgPSAoIGEsIGIsIHggKSA9PiBhICsgKCBiIC0gYSApICogeDtcblVsdHJhQ2F0LmNsYW1wID0gKCB4LCBsLCBoICkgPT4gTWF0aC5taW4oIE1hdGgubWF4KCB4LCBsICksIGggKTtcblVsdHJhQ2F0LnNhdHVyYXRlID0gKCB4ICkgPT4gTWF0aC5taW4oIE1hdGgubWF4KCB4LCAwLjAgKSwgMS4wICk7XG5VbHRyYUNhdC5saW5lYXJzdGVwID0gKCBhLCBiLCB4ICkgPT4gVWx0cmFDYXQuc2F0dXJhdGUoICggeCAtIGEgKSAvICggYiAtIGEgKSApO1xuVWx0cmFDYXQuc21vb3Roc3RlcCA9ICggYSwgYiwgeCApID0+IHtcbiAgY29uc3QgdCA9IFVsdHJhQ2F0LmxpbmVhcnN0ZXAoIGEsIGIsIHggKTtcbiAgcmV0dXJuIHQgKiB0ICogKCAzLjAgLSAyLjAgKiB0ICk7XG59O1xuXG5VbHRyYUNhdC5FeHBTbW9vdGggPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCBmYWN0b3IgKSB7XG4gICAgdGhpcy5mYWN0b3IgPSBmYWN0b3I7XG4gICAgdGhpcy52YWx1ZSA9IDAuMDtcbiAgfVxuXG4gIHVwZGF0ZSggdmFsdWUsIGR0ICkge1xuICAgIHRoaXMudmFsdWUgPSBVbHRyYUNhdC5sZXJwKCB2YWx1ZSwgdGhpcy52YWx1ZSwgTWF0aC5leHAoIC10aGlzLmZhY3RvciAqIGR0ICkgKTtcbiAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgVWx0cmFDYXQ7IiwiY29uc3QgWG9yc2hpZnQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCBfc2VlZCApIHtcbiAgICB0aGlzLnNldCggX3NlZWQgKTtcbiAgfVxuXG4gIGdlbiggX3NlZWQgKSB7XG4gICAgaWYgKCBfc2VlZCApIHsgdGhpcy5zZXQoIF9zZWVkICk7IH1cbiAgICB0aGlzLnNlZWQgPSB0aGlzLnNlZWQgXiAoIHRoaXMuc2VlZCA8PCAxMyApO1xuICAgIHRoaXMuc2VlZCA9IHRoaXMuc2VlZCBeICggdGhpcy5zZWVkID4+PiAxNyApO1xuICAgIHRoaXMuc2VlZCA9IHRoaXMuc2VlZCBeICggdGhpcy5zZWVkIDw8IDUgKTtcbiAgICByZXR1cm4gdGhpcy5zZWVkIC8gTWF0aC5wb3coIDIsIDMyICkgKyAwLjU7XG4gIH1cblxuICBzZXQoIF9zZWVkICkge1xuICAgIHRoaXMuc2VlZCA9IF9zZWVkIHx8IHRoaXMuc2VlZCB8fCAxO1xuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBYb3JzaGlmdDsiLCJpbXBvcnQgJy4vc3R5bGVzL21haW4uc2Nzcyc7XG5cbi8vID09IGltcG9ydCB2YXJpb3VzIG1vZHVsZXMgLyBzdHVmZiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5pbXBvcnQgR0xDYXQgZnJvbSAnLi9saWJzL2dsY2F0LmpzJztcbmltcG9ydCBHTENhdFBhdGggZnJvbSAnLi9saWJzL2dsY2F0LXBhdGgtZ3VpJztcbmltcG9ydCBNYXRoQ2F0IGZyb20gJy4vbGlicy9tYXRoY2F0LmpzJztcbmltcG9ydCBVbHRyYUNhdCBmcm9tICcuL2xpYnMvdWx0cmFjYXQuanMnO1xuaW1wb3J0IEF1dG9tYXRvbiBmcm9tICdAZm1zLWNhdC9hdXRvbWF0b24nO1xuaW1wb3J0IENhbnZhc1NhdmVyIGZyb20gJy4vbGlicy9jYW52YXMtc2F2ZXInO1xuXG5pbXBvcnQgQ09ORklHIGZyb20gJy4vY29uZmlnLmpzb24nO1xuXG4vLyA9PSB3ZSBhcmUgc3R1bGwgc3RydWdnbGluZyBieSB0aGlzID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuY29uc3QgJCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IuYmluZCggZG9jdW1lbnQgKTtcblxuLy8gPT0gaGkgY2FudmFzID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbmNvbnN0IGNhbnZhcyA9ICQoICcjY2FudmFzJyApO1xubGV0IHdpZHRoID0gY2FudmFzLndpZHRoID0gQ09ORklHLnJlc29sdXRpb25bIDAgXTtcbmxldCBoZWlnaHQgPSBjYW52YXMuaGVpZ2h0ID0gQ09ORklHLnJlc29sdXRpb25bIDEgXTtcblxuY29uc3Qgc2F2ZXIgPSBuZXcgQ2FudmFzU2F2ZXIoIGNhbnZhcyApO1xuXG5jb25zdCBnbCA9IGNhbnZhcy5nZXRDb250ZXh0KCAnd2ViZ2wnICk7XG5nbC5saW5lV2lkdGgoIDEgKTsgLy8gZVxuXG5jb25zdCBnbENhdCA9IG5ldyBHTENhdCggZ2wgKTtcbmdsQ2F0LmdldEV4dGVuc2lvbiggJ09FU190ZXh0dXJlX2Zsb2F0JywgdHJ1ZSApO1xuZ2xDYXQuZ2V0RXh0ZW5zaW9uKCAnT0VTX3RleHR1cmVfZmxvYXRfbGluZWFyJywgdHJ1ZSApO1xuZ2xDYXQuZ2V0RXh0ZW5zaW9uKCAnRVhUX2ZyYWdfZGVwdGgnLCB0cnVlICk7XG5nbENhdC5nZXRFeHRlbnNpb24oICdBTkdMRV9pbnN0YW5jZWRfYXJyYXlzJywgdHJ1ZSApO1xuXG5jb25zdCBnbENhdFBhdGggPSBuZXcgR0xDYXRQYXRoKCBnbENhdCwge1xuICBlbDogJCggJyNkaXZQYXRoJyApLFxuICBjYW52YXM6IGNhbnZhcyxcbiAgc3RyZXRjaDogdHJ1ZSxcbiAgZHJhd2J1ZmZlcnM6IHRydWVcbn0gKTtcblxuLy8gb2ggaGlcbmNvbnN0IHZib1F1YWQgPSBnbENhdC5jcmVhdGVWZXJ0ZXhidWZmZXIoIG5ldyBGbG9hdDMyQXJyYXkoIFVsdHJhQ2F0LnRyaWFuZ2xlU3RyaXBRdWFkICkgKTtcblxuLy8gPT0gaGVsbG8gYXV0b21hdG9uID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbmxldCB0b3RhbEZyYW1lID0gMDtcbmxldCBpc0luaXRpYWxGcmFtZSA9IHRydWU7XG5cbmNvbnN0IGF1dG9tYXRvbiA9IG5ldyBBdXRvbWF0b24oIHtcbiAgbG9vcDogdHJ1ZSxcbiAgZnBzOiAxMjAsXG4gIGd1aTogJCggJyNkaXZBdXRvbWF0b24nICksXG4gIGRhdGE6IHJlcXVpcmUoICcuL2F1dG9tYXRvbi5qc29uJyApXG59ICk7XG5jb25zdCBhdXRvID0gYXV0b21hdG9uLmF1dG87XG5cbmlmICggbW9kdWxlLmhvdCApIHtcbiAgbW9kdWxlLmhvdC5hY2NlcHQoXG4gICAgJy4vYXV0b21hdG9uLmpzb24nLFxuICAgICgpID0+IGF1dG9tYXRvbi5sb2FkKCByZXF1aXJlKCAnLi9hdXRvbWF0b24uanNvbicgKSApXG4gICk7XG59XG5cbi8vID09IGxpZ2h0cywgY2FtZXJhLCBhY3Rpb24hID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5sZXQgY2FtZXJhUG9zID0gWyAwLjAsIDAuMCwgMC4wIF07XG5sZXQgY2FtZXJhVGFyID0gWyAwLjAsIDAuMCwgMC4wIF07XG5sZXQgY2FtZXJhUm9sbCA9IDAuMDsgLy8gcHJvdGlwOiBjb25zaWRlcmluZyByb2xsIG9mIGNhbSBpcyBjb29sIGlkZWFcblxubGV0IHBlcnNwRm92ID0gNzAuMDtcbmxldCBwZXJzcE5lYXIgPSAwLjAxO1xubGV0IHBlcnNwRmFyID0gMTAwLjA7XG5cbmxldCBsaWdodFBvcyA9IFsgNS4wLCA1LjAsIDEwLjAgXTsgLy8gdGhpcyBpcyBwcmV0dHkgcmFuZG9tXG5cbmNvbnN0IHNoYWRvd1Jlc28gPSBDT05GSUcuc2hhZG93UmVzbzsgLy8gdGV4dHVyZSBzaXplIGZvciBzaGFkb3cgYnVmZmVyXG5cbmxldCBtYXRQID0gTWF0aENhdC5tYXQ0UGVyc3BlY3RpdmUoIHBlcnNwRm92LCBwZXJzcE5lYXIsIHBlcnNwRmFyICk7XG5sZXQgbWF0ViA9IE1hdGhDYXQubWF0NExvb2tBdCggY2FtZXJhUG9zLCBjYW1lcmFUYXIsIFsgMC4wLCAxLjAsIDAuMCBdLCBjYW1lcmFSb2xsICk7XG5sZXQgbWF0UEwgPSBNYXRoQ2F0Lm1hdDRQZXJzcGVjdGl2ZSggcGVyc3BGb3YsIHBlcnNwTmVhciwgcGVyc3BGYXIgKTtcbmxldCBtYXRWTCA9IE1hdGhDYXQubWF0NExvb2tBdCggbGlnaHRQb3MsIGNhbWVyYVRhciwgWyAwLjAsIDEuMCwgMC4wIF0sIDAuMCApO1xuXG5jb25zdCB1cGRhdGVNYXRyaWNlcyA9ICggY2FtT2Zmc2V0ICkgPT4ge1xuICBjYW1lcmFQb3MgPSBbIDAuMCwgMC4wLCBhdXRvKCAnY2FtZXJhLVJhZGl1cycgKSBdO1xuICBjYW1lcmFQb3MgPSBNYXRoQ2F0LnJvdGF0ZVZlY0J5UXVhdCggY2FtZXJhUG9zLCBNYXRoQ2F0LnF1YXRBbmdsZUF4aXMoIGF1dG8oICdjYW1lcmEtcm90WCcsIHsgc21vb3RoOiAxMC4wIH0gKSAtIDAuNSwgWyAxLjAsIDAuMCwgMC4wIF0gKSApO1xuICBjYW1lcmFQb3MgPSBNYXRoQ2F0LnJvdGF0ZVZlY0J5UXVhdCggY2FtZXJhUG9zLCBNYXRoQ2F0LnF1YXRBbmdsZUF4aXMoIGF1dG8oICdjYW1lcmEtcm90WScsIHsgc21vb3RoOiAxMC4wIH0gKSAtIDAuNSwgWyAwLjAsIDEuMCwgMC4wIF0gKSApO1xuICBpZiAoIGNhbU9mZnNldCApIHsgY2FtZXJhUG9zID0gTWF0aENhdC52ZWNBZGQoIGNhbWVyYVBvcywgY2FtT2Zmc2V0ICk7IH1cblxuICBtYXRQID0gTWF0aENhdC5tYXQ0UGVyc3BlY3RpdmUoIHBlcnNwRm92LCBwZXJzcE5lYXIsIHBlcnNwRmFyICk7XG4gIG1hdFYgPSBNYXRoQ2F0Lm1hdDRMb29rQXQoIGNhbWVyYVBvcywgY2FtZXJhVGFyLCBbIDAuMCwgMS4wLCAwLjAgXSwgY2FtZXJhUm9sbCApO1xuXG4gIG1hdFBMID0gTWF0aENhdC5tYXQ0UGVyc3BlY3RpdmUoIHBlcnNwRm92LCBwZXJzcE5lYXIsIHBlcnNwRmFyICk7XG4gIG1hdFZMID0gTWF0aENhdC5tYXQ0TG9va0F0KCBsaWdodFBvcywgY2FtZXJhVGFyLCBbIDAuMCwgMS4wLCAwLjAgXSwgMC4wICk7XG59O1xudXBkYXRlTWF0cmljZXMoKTtcblxuLy8gPT0gbW91c2UgbGlzdGVuZXIsIHdoeSB0aG8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbmxldCBtb3VzZVggPSAwLjA7XG5sZXQgbW91c2VZID0gMC4wO1xuXG5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lciggJ21vdXNlbW92ZScsICggZXZlbnQgKSA9PiB7XG4gIG1vdXNlWCA9IGV2ZW50Lm9mZnNldFg7XG4gIG1vdXNlWSA9IGV2ZW50Lm9mZnNldFk7XG59ICk7XG5cbi8vID09IGdsb2JhbCB1bmlmb3JtIHZhcmlhYmxlcyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5nbENhdFBhdGguc2V0R2xvYmFsRnVuYyggKCkgPT4ge1xuICBnbENhdC51bmlmb3JtMWkoICdpc0luaXRpYWxGcmFtZScsIGlzSW5pdGlhbEZyYW1lICk7XG5cbiAgZ2xDYXQudW5pZm9ybTFmKCAndGltZScsIGF1dG9tYXRvbi50aW1lICk7XG4gIGdsQ2F0LnVuaWZvcm0xZiggJ2RlbHRhVGltZScsIGF1dG9tYXRvbi5kZWx0YVRpbWUgKTtcbiAgZ2xDYXQudW5pZm9ybTFmKCAndG90YWxGcmFtZScsIHRvdGFsRnJhbWUgKTtcblxuICBnbENhdC51bmlmb3JtM2Z2KCAnY2FtZXJhUG9zJywgY2FtZXJhUG9zICk7XG4gIGdsQ2F0LnVuaWZvcm0zZnYoICdjYW1lcmFUYXInLCBjYW1lcmFUYXIgKTtcbiAgZ2xDYXQudW5pZm9ybTFmKCAnY2FtZXJhUm9sbCcsIGNhbWVyYVJvbGwgKTtcblxuICBnbENhdC51bmlmb3JtMWYoICdwZXJzcEZvdicsIHBlcnNwRm92ICk7XG4gIGdsQ2F0LnVuaWZvcm0xZiggJ3BlcnNwTmVhcicsIHBlcnNwTmVhciApO1xuICBnbENhdC51bmlmb3JtMWYoICdwZXJzcEZhcicsIHBlcnNwRmFyICk7XG5cbiAgZ2xDYXQudW5pZm9ybTNmdiggJ2xpZ2h0UG9zJywgbGlnaHRQb3MgKTtcblxuICBnbENhdC51bmlmb3JtTWF0cml4NGZ2KCAnbWF0UCcsIG1hdFAgKTtcbiAgZ2xDYXQudW5pZm9ybU1hdHJpeDRmdiggJ21hdFYnLCBtYXRWICk7XG4gIGdsQ2F0LnVuaWZvcm1NYXRyaXg0ZnYoICdtYXRQTCcsIG1hdFBMICk7XG4gIGdsQ2F0LnVuaWZvcm1NYXRyaXg0ZnYoICdtYXRWTCcsIG1hdFZMICk7XG5cbiAgZ2xDYXQudW5pZm9ybTJmdiggJ21vdXNlJywgWyBtb3VzZVgsIG1vdXNlWSBdICk7XG5cbiAgZ2xDYXQudW5pZm9ybTRmdiggJ2JnQ29sb3InLCBbIDAuMCwgMC4wLCAwLjAsIDEuMCBdICk7XG59ICk7XG5cbi8vID09IGdsY2F0LXBhdGggc2V0dXAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5nbENhdFBhdGguYWRkKCB7XG4gIHJldHVybjoge1xuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICB2ZXJ0OiByZXF1aXJlKCAnLi9zaGFkZXJzL3F1YWQudmVydCcgKSxcbiAgICBmcmFnOiByZXF1aXJlKCAnLi9zaGFkZXJzL3JldHVybi5mcmFnJyApLFxuICAgIGJsZW5kOiBbIGdsLk9ORSwgZ2wuWkVSTyBdLFxuICAgIGNsZWFyOiBbIDAuMCwgMC4wLCAwLjAsIDEuMCBdLFxuICAgIGZ1bmM6ICggcGF0aCwgcGFyYW1zICkgPT4ge1xuICAgICAgZ2xDYXQuYXR0cmlidXRlKCAncCcsIHZib1F1YWQsIDIgKTtcbiAgICAgIGdsQ2F0LnVuaWZvcm1UZXh0dXJlKCAnc2FtcGxlcjAnLCBwYXJhbXMuaW5wdXQsIDAgKTtcbiAgICAgIGdsLmRyYXdBcnJheXMoIGdsLlRSSUFOR0xFX1NUUklQLCAwLCA0ICk7XG4gICAgfVxuICB9LFxuXG4gIGluc3BlY3Rvcjoge1xuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICB2ZXJ0OiByZXF1aXJlKCAnLi9zaGFkZXJzL3F1YWQudmVydCcgKSxcbiAgICBmcmFnOiByZXF1aXJlKCAnLi9zaGFkZXJzL2luc3BlY3Rvci5mcmFnJyApLFxuICAgIGJsZW5kOiBbIGdsLk9ORSwgZ2wuWkVSTyBdLFxuICAgIGNsZWFyOiBbIDAuMCwgMC4wLCAwLjAsIDEuMCBdLFxuICAgIGZ1bmM6ICggcGF0aCwgcGFyYW1zICkgPT4ge1xuICAgICAgZ2xDYXQuYXR0cmlidXRlKCAncCcsIHZib1F1YWQsIDIgKTtcbiAgICAgIGdsQ2F0LnVuaWZvcm0zZnYoICdjaXJjbGVDb2xvcicsIFsgMS4wLCAxLjAsIDEuMCBdICk7XG4gICAgICBnbENhdC51bmlmb3JtVGV4dHVyZSggJ3NhbXBsZXIwJywgcGFyYW1zLmlucHV0LCAwICk7XG4gICAgICBnbC5kcmF3QXJyYXlzKCBnbC5UUklBTkdMRV9TVFJJUCwgMCwgNCApO1xuICAgIH1cbiAgfSxcblxuICB0YXJnZXQ6IHtcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgdmVydDogcmVxdWlyZSggJy4vc2hhZGVycy9xdWFkLnZlcnQnICksXG4gICAgZnJhZzogcmVxdWlyZSggJy4vc2hhZGVycy9iZy5mcmFnJyApLFxuICAgIGJsZW5kOiBbIGdsLk9ORSwgZ2wuWkVSTyBdLFxuICAgIGNsZWFyOiBbIDAuMCwgMC4wLCAwLjAsIDEuMCBdLFxuICAgIGZyYW1lYnVmZmVyOiB0cnVlLFxuICAgIGZsb2F0OiB0cnVlLFxuICAgIGRyYXdidWZmZXJzOiAyLFxuICAgIGRlcHRoV3JpdGU6IGZhbHNlLFxuICAgIGZ1bmM6ICgpID0+IHtcbiAgICAgIGdsQ2F0LmF0dHJpYnV0ZSggJ3AnLCB2Ym9RdWFkLCAyICk7XG4gICAgICBnbC5kcmF3QXJyYXlzKCBnbC5UUklBTkdMRV9TVFJJUCwgMCwgNCApO1xuICAgIH1cbiAgfSxcblxuICBzaGFkb3c6IHtcbiAgICB3aWR0aDogc2hhZG93UmVzbyxcbiAgICBoZWlnaHQ6IHNoYWRvd1Jlc28sXG4gICAgdmVydDogcmVxdWlyZSggJy4vc2hhZGVycy9xdWFkLnZlcnQnICksXG4gICAgZnJhZzogcmVxdWlyZSggJy4vc2hhZGVycy9iZy5mcmFnJyApLFxuICAgIGJsZW5kOiBbIGdsLk9ORSwgZ2wuWkVSTyBdLFxuICAgIGNsZWFyOiBbIHBlcnNwRmFyLCAwLjAsIDAuMCwgMS4wIF0sXG4gICAgZnJhbWVidWZmZXI6IHRydWUsXG4gICAgZmxvYXQ6IHRydWUsXG4gICAgZnVuYzogKCkgPT4ge1xuICAgICAgLy8gZ2xDYXQuYXR0cmlidXRlKCAncCcsIHZib1F1YWQsIDIgKTtcbiAgICAgIC8vIGdsLmRyYXdBcnJheXMoIGdsLlRSSUFOR0xFX1NUUklQLCAwLCA0ICk7XG4gICAgfVxuICB9LFxufSApO1xuXG4vLyA9PSBzZXR1cCBwYXRocyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuY29uc3QgY29udGV4dCA9IHtcbiAgZ2xDYXRQYXRoOiBnbENhdFBhdGgsXG4gIGF1dG9tYXRvbjogYXV0b21hdG9uLFxuICB3aWR0aDogd2lkdGgsXG4gIGhlaWdodDogaGVpZ2h0XG59O1xuXG5yZXF1aXJlKCAnLi9wYXRocy9ibG9vbScgKS5kZWZhdWx0KCBjb250ZXh0ICk7XG5yZXF1aXJlKCAnLi9wYXRocy9ib3gnICkuZGVmYXVsdCggY29udGV4dCApO1xucmVxdWlyZSggJy4vcGF0aHMvanBlZycgKS5kZWZhdWx0KCBjb250ZXh0ICk7XG5yZXF1aXJlKCAnLi9wYXRocy9vdmVybGF5JyApLmRlZmF1bHQoIGNvbnRleHQgKTtcbnJlcXVpcmUoICcuL3BhdGhzL3BhcnRpY2xlcycgKS5kZWZhdWx0KCBjb250ZXh0ICk7XG5yZXF1aXJlKCAnLi9wYXRocy9wb3N0ZngnICkuZGVmYXVsdCggY29udGV4dCApO1xuXG4vLyA9PSBsb29wIGhlcmUgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuY29uc3QgdXBkYXRlID0gKCkgPT4ge1xuICBpZiAoICEkKCAnI2FjdGl2ZScgKS5jaGVja2VkICkge1xuICAgIHNldFRpbWVvdXQoIHVwZGF0ZSwgMTAwICk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gPT0gdXBkYXRlIHNvbWUgYnVuY2ggb2Ygc2hpdCA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIGF1dG9tYXRvbi51cGRhdGUoKTtcbiAgdXBkYXRlTWF0cmljZXMoKTtcblxuICAvLyA9PSBsZXQncyByZW5kZXIgdGhpcyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgZ2xDYXRQYXRoLmJlZ2luKCk7XG5cbiAgLy8gPT0gY29tcHV0ZSBzdHVmZiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIGdsQ2F0UGF0aC5yZW5kZXIoICdwYXJ0aWNsZXNDb21wdXRlUmV0dXJuJyApO1xuICBnbENhdFBhdGgucmVuZGVyKCAncGFydGljbGVzTW90aW9uUmVhZCcgKTtcbiAgZ2xDYXRQYXRoLnJlbmRlciggJ3BhcnRpY2xlc0VuZm9yY2UnICk7XG4gIGdsQ2F0UGF0aC5yZW5kZXIoICdwYXJ0aWNsZXNEaXZlcmdlbmNlJyApO1xuICBnbENhdFBhdGgucmVuZGVyKCAncGFydGljbGVzUHJlc3N1cmUnICk7XG4gIGdsQ2F0UGF0aC5yZW5kZXIoICdwYXJ0aWNsZXNNb3Rpb25Xcml0ZScgKTtcbiAgZ2xDYXRQYXRoLnJlbmRlciggJ3BhcnRpY2xlc0NvbXB1dGUnICk7XG5cbiAgLy8gPT0gc2hhZG93ID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIGdsQ2F0UGF0aC5yZW5kZXIoICdzaGFkb3cnICk7XG5cbiAgZ2xDYXRQYXRoLnJlbmRlciggJ3BhcnRpY2xlc1JlbmRlcicsIHtcbiAgICB0YXJnZXQ6IGdsQ2F0UGF0aC5mYiggJ3NoYWRvdycgKSxcbiAgICBpc1NoYWRvdzogdHJ1ZSxcbiAgICB3aWR0aDogc2hhZG93UmVzbyxcbiAgICBoZWlnaHQ6IHNoYWRvd1Jlc29cbiAgfSApO1xuXG4gIC8vID09IGZvcmVncm91bmQgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICBnbENhdFBhdGgucmVuZGVyKCAndGFyZ2V0JyApO1xuXG4gIGdsQ2F0UGF0aC5yZW5kZXIoICdwYXJ0aWNsZXNSZW5kZXInLCB7XG4gICAgdGFyZ2V0OiBnbENhdFBhdGguZmIoICd0YXJnZXQnICksXG4gICAgdGV4dHVyZVNoYWRvdzogZ2xDYXRQYXRoLmZiKCAnc2hhZG93JyApLnRleHR1cmUsXG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0XG4gIH0gKTtcblxuICBnbENhdFBhdGgucmVuZGVyKCAnYm94Jywge1xuICAgIHRhcmdldDogZ2xDYXRQYXRoLmZiKCAndGFyZ2V0JyApLFxuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBoZWlnaHQ6IGhlaWdodFxuICB9ICk7XG5cbiAgZ2xDYXRQYXRoLnJlbmRlciggJ292ZXJsYXknLCB7XG4gICAgdGFyZ2V0OiBnbENhdFBhdGguZmIoICd0YXJnZXQnICksXG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0XG4gIH0gKTtcblxuICAvLyA9PSBwb3N0ID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgZ2xDYXRQYXRoLnJlbmRlciggJ3ByZUJsb29tJywge1xuICAgIGlucHV0OiBnbENhdFBhdGguZmIoICd0YXJnZXQnICkudGV4dHVyZXNbIDAgXSxcbiAgICBiaWFzOiBbIC0wLjksIC0wLjksIC0wLjkgXSxcbiAgICBmYWN0b3I6IFsgMS4wLCAxLjAsIDEuMCBdXG4gIH0gKTtcbiAgZ2xDYXRQYXRoLnJlbmRlciggJ2Jsb29tJyApO1xuICBnbENhdFBhdGgucmVuZGVyKCAncG9zdEJsb29tJywge1xuICAgIGRyeTogZ2xDYXRQYXRoLmZiKCAndGFyZ2V0JyApLnRleHR1cmVzWyAwIF1cbiAgfSApO1xuXG4gIGdsQ2F0UGF0aC5yZW5kZXIoICdqcGVnQ29zaW5lJywge1xuICAgIGlucHV0OiBnbENhdFBhdGguZmIoICdwb3N0Qmxvb20nICkudGV4dHVyZVxuICB9ICk7XG4gIGdsQ2F0UGF0aC5yZW5kZXIoICdqcGVnUmVuZGVyJyApO1xuXG4gIGdsQ2F0UGF0aC5yZW5kZXIoICdwb3N0Jywge1xuICAgIGlucHV0OiBnbENhdFBhdGguZmIoICdqcGVnUmVuZGVyJyApLnRleHR1cmVcbiAgfSApO1xuXG4gIGdsQ2F0UGF0aC5yZW5kZXIoICdyZXR1cm4nLCB7XG4gICAgdGFyZ2V0OiBHTENhdFBhdGgubnVsbEZiLFxuICAgIGlucHV0OiBnbENhdFBhdGguZmIoICdwb3N0JyApLnRleHR1cmVcbiAgfSApO1xuXG4gIC8vIGdsQ2F0UGF0aC5yZW5kZXIoICdpbnNwZWN0b3InLCB7XG4gIC8vICAgdGFyZ2V0OiBHTENhdFBhdGgubnVsbEZiLFxuICAvLyAgIGlucHV0OiBnbENhdFBhdGguZmIoICdwYXJ0aWNsZXNNb3Rpb25Xcml0ZScgKS50ZXh0dXJlXG4gIC8vIH0gKTtcblxuICAvLyA9PSBlbmQgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgZ2xDYXRQYXRoLmVuZCgpO1xuXG4gIC8vID09IHNhdmUgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICBpZiAoICQoICcjc2F2ZScgKS5jaGVja2VkICkge1xuICAgIHNhdmVyLmNhcHR1cmUoKTtcbiAgICBpZiAoIGF1dG9tYXRvbi5mcHMgKiBhdXRvbWF0b24ubGVuZ3RoICogMS4xIDwgc2F2ZXIuZnJhbWVDb3VudCApIHtcbiAgICAgICQoICcjc2F2ZScgKS5jaGVja2VkID0gZmFsc2U7XG4gICAgICBzYXZlci5zYXZlKCk7XG4gICAgfVxuICB9XG5cbiAgLy8gPT0gZmluYWxpemUgdGhlIGxvb3AgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIGlzSW5pdGlhbEZyYW1lID0gZmFsc2U7XG4gIHRvdGFsRnJhbWUgKys7XG5cbiAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCB1cGRhdGUgKTtcbn07XG5cbnVwZGF0ZSgpO1xuXG4vLyA9PSBrZXlib2FyZCBpcyBnb29kID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoICdrZXlkb3duJywgKCBldmVudCApID0+IHtcbiAgaWYgKCBldmVudC53aGljaCA9PT0gMjcgKSB7IC8vIHBhbmljIGJ1dHRvblxuICAgICQoICcjYWN0aXZlJyApLmNoZWNrZWQgPSBmYWxzZTtcbiAgfVxuXG4gIGlmICggZXZlbnQud2hpY2ggPT09IDMyICkgeyAvLyBwbGF5IC8gcGF1c2VcbiAgICBhdXRvbWF0b24uaXNQbGF5aW5nID8gYXV0b21hdG9uLnBhdXNlKCkgOiBhdXRvbWF0b24ucGxheSgpO1xuICB9XG59ICk7IiwiaW1wb3J0IFVsdHJhQ2F0IGZyb20gJy4uL2xpYnMvdWx0cmFjYXQnO1xuXG4vLyAtLS0tLS1cblxuZXhwb3J0IGRlZmF1bHQgKCBjb250ZXh0ICkgPT4ge1xuICBjb25zdCBnbENhdFBhdGggPSBjb250ZXh0LmdsQ2F0UGF0aDtcbiAgY29uc3QgZ2xDYXQgPSBnbENhdFBhdGguZ2xDYXQ7XG4gIGNvbnN0IGdsID0gZ2xDYXQuZ2w7XG5cbiAgY29uc3Qgd2lkdGggPSBjb250ZXh0LndpZHRoO1xuICBjb25zdCBoZWlnaHQgPSBjb250ZXh0LmhlaWdodDtcblxuICAvLyAtLS0tLS1cblxuICBjb25zdCB2Ym9RdWFkID0gZ2xDYXQuY3JlYXRlVmVydGV4YnVmZmVyKCBuZXcgRmxvYXQzMkFycmF5KCBVbHRyYUNhdC50cmlhbmdsZVN0cmlwUXVhZCApICk7XG5cbiAgLy8gLS0tLS0tXG5cbiAgZ2xDYXRQYXRoLmFkZCgge1xuICAgIHByZUJsb29tOiB7XG4gICAgICB3aWR0aDogd2lkdGggLyA0LFxuICAgICAgaGVpZ2h0OiBoZWlnaHQgLyA0LFxuICAgICAgdmVydDogcmVxdWlyZSggJy4uL3NoYWRlcnMvcXVhZC52ZXJ0JyApLFxuICAgICAgZnJhZzogcmVxdWlyZSggJy4uL3NoYWRlcnMvYmxvb20tcHJlLmZyYWcnICksXG4gICAgICBibGVuZDogWyBnbC5PTkUsIGdsLk9ORSBdLFxuICAgICAgY2xlYXI6IFsgMC4wLCAwLjAsIDAuMCwgMC4wIF0sXG4gICAgICBmcmFtZWJ1ZmZlcjogdHJ1ZSxcbiAgICAgIGZsb2F0OiB0cnVlLFxuICAgICAgZnVuYzogKCBwYXRoLCBwYXJhbXMgKSA9PiB7XG4gICAgICAgIGdsQ2F0LmF0dHJpYnV0ZSggJ3AnLCB2Ym9RdWFkLCAyICk7XG4gICAgICAgIGdsQ2F0LnVuaWZvcm0zZnYoICdiaWFzJywgcGFyYW1zLmJpYXMgKTtcbiAgICAgICAgZ2xDYXQudW5pZm9ybTNmdiggJ2ZhY3RvcicsIHBhcmFtcy5mYWN0b3IgKTtcbiAgICAgICAgZ2xDYXQudW5pZm9ybVRleHR1cmUoICdzYW1wbGVyMCcsIHBhcmFtcy5pbnB1dCwgMCApO1xuICAgICAgICBnbC5kcmF3QXJyYXlzKCBnbC5UUklBTkdMRV9TVFJJUCwgMCwgNCApO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBibG9vbToge1xuICAgICAgd2lkdGg6IHdpZHRoIC8gNCxcbiAgICAgIGhlaWdodDogaGVpZ2h0IC8gNCxcbiAgICAgIHZlcnQ6IHJlcXVpcmUoICcuLi9zaGFkZXJzL3F1YWQudmVydCcgKSxcbiAgICAgIGZyYWc6IHJlcXVpcmUoICcuLi9zaGFkZXJzL2dhdXNzLmZyYWcnICksXG4gICAgICBibGVuZDogWyBnbC5PTkUsIGdsLk9ORSBdLFxuICAgICAgY2xlYXI6IFsgMC4wLCAwLjAsIDAuMCwgMC4wIF0sXG4gICAgICBmcmFtZWJ1ZmZlcjogdHJ1ZSxcbiAgICAgIGZsb2F0OiB0cnVlLFxuICAgICAgdGVtcEZiOiBnbENhdC5jcmVhdGVGcmFtZWJ1ZmZlciggd2lkdGggLyA0LCBoZWlnaHQgLyA0ICksXG4gICAgICBmdW5jOiAoIHBhdGgsIHBhcmFtcyApID0+IHtcbiAgICAgICAgZ2xDYXQuYXR0cmlidXRlKCAncCcsIHZib1F1YWQsIDIgKTtcblxuICAgICAgICBmb3IgKCBsZXQgaSA9IDA7IGkgPCAzOyBpICsrICkge1xuICAgICAgICAgIGxldCBnYXVzc1ZhciA9IFsgMy4wLCAxMC4wLCAzMC4wIF1bIGkgXTtcbiAgICAgICAgICBnbENhdC51bmlmb3JtMWYoICd2YXInLCBnYXVzc1ZhciApO1xuXG4gICAgICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKCBnbC5GUkFNRUJVRkZFUiwgcGF0aC50ZW1wRmIuZnJhbWVidWZmZXIgKTtcbiAgICAgICAgICBnbENhdC5jbGVhciggLi4ucGF0aC5jbGVhciApO1xuICAgICAgICAgIGdsQ2F0LnVuaWZvcm0xaSggJ2lzVmVydCcsIGZhbHNlICk7XG4gICAgICAgICAgZ2xDYXQudW5pZm9ybVRleHR1cmUoXG4gICAgICAgICAgICAnc2FtcGxlcjAnLFxuICAgICAgICAgICAgaSA9PT0gMCA/IGdsQ2F0UGF0aC5mYiggJ3ByZUJsb29tJyApLnRleHR1cmUgOiBwYXRoLmZyYW1lYnVmZmVyLnRleHR1cmUsXG4gICAgICAgICAgICAwXG4gICAgICAgICAgKTtcbiAgICAgICAgICBnbC5kcmF3QXJyYXlzKCBnbC5UUklBTkdMRV9TVFJJUCwgMCwgNCApO1xuXG4gICAgICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKCBnbC5GUkFNRUJVRkZFUiwgcGFyYW1zLmZyYW1lYnVmZmVyICk7XG4gICAgICAgICAgZ2xDYXQudW5pZm9ybTFpKCAnaXNWZXJ0JywgdHJ1ZSApO1xuICAgICAgICAgIGdsQ2F0LnVuaWZvcm1UZXh0dXJlKCAnc2FtcGxlcjAnLCBwYXRoLnRlbXBGYi50ZXh0dXJlLCAwICk7XG4gICAgICAgICAgZ2wuZHJhd0FycmF5cyggZ2wuVFJJQU5HTEVfU1RSSVAsIDAsIDQgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBwb3N0Qmxvb206IHtcbiAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgdmVydDogcmVxdWlyZSggJy4uL3NoYWRlcnMvcXVhZC52ZXJ0JyApLFxuICAgICAgZnJhZzogcmVxdWlyZSggJy4uL3NoYWRlcnMvYmxvb20tcG9zdC5mcmFnJyApLFxuICAgICAgYmxlbmQ6IFsgZ2wuT05FLCBnbC5aRVJPIF0sXG4gICAgICBjbGVhcjogWyAwLjAsIDAuMCwgMC4wLCAwLjAgXSxcbiAgICAgIGZyYW1lYnVmZmVyOiB0cnVlLFxuICAgICAgZmxvYXQ6IHRydWUsXG4gICAgICBmdW5jOiAoIHBhdGgsIHBhcmFtcyApID0+IHtcbiAgICAgICAgZ2xDYXQuYXR0cmlidXRlKCAncCcsIHZib1F1YWQsIDIgKTtcbiAgICAgICAgZ2xDYXQudW5pZm9ybVRleHR1cmUoICdzYW1wbGVyRHJ5JywgcGFyYW1zLmRyeSwgMCApO1xuICAgICAgICBnbENhdC51bmlmb3JtVGV4dHVyZSggJ3NhbXBsZXJXZXQnLCBnbENhdFBhdGguZmIoICdibG9vbScgKS50ZXh0dXJlLCAxICk7XG4gICAgICAgIGdsLmRyYXdBcnJheXMoIGdsLlRSSUFOR0xFX1NUUklQLCAwLCA0ICk7XG4gICAgICB9XG4gICAgfSxcbiAgfSApO1xufTsiLCJpbXBvcnQgTWF0aENhdCBmcm9tICcuLi9saWJzL21hdGhjYXQnO1xuaW1wb3J0IFVsdHJhQ2F0IGZyb20gJy4uL2xpYnMvdWx0cmFjYXQnO1xuaW1wb3J0IGdlbkN1YmUgZnJvbSAnLi4vZ2VvbXMvY3ViZSc7XG5cbi8vIC0tLS0tLVxuXG5leHBvcnQgZGVmYXVsdCAoIGNvbnRleHQgKSA9PiB7XG4gIC8vID09IGhpIGNvbnRleHQgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICBjb25zdCBnbENhdFBhdGggPSBjb250ZXh0LmdsQ2F0UGF0aDtcbiAgY29uc3QgZ2xDYXQgPSBnbENhdFBhdGguZ2xDYXQ7XG4gIGNvbnN0IGdsID0gZ2xDYXQuZ2w7XG5cbiAgY29uc3QgYXV0byA9IGNvbnRleHQuYXV0b21hdG9uLmF1dG87XG5cbiAgLy8gPT0gaGkgdmJvID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIGNvbnN0IGJveCA9IGdlbkN1YmUoKTtcbiAgY29uc3QgdmJvQm94UG9zID0gZ2xDYXQuY3JlYXRlVmVydGV4YnVmZmVyKCBuZXcgRmxvYXQzMkFycmF5KCBbXG4gICAgLTEuMCwgLTEuMCwgLTEuMCwgMS4wLCAtMS4wLCAtMS4wLFxuICAgIDEuMCwgLTEuMCwgLTEuMCwgMS4wLCAxLjAsIC0xLjAsXG4gICAgMS4wLCAxLjAsIC0xLjAsIC0xLjAsIDEuMCwgLTEuMCxcbiAgICAtMS4wLCAxLjAsIC0xLjAsIC0xLjAsIC0xLjAsIC0xLjAsXG4gICAgLTEuMCwgLTEuMCwgMS4wLCAxLjAsIC0xLjAsIDEuMCxcbiAgICAxLjAsIC0xLjAsIDEuMCwgMS4wLCAxLjAsIDEuMCxcbiAgICAxLjAsIDEuMCwgMS4wLCAtMS4wLCAxLjAsIDEuMCxcbiAgICAtMS4wLCAxLjAsIDEuMCwgLTEuMCwgLTEuMCwgMS4wLFxuICAgIC0xLjAsIC0xLjAsIC0xLjAsIC0xLjAsIC0xLjAsIDEuMCxcbiAgICAxLjAsIC0xLjAsIC0xLjAsIDEuMCwgLTEuMCwgMS4wLFxuICAgIDEuMCwgMS4wLCAtMS4wLCAxLjAsIDEuMCwgMS4wLFxuICAgIC0xLjAsIDEuMCwgLTEuMCwgLTEuMCwgMS4wLCAxLjAsXG4gIF0gKSApO1xuXG4gIC8vID09IHBhdGggZGVmaW5pdGlvbiBiZWdpbiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICBnbENhdFBhdGguYWRkKCB7XG4gICAgYm94OiB7XG4gICAgICB2ZXJ0OiByZXF1aXJlKCAnLi4vc2hhZGVycy9ib3gudmVydCcgKSxcbiAgICAgIGZyYWc6IHJlcXVpcmUoICcuLi9zaGFkZXJzL2JveC5mcmFnJyApLFxuICAgICAgYmxlbmQ6IFsgZ2wuU1JDX0FMUEhBLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBIF0sXG4gICAgICBmdW5jOiAoIHBhdGgsIHBhcmFtcyApID0+IHtcbiAgICAgICAgZ2xDYXQuYXR0cmlidXRlKCAncG9zJywgdmJvQm94UG9zLCAzICk7XG5cbiAgICAgICAgbGV0IG1hdE0gPSBNYXRoQ2F0Lm1hdDRJZGVudGl0eSgpO1xuICAgICAgICBtYXRNID0gTWF0aENhdC5tYXQ0QXBwbHkoIE1hdGhDYXQubWF0NFNjYWxlKCBbIDIuMSwgMi4xICogYXV0byggJ2JveC1waGFzZScgKSwgMi4xIF0gKSwgbWF0TSApO1xuICAgICAgICBtYXRNID0gTWF0aENhdC5tYXQ0QXBwbHkoIE1hdGhDYXQubWF0NFRyYW5zbGF0ZSggWyAwLjAsIC0yLjEgKyAyLjEgKiBhdXRvKCAnYm94LXBoYXNlJyApLCAwLjAgXSApLCBtYXRNICk7XG4gICAgICAgIGdsQ2F0LnVuaWZvcm1NYXRyaXg0ZnYoICdtYXRNJywgbWF0TSApO1xuXG4gICAgICAgIGdsLmRyYXdBcnJheXMoIGdsLkxJTkVTLCAwLCAyNCApO1xuICAgICAgfVxuICAgIH1cbiAgfSApO1xuXG4gIG1vZHVsZS5ob3QuYWNjZXB0KFxuICAgIFtcbiAgICAgICcuLi9zaGFkZXJzL2JveC52ZXJ0JyxcbiAgICAgICcuLi9zaGFkZXJzL2JveC5mcmFnJ1xuICAgIF0sXG4gICAgKCkgPT4ge1xuICAgICAgZ2xDYXRQYXRoLnJlcGxhY2VQcm9ncmFtKFxuICAgICAgICAnYm94JyxcbiAgICAgICAgcmVxdWlyZSggJy4uL3NoYWRlcnMvYm94LnZlcnQnICksXG4gICAgICAgIHJlcXVpcmUoICcuLi9zaGFkZXJzL2JveC5mcmFnJyApXG4gICAgICApO1xuICAgIH1cbiAgKTtcbn07IiwiaW1wb3J0IFVsdHJhQ2F0IGZyb20gJy4uL2xpYnMvdWx0cmFjYXQnO1xuXG4vLyAtLS0tLS1cblxuZXhwb3J0IGRlZmF1bHQgKCBjb250ZXh0ICkgPT4ge1xuICBjb25zdCBnbENhdFBhdGggPSBjb250ZXh0LmdsQ2F0UGF0aDtcbiAgY29uc3QgZ2xDYXQgPSBnbENhdFBhdGguZ2xDYXQ7XG4gIGNvbnN0IGdsID0gZ2xDYXQuZ2w7XG5cbiAgY29uc3Qgd2lkdGggPSBjb250ZXh0LndpZHRoO1xuICBjb25zdCBoZWlnaHQgPSBjb250ZXh0LmhlaWdodDtcblxuICBjb25zdCBhdXRvID0gY29udGV4dC5hdXRvbWF0b24uYXV0bztcblxuICAvLyAtLS0tLS1cblxuICBjb25zdCB2Ym9RdWFkID0gZ2xDYXQuY3JlYXRlVmVydGV4YnVmZmVyKCBuZXcgRmxvYXQzMkFycmF5KCBVbHRyYUNhdC50cmlhbmdsZVN0cmlwUXVhZCApICk7XG5cbiAgLy8gLS0tLS0tXG5cbiAgZ2xDYXRQYXRoLmFkZCgge1xuICAgIGpwZWdDb3NpbmU6IHtcbiAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgdmVydDogcmVxdWlyZSggJy4uL3NoYWRlcnMvcXVhZC52ZXJ0JyApLFxuICAgICAgZnJhZzogcmVxdWlyZSggJy4uL3NoYWRlcnMvanBlZy1jb3NpbmUuZnJhZycgKSxcbiAgICAgIGJsZW5kOiBbIGdsLk9ORSwgZ2wuT05FIF0sXG4gICAgICBjbGVhcjogWyAwLjAsIDAuMCwgMC4wLCAwLjAgXSxcbiAgICAgIGZyYW1lYnVmZmVyOiB0cnVlLFxuICAgICAgZmxvYXQ6IHRydWUsXG4gICAgICB0ZW1wRmI6IGdsQ2F0LmNyZWF0ZUZsb2F0RnJhbWVidWZmZXIoIHdpZHRoLCBoZWlnaHQgKSxcbiAgICAgIGZ1bmM6ICggcGF0aCwgcGFyYW1zICkgPT4ge1xuICAgICAgICBnbENhdC5hdHRyaWJ1dGUoICdwJywgdmJvUXVhZCwgMiApO1xuICAgICAgICBnbENhdC51bmlmb3JtMWkoICdibG9ja1NpemUnLCBwYXJzZUludCggOC4wICsgMTIwLjAgKiBhdXRvKCAnanBlZy1ibG9ja1NpemUnICkgKSApO1xuXG4gICAgICAgIGdsQ2F0LnVuaWZvcm0xZiggJ3F1YW50aXplJywgMC4wICk7XG4gICAgICAgIGdsQ2F0LnVuaWZvcm0xZiggJ3F1YW50aXplRicsIE1hdGgucG93KCBhdXRvKCAnanBlZy1xdWFudGl6ZUYnICksIDIuMCApICk7XG4gICAgICAgIGdsQ2F0LnVuaWZvcm0xZiggJ2hpZ2hGcmVxTXVsdGlwbGllcicsIDAuMCApO1xuXG4gICAgICAgIGdsLmJpbmRGcmFtZWJ1ZmZlciggZ2wuRlJBTUVCVUZGRVIsIHBhdGgudGVtcEZiLmZyYW1lYnVmZmVyICk7XG4gICAgICAgIGdsQ2F0LmNsZWFyKCAuLi5wYXRoLmNsZWFyICk7XG4gICAgICAgIGdsQ2F0LnVuaWZvcm0xaSggJ2lzVmVydCcsIGZhbHNlICk7XG4gICAgICAgIGdsQ2F0LnVuaWZvcm1UZXh0dXJlKCAnc2FtcGxlcjAnLCBwYXJhbXMuaW5wdXQsIDAgKTtcbiAgICAgICAgZ2wuZHJhd0FycmF5cyggZ2wuVFJJQU5HTEVfU1RSSVAsIDAsIDQgKTtcblxuICAgICAgICBnbC5iaW5kRnJhbWVidWZmZXIoIGdsLkZSQU1FQlVGRkVSLCBwYXJhbXMuZnJhbWVidWZmZXIgKTtcbiAgICAgICAgZ2xDYXQudW5pZm9ybTFpKCAnaXNWZXJ0JywgdHJ1ZSApO1xuICAgICAgICBnbENhdC51bmlmb3JtVGV4dHVyZSggJ3NhbXBsZXIwJywgcGF0aC50ZW1wRmIudGV4dHVyZSwgMCApO1xuICAgICAgICBnbC5kcmF3QXJyYXlzKCBnbC5UUklBTkdMRV9TVFJJUCwgMCwgNCApO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBqcGVnUmVuZGVyOiB7XG4gICAgICB3aWR0aDogd2lkdGgsXG4gICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgIHZlcnQ6IHJlcXVpcmUoICcuLi9zaGFkZXJzL3F1YWQudmVydCcgKSxcbiAgICAgIGZyYWc6IHJlcXVpcmUoICcuLi9zaGFkZXJzL2pwZWctcmVuZGVyLmZyYWcnICksXG4gICAgICBibGVuZDogWyBnbC5PTkUsIGdsLk9ORSBdLFxuICAgICAgY2xlYXI6IFsgMC4wLCAwLjAsIDAuMCwgMC4wIF0sXG4gICAgICBmcmFtZWJ1ZmZlcjogdHJ1ZSxcbiAgICAgIGZsb2F0OiB0cnVlLFxuICAgICAgdGVtcEZiOiBnbENhdC5jcmVhdGVGbG9hdEZyYW1lYnVmZmVyKCB3aWR0aCwgaGVpZ2h0ICksXG4gICAgICBmdW5jOiAoIHBhdGgsIHBhcmFtcyApID0+IHtcbiAgICAgICAgZ2xDYXQuYXR0cmlidXRlKCAncCcsIHZib1F1YWQsIDIgKTtcbiAgICAgICAgZ2xDYXQudW5pZm9ybTFpKCAnYmxvY2tTaXplJywgcGFyc2VJbnQoIDguMCArIDEyMC4wICogYXV0byggJ2pwZWctYmxvY2tTaXplJyApICkgKTtcblxuICAgICAgICBnbC5iaW5kRnJhbWVidWZmZXIoIGdsLkZSQU1FQlVGRkVSLCBwYXRoLnRlbXBGYi5mcmFtZWJ1ZmZlciApO1xuICAgICAgICBnbENhdC5jbGVhciggLi4ucGF0aC5jbGVhciApO1xuICAgICAgICBnbENhdC51bmlmb3JtMWkoICdpc1ZlcnQnLCBmYWxzZSApO1xuICAgICAgICBnbENhdC51bmlmb3JtVGV4dHVyZSggJ3NhbXBsZXIwJywgZ2xDYXRQYXRoLmZiKCAnanBlZ0Nvc2luZScgKS50ZXh0dXJlLCAwICk7XG4gICAgICAgIGdsLmRyYXdBcnJheXMoIGdsLlRSSUFOR0xFX1NUUklQLCAwLCA0ICk7XG5cbiAgICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKCBnbC5GUkFNRUJVRkZFUiwgcGFyYW1zLmZyYW1lYnVmZmVyICk7XG4gICAgICAgIGdsQ2F0LnVuaWZvcm0xaSggJ2lzVmVydCcsIHRydWUgKTtcbiAgICAgICAgZ2xDYXQudW5pZm9ybVRleHR1cmUoICdzYW1wbGVyMCcsIHBhdGgudGVtcEZiLnRleHR1cmUsIDAgKTtcbiAgICAgICAgZ2wuZHJhd0FycmF5cyggZ2wuVFJJQU5HTEVfU1RSSVAsIDAsIDQgKTtcbiAgICAgIH1cbiAgICB9LFxuICB9ICk7XG59OyIsImltcG9ydCBVbHRyYUNhdCBmcm9tICcuLi9saWJzL3VsdHJhY2F0JztcblxuLy8gLS0tLS0tXG5cbmV4cG9ydCBkZWZhdWx0ICggY29udGV4dCApID0+IHtcbiAgLy8gPT0gaGkgY29udGV4dCA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIGNvbnN0IGdsQ2F0UGF0aCA9IGNvbnRleHQuZ2xDYXRQYXRoO1xuICBjb25zdCBnbENhdCA9IGdsQ2F0UGF0aC5nbENhdDtcbiAgY29uc3QgZ2wgPSBnbENhdC5nbDtcblxuICBjb25zdCB3aWR0aCA9IGNvbnRleHQud2lkdGg7XG4gIGNvbnN0IGhlaWdodCA9IGNvbnRleHQuaGVpZ2h0O1xuXG4gIGNvbnN0IGF1dG8gPSBjb250ZXh0LmF1dG9tYXRvbi5hdXRvO1xuXG4gIC8vID09IGhpIHZibyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICBjb25zdCB2Ym9RdWFkID0gZ2xDYXQuY3JlYXRlVmVydGV4YnVmZmVyKCBuZXcgRmxvYXQzMkFycmF5KCBVbHRyYUNhdC50cmlhbmdsZVN0cmlwUXVhZCApICk7XG5cbiAgLy8gPT0gaGkgdGV4dHVyZSA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIGNvbnN0IHRleHR1cmVEaXZlcnNpdHkgPSBnbENhdC5jcmVhdGVUZXh0dXJlKCk7XG4gIHtcbiAgICBjb25zdCBpbWFnZSA9IG5ldyBJbWFnZSgpO1xuICAgIGltYWdlLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgIGdsQ2F0LnNldFRleHR1cmUoIHRleHR1cmVEaXZlcnNpdHksIGltYWdlICk7XG4gICAgfTtcbiAgICBpbWFnZS5zcmMgPSByZXF1aXJlKCAnLi4vaW1hZ2VzL2RpdmVyc2l0eS5wbmcnICk7XG4gIH1cblxuICAvLyA9PSBwYXRoIGRlZmluaXRpb24gYmVnaW4gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgZ2xDYXRQYXRoLmFkZCgge1xuICAgIG92ZXJsYXk6IHtcbiAgICAgIHZlcnQ6IHJlcXVpcmUoICcuLi9zaGFkZXJzL3F1YWQudmVydCcgKSxcbiAgICAgIGZyYWc6IHJlcXVpcmUoICcuLi9zaGFkZXJzL292ZXJsYXkuZnJhZycgKSxcbiAgICAgIGJsZW5kOiBbIGdsLlNSQ19BTFBIQSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSBdLFxuICAgICAgZnVuYzogKCBwYXRoLCBwYXJhbXMgKSA9PiB7XG4gICAgICAgIGdsQ2F0LmF0dHJpYnV0ZSggJ3AnLCB2Ym9RdWFkLCAyICk7XG4gICAgICAgIGdsQ2F0LnVuaWZvcm1UZXh0dXJlKCAnc2FtcGxlcjAnLCB0ZXh0dXJlRGl2ZXJzaXR5LCAwICk7XG4gICAgICAgIGdsLmRyYXdBcnJheXMoIGdsLlRSSUFOR0xFX1NUUklQLCAwLCA0ICk7XG4gICAgICB9XG4gICAgfVxuICB9ICk7XG5cbiAgbW9kdWxlLmhvdC5hY2NlcHQoXG4gICAgW1xuICAgICAgJy4uL3NoYWRlcnMvcXVhZC52ZXJ0JyxcbiAgICAgICcuLi9zaGFkZXJzL292ZXJsYXkuZnJhZydcbiAgICBdLFxuICAgICgpID0+IHtcbiAgICAgIGdsQ2F0UGF0aC5yZXBsYWNlUHJvZ3JhbShcbiAgICAgICAgJ292ZXJsYXknLFxuICAgICAgICByZXF1aXJlKCAnLi4vc2hhZGVycy9xdWFkLnZlcnQnICksXG4gICAgICAgIHJlcXVpcmUoICcuLi9zaGFkZXJzL292ZXJsYXkuZnJhZycgKVxuICAgICAgKTtcbiAgICB9XG4gICk7XG59OyIsIi8vID09IGxvYWQgc29tZSBtb2R1bGVzID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5pbXBvcnQgWG9yc2hpZnQgZnJvbSAnLi4vbGlicy94b3JzaGlmdCc7XG5pbXBvcnQgVWx0cmFDYXQgZnJvbSAnLi4vbGlicy91bHRyYWNhdCc7XG5cbi8vID09IHJvbGwgdGhlIGRpY2UgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5jb25zdCBzZWVkID0gMTU4ODIzNTY7XG5sZXQgeG9yc2hpZnQgPSBuZXcgWG9yc2hpZnQoIHNlZWQgKTtcblxuLy8gPT0gdmVyeSBiYXNpYyBjb25zdGFudHMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbmNvbnN0IHBwcCA9IDI7XG5jb25zdCBuUGFydGljbGVTcXJ0ID0gNTEyO1xuY29uc3QgblBhcnRpY2xlID0gblBhcnRpY2xlU3FydCAqIG5QYXJ0aWNsZVNxcnQ7XG5cbmNvbnN0IGphY29iaUl0ZXIgPSA1MDtcblxuY29uc3QgbW90aW9uRmllbGRWb3hlbFVuaXQgPSAwLjI7XG5jb25zdCBtb3Rpb25GaWVsZFJlc29sdXRpb25YWSA9IDI1NjtcbmNvbnN0IG1vdGlvbkZpZWxkUmVzb2x1dGlvbiA9IFsgbW90aW9uRmllbGRSZXNvbHV0aW9uWFkgKiA4LCBtb3Rpb25GaWVsZFJlc29sdXRpb25YWSAqIDggXTtcblxuZXhwb3J0IGRlZmF1bHQgKCBjb250ZXh0ICkgPT4ge1xuICAvLyA9PSBwcmVwYXJlIGNvbnRleHQgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgY29uc3QgZ2xDYXRQYXRoID0gY29udGV4dC5nbENhdFBhdGg7XG4gIGNvbnN0IGdsQ2F0ID0gZ2xDYXRQYXRoLmdsQ2F0O1xuICBjb25zdCBnbCA9IGdsQ2F0LmdsO1xuXG4gIGNvbnN0IGF1dG8gPSBjb250ZXh0LmF1dG9tYXRvbi5hdXRvO1xuXG4gIC8vID09IHByZXBhcmUgdmJvcyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICBjb25zdCB2Ym9RdWFkID0gZ2xDYXQuY3JlYXRlVmVydGV4YnVmZmVyKCBuZXcgRmxvYXQzMkFycmF5KCBVbHRyYUNhdC50cmlhbmdsZVN0cmlwUXVhZCApICk7XG5cbiAgY29uc3QgdmJvQ29tcHV0ZVVWID0gZ2xDYXQuY3JlYXRlVmVydGV4YnVmZmVyKCBuZXcgRmxvYXQzMkFycmF5KFxuICAgIFVsdHJhQ2F0Lm1hdHJpeDJkKCBuUGFydGljbGVTcXJ0LCBuUGFydGljbGVTcXJ0ICkubWFwKCAoIHYsIGkgKSA9PiAoXG4gICAgICBpICUgMiA9PT0gMFxuICAgICAgICA/ICggdiAqIHBwcCArIDAuNSApIC8gblBhcnRpY2xlU3FydCAvIHBwcFxuICAgICAgICA6ICggdiArIDAuNSApIC8gblBhcnRpY2xlU3FydFxuICAgICkgKVxuICApICk7XG5cbiAgY29uc3Qgb2N0ID0gcmVxdWlyZSggJy4uL2dlb21zL29jdGFoZWRyb24nICkoIHsgZGl2OiAxLjAgfSApO1xuXG4gIGNvbnN0IHZib09jdFBvcyA9IGdsQ2F0LmNyZWF0ZVZlcnRleGJ1ZmZlciggbmV3IEZsb2F0MzJBcnJheSggb2N0LnBvc2l0aW9uICkgKTtcbiAgY29uc3QgdmJvT2N0Tm9yID0gZ2xDYXQuY3JlYXRlVmVydGV4YnVmZmVyKCBuZXcgRmxvYXQzMkFycmF5KCBvY3Qubm9ybWFsICkgKTtcbiAgY29uc3QgaWJvT2N0ID0gZ2xDYXQuY3JlYXRlSW5kZXhidWZmZXIoIG5ldyBVaW50MTZBcnJheSggb2N0LmluZGV4ICkgKTtcblxuICAvLyA9PSBwcmVwYXJlIHJhbmRvbSB0ZXh0dXJlID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgY29uc3QgdGV4dHVyZVJhbmRvbVNpemUgPSAzMjtcbiAgY29uc3QgdGV4dHVyZVJhbmRvbVVwZGF0ZSA9ICggX3RleCApID0+IHtcbiAgICBnbENhdC5zZXRUZXh0dXJlRnJvbUFycmF5KCBfdGV4LCB0ZXh0dXJlUmFuZG9tU2l6ZSwgdGV4dHVyZVJhbmRvbVNpemUsICggKCkgPT4ge1xuICAgICAgbGV0IGxlbiA9IHRleHR1cmVSYW5kb21TaXplICogdGV4dHVyZVJhbmRvbVNpemUgKiA0O1xuICAgICAgbGV0IHJldCA9IG5ldyBVaW50OEFycmF5KCBsZW4gKTtcbiAgICAgIGZvciAoIGxldCBpID0gMDsgaSA8IGxlbjsgaSArKyApIHtcbiAgICAgICAgcmV0WyBpIF0gPSBNYXRoLmZsb29yKCB4b3JzaGlmdC5nZW4oKSAqIDI1Ni4wICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH0gKSgpICk7XG4gIH07XG5cbiAgY29uc3QgdGV4dHVyZVJhbmRvbVN0YXRpYyA9IGdsQ2F0LmNyZWF0ZVRleHR1cmUoKTtcbiAgZ2xDYXQudGV4dHVyZVdyYXAoIHRleHR1cmVSYW5kb21TdGF0aWMsIGdsLlJFUEVBVCApO1xuICB0ZXh0dXJlUmFuZG9tVXBkYXRlKCB0ZXh0dXJlUmFuZG9tU3RhdGljICk7XG5cbiAgY29uc3QgdGV4dHVyZVJhbmRvbSA9IGdsQ2F0LmNyZWF0ZVRleHR1cmUoKTtcbiAgZ2xDYXQudGV4dHVyZVdyYXAoIHRleHR1cmVSYW5kb20sIGdsLlJFUEVBVCApO1xuXG4gIC8vID09IFRvYnkgRm94IC0gRHVtbXkhID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICBjb25zdCB0ZXh0dXJlRHVtbXkgPSBnbENhdC5jcmVhdGVUZXh0dXJlKCk7XG4gIGdsQ2F0LnNldFRleHR1cmVGcm9tQXJyYXkoIHRleHR1cmVEdW1teSwgMSwgMSwgbmV3IFVpbnQ4QXJyYXkoIFsgMCwgMCwgMCwgMCBdICkgKTtcblxuICAvLyA9PSBsZXQncyBjcmVhdGUgcGF0aHMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgZ2xDYXRQYXRoLmFkZCgge1xuICAgIC8vID09IGZyYW1lYnVmZmVyIHN1Y2tzID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICBwYXJ0aWNsZXNDb21wdXRlUmV0dXJuOiB7XG4gICAgICB3aWR0aDogblBhcnRpY2xlU3FydCAqIHBwcCxcbiAgICAgIGhlaWdodDogblBhcnRpY2xlU3FydCxcbiAgICAgIHZlcnQ6IHJlcXVpcmUoICcuLi9zaGFkZXJzL3F1YWQudmVydCcgKSxcbiAgICAgIGZyYWc6IHJlcXVpcmUoICcuLi9zaGFkZXJzL3JldHVybi5mcmFnJyApLFxuICAgICAgYmxlbmQ6IFsgZ2wuT05FLCBnbC5aRVJPIF0sXG4gICAgICBjbGVhcjogWyAwLjAsIDAuMCwgMC4wLCAwLjAgXSxcbiAgICAgIGZyYW1lYnVmZmVyOiB0cnVlLFxuICAgICAgZmxvYXQ6IHRydWUsXG4gICAgICBmdW5jOiAoIHBhdGgsIHBhcmFtcyApID0+IHtcbiAgICAgICAgaWYgKCBjb250ZXh0LmF1dG9tYXRvbi50aW1lID09PSAwLjAgKSB7XG4gICAgICAgICAgeG9yc2hpZnQuc2V0KCBzZWVkICk7XG4gICAgICAgIH1cblxuICAgICAgICBnbENhdC5hdHRyaWJ1dGUoICdwJywgdmJvUXVhZCwgMiApO1xuICAgICAgICBnbENhdC51bmlmb3JtVGV4dHVyZSggJ3NhbXBsZXIwJywgZ2xDYXRQYXRoLmZiKCAncGFydGljbGVzQ29tcHV0ZScgKS50ZXh0dXJlLCAwICk7XG4gICAgICAgIGdsLmRyYXdBcnJheXMoIGdsLlRSSUFOR0xFX1NUUklQLCAwLCA0ICk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8vID09IGdlbmVyYXRlIG1vdGlvbiBmaWVsZCBieSBwYXJ0aWNsZXMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICBwYXJ0aWNsZXNNb3Rpb25SZWFkOiB7XG4gICAgICB3aWR0aDogbW90aW9uRmllbGRSZXNvbHV0aW9uWyAwIF0sXG4gICAgICBoZWlnaHQ6IG1vdGlvbkZpZWxkUmVzb2x1dGlvblsgMSBdLFxuICAgICAgdmVydDogcmVxdWlyZSggJy4uL3NoYWRlcnMvcGFydGljbGVzLW1vdGlvbi1yZWFkLnZlcnQnICksXG4gICAgICBmcmFnOiByZXF1aXJlKCAnLi4vc2hhZGVycy9wYXJ0aWNsZXMtbW90aW9uLXJlYWQuZnJhZycgKSxcbiAgICAgIGJsZW5kOiBbIGdsLk9ORSwgZ2wuT05FIF0sXG4gICAgICBjbGVhcjogWyAwLjAsIDAuMCwgMC4wLCAwLjAgXSxcbiAgICAgIGZyYW1lYnVmZmVyOiB0cnVlLFxuICAgICAgZmxvYXQ6IHRydWUsXG4gICAgICBmdW5jOiAoIHBhdGgsIHBhcmFtcyApID0+IHtcbiAgICAgICAgZ2xDYXQuYXR0cmlidXRlKCAnY29tcHV0ZVVWJywgdmJvQ29tcHV0ZVVWLCAyICk7XG5cbiAgICAgICAgZ2xDYXQudW5pZm9ybTJmdiggJ3Jlc29sdXRpb25QY29tcHV0ZScsIFsgblBhcnRpY2xlU3FydCAqIHBwcCwgblBhcnRpY2xlU3FydCBdICk7XG4gICAgICAgIGdsQ2F0LnVuaWZvcm0yZnYoICdyZXNvbHV0aW9uTW90aW9uJywgbW90aW9uRmllbGRSZXNvbHV0aW9uICk7XG4gICAgICAgIGdsQ2F0LnVuaWZvcm0yZnYoICdwbGFuZVJlc29sdXRpb24nLCBbIG1vdGlvbkZpZWxkUmVzb2x1dGlvblhZLCBtb3Rpb25GaWVsZFJlc29sdXRpb25YWSBdICk7XG4gICAgICAgIGdsQ2F0LnVuaWZvcm0xZiggJ3ZveGVsVW5pdCcsIG1vdGlvbkZpZWxkVm94ZWxVbml0ICk7XG5cbiAgICAgICAgZ2xDYXQudW5pZm9ybVRleHR1cmUoICdzYW1wbGVyUGNvbXB1dGUnLCBnbENhdFBhdGguZmIoICdwYXJ0aWNsZXNDb21wdXRlUmV0dXJuJyApLnRleHR1cmUsIDAgKTtcblxuICAgICAgICBnbC5kcmF3QXJyYXlzKCBnbC5QT0lOVFMsIDAsIG5QYXJ0aWNsZSApO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyA9PSBlbmZvcmNlID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgcGFydGljbGVzRW5mb3JjZToge1xuICAgICAgd2lkdGg6IG1vdGlvbkZpZWxkUmVzb2x1dGlvblsgMCBdLFxuICAgICAgaGVpZ2h0OiBtb3Rpb25GaWVsZFJlc29sdXRpb25bIDEgXSxcbiAgICAgIHZlcnQ6IHJlcXVpcmUoICcuLi9zaGFkZXJzL3F1YWQudmVydCcgKSxcbiAgICAgIGZyYWc6IHJlcXVpcmUoICcuLi9zaGFkZXJzL3BhcnRpY2xlcy1lbmZvcmNlLmZyYWcnICksXG4gICAgICBibGVuZDogWyBnbC5PTkUsIGdsLlpFUk8gXSxcbiAgICAgIGNsZWFyOiBbIDAuMCwgMC4wLCAwLjAsIDAuMCBdLFxuICAgICAgZnJhbWVidWZmZXI6IHRydWUsXG4gICAgICBmbG9hdDogdHJ1ZSxcbiAgICAgIGZ1bmM6ICggcGF0aCwgcGFyYW1zICkgPT4ge1xuICAgICAgICBnbENhdC5hdHRyaWJ1dGUoICdwJywgdmJvUXVhZCwgMiApO1xuXG4gICAgICAgIGdsQ2F0LnVuaWZvcm0yZnYoICdyZXNvbHV0aW9uTW90aW9uJywgbW90aW9uRmllbGRSZXNvbHV0aW9uICk7XG4gICAgICAgIGdsQ2F0LnVuaWZvcm0yZnYoICdwbGFuZVJlc29sdXRpb24nLCBbIG1vdGlvbkZpZWxkUmVzb2x1dGlvblhZLCBtb3Rpb25GaWVsZFJlc29sdXRpb25YWSBdICk7XG4gICAgICAgIGdsQ2F0LnVuaWZvcm0xZiggJ3ZveGVsVW5pdCcsIG1vdGlvbkZpZWxkVm94ZWxVbml0ICk7XG5cbiAgICAgICAgZ2xDYXQudW5pZm9ybVRleHR1cmUoICdzYW1wbGVyTW90aW9uJywgZ2xDYXRQYXRoLmZiKCAncGFydGljbGVzTW90aW9uUmVhZCcgKS50ZXh0dXJlLCAwICk7XG5cbiAgICAgICAgZ2wuZHJhd0FycmF5cyggZ2wuVFJJQU5HTEVfU1RSSVAsIDAsIDQgKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gPT0gZ2VuZXJhdGUgZGl2ZXJnZW5jZSBmaWVsZCBieSBtb3Rpb24gZmllbGQgPT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIHBhcnRpY2xlc0RpdmVyZ2VuY2U6IHtcbiAgICAgIHdpZHRoOiBtb3Rpb25GaWVsZFJlc29sdXRpb25bIDAgXSxcbiAgICAgIGhlaWdodDogbW90aW9uRmllbGRSZXNvbHV0aW9uWyAxIF0sXG4gICAgICB2ZXJ0OiByZXF1aXJlKCAnLi4vc2hhZGVycy9xdWFkLnZlcnQnICksXG4gICAgICBmcmFnOiByZXF1aXJlKCAnLi4vc2hhZGVycy9wYXJ0aWNsZXMtZGl2ZXJnZW5jZS5mcmFnJyApLFxuICAgICAgYmxlbmQ6IFsgZ2wuT05FLCBnbC5aRVJPIF0sXG4gICAgICBjbGVhcjogWyAwLjAsIDAuMCwgMC4wLCAwLjAgXSxcbiAgICAgIGZyYW1lYnVmZmVyOiB0cnVlLFxuICAgICAgZmxvYXQ6IHRydWUsXG4gICAgICBmdW5jOiAoIHBhdGgsIHBhcmFtcyApID0+IHtcbiAgICAgICAgZ2xDYXQuYXR0cmlidXRlKCAncCcsIHZib1F1YWQsIDIgKTtcblxuICAgICAgICBnbENhdC51bmlmb3JtMmZ2KCAncmVzb2x1dGlvbk1vdGlvbicsIG1vdGlvbkZpZWxkUmVzb2x1dGlvbiApO1xuICAgICAgICBnbENhdC51bmlmb3JtMmZ2KCAncGxhbmVSZXNvbHV0aW9uJywgWyBtb3Rpb25GaWVsZFJlc29sdXRpb25YWSwgbW90aW9uRmllbGRSZXNvbHV0aW9uWFkgXSApO1xuICAgICAgICBnbENhdC51bmlmb3JtMWYoICd2b3hlbFVuaXQnLCBtb3Rpb25GaWVsZFZveGVsVW5pdCApO1xuXG4gICAgICAgIGdsQ2F0LnVuaWZvcm1UZXh0dXJlKCAnc2FtcGxlck1vdGlvbicsIGdsQ2F0UGF0aC5mYiggJ3BhcnRpY2xlc0VuZm9yY2UnICkudGV4dHVyZSwgMCApO1xuXG4gICAgICAgIGdsLmRyYXdBcnJheXMoIGdsLlRSSUFOR0xFX1NUUklQLCAwLCA0ICk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8vID09IGxldCdzIGNhbGN1bGF0ZSBwcmVzc3VyZSA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICBwYXJ0aWNsZXNQcmVzc3VyZToge1xuICAgICAgd2lkdGg6IG1vdGlvbkZpZWxkUmVzb2x1dGlvblsgMCBdLFxuICAgICAgaGVpZ2h0OiBtb3Rpb25GaWVsZFJlc29sdXRpb25bIDEgXSxcbiAgICAgIHZlcnQ6IHJlcXVpcmUoICcuLi9zaGFkZXJzL3F1YWQudmVydCcgKSxcbiAgICAgIGZyYWc6IHJlcXVpcmUoICcuLi9zaGFkZXJzL3BhcnRpY2xlcy1wcmVzc3VyZS5mcmFnJyApLFxuICAgICAgYmxlbmQ6IFsgZ2wuT05FLCBnbC5aRVJPIF0sXG4gICAgICBjbGVhcjogWyAwLjAsIDAuMCwgMC4wLCAwLjAgXSxcbiAgICAgIGZyYW1lYnVmZmVyOiB0cnVlLFxuICAgICAgZmxvYXQ6IHRydWUsXG4gICAgICB0ZW1wRmI6IFtcbiAgICAgICAgZ2xDYXQuY3JlYXRlRnJhbWVidWZmZXIoIC4uLm1vdGlvbkZpZWxkUmVzb2x1dGlvbiApLFxuICAgICAgICBnbENhdC5jcmVhdGVGcmFtZWJ1ZmZlciggLi4ubW90aW9uRmllbGRSZXNvbHV0aW9uIClcbiAgICAgIF0sXG4gICAgICBmdW5jOiAoIHBhdGgsIHBhcmFtcyApID0+IHtcbiAgICAgICAgZ2xDYXQuYXR0cmlidXRlKCAncCcsIHZib1F1YWQsIDIgKTtcblxuICAgICAgICBnbENhdC51bmlmb3JtMmZ2KCAncmVzb2x1dGlvbk1vdGlvbicsIG1vdGlvbkZpZWxkUmVzb2x1dGlvbiApO1xuICAgICAgICBnbENhdC51bmlmb3JtMmZ2KCAncGxhbmVSZXNvbHV0aW9uJywgWyBtb3Rpb25GaWVsZFJlc29sdXRpb25YWSwgbW90aW9uRmllbGRSZXNvbHV0aW9uWFkgXSApO1xuICAgICAgICBnbENhdC51bmlmb3JtMWYoICd2b3hlbFVuaXQnLCBtb3Rpb25GaWVsZFZveGVsVW5pdCApO1xuXG4gICAgICAgIGZvciAoIGxldCBpID0gMDsgaSA8IGphY29iaUl0ZXI7IGkgKysgKSB7XG4gICAgICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKFxuICAgICAgICAgICAgZ2wuRlJBTUVCVUZGRVIsXG4gICAgICAgICAgICBpID09PSAoIGphY29iaUl0ZXIgLSAxICkgPyBwYXJhbXMuZnJhbWVidWZmZXIgOiBwYXRoLnRlbXBGYlsgaSAlIDIgXS5mcmFtZWJ1ZmZlclxuICAgICAgICAgICk7XG5cbiAgICAgICAgICBnbENhdC51bmlmb3JtVGV4dHVyZSggJ3NhbXBsZXJEaXZlcmdlbmNlJywgZ2xDYXRQYXRoLmZiKCAncGFydGljbGVzRGl2ZXJnZW5jZScgKS50ZXh0dXJlLCAwICk7XG4gICAgICAgICAgZ2xDYXQudW5pZm9ybVRleHR1cmUoXG4gICAgICAgICAgICAnc2FtcGxlclByZXNzdXJlJyxcbiAgICAgICAgICAgIHBhdGgudGVtcEZiWyAoIGkgKyAxICkgJSAyIF0udGV4dHVyZSxcbiAgICAgICAgICAgIDFcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgZ2wuZHJhd0FycmF5cyggZ2wuVFJJQU5HTEVfU1RSSVAsIDAsIDQgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyA9PSB3cml0ZSBiYWNrIHRoZSB2ZWxvY2l0eSA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgcGFydGljbGVzTW90aW9uV3JpdGU6IHtcbiAgICAgIHdpZHRoOiBtb3Rpb25GaWVsZFJlc29sdXRpb25bIDAgXSxcbiAgICAgIGhlaWdodDogbW90aW9uRmllbGRSZXNvbHV0aW9uWyAxIF0sXG4gICAgICB2ZXJ0OiByZXF1aXJlKCAnLi4vc2hhZGVycy9xdWFkLnZlcnQnICksXG4gICAgICBmcmFnOiByZXF1aXJlKCAnLi4vc2hhZGVycy9wYXJ0aWNsZXMtbW90aW9uLXdyaXRlLmZyYWcnICksXG4gICAgICBibGVuZDogWyBnbC5PTkUsIGdsLlpFUk8gXSxcbiAgICAgIGNsZWFyOiBbIDAuMCwgMC4wLCAwLjAsIDAuMCBdLFxuICAgICAgZnJhbWVidWZmZXI6IHRydWUsXG4gICAgICBmbG9hdDogdHJ1ZSxcbiAgICAgIGZ1bmM6ICggcGF0aCwgcGFyYW1zICkgPT4ge1xuICAgICAgICBnbENhdC5hdHRyaWJ1dGUoICdwJywgdmJvUXVhZCwgMiApO1xuXG4gICAgICAgIGdsQ2F0LnVuaWZvcm0yZnYoICdyZXNvbHV0aW9uTW90aW9uJywgbW90aW9uRmllbGRSZXNvbHV0aW9uICk7XG4gICAgICAgIGdsQ2F0LnVuaWZvcm0yZnYoICdwbGFuZVJlc29sdXRpb24nLCBbIG1vdGlvbkZpZWxkUmVzb2x1dGlvblhZLCBtb3Rpb25GaWVsZFJlc29sdXRpb25YWSBdICk7XG4gICAgICAgIGdsQ2F0LnVuaWZvcm0xZiggJ3ZveGVsVW5pdCcsIG1vdGlvbkZpZWxkVm94ZWxVbml0ICk7XG5cbiAgICAgICAgZ2xDYXQudW5pZm9ybVRleHR1cmUoICdzYW1wbGVyTW90aW9uJywgZ2xDYXRQYXRoLmZiKCAncGFydGljbGVzTW90aW9uUmVhZCcgKS50ZXh0dXJlLCAwICk7XG4gICAgICAgIGdsQ2F0LnVuaWZvcm1UZXh0dXJlKCAnc2FtcGxlclByZXNzdXJlJywgZ2xDYXRQYXRoLmZiKCAncGFydGljbGVzUHJlc3N1cmUnICkudGV4dHVyZSwgMSApO1xuXG4gICAgICAgIGdsLmRyYXdBcnJheXMoIGdsLlRSSUFOR0xFX1NUUklQLCAwLCA0ICk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8vID09IGNvbXB1dGUgcGFydGljbGVzID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICBwYXJ0aWNsZXNDb21wdXRlOiB7XG4gICAgICB3aWR0aDogblBhcnRpY2xlU3FydCAqIHBwcCxcbiAgICAgIGhlaWdodDogblBhcnRpY2xlU3FydCxcbiAgICAgIHZlcnQ6IHJlcXVpcmUoICcuLi9zaGFkZXJzL3F1YWQudmVydCcgKSxcbiAgICAgIGZyYWc6IHJlcXVpcmUoICcuLi9zaGFkZXJzL3BhcnRpY2xlcy1jb21wdXRlLmZyYWcnICksXG4gICAgICBibGVuZDogWyBnbC5PTkUsIGdsLlpFUk8gXSxcbiAgICAgIGNsZWFyOiBbIDAuMCwgMC4wLCAwLjAsIDAuMCBdLFxuICAgICAgZnJhbWVidWZmZXI6IHRydWUsXG4gICAgICBmbG9hdDogdHJ1ZSxcbiAgICAgIGZ1bmM6ICggcGF0aCwgcGFyYW1zICkgPT4ge1xuICAgICAgICB0ZXh0dXJlUmFuZG9tVXBkYXRlKCB0ZXh0dXJlUmFuZG9tICk7XG5cbiAgICAgICAgZ2xDYXQuYXR0cmlidXRlKCAncCcsIHZib1F1YWQsIDIgKTtcblxuICAgICAgICBnbENhdC51bmlmb3JtMWYoICduUGFydGljbGUnLCBuUGFydGljbGUgKTtcbiAgICAgICAgZ2xDYXQudW5pZm9ybTFmKCAnblBhcnRpY2xlU3FydCcsIG5QYXJ0aWNsZVNxcnQgKTtcbiAgICAgICAgZ2xDYXQudW5pZm9ybTFmKCAncHBwJywgcHBwICk7XG5cbiAgICAgICAgZ2xDYXQudW5pZm9ybTFpKCAnaXNJbml0RnJhbWUnLCBjb250ZXh0LmF1dG9tYXRvbi50aW1lID09PSAwLjAgPyB0cnVlIDogZmFsc2UgKTtcblxuICAgICAgICBnbENhdC51bmlmb3JtMmZ2KCAncmVzb2x1dGlvbk1vdGlvbicsIG1vdGlvbkZpZWxkUmVzb2x1dGlvbiApO1xuICAgICAgICBnbENhdC51bmlmb3JtMmZ2KCAncGxhbmVSZXNvbHV0aW9uJywgWyBtb3Rpb25GaWVsZFJlc29sdXRpb25YWSwgbW90aW9uRmllbGRSZXNvbHV0aW9uWFkgXSApO1xuICAgICAgICBnbENhdC51bmlmb3JtMWYoICd2b3hlbFVuaXQnLCBtb3Rpb25GaWVsZFZveGVsVW5pdCApO1xuXG4gICAgICAgIGdsQ2F0LnVuaWZvcm1UZXh0dXJlKCAnc2FtcGxlclBjb21wdXRlJywgZ2xDYXRQYXRoLmZiKCAncGFydGljbGVzQ29tcHV0ZVJldHVybicgKS50ZXh0dXJlLCAwICk7XG4gICAgICAgIGdsQ2F0LnVuaWZvcm1UZXh0dXJlKCAnc2FtcGxlclJhbmRvbScsIHRleHR1cmVSYW5kb20sIDEgKTtcbiAgICAgICAgZ2xDYXQudW5pZm9ybVRleHR1cmUoICdzYW1wbGVyUmFuZG9tU3RhdGljJywgdGV4dHVyZVJhbmRvbVN0YXRpYywgMiApO1xuICAgICAgICBnbENhdC51bmlmb3JtVGV4dHVyZSggJ3NhbXBsZXJNb3Rpb25Xcml0ZScsIGdsQ2F0UGF0aC5mYiggJ3BhcnRpY2xlc01vdGlvbldyaXRlJyApLnRleHR1cmUsIDMgKTtcblxuICAgICAgICBnbENhdC51bmlmb3JtMWYoICdub2lzZVBoYXNlJywgYXV0byggJ3BhcnRpY2xlcy1ub2lzZVBoYXNlJyApICk7XG4gICAgICAgIGdsQ2F0LnVuaWZvcm0xZiggJ2dlblJhdGUnLCBhdXRvKCAncGFydGljbGVzLWdlblJhdGUnICkgKTtcblxuICAgICAgICBnbC5kcmF3QXJyYXlzKCBnbC5UUklBTkdMRV9TVFJJUCwgMCwgNCApO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyA9PSByZW5kZXIgcGFydGljbGVzID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgcGFydGljbGVzUmVuZGVyOiB7XG4gICAgICB2ZXJ0OiByZXF1aXJlKCAnLi4vc2hhZGVycy9wYXJ0aWNsZXMtcmVuZGVyLnZlcnQnICksXG4gICAgICBmcmFnOiByZXF1aXJlKCAnLi4vc2hhZGVycy9wYXJ0aWNsZXMtcmVuZGVyLmZyYWcnICksXG4gICAgICBibGVuZDogWyBnbC5TUkNfQUxQSEEsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEgXSxcbiAgICAgIGRyYXdidWZmZXJzOiAyLFxuICAgICAgZnVuYzogKCBwYXRoLCBwYXJhbXMgKSA9PiB7XG4gICAgICAgIGdsQ2F0LmF0dHJpYnV0ZURpdmlzb3IoICdjb21wdXRlVVYnLCB2Ym9Db21wdXRlVVYsIDIsIDEgKTtcbiAgICAgICAgZ2xDYXQuYXR0cmlidXRlKCAnZ2VvbVBvcycsIHZib09jdFBvcywgMyApO1xuICAgICAgICBnbENhdC5hdHRyaWJ1dGUoICdnZW9tTm9yJywgdmJvT2N0Tm9yLCAzICk7XG5cbiAgICAgICAgZ2xDYXQudW5pZm9ybTFmKCAnblBhcnRpY2xlJywgblBhcnRpY2xlICk7XG4gICAgICAgIGdsQ2F0LnVuaWZvcm0xZiggJ25QYXJ0aWNsZVNxcnQnLCBuUGFydGljbGVTcXJ0ICk7XG4gICAgICAgIGdsQ2F0LnVuaWZvcm0xZiggJ3BwcCcsIHBwcCApO1xuXG4gICAgICAgIGdsQ2F0LnVuaWZvcm0yZnYoICdyZXNvbHV0aW9uUGNvbXB1dGUnLCBbIG5QYXJ0aWNsZVNxcnQgKiBwcHAsIG5QYXJ0aWNsZVNxcnQgXSApO1xuXG4gICAgICAgIGdsQ2F0LnVuaWZvcm0xaSggJ2lzU2hhZG93JywgcGFyYW1zLmlzU2hhZG93ID8gMSA6IDAgKTtcblxuICAgICAgICBnbENhdC51bmlmb3JtMWYoICdjb2xvclZhcicsIGF1dG8oICdwYXJ0aWNsZXMtY29sb3JWYXInICkgKTtcbiAgICAgICAgZ2xDYXQudW5pZm9ybTFmKCAnY29sb3JPZmZzZXQnLCBhdXRvKCAncGFydGljbGVzLWNvbG9yT2Zmc2V0JyApICk7XG5cbiAgICAgICAgZ2xDYXQudW5pZm9ybVRleHR1cmUoICdzYW1wbGVyUGNvbXB1dGUnLCBnbENhdFBhdGguZmIoICdwYXJ0aWNsZXNDb21wdXRlJyApLnRleHR1cmUsIDAgKTtcbiAgICAgICAgZ2xDYXQudW5pZm9ybVRleHR1cmUoICdzYW1wbGVyUmFuZG9tJywgdGV4dHVyZVJhbmRvbSwgMSApO1xuICAgICAgICBnbENhdC51bmlmb3JtVGV4dHVyZSggJ3NhbXBsZXJSYW5kb21TdGF0aWMnLCB0ZXh0dXJlUmFuZG9tU3RhdGljLCAyICk7XG4gICAgICAgIGdsQ2F0LnVuaWZvcm1UZXh0dXJlKCAnc2FtcGxlclNoYWRvdycsIHBhcmFtcy50ZXh0dXJlU2hhZG93IHx8IHRleHR1cmVEdW1teSwgMyApO1xuXG4gICAgICAgIGxldCBleHQgPSBnbENhdC5nZXRFeHRlbnNpb24oICdBTkdMRV9pbnN0YW5jZWRfYXJyYXlzJyApO1xuICAgICAgICBnbC5iaW5kQnVmZmVyKCBnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgaWJvT2N0ICk7XG4gICAgICAgIGV4dC5kcmF3RWxlbWVudHNJbnN0YW5jZWRBTkdMRSggZ2wuVFJJQU5HTEVTLCBvY3QuaW5kZXgubGVuZ3RoLCBnbC5VTlNJR05FRF9TSE9SVCwgMCwgblBhcnRpY2xlICk7XG4gICAgICAgIGdsLmJpbmRCdWZmZXIoIGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBudWxsICk7XG4gICAgICB9XG4gICAgfSxcbiAgfSApO1xuXG4gIGlmICggbW9kdWxlLmhvdCApIHtcbiAgICBtb2R1bGUuaG90LmFjY2VwdChcbiAgICAgIFtcbiAgICAgICAgJy4uL3NoYWRlcnMvcGFydGljbGVzLW1vdGlvbi1yZWFkLnZlcnQnLFxuICAgICAgICAnLi4vc2hhZGVycy9wYXJ0aWNsZXMtbW90aW9uLXJlYWQuZnJhZydcbiAgICAgIF0sXG4gICAgICAoKSA9PiB7XG4gICAgICAgIGdsQ2F0UGF0aC5yZXBsYWNlUHJvZ3JhbShcbiAgICAgICAgICAncGFydGljbGVzTW90aW9uUmVhZCcsXG4gICAgICAgICAgcmVxdWlyZSggJy4uL3NoYWRlcnMvcGFydGljbGVzLW1vdGlvbi1yZWFkLnZlcnQnICksXG4gICAgICAgICAgcmVxdWlyZSggJy4uL3NoYWRlcnMvcGFydGljbGVzLW1vdGlvbi1yZWFkLmZyYWcnIClcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICApO1xuXG4gICAgbW9kdWxlLmhvdC5hY2NlcHQoXG4gICAgICBbXG4gICAgICAgICcuLi9zaGFkZXJzL3F1YWQudmVydCcsXG4gICAgICAgICcuLi9zaGFkZXJzL3BhcnRpY2xlcy1lbmZvcmNlLmZyYWcnXG4gICAgICBdLFxuICAgICAgKCkgPT4ge1xuICAgICAgICBnbENhdFBhdGgucmVwbGFjZVByb2dyYW0oXG4gICAgICAgICAgJ3BhcnRpY2xlc0VuZm9yY2UnLFxuICAgICAgICAgIHJlcXVpcmUoICcuLi9zaGFkZXJzL3F1YWQudmVydCcgKSxcbiAgICAgICAgICByZXF1aXJlKCAnLi4vc2hhZGVycy9wYXJ0aWNsZXMtZW5mb3JjZS5mcmFnJyApXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgKTtcblxuICAgIG1vZHVsZS5ob3QuYWNjZXB0KFxuICAgICAgW1xuICAgICAgICAnLi4vc2hhZGVycy9xdWFkLnZlcnQnLFxuICAgICAgICAnLi4vc2hhZGVycy9wYXJ0aWNsZXMtZGl2ZXJnZW5jZS5mcmFnJ1xuICAgICAgXSxcbiAgICAgICgpID0+IHtcbiAgICAgICAgZ2xDYXRQYXRoLnJlcGxhY2VQcm9ncmFtKFxuICAgICAgICAgICdwYXJ0aWNsZXNEaXZlcmdlbmNlJyxcbiAgICAgICAgICByZXF1aXJlKCAnLi4vc2hhZGVycy9xdWFkLnZlcnQnICksXG4gICAgICAgICAgcmVxdWlyZSggJy4uL3NoYWRlcnMvcGFydGljbGVzLWRpdmVyZ2VuY2UuZnJhZycgKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICk7XG5cbiAgICBtb2R1bGUuaG90LmFjY2VwdChcbiAgICAgIFtcbiAgICAgICAgJy4uL3NoYWRlcnMvcXVhZC52ZXJ0JyxcbiAgICAgICAgJy4uL3NoYWRlcnMvcGFydGljbGVzLXByZXNzdXJlLmZyYWcnXG4gICAgICBdLFxuICAgICAgKCkgPT4ge1xuICAgICAgICBnbENhdFBhdGgucmVwbGFjZVByb2dyYW0oXG4gICAgICAgICAgJ3BhcnRpY2xlc1ByZXNzdXJlJyxcbiAgICAgICAgICByZXF1aXJlKCAnLi4vc2hhZGVycy9xdWFkLnZlcnQnICksXG4gICAgICAgICAgcmVxdWlyZSggJy4uL3NoYWRlcnMvcGFydGljbGVzLXByZXNzdXJlLmZyYWcnIClcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICApO1xuXG4gICAgbW9kdWxlLmhvdC5hY2NlcHQoXG4gICAgICBbXG4gICAgICAgICcuLi9zaGFkZXJzL3F1YWQudmVydCcsXG4gICAgICAgICcuLi9zaGFkZXJzL3BhcnRpY2xlcy1tb3Rpb24td3JpdGUuZnJhZydcbiAgICAgIF0sXG4gICAgICAoKSA9PiB7XG4gICAgICAgIGdsQ2F0UGF0aC5yZXBsYWNlUHJvZ3JhbShcbiAgICAgICAgICAncGFydGljbGVzTW90aW9uV3JpdGUnLFxuICAgICAgICAgIHJlcXVpcmUoICcuLi9zaGFkZXJzL3F1YWQudmVydCcgKSxcbiAgICAgICAgICByZXF1aXJlKCAnLi4vc2hhZGVycy9wYXJ0aWNsZXMtbW90aW9uLXdyaXRlLmZyYWcnIClcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICApO1xuXG4gICAgbW9kdWxlLmhvdC5hY2NlcHQoXG4gICAgICBbXG4gICAgICAgICcuLi9zaGFkZXJzL3F1YWQudmVydCcsXG4gICAgICAgICcuLi9zaGFkZXJzL3BhcnRpY2xlcy1jb21wdXRlLmZyYWcnXG4gICAgICBdLFxuICAgICAgKCkgPT4ge1xuICAgICAgICBnbENhdFBhdGgucmVwbGFjZVByb2dyYW0oXG4gICAgICAgICAgJ3BhcnRpY2xlc0NvbXB1dGUnLFxuICAgICAgICAgIHJlcXVpcmUoICcuLi9zaGFkZXJzL3F1YWQudmVydCcgKSxcbiAgICAgICAgICByZXF1aXJlKCAnLi4vc2hhZGVycy9wYXJ0aWNsZXMtY29tcHV0ZS5mcmFnJyApXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgKTtcblxuICAgIG1vZHVsZS5ob3QuYWNjZXB0KFxuICAgICAgW1xuICAgICAgICAnLi4vc2hhZGVycy9wYXJ0aWNsZXMtcmVuZGVyLnZlcnQnLFxuICAgICAgICAnLi4vc2hhZGVycy9wYXJ0aWNsZXMtcmVuZGVyLmZyYWcnXG4gICAgICBdLFxuICAgICAgKCkgPT4ge1xuICAgICAgICBnbENhdFBhdGgucmVwbGFjZVByb2dyYW0oXG4gICAgICAgICAgJ3BhcnRpY2xlc1JlbmRlcicsXG4gICAgICAgICAgcmVxdWlyZSggJy4uL3NoYWRlcnMvcGFydGljbGVzLXJlbmRlci52ZXJ0JyApLFxuICAgICAgICAgIHJlcXVpcmUoICcuLi9zaGFkZXJzL3BhcnRpY2xlcy1yZW5kZXIuZnJhZycgKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICk7XG4gIH1cbn07IiwiaW1wb3J0IFVsdHJhQ2F0IGZyb20gJy4uL2xpYnMvdWx0cmFjYXQnO1xuXG4vLyAtLS0tLS1cblxuZXhwb3J0IGRlZmF1bHQgKCBjb250ZXh0ICkgPT4ge1xuICBjb25zdCBnbENhdFBhdGggPSBjb250ZXh0LmdsQ2F0UGF0aDtcbiAgY29uc3QgZ2xDYXQgPSBnbENhdFBhdGguZ2xDYXQ7XG4gIGNvbnN0IGdsID0gZ2xDYXQuZ2w7XG5cbiAgY29uc3Qgd2lkdGggPSBjb250ZXh0LndpZHRoO1xuICBjb25zdCBoZWlnaHQgPSBjb250ZXh0LmhlaWdodDtcblxuICBjb25zdCBhdXRvID0gY29udGV4dC5hdXRvbWF0b24uYXV0bztcblxuICAvLyAtLS0tLS1cblxuICBjb25zdCB2Ym9RdWFkID0gZ2xDYXQuY3JlYXRlVmVydGV4YnVmZmVyKCBuZXcgRmxvYXQzMkFycmF5KCBVbHRyYUNhdC50cmlhbmdsZVN0cmlwUXVhZCApICk7XG5cbiAgLy8gLS0tLS0tXG5cbiAgZ2xDYXRQYXRoLmFkZCgge1xuICAgIHBvc3Q6IHtcbiAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgdmVydDogcmVxdWlyZSggJy4uL3NoYWRlcnMvcXVhZC52ZXJ0JyApLFxuICAgICAgZnJhZzogcmVxdWlyZSggJy4uL3NoYWRlcnMvcG9zdC5mcmFnJyApLFxuICAgICAgYmxlbmQ6IFsgZ2wuT05FLCBnbC5aRVJPIF0sXG4gICAgICBjbGVhcjogWyAwLjAsIDAuMCwgMC4wLCAwLjAgXSxcbiAgICAgIGZyYW1lYnVmZmVyOiB0cnVlLFxuICAgICAgZmxvYXQ6IHRydWUsXG4gICAgICBmdW5jOiAoIHBhdGgsIHBhcmFtcyApID0+IHtcbiAgICAgICAgZ2xDYXQuYXR0cmlidXRlKCAncCcsIHZib1F1YWQsIDIgKTtcbiAgICAgICAgZ2xDYXQudW5pZm9ybTFmKCAnYmFycmVsQW1wJywgYXV0byggJ3Bvc3QtYmFycmVsQW1wJyApICk7XG4gICAgICAgIGdsQ2F0LnVuaWZvcm0xZiggJ2JhcnJlbE9mZnNldCcsIGF1dG8oICdwb3N0LWJhcnJlbE9mZnNldCcgKSApO1xuICAgICAgICBnbENhdC51bmlmb3JtVGV4dHVyZSggJ3NhbXBsZXIwJywgcGFyYW1zLmlucHV0LCAwICk7XG4gICAgICAgIGdsLmRyYXdBcnJheXMoIGdsLlRSSUFOR0xFX1NUUklQLCAwLCA0ICk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGZ4YWE6IHtcbiAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgdmVydDogcmVxdWlyZSggJy4uL3NoYWRlcnMvcXVhZC52ZXJ0JyApLFxuICAgICAgZnJhZzogcmVxdWlyZSggJy4uL3NoYWRlcnMvZnhhYS5mcmFnJyApLFxuICAgICAgYmxlbmQ6IFsgZ2wuT05FLCBnbC5aRVJPIF0sXG4gICAgICBjbGVhcjogWyAwLjAsIDAuMCwgMC4wLCAwLjAgXSxcbiAgICAgIGZyYW1lYnVmZmVyOiB0cnVlLFxuICAgICAgZmxvYXQ6IHRydWUsXG4gICAgICBmdW5jOiAoIHBhdGgsIHBhcmFtcyApID0+IHtcbiAgICAgICAgZ2xDYXQuYXR0cmlidXRlKCAncCcsIHZib1F1YWQsIDIgKTtcbiAgICAgICAgZ2xDYXQudW5pZm9ybVRleHR1cmUoICdzYW1wbGVyMCcsIHBhcmFtcy5pbnB1dCwgMCApO1xuICAgICAgICBnbC5kcmF3QXJyYXlzKCBnbC5UUklBTkdMRV9TVFJJUCwgMCwgNCApO1xuICAgICAgfVxuICAgIH0sXG4gIH0gKTtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBcIiNleHRlbnNpb24gR0xfRVhUX2RyYXdfYnVmZmVycyA6IHJlcXVpcmVcXG5wcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuI2RlZmluZSBHTFNMSUZZIDFcXG5cXG51bmlmb3JtIHZlYzQgYmdDb2xvcjtcXG51bmlmb3JtIGZsb2F0IHBlcnNwRmFyO1xcblxcbi8vIC0tLS0tLVxcblxcbnZvaWQgbWFpbigpIHtcXG4gIGdsX0ZyYWdEYXRhWyAwIF0gPSBiZ0NvbG9yO1xcbiAgZ2xfRnJhZ0RhdGFbIDEgXSA9IHZlYzQoIHBlcnNwRmFyLCAwLjAsIDAuMCwgMS4wICk7XFxufVwiIiwibW9kdWxlLmV4cG9ydHMgPSBcIiNkZWZpbmUgc2F0dXJhdGUoaSkgY2xhbXAoaSwwLiwxLilcXG5cXG5wcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuI2RlZmluZSBHTFNMSUZZIDFcXG5cXG51bmlmb3JtIHZlYzIgcmVzb2x1dGlvbjtcXG51bmlmb3JtIHNhbXBsZXIyRCBzYW1wbGVyRHJ5O1xcbnVuaWZvcm0gc2FtcGxlcjJEIHNhbXBsZXJXZXQ7XFxuXFxudm9pZCBtYWluKCkge1xcbiAgdmVjMiB1diA9IGdsX0ZyYWdDb29yZC54eSAvIHJlc29sdXRpb247XFxuICB2ZWMzIGRyeSA9IHRleHR1cmUyRCggc2FtcGxlckRyeSwgdXYgKS54eXo7XFxuICB2ZWMzIHdldCA9IHRleHR1cmUyRCggc2FtcGxlcldldCwgdXYgKS54eXo7XFxuICBnbF9GcmFnQ29sb3IgPSB2ZWM0KCBtYXgoIHZlYzMoIDAuMCApLCBzYXR1cmF0ZSggZHJ5ICsgd2V0ICkgKSwgMS4wICk7XFxufVxcblwiIiwibW9kdWxlLmV4cG9ydHMgPSBcInByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4jZGVmaW5lIEdMU0xJRlkgMVxcblxcbnVuaWZvcm0gdmVjMiByZXNvbHV0aW9uO1xcbnVuaWZvcm0gdmVjMyBiaWFzO1xcbnVuaWZvcm0gdmVjMyBmYWN0b3I7XFxudW5pZm9ybSBzYW1wbGVyMkQgc2FtcGxlcjA7XFxuXFxudm9pZCBtYWluKCkge1xcbiAgdmVjMiB1diA9IGdsX0ZyYWdDb29yZC54eSAvIHJlc29sdXRpb247XFxuICB2ZWMyIGRlbHRhVGV4ZWwgPSAwLjI1IC8gcmVzb2x1dGlvbjtcXG4gIHZlYzIgdXZPcmlnaW4gPSAoIGZsb29yKCBnbF9GcmFnQ29vcmQueHkgKSArIGRlbHRhVGV4ZWwgKiAwLjUgKSAvIHJlc29sdXRpb247XFxuXFxuICB2ZWMzIHN1bSA9IHZlYzMoIDAuMCApO1xcbiAgZm9yICggaW50IGl5ID0gMDsgaXkgPCA0OyBpeSArKyApIHtcXG4gICAgZm9yICggaW50IGl4ID0gMDsgaXggPCA0OyBpeCArKyApIHtcXG4gICAgICB2ZWMyIHV2ID0gdXZPcmlnaW4gKyB2ZWMyKCBpeCwgaXkgKSAqIGRlbHRhVGV4ZWw7XFxuICAgICAgc3VtICs9IHRleHR1cmUyRCggc2FtcGxlcjAsIHV2ICkueHl6IC8gMTYuMDtcXG4gICAgfVxcbiAgfVxcblxcbiAgZ2xfRnJhZ0NvbG9yID0gdmVjNChcXG4gICAgbWF4KCB2ZWMzKCAwLjAgKSwgKCBzdW0gKyBiaWFzICkgKiBmYWN0b3IgKSxcXG4gICAgMS4wXFxuICApO1xcbn1cXG5cIiIsIm1vZHVsZS5leHBvcnRzID0gXCJwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuI2RlZmluZSBHTFNMSUZZIDFcXG5cXG52b2lkIG1haW4oKSB7XFxuICBnbF9GcmFnQ29sb3IgPSB2ZWM0KCB2ZWMzKCAwLjUgKSwgMS4wICk7XFxufVwiIiwibW9kdWxlLmV4cG9ydHMgPSBcIiNkZWZpbmUgR0xTTElGWSAxXFxuI2RlZmluZSBIVUdFIDlFMTZcXG4jZGVmaW5lIFBJIDMuMTQxNTkyNjVcXG4jZGVmaW5lIFYgdmVjMygwLiwxLiwtMS4pXFxuI2RlZmluZSBzYXR1cmF0ZShpKSBjbGFtcChpLDAuLDEuKVxcbiNkZWZpbmUgbG9maShpLG0pIChmbG9vcigoaSkvKG0pKSoobSkpXFxuXFxuLy8gLS0tLS0tXFxuXFxuYXR0cmlidXRlIHZlYzMgcG9zO1xcblxcbnVuaWZvcm0gdmVjMiByZXNvbHV0aW9uO1xcbnVuaWZvcm0gdmVjMyBjb2xvcjtcXG5cXG52YXJ5aW5nIHZlYzMgdlBvcztcXG5cXG51bmlmb3JtIGJvb2wgaXNTaGFkb3c7XFxuXFxudW5pZm9ybSBtYXQ0IG1hdFA7XFxudW5pZm9ybSBtYXQ0IG1hdFY7XFxudW5pZm9ybSBtYXQ0IG1hdFBMO1xcbnVuaWZvcm0gbWF0NCBtYXRWTDtcXG51bmlmb3JtIG1hdDQgbWF0TTtcXG5cXG4vLyAtLS0tLS1cXG5cXG52b2lkIG1haW4oKSB7XFxuICB2ZWM0IHBvcyA9IG1hdE0gKiB2ZWM0KCBwb3MsIDEuMCApO1xcbiAgdlBvcyA9IHBvcy54eXo7XFxuXFxuICB2ZWM0IG91dFBvcztcXG4gIGlmICggaXNTaGFkb3cgKSB7XFxuICAgIG91dFBvcyA9IG1hdFBMICogbWF0VkwgKiBwb3M7XFxuICB9IGVsc2Uge1xcbiAgICBvdXRQb3MgPSBtYXRQICogbWF0ViAqIHBvcztcXG4gICAgb3V0UG9zLnggLz0gcmVzb2x1dGlvbi54IC8gcmVzb2x1dGlvbi55O1xcbiAgfVxcbiAgZ2xfUG9zaXRpb24gPSBvdXRQb3M7XFxufVwiIiwibW9kdWxlLmV4cG9ydHMgPSBcIiNkZWZpbmUgUEkgMy4xNDE1OTI2NVxcbiNkZWZpbmUgViB2ZWMzKDAuLDEuLC0xLilcXG5cXG4jZGVmaW5lIEZYQUFfUkVEVUNFX01JTiAoMS4wIC8gMTI4LjApXFxuI2RlZmluZSBGWEFBX1JFRFVDRV9NVUwgKDEuMCAvIDguMClcXG4jZGVmaW5lIEZYQUFfU1BBTl9NQVggMTYuMFxcblxcbi8vIC0tLS0tLVxcblxcbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4jZGVmaW5lIEdMU0xJRlkgMVxcblxcbnVuaWZvcm0gdmVjMiByZXNvbHV0aW9uO1xcblxcbnVuaWZvcm0gc2FtcGxlcjJEIHRleHR1cmU7XFxuXFxuLy8gLS0tLS0tXFxuXFxudm9pZCBtYWluKCkge1xcbiAgdmVjMiB1diA9IGdsX0ZyYWdDb29yZC54eSAvIHJlc29sdXRpb247XFxuXFxuICAjZGVmaW5lIFQodikgdGV4dHVyZTJEKCB0ZXh0dXJlLCAodikgLyByZXNvbHV0aW9uICkueHl6XFxuICB2ZWMzIHJnYjExID0gVCggZ2xfRnJhZ0Nvb3JkLnh5ICk7XFxuICB2ZWMzIHJnYjAwID0gVCggZ2xfRnJhZ0Nvb3JkLnh5ICsgVi56eiApO1xcbiAgdmVjMyByZ2IwMiA9IFQoIGdsX0ZyYWdDb29yZC54eSArIFYuenkgKTtcXG4gIHZlYzMgcmdiMjAgPSBUKCBnbF9GcmFnQ29vcmQueHkgKyBWLnl6ICk7XFxuICB2ZWMzIHJnYjIyID0gVCggZ2xfRnJhZ0Nvb3JkLnh5ICsgVi55eSApO1xcbiAgI3VuZGVmIFRcXG5cXG4gIHZlYzMgbHVtYSA9IHZlYzMoIDAuMjk5LCAwLjU4NywgMC4xMTQgKTtcXG4gICNkZWZpbmUgTChjKSBkb3QoIGMsIGx1bWEgKVxcbiAgZmxvYXQgbHVtYTExID0gTCggcmdiMTEgKTtcXG4gIGZsb2F0IGx1bWEwMCA9IEwoIHJnYjAwICk7XFxuICBmbG9hdCBsdW1hMDIgPSBMKCByZ2IwMiApO1xcbiAgZmxvYXQgbHVtYTIwID0gTCggcmdiMjAgKTtcXG4gIGZsb2F0IGx1bWEyMiA9IEwoIHJnYjIyICk7XFxuICAjdW5kZWYgTFxcblxcbiAgZmxvYXQgbHVtYU1pbiA9IG1pbiggbHVtYTAwLCBtaW4oIG1pbiggbHVtYTAwLCBsdW1hMDIgKSwgbWluKCBsdW1hMjAsIGx1bWEyMiApICkgKTtcXG4gIGZsb2F0IGx1bWFNYXggPSBtYXgoIGx1bWEwMCwgbWF4KCBtYXgoIGx1bWEwMCwgbHVtYTAyICksIG1heCggbHVtYTIwLCBsdW1hMjIgKSApICk7XFxuXFxuICB2ZWMyIGRpciA9IHZlYzIoXFxuICAgIC0oICggbHVtYTAwICsgbHVtYTIwICkgLSAoIGx1bWEwMiArIGx1bWEyMiApICksXFxuICAgICggKCBsdW1hMDAgKyBsdW1hMDIgKSAtICggbHVtYTIwICsgbHVtYTIyICkgKVxcbiAgKTtcXG5cXG4gIGZsb2F0IGRpclJlZHVjZSA9IG1heChcXG4gICAgKCBsdW1hMDAgKyBsdW1hMDIgKyBsdW1hMjAgKyBsdW1hMjIgKSAqIDAuMjUgKiBGWEFBX1JFRFVDRV9NVUwsXFxuICAgIEZYQUFfUkVEVUNFX01JTlxcbiAgKTtcXG4gIGZsb2F0IHJjcERpck1pbiA9IDEuMCAvICggbWluKCBhYnMoIGRpci54ICksIGFicyggZGlyLnkgKSApICsgZGlyUmVkdWNlICk7XFxuICBkaXIgPSBtaW4oXFxuICAgIHZlYzIoIEZYQUFfU1BBTl9NQVggKSxcXG4gICAgbWF4KFxcbiAgICAgIHZlYzIoIC1GWEFBX1NQQU5fTUFYICksXFxuICAgICAgZGlyICogcmNwRGlyTWluXFxuICAgIClcXG4gICkgLyByZXNvbHV0aW9uO1xcblxcbiAgdmVjMyByZ2JBID0gMC41ICogKFxcbiAgICB0ZXh0dXJlMkQoIHRleHR1cmUsIHV2ICsgZGlyICogKCAxLjAgLyAzLjAgLSAwLjUgKSApLnh5eiArXFxuICAgIHRleHR1cmUyRCggdGV4dHVyZSwgdXYgKyBkaXIgKiAoIDIuMCAvIDMuMCAtIDAuNSApICkueHl6XFxuICApO1xcbiAgdmVjMyByZ2JCID0gcmdiQSAqIDAuNSArIDAuMjUgKiAoXFxuICAgIHRleHR1cmUyRCggdGV4dHVyZSwgdXYgLSBkaXIgKiAwLjUgKS54eXogK1xcbiAgICB0ZXh0dXJlMkQoIHRleHR1cmUsIHV2ICsgZGlyICogMC41ICkueHl6XFxuICApO1xcblxcbiAgZmxvYXQgbHVtYUIgPSBkb3QoIHJnYkIsIGx1bWEgKTtcXG4gIGdsX0ZyYWdDb2xvciA9IChcXG4gICAgKCAoIGx1bWFCIDwgbHVtYU1pbiApIHx8ICggbHVtYU1heCA8IGx1bWFCICkgKSA/XFxuICAgIHZlYzQoIHJnYkEsIDEuMCApIDpcXG4gICAgdmVjNCggcmdiQiwgMS4wIClcXG4gICk7XFxufVwiIiwibW9kdWxlLmV4cG9ydHMgPSBcIiNkZWZpbmUgc2F0dXJhdGUoaSkgY2xhbXAoaSwwLiwxLilcXG4jZGVmaW5lIFBJIDMuMTQxNTkyNjVcXG4jZGVmaW5lIFNBTVBMRVMgMjBcXG4jZGVmaW5lIE1VTF9USFIgMC4wMVxcblxcbi8vIC0tLS0tLVxcblxcbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4jZGVmaW5lIEdMU0xJRlkgMVxcblxcbnVuaWZvcm0gdmVjMiByZXNvbHV0aW9uO1xcbnVuaWZvcm0gYm9vbCBpc1ZlcnQ7XFxudW5pZm9ybSBzYW1wbGVyMkQgc2FtcGxlcjA7XFxuXFxudW5pZm9ybSBmbG9hdCB2YXI7XFxuXFxuZmxvYXQgZ2F1c3NpYW4oIGZsb2F0IF94LCBmbG9hdCBfdiApIHtcXG4gIHJldHVybiAxLjAgLyBzcXJ0KCAyLjAgKiBQSSAqIF92ICkgKiBleHAoIC0gX3ggKiBfeCAvIDIuMCAvIF92ICk7XFxufVxcblxcbnZvaWQgbWFpbigpIHtcXG4gIHZlYzIgdXYgPSBnbF9GcmFnQ29vcmQueHkgLyByZXNvbHV0aW9uO1xcblxcbiAgaWYgKCB2YXIgPD0gMC4wICkge1xcbiAgICBnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQoIHNhbXBsZXIwLCB1diApO1xcbiAgICByZXR1cm47XFxuICB9XFxuXFxuICB2ZWMyIGJ2ID0gKCBpc1ZlcnQgPyB2ZWMyKCAwLjAsIDEuMCApIDogdmVjMiggMS4wLCAwLjAgKSApIC8gcmVzb2x1dGlvbjtcXG5cXG4gIHZlYzMgc3VtID0gdmVjMyggMC4wICk7XFxuICBmb3IgKCBpbnQgaSA9IDA7IGkgPD0gU0FNUExFUzsgaSArKyApIHtcXG4gICAgZmxvYXQgbXVsID0gZ2F1c3NpYW4oIGFicyggZmxvYXQoIGkgKSApLCB2YXIgKTtcXG4gICAgaWYgKCBtdWwgPCBNVUxfVEhSICkgeyBicmVhazsgfVxcbiAgICBmb3IgKCBpbnQgaiA9IC0xOyBqIDwgMjsgaiArPSAyICkge1xcbiAgICAgIHZlYzIgdiA9IHNhdHVyYXRlKCB1diArIGJ2ICogZmxvYXQoIGkgKiBqICkgKTtcXG4gICAgICB2ZWMzIHRleCA9IHRleHR1cmUyRCggc2FtcGxlcjAsIHYgKS54eXo7XFxuICAgICAgc3VtICs9IHRleCAqIG11bDtcXG4gICAgICBpZiAoIGkgPT0gMCApIHsgYnJlYWs7IH1cXG4gICAgfVxcbiAgfVxcblxcbiAgZ2xfRnJhZ0NvbG9yID0gdmVjNCggc3VtLCAxLjAgKTtcXG59XFxuXCIiLCJtb2R1bGUuZXhwb3J0cyA9IFwiI2RlZmluZSBSQURJVVMgNDAuMFxcblxcbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4jZGVmaW5lIEdMU0xJRlkgMVxcblxcbnVuaWZvcm0gdmVjMiByZXNvbHV0aW9uO1xcbnVuaWZvcm0gdmVjMiBtb3VzZTtcXG51bmlmb3JtIHZlYzMgY2lyY2xlQ29sb3I7XFxudW5pZm9ybSBzYW1wbGVyMkQgc2FtcGxlcjA7XFxuXFxuYm9vbCBwcmludCggaW4gdmVjMiBfY29vcmQsIGZsb2F0IF9pbiApIHtcXG4gIHZlYzIgY29vcmQgPSBfY29vcmQ7XFxuXFxuICAvLyB2ZXJ0aWNhbCByZXN0cmljdGlvblxcbiAgaWYgKCBjb29yZC55IDw9IDAuMCB8fCA1LjAgPD0gY29vcmQueSApIHsgcmV0dXJuIGZhbHNlOyB9XFxuICBcXG4gIC8vIGRvdFxcbiAgaWYgKCAwLjAgPCBjb29yZC54ICYmIGNvb3JkLnggPCAyLjAgKSB7XFxuICAgIHJldHVybiBjb29yZC54IDwgMS4wICYmIGNvb3JkLnkgPCAxLjA7XFxuICB9XFxuXFxuICAvLyBwYWRkZWQgYnkgZG90XFxuICBpZiAoIDIuMCA8IGNvb3JkLnggKSB7IGNvb3JkLnggLT0gMi4wOyB9XFxuICBcXG4gIC8vIGRldGVybWluZSBkaWdpdFxcbiAgZmxvYXQgY2kgPSBmbG9vciggY29vcmQueCAvIDUuMCApICsgMS4wO1xcblxcbiAgLy8gdG9vIGxvdyAvIHRvbyBoaWdoXFxuICBpZiAoIDQuMCA8IGNpICkgeyByZXR1cm4gZmFsc2U7IH1cXG4gIGlmICggY2kgPCAtNC4wICkgeyByZXR1cm4gZmFsc2U7IH1cXG5cXG4gIC8vIHggb2YgY2hhclxcbiAgZmxvYXQgY2Z4ID0gZmxvb3IoIG1vZCggY29vcmQueCwgNS4wICkgKTtcXG5cXG4gIC8vIHdpZHRoIGlzIDRcXG4gIGlmICggNC4wID09IGNmeCApIHsgcmV0dXJuIGZhbHNlOyB9XFxuXFxuICAvLyB5IG9mIGNoYXJcXG4gIGZsb2F0IGNmeSA9IGZsb29yKCBjb29yZC55ICk7XFxuXFxuICAvLyBiaXQgb2YgY2hhclxcbiAgZmxvYXQgY2YgPSBjZnggKyA0LjAgKiBjZnk7XFxuXFxuICAvLyBkZXRlcm1pbmUgY2hhciAgXFxuICBmbG9hdCBudW0gPSAwLjA7XFxuICBpZiAoIDAuMCA8IGNpICkge1xcbiAgICBmbG9hdCBuID0gYWJzKCBfaW4gKTtcXG4gICAgZm9yICggaW50IGkgPSAwOyBpIDwgNjsgaSArKyApIHtcXG4gICAgICBpZiAoIGNpIDwgZmxvYXQoIGkgKSApIHsgYnJlYWs7IH1cXG4gICAgICBcXG4gICAgICBudW0gPSBtb2QoIGZsb29yKCBuICksIDEwLjAgKTtcXG4gICAgICBuIC09IG51bTtcXG4gICAgICBuICo9IDEwLjA7XFxuICAgIH1cXG4gIH0gZWxzZSB7XFxuICAgIGZsb2F0IG4gPSBhYnMoIF9pbiApO1xcbiAgICBmb3IgKCBpbnQgaSA9IDA7IGkgPCA2OyBpICsrICkge1xcbiAgICAgIGlmICggLWNpIDwgZmxvYXQoIGkgKSApIHsgYnJlYWs7IH1cXG4gICAgICBcXG4gICAgICBpZiAoIGNpICE9IDAuMCAmJiBuIDwgMS4wICkge1xcbiAgICAgICAgLy8gbWludXNcXG4gICAgICAgIHJldHVybiBmbG9hdCggaSApID09IC1jaSAmJiBfaW4gPCAwLjAgJiYgY2Z5ID09IDIuMCAmJiAwLjAgPCBjZng7XFxuICAgICAgfVxcbiAgICAgIG51bSA9IG1vZCggZmxvb3IoIG4gKSwgMTAuMCApO1xcbiAgICAgIG4gLT0gbnVtO1xcbiAgICAgIG4gLz0gMTAuMDtcXG4gICAgfVxcbiAgfVxcblxcbiAgYm9vbCBhO1xcbiAgYSA9IDEuMCA9PSBtb2QoIGZsb29yKCAoXFxuICAgIG51bSA9PSAwLjAgPyA0MzI1MzQuMCA6XFxuICAgIG51bSA9PSAxLjAgPyA0MTA2OTIuMCA6XFxuICAgIG51bSA9PSAyLjAgPyA0OTMwODcuMCA6XFxuICAgIG51bSA9PSAzLjAgPyA0OTMxOTEuMCA6XFxuICAgIG51bSA9PSA0LjAgPyA2MzA0MDguMCA6XFxuICAgIG51bSA9PSA1LjAgPyA5ODkwNjMuMCA6XFxuICAgIG51bSA9PSA2LjAgPyAzOTkyNTQuMCA6XFxuICAgIG51bSA9PSA3LjAgPyAxMDE2ODk4LjAgOlxcbiAgICBudW0gPT0gOC4wID8gNDMxNzY2LjAgOlxcbiAgICA0MzM3OTguMFxcbiAgKSAvIHBvdyggMi4wLCBjZiApICksIDIuMCApO1xcbiAgXFxuICByZXR1cm4gYSA/IHRydWUgOiBmYWxzZTtcXG59XFxuXFxudm9pZCBtYWluKCkge1xcbiAgdmVjMiB1diA9IGdsX0ZyYWdDb29yZC54eSAvIHJlc29sdXRpb247XFxuXFxuICB2ZWMyIG0gPSBmbG9vciggdmVjMiggMC4wLCByZXNvbHV0aW9uLnkgKSArIHZlYzIoIDEuMCwgLTEuMCApICogbW91c2UgKTtcXG4gIHZlYzIgY2VudGVyID0gZmxvb3IoIG0gKyB2ZWMyKCAxLjAsIDAuNyApICogUkFESVVTICk7XFxuICBmbG9hdCBjaXJjbGUgPSBsZW5ndGgoIGdsX0ZyYWdDb29yZC54eSAtIGNlbnRlciApIC0gUkFESVVTO1xcblxcbiAgdmVjNCBjb2wgPSB0ZXh0dXJlMkQoIHNhbXBsZXIwLCB1diApO1xcbiAgdmVjNCBtY29sID0gdGV4dHVyZTJEKCBzYW1wbGVyMCwgKCBtICsgMC41ICkgLyByZXNvbHV0aW9uICk7XFxuICB2ZWM0IGJjb2wgPSB2ZWM0KCBjaXJjbGVDb2xvciwgMS4wICk7XFxuXFxuICBjb2wgPSBtaXgoXFxuICAgIGNvbCxcXG4gICAgbWl4KFxcbiAgICAgIGJjb2wsXFxuICAgICAgbWNvbCxcXG4gICAgICBzbW9vdGhzdGVwKCAxLjAsIDAuMCwgY2lyY2xlICsgNS4wIClcXG4gICAgKSxcXG4gICAgc21vb3Roc3RlcCggMS4wLCAwLjAsIGNpcmNsZSApXFxuICApO1xcblxcbiAgaWYgKCBjaXJjbGUgPCAwLjAgKSB7XFxuICAgIGNvbCA9IHByaW50KCBnbF9GcmFnQ29vcmQueHkgLSBjZW50ZXIgLSB2ZWMyKCAwLjAsIDguMCApLCBtY29sLnggKSA/IGJjb2wgOiBjb2w7XFxuICAgIGNvbCA9IHByaW50KCBnbF9GcmFnQ29vcmQueHkgLSBjZW50ZXIgLSB2ZWMyKCAwLjAsIDAuMCApLCBtY29sLnkgKSA/IGJjb2wgOiBjb2w7XFxuICAgIGNvbCA9IHByaW50KCBnbF9GcmFnQ29vcmQueHkgLSBjZW50ZXIgLSB2ZWMyKCAwLjAsIC04LjAgKSwgbWNvbC56ICkgPyBiY29sIDogY29sO1xcbiAgICBjb2wgPSBwcmludCggZ2xfRnJhZ0Nvb3JkLnh5IC0gY2VudGVyIC0gdmVjMiggMC4wLCAtMTYuMCApLCBtY29sLncgKSA/IGJjb2wgOiBjb2w7XFxuICB9XFxuXFxuICBnbF9GcmFnQ29sb3IgPSBjb2w7XFxufVwiIiwibW9kdWxlLmV4cG9ydHMgPSBcIiNkZWZpbmUgbG9maShpLGopIGZsb29yKChpKS8oaikrLjUpKihqKVxcbiNkZWZpbmUgUEkgMy4xNDE1OTI2NVxcblxcbi8vIC0tLS0tLVxcblxcbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4jZGVmaW5lIEdMU0xJRlkgMVxcblxcbnVuaWZvcm0gdmVjMiByZXNvbHV0aW9uO1xcblxcbnVuaWZvcm0gYm9vbCBpc1ZlcnQ7XFxudW5pZm9ybSBpbnQgYmxvY2tTaXplO1xcbnVuaWZvcm0gc2FtcGxlcjJEIHNhbXBsZXIwO1xcblxcbnVuaWZvcm0gZmxvYXQgaGlnaEZyZXFNdWx0aXBsaWVyO1xcbnVuaWZvcm0gZmxvYXQgcXVhbnRpemU7XFxudW5pZm9ybSBmbG9hdCBxdWFudGl6ZUY7XFxuXFxuLy8gLS0tLS0tXFxuXFxudmVjMyByZ2IyeXV2KCB2ZWMzIHJnYiApIHtcXG4gIHJldHVybiB2ZWMzKFxcbiAgICAwLjI5OSAqIHJnYi54ICsgMC41ODcgKiByZ2IueSArIDAuMTE0ICogcmdiLnosXFxuICAgIC0wLjE0ODczNiAqIHJnYi54IC0gMC4zMzEyNjQgKiByZ2IueSArIDAuNSAqIHJnYi56LFxcbiAgICAwLjUgKiByZ2IueCAtIDAuNDE4Njg4ICogcmdiLnkgLSAwLjA4MTMxMiAqIHJnYi56XFxuICApO1xcbn1cXG5cXG52ZWMzIHJnYjJoc3YoIHZlYzMgcmdiICkge1xcbiAgZmxvYXQgaGkgPSBtYXgoIHJnYi54LCBtYXgoIHJnYi55LCByZ2IueiApICk7XFxuICBmbG9hdCBsbyA9IG1pbiggcmdiLngsIG1pbiggcmdiLnksIHJnYi56ICkgKTtcXG4gIGZsb2F0IGQgPSBoaSAtIGxvO1xcbiAgcmV0dXJuIHZlYzMoXFxuICAgIChcXG4gICAgICBkID09IDAuMCA/IDAuMCA6XFxuICAgICAgbG8gPT0gcmdiLnogPyAoIHJnYi55IC0gcmdiLnggKSAvIGQgKyAxLjAgOlxcbiAgICAgIGxvID09IHJnYi54ID8gKCByZ2IueiAtIHJnYi55ICkgLyBkICsgMy4wIDpcXG4gICAgICAgICAgICAgICAgICAgICggcmdiLnggLSByZ2IueiApIC8gZCArIDUuMFxcbiAgICApIC8gNi4wLCAvLyBoXFxuICAgIGQsIC8vIHNcXG4gICAgaGkgLy8gdlxcbiAgKTtcXG59XFxuXFxudm9pZCBtYWluKCkge1xcbiAgdmVjMiBidiA9ICggaXNWZXJ0ID8gdmVjMiggMC4wLCAxLjAgKSA6IHZlYzIoIDEuMCwgMC4wICkgKTtcXG4gIHZlYzIgYmxvY2sgPSBidiAqIGZsb2F0KCBibG9ja1NpemUgLSAxICkgKyB2ZWMyKCAxLjAgKTtcXG4gIHZlYzIgYmxvY2tPcmlnaW4gPSAwLjUgKyBmbG9vciggZ2xfRnJhZ0Nvb3JkLnh5IC8gYmxvY2sgKSAqIGJsb2NrO1xcbiAgaW50IGJzID0gaW50KCBtaW4oIGZsb2F0KCBibG9ja1NpemUgKSwgZG90KCBidiwgcmVzb2x1dGlvbiAtIGJsb2NrT3JpZ2luICsgMC41ICkgKSApO1xcblxcbiAgZmxvYXQgZnJlcSA9IGZsb29yKCBtb2QoIGRvdCggYnYsIGdsX0ZyYWdDb29yZC54eSApLCBmbG9hdCggYmxvY2tTaXplICkgKSApIC8gZmxvYXQoIGJzICkgKiBQSTtcXG4gIGZsb2F0IGZhY3RvciA9ICggZnJlcSA9PSAwLjAgPyAxLjAgOiAyLjAgKSAvIGZsb2F0KCBicyApO1xcblxcbiAgdmVjNCBzdW0gPSB2ZWM0KCAwLjAgKTtcXG4gIGZvciAoIGludCBpID0gMDsgaSA8IDEwMjQ7IGkgKysgKSB7XFxuICAgIGlmICggYnMgPD0gaSApIHsgYnJlYWs7IH1cXG5cXG4gICAgdmVjMiBkZWx0YSA9IGZsb2F0KCBpICkgKiBidjtcXG4gICAgZmxvYXQgd2F2ZSA9IGNvcyggKCBmbG9hdCggaSApICsgMC41ICkgKiBmcmVxICk7XFxuXFxuICAgIHZlYzIgdXYgPSAoIGJsb2NrT3JpZ2luICsgZGVsdGEgKSAvIHJlc29sdXRpb247XFxuICAgIHZlYzQgdmFsID0gdGV4dHVyZTJEKCBzYW1wbGVyMCwgdXYgKTtcXG4gICAgaWYgKCAhaXNWZXJ0ICkgeyB2YWwueHl6ID0gcmdiMnl1diggdmFsLnh5eiApOyB9XFxuICAgIHN1bSArPSB3YXZlICogZmFjdG9yICogdmFsO1xcbiAgfVxcblxcbiAgaWYgKCBpc1ZlcnQgKSB7XFxuICAgIGZsb2F0IGxlbiA9IGxlbmd0aCggZmxvb3IoIG1vZCggZ2xfRnJhZ0Nvb3JkLnh5LCBmbG9hdCggYmxvY2tTaXplICkgKSApICk7XFxuXFxuICAgIGZsb2F0IHEgPSBxdWFudGl6ZSArIHF1YW50aXplRiAqIGxlbjtcXG4gICAgc3VtLnggPSAwLjAgPCBxID8gbG9maSggc3VtLngsIHEgKSA6IHN1bS54O1xcbiAgICBzdW0ueSA9IDAuMCA8IHEgPyBsb2ZpKCBzdW0ueSwgcSApIDogc3VtLnk7XFxuICAgIHN1bS56ID0gMC4wIDwgcSA/IGxvZmkoIHN1bS56LCBxICkgOiBzdW0uejtcXG4gICAgc3VtLmEgPSAwLjAgPCBxID8gbG9maSggc3VtLmEsIHEgKSA6IHN1bS5hO1xcblxcbiAgICBzdW0gKj0gMS4wICsgbGVuICogaGlnaEZyZXFNdWx0aXBsaWVyO1xcbiAgfVxcblxcbiAgZ2xfRnJhZ0NvbG9yID0gc3VtO1xcbn1cIiIsIm1vZHVsZS5leHBvcnRzID0gXCIjZGVmaW5lIHNhdHVyYXRlKGkpIGNsYW1wKGksMC4sMS4pXFxuI2RlZmluZSBsb2ZpKGksaikgZmxvb3IoKGkpLyhqKSsuNSkqKGopXFxuI2RlZmluZSBQSSAzLjE0MTU5MjY1XFxuXFxucHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbiNkZWZpbmUgR0xTTElGWSAxXFxuXFxudW5pZm9ybSB2ZWMyIHJlc29sdXRpb247XFxuXFxudW5pZm9ybSBib29sIGlzVmVydDtcXG51bmlmb3JtIGludCBibG9ja1NpemU7XFxudW5pZm9ybSBzYW1wbGVyMkQgc2FtcGxlcjA7XFxuXFxuLy8gLS0tLS0tXFxuXFxuYm9vbCB2YWxpZHV2KCB2ZWMyIHYgKSB7IHJldHVybiAwLjAgPCB2LnggJiYgdi54IDwgMS4wICYmIDAuMCA8IHYueSAmJiB2LnkgPCAxLjA7IH1cXG5cXG52ZWMzIHl1djJyZ2IoIHZlYzMgeXV2ICkge1xcbiAgcmV0dXJuIHZlYzMoXFxuICAgIHl1di54ICsgMS40MDIgKiB5dXYueixcXG4gICAgeXV2LnggLSAwLjM0NDEzNiAqIHl1di55IC0gMC43MTQxMzYgKiB5dXYueixcXG4gICAgeXV2LnggKyAxLjc3MiAqIHl1di55XFxuICApO1xcbn1cXG5cXG52ZWMzIGhzdjJyZ2IoIHZlYzMgaHN2ICkge1xcbiAgZmxvYXQgaCA9IDYuMCAqIGhzdi54O1xcbiAgZmxvYXQgYyA9IGhzdi55O1xcbiAgZmxvYXQgeCA9IGMgKiAoIDEuMCAtIGFicyggbW9kKCBoLCAyLjAgKSAtIDEuMCApICk7XFxuICByZXR1cm4gc2F0dXJhdGUoIGhzdi56IC0gYyArIChcXG4gICAgaCA8IDEuMCA/IHZlYzMoIGMsIHgsIDAuMCApIDpcXG4gICAgaCA8IDIuMCA/IHZlYzMoIHgsIGMsIDAuMCApIDpcXG4gICAgaCA8IDMuMCA/IHZlYzMoIDAuMCwgYywgeCApIDpcXG4gICAgaCA8IDQuMCA/IHZlYzMoIDAuMCwgeCwgYyApIDpcXG4gICAgaCA8IDUuMCA/IHZlYzMoIHgsIDAuMCwgYyApIDpcXG4gICAgICAgICAgICAgIHZlYzMoIGMsIDAuMCwgeCApXFxuICApICk7XFxufVxcblxcbnZvaWQgbWFpbigpIHtcXG4gIHZlYzIgYnYgPSAoIGlzVmVydCA/IHZlYzIoIDAuMCwgMS4wICkgOiB2ZWMyKCAxLjAsIDAuMCApICk7XFxuICB2ZWMyIGJsb2NrID0gYnYgKiBmbG9hdCggYmxvY2tTaXplIC0gMSApICsgdmVjMiggMS4wICk7XFxuICB2ZWMyIGJsb2NrT3JpZ2luID0gMC41ICsgZmxvb3IoIGdsX0ZyYWdDb29yZC54eSAvIGJsb2NrICkgKiBibG9jaztcXG4gIGludCBicyA9IGludCggbWluKCBmbG9hdCggYmxvY2tTaXplICksIGRvdCggYnYsIHJlc29sdXRpb24gLSBibG9ja09yaWdpbiArIDAuNSApICkgKTtcXG5cXG4gIGZsb2F0IGRlbHRhID0gbW9kKCBkb3QoIGJ2LCBnbF9GcmFnQ29vcmQueHkgKSwgZmxvYXQoIGJsb2NrU2l6ZSApICk7XFxuICBcXG4gIHZlYzQgc3VtID0gdmVjNCggMC4wICk7XFxuICBmb3IgKCBpbnQgaSA9IDA7IGkgPCAxMDI0OyBpICsrICkge1xcbiAgICBpZiAoIGJzIDw9IGkgKSB7IGJyZWFrOyB9XFxuXFxuICAgIGZsb2F0IGZkZWx0YSA9IGZsb2F0KCBpICk7XFxuICAgIHZlYzQgdmFsID0gdGV4dHVyZTJEKCBzYW1wbGVyMCwgKCBibG9ja09yaWdpbiArIGJ2ICogZmRlbHRhICkgLyByZXNvbHV0aW9uICk7XFxuXFxuICAgIGZsb2F0IHdhdmUgPSBjb3MoIGRlbHRhICogZmRlbHRhIC8gZmxvYXQoIGJzICkgKiBQSSApO1xcbiAgICBzdW0gKz0gd2F2ZSAqIHZhbDtcXG4gIH1cXG5cXG4gIGlmICggaXNWZXJ0ICkge1xcbiAgICBzdW0ueHl6ID0geXV2MnJnYiggc3VtLnh5eiApO1xcbiAgfVxcblxcbiAgZ2xfRnJhZ0NvbG9yID0gc3VtO1xcbn1cIiIsIm1vZHVsZS5leHBvcnRzID0gXCIjZGVmaW5lIFBJIDMuMTQxNTkyNjVcXG4jZGVmaW5lIFRBVSA2LjI4MzE4NTMxXFxuI2RlZmluZSBsb2ZpKGksbSkgKGZsb29yKChpKS8obSkpKihtKSlcXG5cXG5wcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuI2RlZmluZSBHTFNMSUZZIDFcXG5cXG51bmlmb3JtIGZsb2F0IHRpbWU7XFxudW5pZm9ybSB2ZWMyIHJlc29sdXRpb247XFxudW5pZm9ybSBzYW1wbGVyMkQgc2FtcGxlcjA7XFxuXFxuZmxvYXQgZnJhY3RTaW4oIGZsb2F0IGkgKSB7XFxuICByZXR1cm4gZnJhY3QoIHNpbiggaSApICogMTg0Ni40MiApO1xcbn1cXG5cXG52b2lkIG1haW4oKSB7XFxuICB2ZWMyIHV2ID0gdmVjMiggMC4wLCAxLjAgKSArIHZlYzIoIDEuMCwgLTEuMCApICogZ2xfRnJhZ0Nvb3JkLnh5IC8gcmVzb2x1dGlvbjtcXG5cXG4gIGZsb2F0IGRlZm9ybSA9IDEuMCAtIDIuMCAqIGZyYWN0U2luKCBzaW4oIGxvZmkoIHRpbWUgKiBUQVUgKyA0MC4wICogKCB1di54ICsgdXYueSApLCAxLjAgKSApICk7XFxuICBkZWZvcm0gPSAwLjAwNSAqIHNpZ24oIGRlZm9ybSApICogcG93KCBhYnMoIGRlZm9ybSApLCAxMC4wICk7XFxuXFxuICB2ZWMzIGNvbCA9IHZlYzMoXFxuICAgIHRleHR1cmUyRCggc2FtcGxlcjAsIHV2ICsgZGVmb3JtICkueSxcXG4gICAgdGV4dHVyZTJEKCBzYW1wbGVyMCwgdXYgKyAyLjAgKiBkZWZvcm0gKS55LFxcbiAgICB0ZXh0dXJlMkQoIHNhbXBsZXIwLCB1diArIDMuMCAqIGRlZm9ybSApLnlcXG4gICk7XFxuICBmbG9hdCBib3JkZXIgPSBtYXgoXFxuICAgIHRleHR1cmUyRCggc2FtcGxlcjAsIHV2ICsgZGVmb3JtICkueCxcXG4gICAgbWF4KFxcbiAgICAgIHRleHR1cmUyRCggc2FtcGxlcjAsIHV2ICsgMi4wICogZGVmb3JtICkueCxcXG4gICAgICB0ZXh0dXJlMkQoIHNhbXBsZXIwLCB1diArIDMuMCAqIGRlZm9ybSApLnhcXG4gICAgKVxcbiAgKTtcXG5cXG4gIGdsX0ZyYWdDb2xvciA9IHZlYzQoIGNvbCwgY29sICsgMC41ICogYm9yZGVyICk7XFxufVwiIiwibW9kdWxlLmV4cG9ydHMgPSBcIiNkZWZpbmUgUEFSVElDTEVfTElGRV9MRU5HVEggMy4wXFxuXFxuI2RlZmluZSBIVUdFIDlFMTZcXG4jZGVmaW5lIFBJIDMuMTQxNTkyNjVcXG4jZGVmaW5lIFRBVSA2LjI4MzE4NTMwN1xcbiNkZWZpbmUgViB2ZWMzKDAuLDEuLC0xLilcXG4jZGVmaW5lIHNhdHVyYXRlKGkpIGNsYW1wKGksMC4sMS4pXFxuI2RlZmluZSBsb2ZpKGksbSkgKGZsb29yKChpKS8obSkpKihtKSlcXG4jZGVmaW5lIGxvZmlyKGksbSkgKGZsb29yKChpKS8obSkrLjUpKihtKSlcXG5cXG4vLyAtLS0tLS1cXG5cXG5wcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuI2RlZmluZSBHTFNMSUZZIDFcXG5cXG51bmlmb3JtIGZsb2F0IHRpbWU7XFxuXFxudW5pZm9ybSBmbG9hdCBuUGFydGljbGVTcXJ0O1xcbnVuaWZvcm0gZmxvYXQgblBhcnRpY2xlO1xcbnVuaWZvcm0gZmxvYXQgcHBwO1xcblxcbnVuaWZvcm0gZmxvYXQgdG90YWxGcmFtZTtcXG51bmlmb3JtIGJvb2wgaW5pdDtcXG51bmlmb3JtIGZsb2F0IGRlbHRhVGltZTtcXG51bmlmb3JtIHZlYzIgcmVzb2x1dGlvbjtcXG5cXG51bmlmb3JtIGJvb2wgaXNJbml0RnJhbWU7XFxuXFxudW5pZm9ybSB2ZWMyIHJlc29sdXRpb25Nb3Rpb247XFxudW5pZm9ybSB2ZWMyIHBsYW5lUmVzb2x1dGlvbjtcXG51bmlmb3JtIGZsb2F0IHZveGVsVW5pdDtcXG5cXG51bmlmb3JtIHNhbXBsZXIyRCBzYW1wbGVyUGNvbXB1dGU7XFxudW5pZm9ybSBzYW1wbGVyMkQgc2FtcGxlck1vdGlvbldyaXRlO1xcbnVuaWZvcm0gc2FtcGxlcjJEIHNhbXBsZXJSYW5kb207XFxuXFxudW5pZm9ybSBmbG9hdCBub2lzZVBoYXNlO1xcbnVuaWZvcm0gZmxvYXQgdmVsU2NhbGU7XFxudW5pZm9ybSBmbG9hdCBnZW5SYXRlO1xcblxcbi8vIC0tLS0tLVxcblxcbnZlYzIgdkludmVydCggdmVjMiBfdXYgKSB7XFxuICByZXR1cm4gdmVjMiggMC4wLCAxLjAgKSArIHZlYzIoIDEuMCwgLTEuMCApICogX3V2O1xcbn1cXG5cXG4vLyAtLS0tLS1cXG5cXG5tYXQyIHJvdGF0ZTJEKCBmbG9hdCBfdCApIHtcXG4gIHJldHVybiBtYXQyKCBjb3MoIF90ICksIHNpbiggX3QgKSwgLXNpbiggX3QgKSwgY29zKCBfdCApICk7XFxufVxcblxcbmZsb2F0IGZyYWN0U2luKCBmbG9hdCBpICkge1xcbiAgcmV0dXJuIGZyYWN0KCBzaW4oIGkgKSAqIDE4NDYuNDIgKTtcXG59XFxuXFxudmVjNCBzYW1wbGVSYW5kb20oIHZlYzIgX3V2ICkge1xcbiAgcmV0dXJuIHRleHR1cmUyRCggc2FtcGxlclJhbmRvbSwgX3V2ICk7XFxufVxcblxcbmZsb2F0IEdQVVJuZChpbm91dCB2ZWM0IG4pXFxue1xcblxcdC8vIEJhc2VkIG9uIHRoZSBwb3N0IGh0dHA6Ly9ncGdwdS5vcmcvZm9ydW1zL3ZpZXd0b3BpYy5waHA/dD0yNTkxJnNpZD0xNzA1MTQ4MWI5Zjc4ZmI0OWZiYTViOThhNWUwZjFmM1xcblxcdC8vIChUaGUgcGFnZSBubyBsb25nZXIgZXhpc3RzIGFzIG9mIE1hcmNoIDE3dGgsIDIwMTUuIFBsZWFzZSBsZXQgbWUga25vdyBpZiB5b3Ugc2VlIHdoeSB0aGlzIGNvZGUgd29ya3MuKVxcblxcdGNvbnN0IHZlYzQgcSA9IHZlYzQoICAgMTIyNS4wLCAgICAxNTg1LjAsICAgIDI0NTcuMCwgICAgMjA5OC4wKTtcXG5cXHRjb25zdCB2ZWM0IHIgPSB2ZWM0KCAgIDExMTIuMCwgICAgIDM2Ny4wLCAgICAgIDkyLjAsICAgICAyNjUuMCk7XFxuXFx0Y29uc3QgdmVjNCBhID0gdmVjNCggICAzNDIzLjAsICAgIDI2NDYuMCwgICAgMTcwNy4wLCAgICAxOTk5LjApO1xcblxcdGNvbnN0IHZlYzQgbSA9IHZlYzQoNDE5NDI4Ny4wLCA0MTk0Mjc3LjAsIDQxOTQxOTEuMCwgNDE5NDE2Ny4wKTtcXG5cXG5cXHR2ZWM0IGJldGEgPSBmbG9vcihuIC8gcSk7XFxuXFx0dmVjNCBwID0gYSAqIChuIC0gYmV0YSAqIHEpIC0gYmV0YSAqIHI7XFxuXFx0YmV0YSA9IChzaWduKC1wKSArIHZlYzQoMS4wKSkgKiB2ZWM0KDAuNSkgKiBtO1xcblxcdG4gPSAocCArIGJldGEpO1xcblxcblxcdHJldHVybiBmcmFjdChkb3QobiAvIG0sIHZlYzQoMS4wLCAtMS4wLCAxLjAsIC0xLjApKSk7XFxufVxcblxcbi8vXFxuLy8gRGVzY3JpcHRpb24gOiBBcnJheSBhbmQgdGV4dHVyZWxlc3MgR0xTTCAyRC8zRC80RCBzaW1wbGV4XFxuLy8gICAgICAgICAgICAgICBub2lzZSBmdW5jdGlvbnMuXFxuLy8gICAgICBBdXRob3IgOiBJYW4gTWNFd2FuLCBBc2hpbWEgQXJ0cy5cXG4vLyAgTWFpbnRhaW5lciA6IGlqbVxcbi8vICAgICBMYXN0bW9kIDogMjAxMTA4MjIgKGlqbSlcXG4vLyAgICAgTGljZW5zZSA6IENvcHlyaWdodCAoQykgMjAxMSBBc2hpbWEgQXJ0cy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cXG4vLyAgICAgICAgICAgICAgIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZS5cXG4vLyAgICAgICAgICAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9hc2hpbWEvd2ViZ2wtbm9pc2VcXG4vL1xcblxcbnZlYzQgbW9kMjg5KHZlYzQgeCkge1xcbiAgcmV0dXJuIHggLSBmbG9vcih4ICogKDEuMCAvIDI4OS4wKSkgKiAyODkuMDsgfVxcblxcbmZsb2F0IG1vZDI4OShmbG9hdCB4KSB7XFxuICByZXR1cm4geCAtIGZsb29yKHggKiAoMS4wIC8gMjg5LjApKSAqIDI4OS4wOyB9XFxuXFxudmVjNCBwZXJtdXRlKHZlYzQgeCkge1xcbiAgICAgcmV0dXJuIG1vZDI4OSgoKHgqMzQuMCkrMS4wKSp4KTtcXG59XFxuXFxuZmxvYXQgcGVybXV0ZShmbG9hdCB4KSB7XFxuICAgICByZXR1cm4gbW9kMjg5KCgoeCozNC4wKSsxLjApKngpO1xcbn1cXG5cXG52ZWM0IHRheWxvckludlNxcnQodmVjNCByKVxcbntcXG4gIHJldHVybiAxLjc5Mjg0MjkxNDAwMTU5IC0gMC44NTM3MzQ3MjA5NTMxNCAqIHI7XFxufVxcblxcbmZsb2F0IHRheWxvckludlNxcnQoZmxvYXQgcilcXG57XFxuICByZXR1cm4gMS43OTI4NDI5MTQwMDE1OSAtIDAuODUzNzM0NzIwOTUzMTQgKiByO1xcbn1cXG5cXG52ZWM0IGdyYWQ0KGZsb2F0IGosIHZlYzQgaXApXFxuICB7XFxuICBjb25zdCB2ZWM0IG9uZXMgPSB2ZWM0KDEuMCwgMS4wLCAxLjAsIC0xLjApO1xcbiAgdmVjNCBwLHM7XFxuXFxuICBwLnh5eiA9IGZsb29yKCBmcmFjdCAodmVjMyhqKSAqIGlwLnh5eikgKiA3LjApICogaXAueiAtIDEuMDtcXG4gIHAudyA9IDEuNSAtIGRvdChhYnMocC54eXopLCBvbmVzLnh5eik7XFxuICBzID0gdmVjNChsZXNzVGhhbihwLCB2ZWM0KDAuMCkpKTtcXG4gIHAueHl6ID0gcC54eXogKyAocy54eXoqMi4wIC0gMS4wKSAqIHMud3d3O1xcblxcbiAgcmV0dXJuIHA7XFxuICB9XFxuXFxuLy8gKHNxcnQoNSkgLSAxKS80ID0gRjQsIHVzZWQgb25jZSBiZWxvd1xcbiNkZWZpbmUgRjQgMC4zMDkwMTY5OTQzNzQ5NDc0NTFcXG5cXG5mbG9hdCBzbm9pc2UodmVjNCB2KVxcbiAge1xcbiAgY29uc3QgdmVjNCAgQyA9IHZlYzQoIDAuMTM4MTk2NjAxMTI1MDExLCAgLy8gKDUgLSBzcXJ0KDUpKS8yMCAgRzRcXG4gICAgICAgICAgICAgICAgICAgICAgICAwLjI3NjM5MzIwMjI1MDAyMSwgIC8vIDIgKiBHNFxcbiAgICAgICAgICAgICAgICAgICAgICAgIDAuNDE0NTg5ODAzMzc1MDMyLCAgLy8gMyAqIEc0XFxuICAgICAgICAgICAgICAgICAgICAgICAtMC40NDcyMTM1OTU0OTk5NTgpOyAvLyAtMSArIDQgKiBHNFxcblxcbi8vIEZpcnN0IGNvcm5lclxcbiAgdmVjNCBpICA9IGZsb29yKHYgKyBkb3QodiwgdmVjNChGNCkpICk7XFxuICB2ZWM0IHgwID0gdiAtICAgaSArIGRvdChpLCBDLnh4eHgpO1xcblxcbi8vIE90aGVyIGNvcm5lcnNcXG5cXG4vLyBSYW5rIHNvcnRpbmcgb3JpZ2luYWxseSBjb250cmlidXRlZCBieSBCaWxsIExpY2VhLUthbmUsIEFNRCAoZm9ybWVybHkgQVRJKVxcbiAgdmVjNCBpMDtcXG4gIHZlYzMgaXNYID0gc3RlcCggeDAueXp3LCB4MC54eHggKTtcXG4gIHZlYzMgaXNZWiA9IHN0ZXAoIHgwLnp3dywgeDAueXl6ICk7XFxuLy8gIGkwLnggPSBkb3QoIGlzWCwgdmVjMyggMS4wICkgKTtcXG4gIGkwLnggPSBpc1gueCArIGlzWC55ICsgaXNYLno7XFxuICBpMC55encgPSAxLjAgLSBpc1g7XFxuLy8gIGkwLnkgKz0gZG90KCBpc1laLnh5LCB2ZWMyKCAxLjAgKSApO1xcbiAgaTAueSArPSBpc1laLnggKyBpc1laLnk7XFxuICBpMC56dyArPSAxLjAgLSBpc1laLnh5O1xcbiAgaTAueiArPSBpc1laLno7XFxuICBpMC53ICs9IDEuMCAtIGlzWVouejtcXG5cXG4gIC8vIGkwIG5vdyBjb250YWlucyB0aGUgdW5pcXVlIHZhbHVlcyAwLDEsMiwzIGluIGVhY2ggY2hhbm5lbFxcbiAgdmVjNCBpMyA9IGNsYW1wKCBpMCwgMC4wLCAxLjAgKTtcXG4gIHZlYzQgaTIgPSBjbGFtcCggaTAtMS4wLCAwLjAsIDEuMCApO1xcbiAgdmVjNCBpMSA9IGNsYW1wKCBpMC0yLjAsIDAuMCwgMS4wICk7XFxuXFxuICAvLyAgeDAgPSB4MCAtIDAuMCArIDAuMCAqIEMueHh4eFxcbiAgLy8gIHgxID0geDAgLSBpMSAgKyAxLjAgKiBDLnh4eHhcXG4gIC8vICB4MiA9IHgwIC0gaTIgICsgMi4wICogQy54eHh4XFxuICAvLyAgeDMgPSB4MCAtIGkzICArIDMuMCAqIEMueHh4eFxcbiAgLy8gIHg0ID0geDAgLSAxLjAgKyA0LjAgKiBDLnh4eHhcXG4gIHZlYzQgeDEgPSB4MCAtIGkxICsgQy54eHh4O1xcbiAgdmVjNCB4MiA9IHgwIC0gaTIgKyBDLnl5eXk7XFxuICB2ZWM0IHgzID0geDAgLSBpMyArIEMuenp6ejtcXG4gIHZlYzQgeDQgPSB4MCArIEMud3d3dztcXG5cXG4vLyBQZXJtdXRhdGlvbnNcXG4gIGkgPSBtb2QyODkoaSk7XFxuICBmbG9hdCBqMCA9IHBlcm11dGUoIHBlcm11dGUoIHBlcm11dGUoIHBlcm11dGUoaS53KSArIGkueikgKyBpLnkpICsgaS54KTtcXG4gIHZlYzQgajEgPSBwZXJtdXRlKCBwZXJtdXRlKCBwZXJtdXRlKCBwZXJtdXRlIChcXG4gICAgICAgICAgICAgaS53ICsgdmVjNChpMS53LCBpMi53LCBpMy53LCAxLjAgKSlcXG4gICAgICAgICAgICsgaS56ICsgdmVjNChpMS56LCBpMi56LCBpMy56LCAxLjAgKSlcXG4gICAgICAgICAgICsgaS55ICsgdmVjNChpMS55LCBpMi55LCBpMy55LCAxLjAgKSlcXG4gICAgICAgICAgICsgaS54ICsgdmVjNChpMS54LCBpMi54LCBpMy54LCAxLjAgKSk7XFxuXFxuLy8gR3JhZGllbnRzOiA3eDd4NiBwb2ludHMgb3ZlciBhIGN1YmUsIG1hcHBlZCBvbnRvIGEgNC1jcm9zcyBwb2x5dG9wZVxcbi8vIDcqNyo2ID0gMjk0LCB3aGljaCBpcyBjbG9zZSB0byB0aGUgcmluZyBzaXplIDE3KjE3ID0gMjg5LlxcbiAgdmVjNCBpcCA9IHZlYzQoMS4wLzI5NC4wLCAxLjAvNDkuMCwgMS4wLzcuMCwgMC4wKSA7XFxuXFxuICB2ZWM0IHAwID0gZ3JhZDQoajAsICAgaXApO1xcbiAgdmVjNCBwMSA9IGdyYWQ0KGoxLngsIGlwKTtcXG4gIHZlYzQgcDIgPSBncmFkNChqMS55LCBpcCk7XFxuICB2ZWM0IHAzID0gZ3JhZDQoajEueiwgaXApO1xcbiAgdmVjNCBwNCA9IGdyYWQ0KGoxLncsIGlwKTtcXG5cXG4vLyBOb3JtYWxpc2UgZ3JhZGllbnRzXFxuICB2ZWM0IG5vcm0gPSB0YXlsb3JJbnZTcXJ0KHZlYzQoZG90KHAwLHAwKSwgZG90KHAxLHAxKSwgZG90KHAyLCBwMiksIGRvdChwMyxwMykpKTtcXG4gIHAwICo9IG5vcm0ueDtcXG4gIHAxICo9IG5vcm0ueTtcXG4gIHAyICo9IG5vcm0uejtcXG4gIHAzICo9IG5vcm0udztcXG4gIHA0ICo9IHRheWxvckludlNxcnQoZG90KHA0LHA0KSk7XFxuXFxuLy8gTWl4IGNvbnRyaWJ1dGlvbnMgZnJvbSB0aGUgZml2ZSBjb3JuZXJzXFxuICB2ZWMzIG0wID0gbWF4KDAuNiAtIHZlYzMoZG90KHgwLHgwKSwgZG90KHgxLHgxKSwgZG90KHgyLHgyKSksIDAuMCk7XFxuICB2ZWMyIG0xID0gbWF4KDAuNiAtIHZlYzIoZG90KHgzLHgzKSwgZG90KHg0LHg0KSAgICAgICAgICAgICksIDAuMCk7XFxuICBtMCA9IG0wICogbTA7XFxuICBtMSA9IG0xICogbTE7XFxuICByZXR1cm4gNDkuMCAqICggZG90KG0wKm0wLCB2ZWMzKCBkb3QoIHAwLCB4MCApLCBkb3QoIHAxLCB4MSApLCBkb3QoIHAyLCB4MiApKSlcXG4gICAgICAgICAgICAgICArIGRvdChtMSptMSwgdmVjMiggZG90KCBwMywgeDMgKSwgZG90KCBwNCwgeDQgKSApICkgKSA7XFxuXFxuICB9XFxuXFxudmVjMyByYW5kb21TcGhlcmUoIGlub3V0IHZlYzQgc2VlZCApIHtcXG4gIHZlYzMgdjtcXG4gIGZvciAoIGludCBpID0gMDsgaSA8IDEwOyBpICsrICkge1xcbiAgICB2ID0gdmVjMyhcXG4gICAgICBHUFVSbmQoIHNlZWQgKSxcXG4gICAgICBHUFVSbmQoIHNlZWQgKSxcXG4gICAgICBHUFVSbmQoIHNlZWQgKVxcbiAgICApICogMi4wIC0gMS4wO1xcbiAgICBpZiAoIGxlbmd0aCggdiApIDwgMS4wICkgeyBicmVhazsgfVxcbiAgfVxcbiAgcmV0dXJuIHY7XFxufVxcblxcbnZlYzIgcmFuZG9tQ2lyY2xlKCBpbm91dCB2ZWM0IHNlZWQgKSB7XFxuICB2ZWMyIHY7XFxuICBmb3IgKCBpbnQgaSA9IDA7IGkgPCAxMDsgaSArKyApIHtcXG4gICAgdiA9IHZlYzIoXFxuICAgICAgR1BVUm5kKCBzZWVkICksXFxuICAgICAgR1BVUm5kKCBzZWVkIClcXG4gICAgKSAqIDIuMCAtIDEuMDtcXG4gICAgaWYgKCBsZW5ndGgoIHYgKSA8IDEuMCApIHsgYnJlYWs7IH1cXG4gIH1cXG4gIHJldHVybiB2O1xcbn1cXG5cXG52ZWMzIHJhbmRvbUJveCggaW5vdXQgdmVjNCBzZWVkICkge1xcbiAgdmVjMyB2O1xcbiAgdiA9IHZlYzMoXFxuICAgIEdQVVJuZCggc2VlZCApLFxcbiAgICBHUFVSbmQoIHNlZWQgKSxcXG4gICAgR1BVUm5kKCBzZWVkIClcXG4gICkgKiAyLjAgLSAxLjA7XFxuICByZXR1cm4gdjtcXG59XFxuXFxuLy8gPT0gZGVhbCB3aXRoIG1vdGlvbiBmaWVsZCA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXG52ZWMyIG1vdGlvbkNvb3JkKCB2ZWMzIF92ICkge1xcbiAgdmVjMyB2ID0gZmxvb3IoIF92IC8gdm94ZWxVbml0ICkgKyAwLjU7XFxuICB2ZWMyIHBsYW5lU2l6ZSA9IHBsYW5lUmVzb2x1dGlvbiAvIHJlc29sdXRpb25Nb3Rpb247XFxuXFxuICAvLyA9PSB3aGVyZSBhcmUgdGhlIHBsYW5lIG9yaWdpbj8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXG4gIGZsb2F0IHpSYW5nZSA9IGZsb29yKCAxLjAgLyBwbGFuZVNpemUueCApICogZmxvb3IoIDEuMCAvIHBsYW5lU2l6ZS55ICkgLyAyLjA7XFxuICBpZiAoIHYueiA8IC16UmFuZ2UgfHwgelJhbmdlIDwgdi56ICkge1xcbiAgICByZXR1cm4gdmVjMiggMC4wLCAwLjAgKTtcXG4gIH1cXG4gIGZsb2F0IHBsYW5lSW5kZXggPSBmbG9vciggdi56ICsgelJhbmdlICk7XFxuICB2ZWMyIHBsYW5lT3JpZ2luID0gdmVjMiggZnJhY3QoIHBsYW5lSW5kZXggKiBwbGFuZVNpemUueCApLCBmbG9vciggcGxhbmVJbmRleCAqIHBsYW5lU2l6ZS54ICkgKiBwbGFuZVNpemUueSApO1xcblxcbiAgLy8gPT0gcGxhY2UgYSBkb3Qgb24gdGhlIHBsYW5lID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxuICB2ZWMyIHh5UmFuZ2UgPSBwbGFuZVJlc29sdXRpb24gLyAyLjA7XFxuICBpZiAoIHYueCA8IC14eVJhbmdlLnggfHwgeHlSYW5nZS54IDwgdi54IHx8IHYueSA8IC14eVJhbmdlLnkgfHwgeHlSYW5nZS55IDwgdi55ICkge1xcbiAgICByZXR1cm4gdmVjMiggMC4wLCAwLjAgKTtcXG4gIH1cXG4gIHJldHVybiBwbGFuZU9yaWdpbiArICggdi54eSArIHh5UmFuZ2UgKSAvIHBsYW5lUmVzb2x1dGlvbiAqIHBsYW5lU2l6ZTtcXG59XFxuXFxuLy8gLS0tLS0tXFxuXFxudm9pZCBtYWluKCkge1xcbiAgdmVjMiB1diA9IGdsX0ZyYWdDb29yZC54eSAvIHJlc29sdXRpb247XFxuICB2ZWMyIHB1diA9IHZlYzIoICggZmxvb3IoIGdsX0ZyYWdDb29yZC54IC8gcHBwICkgKiBwcHAgKyAwLjUgKSAvIHJlc29sdXRpb24ueCwgdXYueSApO1xcbiAgZmxvYXQgbW9kZSA9IG1vZCggZ2xfRnJhZ0Nvb3JkLngsIHBwcCApO1xcbiAgdmVjMiBkcGl4ID0gdmVjMiggMS4wICkgLyByZXNvbHV0aW9uO1xcblxcbiAgZmxvYXQgZHQgPSBkZWx0YVRpbWU7XFxuXFxuICAvLyA9PSBwcmVwYXJlIHNvbWUgdmFycyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXG4gIHZlYzQgc2VlZCA9IHRleHR1cmUyRCggc2FtcGxlclJhbmRvbSwgcHV2ICk7XFxuICBHUFVSbmQoIHNlZWQgKTtcXG5cXG4gIHZlYzQgcG9zID0gdGV4dHVyZTJEKCBzYW1wbGVyUGNvbXB1dGUsIHB1diApO1xcbiAgdmVjNCB2ZWwgPSB0ZXh0dXJlMkQoIHNhbXBsZXJQY29tcHV0ZSwgcHV2ICsgZHBpeCAqIHZlYzIoIDEuMCwgMC4wICkgKTtcXG5cXG4gIGZsb2F0IHRpbWluZyA9IG1peCggMC4wLCBQQVJUSUNMRV9MSUZFX0xFTkdUSCwgZmxvb3IoIHB1di55ICogblBhcnRpY2xlU3FydCApIC8gblBhcnRpY2xlU3FydCApO1xcbiAgdGltaW5nICs9IGxvZmkoIHRpbWUsIFBBUlRJQ0xFX0xJRkVfTEVOR1RIICk7XFxuXFxuICBpZiAoIHRpbWUgLSBkZWx0YVRpbWUgKyBQQVJUSUNMRV9MSUZFX0xFTkdUSCA8IHRpbWluZyApIHtcXG4gICAgdGltaW5nIC09IFBBUlRJQ0xFX0xJRkVfTEVOR1RIO1xcbiAgfVxcblxcbiAgLy8gPT0gaW5pdGlhbGl6ZSBwYXJ0aWNsZXMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxuICBpZiAoIGlzSW5pdEZyYW1lICkge1xcbiAgICBwb3MudyA9IDAuMDtcXG4gIH1cXG5cXG4gIC8vID09IGdlbmVyYXRlIHBhcnRpY2xlcyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcbiAgaWYgKFxcbiAgICB0aW1lIC0gZGVsdGFUaW1lIDwgdGltaW5nICYmIHRpbWluZyA8PSB0aW1lICYmXFxuICAgIEdQVVJuZCggc2VlZCApIDwgZ2VuUmF0ZVxcbiAgKSB7XFxuICAgIGR0ID0gdGltZSAtIHRpbWluZztcXG5cXG4gICAgcG9zLnh5eiA9IDAuMyAqIHJhbmRvbVNwaGVyZSggc2VlZCApO1xcbiAgICBwb3MueSArPSAxLjA7XFxuXFxuICAgIHZlbC54eXogPSAyLjAgKiByYW5kb21TcGhlcmUoIHNlZWQgKTtcXG4gICAgdmVsLnkgPSA0LjA7XFxuICAgIHZlbC53ID0gMC4wO1xcblxcbiAgICBwb3MudyA9IDEuMDsgLy8gbGlmZVxcbiAgfSBlbHNlIHtcXG4gICAgLy8gPT0gdXBkYXRlIHBhcnRpY2xlcyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxuICAgIHtcXG4gICAgICB2ZWMzIG1vdGlvbiA9IHRleHR1cmUyRCggc2FtcGxlck1vdGlvbldyaXRlLCBtb3Rpb25Db29yZCggcG9zLnh5eiApICkueHl6O1xcbiAgICAgIHZlYzMgdG1wID0gcG9zLnh5eiArIGR0ICogMC41ICogKCB2ZWwueHl6ICsgbW90aW9uICk7XFxuICAgICAgbW90aW9uID0gdGV4dHVyZTJEKCBzYW1wbGVyTW90aW9uV3JpdGUsIG1vdGlvbkNvb3JkKCB0bXAgKSApLnh5ejtcXG4gICAgICB2ZWwueHl6ICs9IG1vdGlvbjtcXG4gICAgfVxcblxcbiAgICBmb3IgKCBpbnQgaSA9IDA7IGkgPCAzOyBpICsrICkge1xcbiAgICAgIGlmICggMi4wIDwgYWJzKCBwb3NbIGkgXSApICkge1xcbiAgICAgICAgZmxvYXQgcyA9IHNpZ24oIHBvc1sgaSBdICk7XFxuICAgICAgICBpZiAoIGkgPT0gMSAmJiBzID09IDEuMCApIHsgY29udGludWU7IH1cXG4gICAgICAgIHBvc1sgaSBdID0gcyAqIDIuMDtcXG4gICAgICAgIHZlbFsgaSBdICo9IDAuMDtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgdmVsLnp4IC09IGR0ICogMTAuMCAqIHZlYzIoIC0xLjAsIDEuMCApICogbm9ybWFsaXplKCBwb3MueHogKTtcXG4gICAgdmVsLnh5eiArPSBkdCAqIDIuMCAqIHZlYzMoXFxuICAgICAgLXNub2lzZSggdmVjNCggMC44ICogcG9zLnh5eiwgMS40ODUgKyBub2lzZVBoYXNlICkgKSxcXG4gICAgICBzbm9pc2UoIHZlYzQoIDAuOCAqIHBvcy54eXosIDMuNDg1ICsgbm9pc2VQaGFzZSApICksXFxuICAgICAgLXNub2lzZSggdmVjNCggMC44ICogcG9zLnh5eiwgNS40ODUgKyBub2lzZVBoYXNlICkgKVxcbiAgICApO1xcbiAgICB2ZWwueSAtPSBkdCAqIDIwLjg7XFxuXFxuICAgIHBvcy54eXogKz0gdmVsLnh5eiAqIGR0O1xcbiAgICBwb3MueHl6ICs9IDAuMDEgKiBkdCAqICggdmVjMyhcXG4gICAgICBHUFVSbmQoIHNlZWQgKSxcXG4gICAgICBHUFVSbmQoIHNlZWQgKSxcXG4gICAgICBHUFVSbmQoIHNlZWQgKVxcbiAgICApIC0gMC41ICk7XFxuICAgIHBvcy53IC09IGR0IC8gUEFSVElDTEVfTElGRV9MRU5HVEg7XFxuICB9XFxuXFxuICBnbF9GcmFnQ29sb3IgPSAoXFxuICAgIG1vZGUgPCAxLjAgPyBwb3MgOlxcbiAgICB2ZWxcXG4gICk7XFxufVwiIiwibW9kdWxlLmV4cG9ydHMgPSBcInByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4jZGVmaW5lIEdMU0xJRlkgMVxcblxcbi8vID09IHZhcmlhYmxlcyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxudW5pZm9ybSB2ZWMyIHJlc29sdXRpb25Nb3Rpb247XFxudW5pZm9ybSB2ZWMyIHBsYW5lUmVzb2x1dGlvbjtcXG51bmlmb3JtIGZsb2F0IHZveGVsVW5pdDtcXG5cXG51bmlmb3JtIHNhbXBsZXIyRCBzYW1wbGVyTW90aW9uO1xcblxcbi8vID09IGRlYWwgd2l0aCBtb3Rpb24gZmllbGQgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxudmVjMiBtb3Rpb25Db29yZCggdmVjMyBfdiApIHtcXG4gIHZlYzMgdiA9IGZsb29yKCBfdiAvIHZveGVsVW5pdCApICsgMC41O1xcbiAgdmVjMiBwbGFuZVNpemUgPSBwbGFuZVJlc29sdXRpb24gLyByZXNvbHV0aW9uTW90aW9uO1xcblxcbiAgLy8gPT0gd2hlcmUgYXJlIHRoZSBwbGFuZSBvcmlnaW4/ID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxuICBmbG9hdCB6UmFuZ2UgPSBmbG9vciggMS4wIC8gcGxhbmVTaXplLnggKSAqIGZsb29yKCAxLjAgLyBwbGFuZVNpemUueSApIC8gMi4wO1xcbiAgaWYgKCB2LnogPCAtelJhbmdlIHx8IHpSYW5nZSA8IHYueiApIHtcXG4gICAgcmV0dXJuIHZlYzIoIDAuMCwgMC4wICk7XFxuICB9XFxuICBmbG9hdCBwbGFuZUluZGV4ID0gZmxvb3IoIHYueiArIHpSYW5nZSApO1xcbiAgdmVjMiBwbGFuZU9yaWdpbiA9IHZlYzIoIGZyYWN0KCBwbGFuZUluZGV4ICogcGxhbmVTaXplLnggKSwgZmxvb3IoIHBsYW5lSW5kZXggKiBwbGFuZVNpemUueCApICogcGxhbmVTaXplLnkgKTtcXG5cXG4gIC8vID09IHBsYWNlIGEgZG90IG9uIHRoZSBwbGFuZSA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcbiAgdmVjMiB4eVJhbmdlID0gcGxhbmVSZXNvbHV0aW9uIC8gMi4wO1xcbiAgaWYgKCB2LnggPCAteHlSYW5nZS54IHx8IHh5UmFuZ2UueCA8IHYueCB8fCB2LnkgPCAteHlSYW5nZS55IHx8IHh5UmFuZ2UueSA8IHYueSApIHtcXG4gICAgcmV0dXJuIHZlYzIoIDAuMCwgMC4wICk7XFxuICB9XFxuICByZXR1cm4gcGxhbmVPcmlnaW4gKyAoIHYueHkgKyB4eVJhbmdlICkgLyBwbGFuZVJlc29sdXRpb24gKiBwbGFuZVNpemU7XFxufVxcblxcbnZlYzMgbW90aW9uQ29vcmRJbnYoIHZlYzIgX2Nvb3JkICkge1xcbiAgdmVjMiBwbGFuZVNpemUgPSBwbGFuZVJlc29sdXRpb24gLyByZXNvbHV0aW9uTW90aW9uO1xcbiAgdmVjMyByZXQgPSB2ZWMzKCAwLjAgKTtcXG5cXG4gIC8vID09IHggYW5kIHkgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcbiAgcmV0Lnh5ID0gKCAoIGZyYWN0KCBfY29vcmQgLyBwbGFuZVNpemUgKSAtIDAuNSApICogcGxhbmVSZXNvbHV0aW9uICkgKiB2b3hlbFVuaXQ7XFxuXFxuICAvLyA9PSB6ID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXG4gIGZsb2F0IHpSYW5nZSA9IGZsb29yKCAxLjAgLyBwbGFuZVNpemUueCApICogZmxvb3IoIDEuMCAvIHBsYW5lU2l6ZS55ICkgLyAyLjA7XFxuICB2ZWMyIHBsYW5lUGxhY2UgPSBmbG9vciggX2Nvb3JkIC8gcGxhbmVTaXplICk7XFxuICByZXQueiA9ICggcGxhbmVQbGFjZS54ICsgZmxvb3IoIHBsYW5lUGxhY2UueSAvIHBsYW5lU2l6ZS54ICkgLSB6UmFuZ2UgKyAwLjUgKSAqIHZveGVsVW5pdDtcXG5cXG4gIHJldHVybiByZXQ7XFxufVxcblxcbi8vID09IG1haW4gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxudm9pZCBtYWluKCkge1xcbiAgdmVjMiB1diA9IGdsX0ZyYWdDb29yZC54eSAvIHJlc29sdXRpb25Nb3Rpb247XFxuICB2ZWMzIHYgPSBtb3Rpb25Db29yZEludiggdXYgKTtcXG5cXG4gIHZlYzIgZCA9IHZlYzIoIDAuMCwgdm94ZWxVbml0ICk7XFxuXFxuICB2ZWM0IGNlbnRlciA9IHRleHR1cmUyRCggc2FtcGxlck1vdGlvbiwgdXYgKTtcXG4gIGZsb2F0IHhtID0gdGV4dHVyZTJEKCBzYW1wbGVyTW90aW9uLCBtb3Rpb25Db29yZCggdiAtIGQueXh4ICkgKS54O1xcbiAgZmxvYXQgeHAgPSB0ZXh0dXJlMkQoIHNhbXBsZXJNb3Rpb24sIG1vdGlvbkNvb3JkKCB2ICsgZC55eHggKSApLng7XFxuICBmbG9hdCB5bSA9IHRleHR1cmUyRCggc2FtcGxlck1vdGlvbiwgbW90aW9uQ29vcmQoIHYgLSBkLnh5eCApICkueTtcXG4gIGZsb2F0IHlwID0gdGV4dHVyZTJEKCBzYW1wbGVyTW90aW9uLCBtb3Rpb25Db29yZCggdiArIGQueHl4ICkgKS55O1xcbiAgZmxvYXQgem0gPSB0ZXh0dXJlMkQoIHNhbXBsZXJNb3Rpb24sIG1vdGlvbkNvb3JkKCB2IC0gZC54eHkgKSApLno7XFxuICBmbG9hdCB6cCA9IHRleHR1cmUyRCggc2FtcGxlck1vdGlvbiwgbW90aW9uQ29vcmQoIHYgKyBkLnh4eSApICkuejtcXG5cXG4gIGZsb2F0IGRpdmVyZ2VuY2UgPSB4cCAtIHhtICsgeXAgLSB5bSArIHpwIC0gem07XFxuICBkaXZlcmdlbmNlIC09IGV4cCggKCBjZW50ZXIudyAvIDEwMDAuMCAtIDIwLjAgKSApO1xcblxcbiAgZ2xfRnJhZ0NvbG9yID0gdmVjNCggZGl2ZXJnZW5jZSwgMC4wLCAwLjAsIGNlbnRlci53ICk7XFxufVwiIiwibW9kdWxlLmV4cG9ydHMgPSBcInByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4jZGVmaW5lIEdMU0xJRlkgMVxcblxcbi8vID09IHZhcmlhYmxlcyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxudW5pZm9ybSB2ZWMyIHJlc29sdXRpb25Nb3Rpb247XFxudW5pZm9ybSB2ZWMyIHBsYW5lUmVzb2x1dGlvbjtcXG51bmlmb3JtIGZsb2F0IHZveGVsVW5pdDtcXG5cXG51bmlmb3JtIGZsb2F0IGRlbHRhVGltZTtcXG51bmlmb3JtIHNhbXBsZXIyRCBzYW1wbGVyTW90aW9uO1xcblxcbi8vID09IGRlYWwgd2l0aCBtb3Rpb24gZmllbGQgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxudmVjMiBtb3Rpb25Db29yZCggdmVjMyBfdiApIHtcXG4gIHZlYzMgdiA9IGZsb29yKCBfdiAvIHZveGVsVW5pdCApICsgMC41O1xcbiAgdmVjMiBwbGFuZVNpemUgPSBwbGFuZVJlc29sdXRpb24gLyByZXNvbHV0aW9uTW90aW9uO1xcblxcbiAgLy8gPT0gd2hlcmUgYXJlIHRoZSBwbGFuZSBvcmlnaW4/ID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxuICBmbG9hdCB6UmFuZ2UgPSBmbG9vciggMS4wIC8gcGxhbmVTaXplLnggKSAqIGZsb29yKCAxLjAgLyBwbGFuZVNpemUueSApIC8gMi4wO1xcbiAgaWYgKCB2LnogPCAtelJhbmdlIHx8IHpSYW5nZSA8IHYueiApIHtcXG4gICAgcmV0dXJuIHZlYzIoIDAuMCwgMC4wICk7XFxuICB9XFxuICBmbG9hdCBwbGFuZUluZGV4ID0gZmxvb3IoIHYueiArIHpSYW5nZSApO1xcbiAgdmVjMiBwbGFuZU9yaWdpbiA9IHZlYzIoIGZyYWN0KCBwbGFuZUluZGV4ICogcGxhbmVTaXplLnggKSwgZmxvb3IoIHBsYW5lSW5kZXggKiBwbGFuZVNpemUueCApICogcGxhbmVTaXplLnkgKTtcXG5cXG4gIC8vID09IHBsYWNlIGEgZG90IG9uIHRoZSBwbGFuZSA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcbiAgdmVjMiB4eVJhbmdlID0gcGxhbmVSZXNvbHV0aW9uIC8gMi4wO1xcbiAgaWYgKCB2LnggPCAteHlSYW5nZS54IHx8IHh5UmFuZ2UueCA8IHYueCB8fCB2LnkgPCAteHlSYW5nZS55IHx8IHh5UmFuZ2UueSA8IHYueSApIHtcXG4gICAgcmV0dXJuIHZlYzIoIDAuMCwgMC4wICk7XFxuICB9XFxuICByZXR1cm4gcGxhbmVPcmlnaW4gKyAoIHYueHkgKyB4eVJhbmdlICkgLyBwbGFuZVJlc29sdXRpb24gKiBwbGFuZVNpemU7XFxufVxcblxcbnZlYzMgbW90aW9uQ29vcmRJbnYoIHZlYzIgX2Nvb3JkICkge1xcbiAgdmVjMiBwbGFuZVNpemUgPSBwbGFuZVJlc29sdXRpb24gLyByZXNvbHV0aW9uTW90aW9uO1xcbiAgdmVjMyByZXQgPSB2ZWMzKCAwLjAgKTtcXG5cXG4gIC8vID09IHggYW5kIHkgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcbiAgcmV0Lnh5ID0gKCAoIGZyYWN0KCBfY29vcmQgLyBwbGFuZVNpemUgKSAtIDAuNSApICogcGxhbmVSZXNvbHV0aW9uICkgKiB2b3hlbFVuaXQ7XFxuXFxuICAvLyA9PSB6ID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXG4gIGZsb2F0IHpSYW5nZSA9IGZsb29yKCAxLjAgLyBwbGFuZVNpemUueCApICogZmxvb3IoIDEuMCAvIHBsYW5lU2l6ZS55ICkgLyAyLjA7XFxuICB2ZWMyIHBsYW5lUGxhY2UgPSBmbG9vciggX2Nvb3JkIC8gcGxhbmVTaXplICk7XFxuICByZXQueiA9ICggcGxhbmVQbGFjZS54ICsgZmxvb3IoIHBsYW5lUGxhY2UueSAvIHBsYW5lU2l6ZS54ICkgLSB6UmFuZ2UgKyAwLjUgKSAqIHZveGVsVW5pdDtcXG5cXG4gIHJldHVybiByZXQ7XFxufVxcblxcbi8vID09IHVtID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxudmVjMyBleHRyYWN0VmVsb2NpdHkoIHZlYzQgdGV4ICkge1xcbiAgcmV0dXJuIHRleC53ID09IDAuMCA/IHZlYzMoIDAuMCApIDogdGV4Lnh5eiAvIHRleC53O1xcbn1cXG5cXG4vLyA9PSBtYWluID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcbnZvaWQgbWFpbigpIHtcXG4gIHZlYzIgdXYgPSBnbF9GcmFnQ29vcmQueHkgLyByZXNvbHV0aW9uTW90aW9uO1xcbiAgdmVjMyB2ID0gbW90aW9uQ29vcmRJbnYoIHV2ICk7XFxuXFxuICB2ZWM0IHRleCA9IHRleHR1cmUyRCggc2FtcGxlck1vdGlvbiwgdXYgKTtcXG4gIHZlYzMgdmVsID0gdmVjMyggMC4wICk7XFxuICBmb3IgKCBpbnQgaXogPSAtMTsgaXogPD0gMTsgaXogKysgKSB7XFxuICAgIGZvciAoIGludCBpeSA9IC0xOyBpeSA8PSAxOyBpeSArKyApIHtcXG4gICAgICBmb3IgKCBpbnQgaXggPSAtMTsgaXggPD0gMTsgaXggKysgKSB7XFxuICAgICAgICB2ZWM0IHRleCA9IHRleHR1cmUyRCggc2FtcGxlck1vdGlvbiwgbW90aW9uQ29vcmQoIHYgKyB2ZWMzKCBpeCwgaXksIGl6ICkgKiB2b3hlbFVuaXQgKSApO1xcbiAgICAgICAgdmVsICs9IGV4dHJhY3RWZWxvY2l0eSggdGV4ICkgLyAyNy4wO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfVxcblxcbiAgaWYgKCAyLjAgPCBhYnMoIHYueCApICkgeyB2ZWwueCA9IDAuMDsgfVxcbiAgaWYgKCAyLjAgPCBhYnMoIHYueiApICkgeyB2ZWwueiA9IDAuMDsgfVxcbiAgaWYgKCB2LnkgPCAtMi4wICkgeyB2ZWwueSA9IDAuMDsgfVxcblxcbiAgZ2xfRnJhZ0NvbG9yID0gdmVjNCggdmVsLCB0ZXgudyApO1xcbn1cIiIsIm1vZHVsZS5leHBvcnRzID0gXCJwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuI2RlZmluZSBHTFNMSUZZIDFcXG5cXG4vLyA9PSB2YXJpYWJsZXMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcbnZhcnlpbmcgdmVjMyB2Q29sO1xcbnZhcnlpbmcgZmxvYXQgdlZhbGlkO1xcblxcbnZvaWQgbWFpbigpIHtcXG4gIC8vID09IGlmIGl0IGlzIGludmFsaWQgdGhlbiBqdXN0IGRpc2NhcmQgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcbiAgaWYgKCB2VmFsaWQgPT0gMC4wICkgeyBkaXNjYXJkOyB9XFxuXFxuICAvLyA9PSBqdXN0IHNob3QgYSBkb3QgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXG4gIGdsX0ZyYWdDb2xvciA9IHZlYzQoIHZDb2wsIDEuMCApO1xcbn1cIiIsIm1vZHVsZS5leHBvcnRzID0gXCIjZGVmaW5lIEdMU0xJRlkgMVxcbiNkZWZpbmUgSFVHRSA5RTE2XFxuI2RlZmluZSBQSSAzLjE0MTU5MjY1NFxcbiNkZWZpbmUgVEFVIDYuMjgzMTg1MzA3XFxuI2RlZmluZSBWIHZlYzMoMC4sMS4sLTEuKVxcbiNkZWZpbmUgc2F0dXJhdGUoaSkgY2xhbXAoaSwwLiwxLilcXG4jZGVmaW5lIGxvZmkoaSxtKSAoZmxvb3IoKGkpLyhtKSkqKG0pKVxcbiNkZWZpbmUgbG9maXIoaSxtKSAoZmxvb3IoKGkrMC41KS8obSkpKihtKSlcXG5cXG4vLyA9PSB2YXJpYWJsZXMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcbmF0dHJpYnV0ZSB2ZWMyIGNvbXB1dGVVVjtcXG5cXG52YXJ5aW5nIHZlYzMgdkNvbDtcXG52YXJ5aW5nIGZsb2F0IHZWYWxpZDtcXG5cXG51bmlmb3JtIHZlYzIgcmVzb2x1dGlvblBjb21wdXRlO1xcblxcbnVuaWZvcm0gdmVjMiByZXNvbHV0aW9uTW90aW9uO1xcbnVuaWZvcm0gdmVjMiBwbGFuZVJlc29sdXRpb247XFxudW5pZm9ybSBmbG9hdCB2b3hlbFVuaXQ7XFxuXFxudW5pZm9ybSBzYW1wbGVyMkQgc2FtcGxlclBjb21wdXRlO1xcblxcbi8vID09IGRlYWwgd2l0aCBtb3Rpb24gZmllbGQgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxudmVjMiBtb3Rpb25Db29yZCggdmVjMyBfdiApIHtcXG4gIHZlYzMgdiA9IGZsb29yKCBfdiAvIHZveGVsVW5pdCApICsgMC41O1xcbiAgdmVjMiBwbGFuZVNpemUgPSBwbGFuZVJlc29sdXRpb24gLyByZXNvbHV0aW9uTW90aW9uO1xcblxcbiAgLy8gPT0gd2hlcmUgYXJlIHRoZSBwbGFuZSBvcmlnaW4/ID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxuICBmbG9hdCB6UmFuZ2UgPSBmbG9vciggMS4wIC8gcGxhbmVTaXplLnggKSAqIGZsb29yKCAxLjAgLyBwbGFuZVNpemUueSApIC8gMi4wO1xcbiAgaWYgKCB2LnogPCAtelJhbmdlIHx8IHpSYW5nZSA8IHYueiApIHtcXG4gICAgcmV0dXJuIHZlYzIoIDAuMCwgMC4wICk7XFxuICB9XFxuICBmbG9hdCBwbGFuZUluZGV4ID0gZmxvb3IoIHYueiArIHpSYW5nZSApO1xcbiAgdmVjMiBwbGFuZU9yaWdpbiA9IHZlYzIoIGZyYWN0KCBwbGFuZUluZGV4ICogcGxhbmVTaXplLnggKSwgZmxvb3IoIHBsYW5lSW5kZXggKiBwbGFuZVNpemUueCApICogcGxhbmVTaXplLnkgKTtcXG5cXG4gIC8vID09IHBsYWNlIGEgZG90IG9uIHRoZSBwbGFuZSA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcbiAgdmVjMiB4eVJhbmdlID0gcGxhbmVSZXNvbHV0aW9uIC8gMi4wO1xcbiAgaWYgKCB2LnggPCAteHlSYW5nZS54IHx8IHh5UmFuZ2UueCA8IHYueCB8fCB2LnkgPCAteHlSYW5nZS55IHx8IHh5UmFuZ2UueSA8IHYueSApIHtcXG4gICAgcmV0dXJuIHZlYzIoIDAuMCwgMC4wICk7XFxuICB9XFxuICByZXR1cm4gcGxhbmVPcmlnaW4gKyAoIHYueHkgKyB4eVJhbmdlICkgLyBwbGFuZVJlc29sdXRpb24gKiBwbGFuZVNpemU7XFxufVxcblxcbi8vID09IG1haW4gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxudm9pZCBtYWluKCkge1xcbiAgLy8gPT0gZmV0Y2ggY29tcHV0ZSB0ZXh0dXJlID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxuICB2ZWMyIHB1diA9IGNvbXB1dGVVVjtcXG4gIHZlYzIgZHBwaXggPSB2ZWMyKCAxLjAgKSAvIHJlc29sdXRpb25QY29tcHV0ZTtcXG5cXG4gIHZlYzQgcG9zID0gdGV4dHVyZTJEKCBzYW1wbGVyUGNvbXB1dGUsIHB1diApO1xcbiAgdmVjNCB2ZWwgPSB0ZXh0dXJlMkQoIHNhbXBsZXJQY29tcHV0ZSwgcHV2ICsgZHBwaXggKiB2ZWMyKCAxLjAsIDAuMCApICk7XFxuXFxuICAvLyA9PSBwbGFjZSBhIGRvdCA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXG4gIHZlYzIgY29vcmQgPSBtb3Rpb25Db29yZCggcG9zLnh5eiApO1xcbiAgdlZhbGlkID0gY29vcmQgIT0gdmVjMiggMC4wLCAwLjAgKSA/IDEuMCA6IDAuMDsgLy8gb3V0IG9mIGNvbXB1dGUgY2VsbHNcXG4gIHZWYWxpZCA9IDAuMCA8IHBvcy53ID8gMS4wIDogMC4wOyAvLyBsaWZlIGlzIGRlcGxldGVkXFxuICBnbF9Qb3NpdGlvbiA9IHZlYzQoIGNvb3JkICogMi4wIC0gMS4wLCAwLjAsIDEuMCApO1xcbiAgZ2xfUG9pbnRTaXplID0gMS4wO1xcblxcbiAgLy8gPT0gc2V0IGEgY29sb3IgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxuICB2Q29sID0gdmVsLnh5ejtcXG59XCIiLCJtb2R1bGUuZXhwb3J0cyA9IFwicHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbiNkZWZpbmUgR0xTTElGWSAxXFxuXFxuLy8gPT0gdmFyaWFibGVzID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXG51bmlmb3JtIHZlYzIgcmVzb2x1dGlvbk1vdGlvbjtcXG51bmlmb3JtIHZlYzIgcGxhbmVSZXNvbHV0aW9uO1xcbnVuaWZvcm0gZmxvYXQgdm94ZWxVbml0O1xcblxcbnVuaWZvcm0gc2FtcGxlcjJEIHNhbXBsZXJNb3Rpb247XFxudW5pZm9ybSBzYW1wbGVyMkQgc2FtcGxlclByZXNzdXJlO1xcblxcbi8vID09IGRlYWwgd2l0aCBtb3Rpb24gZmllbGQgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxudmVjMiBtb3Rpb25Db29yZCggdmVjMyBfdiApIHtcXG4gIHZlYzMgdiA9IGZsb29yKCBfdiAvIHZveGVsVW5pdCApICsgMC41O1xcbiAgdmVjMiBwbGFuZVNpemUgPSBwbGFuZVJlc29sdXRpb24gLyByZXNvbHV0aW9uTW90aW9uO1xcblxcbiAgLy8gPT0gd2hlcmUgYXJlIHRoZSBwbGFuZSBvcmlnaW4/ID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxuICBmbG9hdCB6UmFuZ2UgPSBmbG9vciggMS4wIC8gcGxhbmVTaXplLnggKSAqIGZsb29yKCAxLjAgLyBwbGFuZVNpemUueSApIC8gMi4wO1xcbiAgaWYgKCB2LnogPCAtelJhbmdlIHx8IHpSYW5nZSA8IHYueiApIHtcXG4gICAgcmV0dXJuIHZlYzIoIDAuMCwgMC4wICk7XFxuICB9XFxuICBmbG9hdCBwbGFuZUluZGV4ID0gZmxvb3IoIHYueiArIHpSYW5nZSApO1xcbiAgdmVjMiBwbGFuZU9yaWdpbiA9IHZlYzIoIGZyYWN0KCBwbGFuZUluZGV4ICogcGxhbmVTaXplLnggKSwgZmxvb3IoIHBsYW5lSW5kZXggKiBwbGFuZVNpemUueCApICogcGxhbmVTaXplLnkgKTtcXG5cXG4gIC8vID09IHBsYWNlIGEgZG90IG9uIHRoZSBwbGFuZSA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcbiAgdmVjMiB4eVJhbmdlID0gcGxhbmVSZXNvbHV0aW9uIC8gMi4wO1xcbiAgaWYgKCB2LnggPCAteHlSYW5nZS54IHx8IHh5UmFuZ2UueCA8IHYueCB8fCB2LnkgPCAteHlSYW5nZS55IHx8IHh5UmFuZ2UueSA8IHYueSApIHtcXG4gICAgcmV0dXJuIHZlYzIoIDAuMCwgMC4wICk7XFxuICB9XFxuICByZXR1cm4gcGxhbmVPcmlnaW4gKyAoIHYueHkgKyB4eVJhbmdlICkgLyBwbGFuZVJlc29sdXRpb24gKiBwbGFuZVNpemU7XFxufVxcblxcbnZlYzMgbW90aW9uQ29vcmRJbnYoIHZlYzIgX2Nvb3JkICkge1xcbiAgdmVjMiBwbGFuZVNpemUgPSBwbGFuZVJlc29sdXRpb24gLyByZXNvbHV0aW9uTW90aW9uO1xcbiAgdmVjMyByZXQgPSB2ZWMzKCAwLjAgKTtcXG5cXG4gIC8vID09IHggYW5kIHkgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcbiAgcmV0Lnh5ID0gKCAoIGZyYWN0KCBfY29vcmQgLyBwbGFuZVNpemUgKSAtIDAuNSApICogcGxhbmVSZXNvbHV0aW9uICkgKiB2b3hlbFVuaXQ7XFxuXFxuICAvLyA9PSB6ID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXG4gIGZsb2F0IHpSYW5nZSA9IGZsb29yKCAxLjAgLyBwbGFuZVNpemUueCApICogZmxvb3IoIDEuMCAvIHBsYW5lU2l6ZS55ICkgLyAyLjA7XFxuICB2ZWMyIHBsYW5lUGxhY2UgPSBmbG9vciggX2Nvb3JkIC8gcGxhbmVTaXplICk7XFxuICByZXQueiA9ICggcGxhbmVQbGFjZS54ICsgZmxvb3IoIHBsYW5lUGxhY2UueSAvIHBsYW5lU2l6ZS54ICkgLSB6UmFuZ2UgKyAwLjUgKSAqIHZveGVsVW5pdDtcXG5cXG4gIHJldHVybiByZXQ7XFxufVxcblxcbi8vID09IHVtID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxudmVjMyBleHRyYWN0VmVsb2NpdHkoIHZlYzQgdGV4ICkge1xcbiAgcmV0dXJuIHRleC53ID09IDAuMCA/IHZlYzMoIDAuMCApIDogdGV4Lnh5eiAvIHRleC53O1xcbn1cXG5cXG4vLyA9PSBtYWluID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcbnZvaWQgbWFpbigpIHtcXG4gIHZlYzIgdXYgPSBnbF9GcmFnQ29vcmQueHkgLyByZXNvbHV0aW9uTW90aW9uO1xcbiAgdmVjMyB2ID0gbW90aW9uQ29vcmRJbnYoIHV2ICk7XFxuXFxuICB2ZWMyIGQgPSB2ZWMyKCAwLjAsIHZveGVsVW5pdCApO1xcblxcbiAgZmxvYXQgeG0gPSB0ZXh0dXJlMkQoIHNhbXBsZXJQcmVzc3VyZSwgbW90aW9uQ29vcmQoIHYgLSBkLnl4eCApICkueDtcXG4gIGZsb2F0IHhwID0gdGV4dHVyZTJEKCBzYW1wbGVyUHJlc3N1cmUsIG1vdGlvbkNvb3JkKCB2ICsgZC55eHggKSApLng7XFxuICBmbG9hdCB5bSA9IHRleHR1cmUyRCggc2FtcGxlclByZXNzdXJlLCBtb3Rpb25Db29yZCggdiAtIGQueHl4ICkgKS54O1xcbiAgZmxvYXQgeXAgPSB0ZXh0dXJlMkQoIHNhbXBsZXJQcmVzc3VyZSwgbW90aW9uQ29vcmQoIHYgKyBkLnh5eCApICkueDtcXG4gIGZsb2F0IHptID0gdGV4dHVyZTJEKCBzYW1wbGVyUHJlc3N1cmUsIG1vdGlvbkNvb3JkKCB2IC0gZC54eHkgKSApLng7XFxuICBmbG9hdCB6cCA9IHRleHR1cmUyRCggc2FtcGxlclByZXNzdXJlLCBtb3Rpb25Db29yZCggdiArIGQueHh5ICkgKS54O1xcblxcbiAgdmVjMyBvbGRWZWwgPSBleHRyYWN0VmVsb2NpdHkoIHRleHR1cmUyRCggc2FtcGxlck1vdGlvbiwgdXYgKSApO1xcbiAgdmVjMyBuZXdWZWwgPSBvbGRWZWwgLSB2ZWMzKCB4cCAtIHhtLCB5cCAtIHltLCB6cCAtIHptICk7XFxuXFxuICBnbF9GcmFnQ29sb3IgPSB2ZWM0KCBuZXdWZWwgLSBvbGRWZWwsIDEuMCApO1xcbn1cIiIsIm1vZHVsZS5leHBvcnRzID0gXCJwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuI2RlZmluZSBHTFNMSUZZIDFcXG5cXG4vLyA9PSB2YXJpYWJsZXMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcbnVuaWZvcm0gdmVjMiByZXNvbHV0aW9uTW90aW9uO1xcbnVuaWZvcm0gdmVjMiBwbGFuZVJlc29sdXRpb247XFxudW5pZm9ybSBmbG9hdCB2b3hlbFVuaXQ7XFxuXFxudW5pZm9ybSBzYW1wbGVyMkQgc2FtcGxlckRpdmVyZ2VuY2U7XFxudW5pZm9ybSBzYW1wbGVyMkQgc2FtcGxlclByZXNzdXJlO1xcblxcbi8vID09IGRlYWwgd2l0aCBtb3Rpb24gZmllbGQgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxudmVjMiBtb3Rpb25Db29yZCggdmVjMyBfdiApIHtcXG4gIHZlYzMgdiA9IGZsb29yKCBfdiAvIHZveGVsVW5pdCApICsgMC41O1xcbiAgdmVjMiBwbGFuZVNpemUgPSBwbGFuZVJlc29sdXRpb24gLyByZXNvbHV0aW9uTW90aW9uO1xcblxcbiAgLy8gPT0gd2hlcmUgYXJlIHRoZSBwbGFuZSBvcmlnaW4/ID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxuICBmbG9hdCB6UmFuZ2UgPSBmbG9vciggMS4wIC8gcGxhbmVTaXplLnggKSAqIGZsb29yKCAxLjAgLyBwbGFuZVNpemUueSApIC8gMi4wO1xcbiAgaWYgKCB2LnogPCAtelJhbmdlIHx8IHpSYW5nZSA8IHYueiApIHtcXG4gICAgcmV0dXJuIHZlYzIoIDAuMCwgMC4wICk7XFxuICB9XFxuICBmbG9hdCBwbGFuZUluZGV4ID0gZmxvb3IoIHYueiArIHpSYW5nZSApO1xcbiAgdmVjMiBwbGFuZU9yaWdpbiA9IHZlYzIoIGZyYWN0KCBwbGFuZUluZGV4ICogcGxhbmVTaXplLnggKSwgZmxvb3IoIHBsYW5lSW5kZXggKiBwbGFuZVNpemUueCApICogcGxhbmVTaXplLnkgKTtcXG5cXG4gIC8vID09IHBsYWNlIGEgZG90IG9uIHRoZSBwbGFuZSA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcbiAgdmVjMiB4eVJhbmdlID0gcGxhbmVSZXNvbHV0aW9uIC8gMi4wO1xcbiAgaWYgKCB2LnggPCAteHlSYW5nZS54IHx8IHh5UmFuZ2UueCA8IHYueCB8fCB2LnkgPCAteHlSYW5nZS55IHx8IHh5UmFuZ2UueSA8IHYueSApIHtcXG4gICAgcmV0dXJuIHZlYzIoIDAuMCwgMC4wICk7XFxuICB9XFxuICByZXR1cm4gcGxhbmVPcmlnaW4gKyAoIHYueHkgKyB4eVJhbmdlICkgLyBwbGFuZVJlc29sdXRpb24gKiBwbGFuZVNpemU7XFxufVxcblxcbnZlYzMgbW90aW9uQ29vcmRJbnYoIHZlYzIgX2Nvb3JkICkge1xcbiAgdmVjMiBwbGFuZVNpemUgPSBwbGFuZVJlc29sdXRpb24gLyByZXNvbHV0aW9uTW90aW9uO1xcbiAgdmVjMyByZXQgPSB2ZWMzKCAwLjAgKTtcXG5cXG4gIC8vID09IHggYW5kIHkgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcbiAgcmV0Lnh5ID0gKCAoIGZyYWN0KCBfY29vcmQgLyBwbGFuZVNpemUgKSAtIDAuNSApICogcGxhbmVSZXNvbHV0aW9uICkgKiB2b3hlbFVuaXQ7XFxuXFxuICAvLyA9PSB6ID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXG4gIGZsb2F0IHpSYW5nZSA9IGZsb29yKCAxLjAgLyBwbGFuZVNpemUueCApICogZmxvb3IoIDEuMCAvIHBsYW5lU2l6ZS55ICkgLyAyLjA7XFxuICB2ZWMyIHBsYW5lUGxhY2UgPSBmbG9vciggX2Nvb3JkIC8gcGxhbmVTaXplICk7XFxuICByZXQueiA9ICggcGxhbmVQbGFjZS54ICsgZmxvb3IoIHBsYW5lUGxhY2UueSAvIHBsYW5lU2l6ZS54ICkgLSB6UmFuZ2UgKyAwLjUgKSAqIHZveGVsVW5pdDtcXG5cXG4gIHJldHVybiByZXQ7XFxufVxcblxcbi8vID09IG1haW4gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxudm9pZCBtYWluKCkge1xcbiAgdmVjMiB1diA9IGdsX0ZyYWdDb29yZC54eSAvIHJlc29sdXRpb25Nb3Rpb247XFxuICB2ZWMzIHYgPSBtb3Rpb25Db29yZEludiggdXYgKTtcXG5cXG4gIHZlYzIgZCA9IHZlYzIoIDAuMCwgdm94ZWxVbml0ICk7XFxuXFxuICB2ZWM0IGRpdmVyZ2VuY2UgPSB0ZXh0dXJlMkQoIHNhbXBsZXJEaXZlcmdlbmNlLCB1diApO1xcbiAgaWYgKCBkaXZlcmdlbmNlLncgPT0gMC4wICkgeyBkaXNjYXJkOyB9IC8vIHRoaXMgaXMgYW4gYWlyXFxuXFxuICBmbG9hdCB4bSA9IHRleHR1cmUyRCggc2FtcGxlclByZXNzdXJlLCBtb3Rpb25Db29yZCggdiAtIGQueXh4ICkgKS54O1xcbiAgZmxvYXQgeHAgPSB0ZXh0dXJlMkQoIHNhbXBsZXJQcmVzc3VyZSwgbW90aW9uQ29vcmQoIHYgKyBkLnl4eCApICkueDtcXG4gIGZsb2F0IHltID0gdGV4dHVyZTJEKCBzYW1wbGVyUHJlc3N1cmUsIG1vdGlvbkNvb3JkKCB2IC0gZC54eXggKSApLng7XFxuICBmbG9hdCB5cCA9IHRleHR1cmUyRCggc2FtcGxlclByZXNzdXJlLCBtb3Rpb25Db29yZCggdiArIGQueHl4ICkgKS54O1xcbiAgZmxvYXQgem0gPSB0ZXh0dXJlMkQoIHNhbXBsZXJQcmVzc3VyZSwgbW90aW9uQ29vcmQoIHYgLSBkLnh4eSApICkueDtcXG4gIGZsb2F0IHpwID0gdGV4dHVyZTJEKCBzYW1wbGVyUHJlc3N1cmUsIG1vdGlvbkNvb3JkKCB2ICsgZC54eHkgKSApLng7XFxuXFxuICBmbG9hdCBwcmVzc3VyZSA9ICggeG0gKyB4cCArIHltICsgeXAgKyB6bSArIHpwIC0gZGl2ZXJnZW5jZS54ICkgLyA2LjA7XFxuXFxuICBnbF9GcmFnQ29sb3IgPSB2ZWM0KCBwcmVzc3VyZSwgMC4wLCAwLjAsIDEuMCApO1xcbn1cIiIsIm1vZHVsZS5leHBvcnRzID0gXCIjZGVmaW5lIFBJIDMuMTQxNTkyNjVcXG4jZGVmaW5lIFRBVSA2LjI4MzE4NTMxXFxuI2RlZmluZSBzYXR1cmF0ZShpKSBjbGFtcChpLDAuLDEuKVxcblxcbi8vIC0tLS0tLVxcblxcbiNleHRlbnNpb24gR0xfRVhUX2RyYXdfYnVmZmVycyA6IHJlcXVpcmVcXG5wcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuI2RlZmluZSBHTFNMSUZZIDFcXG5cXG52YXJ5aW5nIHZlYzMgdlBvcztcXG52YXJ5aW5nIHZlYzMgdk5vcjtcXG52YXJ5aW5nIHZlYzMgdkNvbDtcXG52YXJ5aW5nIGZsb2F0IHZMaWZlO1xcblxcbnVuaWZvcm0gbWF0NCBtYXRQTDtcXG51bmlmb3JtIG1hdDQgbWF0Vkw7XFxuXFxudW5pZm9ybSB2ZWMzIGNhbWVyYVBvcztcXG51bmlmb3JtIGZsb2F0IHBlcnNwRmFyO1xcbnVuaWZvcm0gdmVjMyBsaWdodFBvcztcXG5cXG51bmlmb3JtIGJvb2wgaXNTaGFkb3c7XFxuXFxudW5pZm9ybSBzYW1wbGVyMkQgc2FtcGxlclNoYWRvdztcXG5cXG4vLyA9PSBuYW5kZSA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcbnZlYzMgcmdiMnl1diggdmVjMyByZ2IgKSB7XFxuICByZXR1cm4gdmVjMyhcXG4gICAgMC4yOTkgKiByZ2IueCArIDAuNTg3ICogcmdiLnkgKyAwLjExNCAqIHJnYi56LFxcbiAgICAtMC4xNDg3MzYgKiByZ2IueCAtIDAuMzMxMjY0ICogcmdiLnkgKyAwLjUgKiByZ2IueixcXG4gICAgMC41ICogcmdiLnggLSAwLjQxODY4OCAqIHJnYi55IC0gMC4wODEzMTIgKiByZ2IuelxcbiAgKTtcXG59XFxuXFxudmVjMyBoc3YycmdiKCB2ZWMzIGhzdiApIHtcXG4gIGZsb2F0IGggPSA2LjAgKiBoc3YueDtcXG4gIGZsb2F0IGMgPSBoc3YueTtcXG4gIGZsb2F0IHggPSBjICogKCAxLjAgLSBhYnMoIG1vZCggaCwgMi4wICkgLSAxLjAgKSApO1xcbiAgcmV0dXJuIHNhdHVyYXRlKCBoc3YueiAtIGMgKyAoXFxuICAgIGggPCAxLjAgPyB2ZWMzKCBjLCB4LCAwLjAgKSA6XFxuICAgIGggPCAyLjAgPyB2ZWMzKCB4LCBjLCAwLjAgKSA6XFxuICAgIGggPCAzLjAgPyB2ZWMzKCAwLjAsIGMsIHggKSA6XFxuICAgIGggPCA0LjAgPyB2ZWMzKCAwLjAsIHgsIGMgKSA6XFxuICAgIGggPCA1LjAgPyB2ZWMzKCB4LCAwLjAsIGMgKSA6XFxuICAgICAgICAgICAgICB2ZWMzKCBjLCAwLjAsIHggKVxcbiAgKSApO1xcbn1cXG5cXG4vLyA9PSByb3RhdGUgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcbm1hdDIgcm90YXRlMkQoIGZsb2F0IF90ICkge1xcbiAgcmV0dXJuIG1hdDIoIGNvcyggX3QgKSwgc2luKCBfdCApLCAtc2luKCBfdCApLCBjb3MoIF90ICkgKTtcXG59XFxuXFxuLy8gPT0gdWggPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXG5mbG9hdCBzaGFkb3coIGZsb2F0IGQgKSB7XFxuICB2ZWM0IHBsID0gbWF0UEwgKiBtYXRWTCAqIHZlYzQoIHZQb3MsIDEuMCApO1xcbiAgdmVjMiB1diA9IHBsLnh5IC8gcGwudyAqIDAuNSArIDAuNTtcXG5cXG4gIGZsb2F0IGRjID0gbGVuZ3RoKCB2UG9zIC0gbGlnaHRQb3MgKTtcXG4gIGZsb2F0IHJldCA9IDAuMDtcXG4gIGZvciAoIGludCBpeSA9IC0xOyBpeSA8PSAxOyBpeSArKyApIHtcXG4gICAgZm9yICggaW50IGl4ID0gLTE7IGl4IDw9IDE7IGl4ICsrICkge1xcbiAgICAgIHZlYzIgdXYgPSB1diArIHZlYzIoIGZsb2F0KCBpeCApLCBmbG9hdCAoIGl5ICkgKSAqIDRFLTQ7XFxuICAgICAgZmxvYXQgcHJvaiA9IHRleHR1cmUyRCggc2FtcGxlclNoYWRvdywgdXYgKS54O1xcbiAgICAgIGZsb2F0IGJpYXMgPSAwLjEgKyAoIDEuMCAtIGQgKSAqIDAuMztcXG5cXG4gICAgICBmbG9hdCBkaWYgPSBzbW9vdGhzdGVwKCBiaWFzICogMi4wLCBiaWFzLCAoIGRjIC0gcHJvaiApICk7XFxuICAgICAgcmV0ICs9IGRpZiAvIDkuMDtcXG4gICAgfVxcbiAgfVxcbiAgcmV0dXJuIHJldDtcXG59XFxuXFxuLy8gPT0gbWFpbiBwcm9jZWR1cmUgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXG52b2lkIG1haW4oKSB7XFxuICBpZiAoIHZMaWZlIDw9IDAuMCApIHsgZGlzY2FyZDsgfVxcblxcbiAgaWYgKCBpc1NoYWRvdyApIHtcXG4gICAgZmxvYXQgZGVwdGggPSBsZW5ndGgoIHZQb3MgLSBsaWdodFBvcyApO1xcbiAgICBnbF9GcmFnRGF0YVsgMCBdID0gdmVjNCggZGVwdGgsIDAuMCwgMC4wLCAxLjAgKTtcXG4gICAgcmV0dXJuO1xcbiAgfVxcblxcbiAgdmVjMyBsaWdodERpciA9IG5vcm1hbGl6ZSggdlBvcyAtIGxpZ2h0UG9zICk7XFxuICB2ZWMzIHJheURpciA9IG5vcm1hbGl6ZSggdlBvcyAtIGNhbWVyYVBvcyApO1xcbiAgZmxvYXQgZCA9IGRvdCggLXZOb3IsIGxpZ2h0RGlyICk7XFxuICBmbG9hdCBkaWYgPSBtaXgoIDEuMCwgZCwgMC41ICk7XFxuICB2ZWMzIGNvbCA9IGRpZiAqIHZDb2w7XFxuXFxuICBmbG9hdCBzaGFkb3dGYWN0b3IgPSBzaGFkb3coIGQgKTtcXG4gIGNvbCAqPSBtaXgoIDAuMiwgMS4wLCBzaGFkb3dGYWN0b3IgKTtcXG4gIGNvbCA9IG1heCggdmVjMyggMC4wICksIGNvbCApO1xcblxcbiAgZ2xfRnJhZ0RhdGFbIDAgXSA9IHZlYzQoIGhzdjJyZ2IoIHJnYjJ5dXYoIGNvbCApICksIDEuMCApO1xcbiAgZ2xfRnJhZ0RhdGFbIDEgXSA9IHZlYzQoIGxlbmd0aCggY2FtZXJhUG9zIC0gdlBvcyApLCAwLjAsIDAuMCwgMS4wICk7XFxufVwiIiwibW9kdWxlLmV4cG9ydHMgPSBcIiNkZWZpbmUgR0xTTElGWSAxXFxuI2RlZmluZSBIVUdFIDlFMTZcXG4jZGVmaW5lIFBJIDMuMTQxNTkyNjU0XFxuI2RlZmluZSBUQVUgNi4yODMxODUzMDdcXG4jZGVmaW5lIFYgdmVjMygwLiwxLiwtMS4pXFxuI2RlZmluZSBzYXR1cmF0ZShpKSBjbGFtcChpLDAuLDEuKVxcbiNkZWZpbmUgbG9maShpLG0pIChmbG9vcigoaSkvKG0pKSoobSkpXFxuI2RlZmluZSBsb2ZpcihpLG0pIChmbG9vcigoaSswLjUpLyhtKSkqKG0pKVxcblxcbi8vIC0tLS0tLVxcblxcbmF0dHJpYnV0ZSB2ZWMyIGNvbXB1dGVVVjtcXG5hdHRyaWJ1dGUgdmVjMyBnZW9tUG9zO1xcbmF0dHJpYnV0ZSB2ZWMzIGdlb21Ob3I7XFxuXFxudmFyeWluZyB2ZWMzIHZQb3M7XFxudmFyeWluZyB2ZWMzIHZOb3I7XFxudmFyeWluZyB2ZWMzIHZDb2w7XFxudmFyeWluZyBmbG9hdCB2TGlmZTtcXG5cXG51bmlmb3JtIHZlYzIgcmVzb2x1dGlvbjtcXG51bmlmb3JtIHZlYzIgcmVzb2x1dGlvblBjb21wdXRlO1xcblxcbnVuaWZvcm0gbWF0NCBtYXRQO1xcbnVuaWZvcm0gbWF0NCBtYXRWO1xcbnVuaWZvcm0gbWF0NCBtYXRWTDtcXG51bmlmb3JtIG1hdDQgbWF0UEw7XFxuXFxudW5pZm9ybSBib29sIGlzU2hhZG93O1xcblxcbnVuaWZvcm0gZmxvYXQgY29sb3JWYXI7XFxudW5pZm9ybSBmbG9hdCBjb2xvck9mZnNldDtcXG5cXG51bmlmb3JtIHNhbXBsZXIyRCBzYW1wbGVyUGNvbXB1dGU7XFxudW5pZm9ybSBzYW1wbGVyMkQgc2FtcGxlclJhbmRvbVN0YXRpYztcXG5cXG4vLyAtLS0tLS1cXG5cXG52ZWMzIGNhdENvbG9yKCBmbG9hdCBfcCApIHtcXG4gIHJldHVybiAwLjUgKyAwLjUgKiB2ZWMzKFxcbiAgICBjb3MoIF9wICksXFxuICAgIGNvcyggX3AgKyBQSSAvIDMuMCAqIDQuMCApLFxcbiAgICBjb3MoIF9wICsgUEkgLyAzLjAgKiAyLjAgKVxcbiAgKTtcXG59XFxuXFxudmVjNCByYW5kb20oIHZlYzIgX3V2ICkge1xcbiAgcmV0dXJuIHRleHR1cmUyRCggc2FtcGxlclJhbmRvbVN0YXRpYywgX3V2ICk7XFxufVxcblxcbm1hdDIgcm90YXRlMkQoIGZsb2F0IF90ICkge1xcbiAgcmV0dXJuIG1hdDIoIGNvcyggX3QgKSwgc2luKCBfdCApLCAtc2luKCBfdCApLCBjb3MoIF90ICkgKTtcXG59XFxuXFxuLy8gLS0tLS0tXFxuXFxudmVjMyByb3RhdGVHZW9tZXRyeSggdmVjMyBfcCwgdmVjMyBfdiApIHtcXG4gIHZlYzMgdiA9IF92O1xcbiAgdi55eiA9IHJvdGF0ZTJEKCA0LjAgKiBfcC54ICkgKiB2Lnl6O1xcbiAgdi56eCA9IHJvdGF0ZTJEKCA0LjAgKiBfcC55ICkgKiB2Lnp4O1xcbiAgdi54eSA9IHJvdGF0ZTJEKCA0LjAgKiBfcC56ICkgKiB2Lnh5O1xcbiAgcmV0dXJuIHY7XFxufVxcblxcbnZvaWQgbWFpbigpIHtcXG4gIC8vID09IGZldGNoIGNvbXB1dGUgdGV4dHVyZSA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcbiAgdmVjMiBwdXYgPSBjb21wdXRlVVY7XFxuICB2ZWMyIGRwcGl4ID0gdmVjMiggMS4wICkgLyByZXNvbHV0aW9uUGNvbXB1dGU7XFxuXFxuICB2ZWM0IHBvcyA9IHRleHR1cmUyRCggc2FtcGxlclBjb21wdXRlLCBwdXYgKTtcXG4gIHZlYzQgdmVsID0gdGV4dHVyZTJEKCBzYW1wbGVyUGNvbXB1dGUsIHB1diArIGRwcGl4ICogdmVjMiggMS4wLCAwLjAgKSApO1xcblxcbiAgLy8gPT0gPz8/Pz8/Pz8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxuICB2ZWM0IGRpY2UgPSByYW5kb20oIHB1di55eSAqIDE4Mi45MiApO1xcblxcbiAgLy8gPT0gYXNzaWduIHZhcnlpbmcgdmFyaWFibGVzID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxuICB2TGlmZSA9IHBvcy53O1xcblxcbiAgLy8gdkNvbCA9IChcXG4gIC8vICAgZGljZS55IDwgMC44XFxuICAvLyAgID8gcG93KCBjYXRDb2xvciggVEFVICogKCAoIGRpY2UueCAqIDIuMCAtIDEuMCApICogY29sb3JWYXIgKyBjb2xvck9mZnNldCApICksIHZlYzMoIDIuMCApIClcXG4gIC8vICAgOiB2ZWMzKCAwLjQgKVxcbiAgLy8gKTtcXG4gIC8vIHZDb2wgPSBhYnMoIHZlbC54eXogKTtcXG4gIHZDb2wgPSAyLjAgKiBleHAoIDIuMyAqICggdkxpZmUgLSAxLjAgKSApICogY2F0Q29sb3IoIDYuOSArIDIuMCAqICggMS4wIC0gdkxpZmUgKSApO1xcblxcbiAgLy8gPT0gZ2VvbWV0cnkgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxuICBmbG9hdCBzaXplID0gKCAwLjAxICsgMC4xICogcG93KCBkaWNlLncsIDIuMCApICkgKiBwb3coIHNpbiggUEkgKiB2TGlmZSApLCAwLjI1ICk7XFxuXFxuICB2Tm9yID0gcm90YXRlR2VvbWV0cnkoIHBvcy54eXosIGdlb21Ob3IgKTtcXG4gIHBvcy54eXogKz0gc2l6ZSAqIHJvdGF0ZUdlb21ldHJ5KCBwb3MueHl6LCBnZW9tUG9zICk7XFxuXFxuICAvLyA9PSBmaW5hbGl6ZSA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXG4gIHZQb3MgPSBwb3MueHl6O1xcblxcbiAgdmVjNCBvdXRQb3M7XFxuICBpZiAoIGlzU2hhZG93ICkge1xcbiAgICBvdXRQb3MgPSBtYXRQTCAqIG1hdFZMICogdmVjNCggcG9zLnh5eiwgMS4wICk7XFxuICB9IGVsc2Uge1xcbiAgICBvdXRQb3MgPSBtYXRQICogbWF0ViAqIHZlYzQoIHBvcy54eXosIDEuMCApO1xcbiAgICBvdXRQb3MueCAvPSByZXNvbHV0aW9uLnggLyByZXNvbHV0aW9uLnk7XFxuICB9XFxuICBnbF9Qb3NpdGlvbiA9IG91dFBvcztcXG4gIC8vIGdsX1BvaW50U2l6ZSA9IHJlc29sdXRpb24ueSAqIHNpemUgLyBvdXRQb3MuejtcXG59XCIiLCJtb2R1bGUuZXhwb3J0cyA9IFwiI2RlZmluZSBCQVJSRUxfSVRFUiAxMFxcblxcbiNkZWZpbmUgSFVHRSA5RTE2XFxuI2RlZmluZSBQSSAzLjE0MTU5MjY1XFxuI2RlZmluZSBWIHZlYzMoMC4sMS4sLTEuKVxcbiNkZWZpbmUgc2F0dXJhdGUoaSkgY2xhbXAoaSwwLiwxLilcXG4jZGVmaW5lIGxvZmkoaSxtKSAoZmxvb3IoKGkpLyhtKSkqKG0pKVxcblxcbi8vIC0tLS0tLVxcblxcbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4jZGVmaW5lIEdMU0xJRlkgMVxcblxcbnVuaWZvcm0gZmxvYXQgdGltZTtcXG51bmlmb3JtIHZlYzIgcmVzb2x1dGlvbjtcXG5cXG51bmlmb3JtIGZsb2F0IGJhcnJlbEFtcDtcXG51bmlmb3JtIGZsb2F0IGJhcnJlbE9mZnNldDtcXG51bmlmb3JtIGZsb2F0IHF1YWxpdHlTaGl0NjtcXG5cXG51bmlmb3JtIHNhbXBsZXIyRCBzYW1wbGVyMDtcXG5cXG4vLyAtLS0tLS1cXG5cXG52ZWMzIGJhcnJlbCggZmxvYXQgYW1wLCB2ZWMyIHV2ICkge1xcblxcdGZsb2F0IGNvcm4gPSBsZW5ndGgoIHZlYzIoIDAuNSApICk7XFxuXFx0ZmxvYXQgYSA9IG1pbiggMy4wICogc3FydCggYW1wICksIGNvcm4gKiBQSSApO1xcblxcdGZsb2F0IHpvb20gPSBjb3JuIC8gKCB0YW4oIGNvcm4gKiBhICkgKyBjb3JuICk7XFxuXFx0dmVjMiBwID0gc2F0dXJhdGUoXFxuICAgICggdXYgKyBub3JtYWxpemUoIHV2IC0gMC41ICkgKiB0YW4oIGxlbmd0aCggdXYgLSAwLjUgKSAqIGEgKSApICogem9vbSArXFxuICAgIDAuNSAqICggMS4wIC0gem9vbSApXFxuICApO1xcblxcdHJldHVybiB0ZXh0dXJlMkQoIHNhbXBsZXIwLCB2ZWMyKCBwLngsIHAueSApICkueHl6O1xcbn1cXG5cXG4vLyAtLS0tLS1cXG5cXG52b2lkIG1haW4oKSB7XFxuICB2ZWMyIHV2ID0gZ2xfRnJhZ0Nvb3JkLnh5IC8gcmVzb2x1dGlvbjtcXG4gIHZlYzIgcCA9ICggZ2xfRnJhZ0Nvb3JkLnh5ICogMi4wIC0gcmVzb2x1dGlvbiApIC8gcmVzb2x1dGlvbi55O1xcbiAgZmxvYXQgdmlnID0gMS4wIC0gbGVuZ3RoKCBwICkgKiAwLjI7XFxuXFxuICB2ZWMzIHRleCA9IHZlYzMoIDAuMCApO1xcblxcbiAgZm9yICggaW50IGkgPSAwOyBpIDwgQkFSUkVMX0lURVI7IGkgKysgKSB7XFxuICAgIGZsb2F0IGZpID0gKCBmbG9hdCggaSApICsgMC41ICkgLyBmbG9hdCggQkFSUkVMX0lURVIgKTtcXG4gICAgdmVjMyBhID0gc2F0dXJhdGUoIHZlYzMoXFxuICAgICAgMS4wIC0gMy4wICogYWJzKCAxLjAgLyA2LjAgLSBmaSApLFxcbiAgICAgIDEuMCAtIDMuMCAqIGFicyggMS4wIC8gMi4wIC0gZmkgKSxcXG4gICAgICAxLjAgLSAzLjAgKiBhYnMoIDUuMCAvIDYuMCAtIGZpIClcXG4gICAgKSApIC8gZmxvYXQoIEJBUlJFTF9JVEVSICkgKiA0LjA7XFxuICAgIHRleCArPSBhICogYmFycmVsKCBiYXJyZWxPZmZzZXQgKyBiYXJyZWxBbXAgKiBmaSwgdXYgKTtcXG4gIH1cXG5cXG4gIHRleCA9IG1peCggdmVjMyggMC4wICksIHRleCwgdmlnICk7XFxuXFxuICB2ZWMzIGNvbCA9IHBvdyggc2F0dXJhdGUoIHRleC54eXogKSwgdmVjMyggMS4wIC8gMi4yICkgKTtcXG4gIGNvbCA9IHZlYzMoXFxuICAgIHNtb290aHN0ZXAoIC0wLjEwLCAxLjEwLCBjb2wueCApLFxcbiAgICBzbW9vdGhzdGVwKCAgMC4wMCwgMS4wMCwgY29sLnkgKSxcXG4gICAgc21vb3Roc3RlcCggLTAuMzAsIDEuMzAsIGNvbC56IClcXG4gICk7XFxuICBjb2wgPSBtaXgoIGNvbCwgMS4wIC0gY29sLCBxdWFsaXR5U2hpdDYgKTtcXG5cXG4gIGdsX0ZyYWdDb2xvciA9IHZlYzQoIGNvbCwgMS4wICk7XFxufVwiIiwibW9kdWxlLmV4cG9ydHMgPSBcIiNkZWZpbmUgR0xTTElGWSAxXFxuYXR0cmlidXRlIHZlYzIgcDtcXG5cXG52b2lkIG1haW4oKSB7XFxuICBnbF9Qb3NpdGlvbiA9IHZlYzQoIHAsIDAuMCwgMS4wICk7XFxufVwiIiwibW9kdWxlLmV4cG9ydHMgPSBcInByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4jZGVmaW5lIEdMU0xJRlkgMVxcblxcbnVuaWZvcm0gdmVjMiByZXNvbHV0aW9uO1xcbnVuaWZvcm0gc2FtcGxlcjJEIHNhbXBsZXIwO1xcblxcbnZvaWQgbWFpbigpIHtcXG4gIHZlYzIgdXYgPSBnbF9GcmFnQ29vcmQueHkgLyByZXNvbHV0aW9uO1xcbiAgZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKCBzYW1wbGVyMCwgdXYgKTtcXG59XCIiLCJcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanMhLi9tYWluLnNjc3NcIik7XG5cbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuXG52YXIgdHJhbnNmb3JtO1xudmFyIGluc2VydEludG87XG5cblxuXG52YXIgb3B0aW9ucyA9IHtcImhtclwiOnRydWV9XG5cbm9wdGlvbnMudHJhbnNmb3JtID0gdHJhbnNmb3JtXG5vcHRpb25zLmluc2VydEludG8gPSB1bmRlZmluZWQ7XG5cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCBvcHRpb25zKTtcblxuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG5cbmlmKG1vZHVsZS5ob3QpIHtcblx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzIS4vbWFpbi5zY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanMhLi9tYWluLnNjc3NcIik7XG5cblx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblxuXHRcdHZhciBsb2NhbHMgPSAoZnVuY3Rpb24oYSwgYikge1xuXHRcdFx0dmFyIGtleSwgaWR4ID0gMDtcblxuXHRcdFx0Zm9yKGtleSBpbiBhKSB7XG5cdFx0XHRcdGlmKCFiIHx8IGFba2V5XSAhPT0gYltrZXldKSByZXR1cm4gZmFsc2U7XG5cdFx0XHRcdGlkeCsrO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3Ioa2V5IGluIGIpIGlkeC0tO1xuXG5cdFx0XHRyZXR1cm4gaWR4ID09PSAwO1xuXHRcdH0oY29udGVudC5sb2NhbHMsIG5ld0NvbnRlbnQubG9jYWxzKSk7XG5cblx0XHRpZighbG9jYWxzKSB0aHJvdyBuZXcgRXJyb3IoJ0Fib3J0aW5nIENTUyBITVIgZHVlIHRvIGNoYW5nZWQgY3NzLW1vZHVsZXMgbG9jYWxzLicpO1xuXG5cdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHR9KTtcblxuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn0iLCIvKiAoaWdub3JlZCkgKi8iLCIvKiAoaWdub3JlZCkgKi8iXSwic291cmNlUm9vdCI6IiJ9